VIVA 3.03 Implementation Independent Algorithm Description Language
// Sheet   2020/7/9 15:03:00

ComLibrary "$(DirName:Viva)SYSTEMDESCRIPTIONS\OPALKELLY\COMMONLIB\OPKFPWRAPPER.DLL"
ComLibrary "$(DirName:VivaSystem)SBHC_LINK.OCX"

DataSet Fix32 = ( Word , Word ); //_ Attributes 4,12632256,System\Static
DataSet Fix16 = ( Byte , Byte ); //_ Attributes 4,32896,System\Static
DataSet Complex = ( List ); //_ Attributes 1,8421504
DataSet Fixed = ( List ); //_ Attributes 1,4227327
DataSet Floating = ( List ); //_ Attributes 1,32896
DataSet Signed = ( Variant ); //_ Attributes 1,16776960
DataSet TBus = ( List ); //_ Attributes 1,0,User\General
DataSet IndexedEl = ( Variant , Variant ); //_ Attributes 1,13290239,User\Join
DataSet IndEl_Or_Wrap = ( Variant ); //_ Attributes 1,8421631,User\Join
DataSet IndEl_And_Wrap = ( Variant ); //_ Attributes 1,8421631,User\Join
DataSet IndEl_Unique_Wrap = ( Variant ); //_ Attributes 1,8421631,User\Join
DataSet "MSB032*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "IVivaString*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "IWaveDisplay*" = ( Word , Word ); //_ Attributes 1,11141375,WaveDisplayProj1,9
DataSet "IDispatch**" = ( Word , Word ); //_ Attributes 1,11141375,System\Com
DataSet WFD_Enable = ( Bit ); //_ Attributes 1,8388863,User\Join
DataSet WFD_Analyzer = ( List ); //_ Attributes 1,8388863,User\Join
DataSet "ISBHC_LinkNV*" = ( Word , Word ); //_ Attributes 1,11141375,SBHC_LinkLib,9
DataSet "BIN512*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet NPI_DeRef = ( Variant ); //_ Attributes 1,4194432
DataSet S18 = ( MSB018 ); //_ Attributes 2,0
DataSet IXYGraph = ( Unsupported ); //_ Attributes 1,11141375,XYGraphProj1,1
DataSet "IXYGraph*" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphProj1,9
DataSet ITreeView = ( Unsupported ); //_ Attributes 1,11141375,ComctlLib,1
DataSet "ITreeView*" = ( Word , Word ); //_ Attributes 1,11141375,ComctlLib,9
DataSet "MSB112*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB020*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB064*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB040*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB160*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB044*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB208*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB046*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB232*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB047*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet s9 = ( MSB008 , Bit ); //_ Attributes 2,16744576
DataSet s13 = ( MSB012 , Bit ); //_ Attributes 2,0
DataSet "MSB039*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "Byte*" = ( Pointer ); //_ Attributes 1,11141375,System,16401
DataSet "DWord*" = ( Word , Word ); //_ Attributes 1,11141375,System\Static,16403
DataSet "MSB053*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "IXYGraphForm*" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,9
DataSet 8BitSigned = ( MSB009 ); //_ Attributes 2,12632256,System
DataSet "MSB102*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet ZTerm = ( NULL ); //_ Attributes 1,13684991,Layer2\ZTLib
DataSet ZTList = ( Variant , Variant ); //_ Attributes 1,8421631,Layer2\ZTLib
DataSet "MSB184*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB103*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet MIGWrite_DeRef = ( Variant ); //_ Attributes 1,8453888
DataSet MIGRead_DeRef = ( Variant ); //_ Attributes 1,16744576
DataSet Fixed13p5 = ( MSB005 , MSB013 ); //_ Attributes 4,33023
DataSet Fixed13p16 = ( MSB016 , MSB013 ); //_ Attributes 4,33023
DataSet Fix18 = ( MSB009 , MSB009 ); //_ Attributes 4,32896,System\Static
DataSet "LSB064*" = ( Word , Word ); //_ Attributes 1,11141375,System\$LSB,16385
DataSet "IMemory*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet ISBHC_LinkNV = ( Unsupported ); //_ Attributes 1,11141375,SBHC_LinkLib,1
DataSet DeviceIOControlConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceAccessConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceShareConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceCreateConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceAttributeConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "QWord*" = ( Word , Word ); //_ Attributes 1,11141375,System\Static,16405
DataSet Pipelined = ( Bit ); //_ Attributes 1,0
DataSet Mul = ( Bit ); //_ Attributes 1,8421376,Operators
DataSet Add = ( Bit ); //_ Attributes 1,8404992,Operators
DataSet Sub = ( Bit ); //_ Attributes 1,8388863,Operators
DataSet AddSub = ( Bit ); //_ Attributes 1,65535,Operators
DataSet Div = ( Bit ); //_ Attributes 1,8454016,Operators
DataSet "Ix86Atoms*" = ( Word , Word ); //_ Attributes 1,11141375,VIVAATOMLib,9
DataSet FileModeConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "IFileObject*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "Variant*" = ( Pointer ); //_ Attributes 1,11141375,System\$BIN
DataSet "ComUInt*" = ( Word , Word ); //_ Attributes 1,11141375,System\Com
DataSet "MSB016*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet Fix64 = ( DWord , DWord ); //_ Attributes 4,10526880,System\Static
DataSet Decimal = ( ZTList ); //_ Attributes 1,128
DataSet FloatSM = ( MSB013 , MSB007 ); //_ Attributes 8,33023
DataSet IDevice = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet "IDevice*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "DWord**" = ( Word , Word ); //_ Attributes 1,11141375,System\Static,16403
DataSet IMemory = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet S32 = ( MSB032 ); //_ Attributes 2,16744448
DataSet Default = ( Variant ); //_ Attributes 1,16777215
DataSet RR = ( MSB ); //_ Attributes 1,16711808,User\PCIX\RWCR
DataSet ChEn = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChMode = ( LSB002 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChPrio = ( LSB008 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChFifoNum = ( LSB004 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChFifoMask = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChSize = ( LSB017 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet DmaAddrR = ( MSB064 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet DmaNxtR = ( MSB064 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet DmaSizeR = ( ChPrio , MSB , ChRunning , FifoRdy , ChEn , ChFifoNum , MSB006 , ChFifoMask , ChMode , MSB013 , ChSize ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChRunning = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet FifoRdy = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FpgaHalt = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet HostHalt = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet ClrFifo = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FifoRdyCnt = ( LSB004 ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet RDmaEnable = ( MSB ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet RDmaEnabled = ( MSB ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet RDmaDisable = ( MSB ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet WDmaDisable = ( MSB ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet WDmaEnable = ( MSB ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet WDmaEnabled = ( MSB ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet FpgaState = ( MSB002 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaStates = ( LSB020 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet HcCCR = ( MSB013 , RDmaEnabled , RDmaEnable , RDmaDisable , MSB013 , WDmaEnabled , WDmaEnable , WDmaDisable , MSB012 , FpgaStates ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet ChNum = ( LSB004 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet ChBits = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Channel
DataSet FifoErr = ( Bit ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FifoErrs = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FifoRdys = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FifoRdyR = ( MSB006 , FifoErrs , MSB006 , FifoRdys , MSB006 , FifoErrs , MSB006 , FifoRdys ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FifoCountR = ( MSB032 , FpgaHalt , HostHalt , ChMode , ClrFifo , MSB016 , FifoRdyCnt ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet DataBits = ( BIN064 ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet BarClk = ( MSB ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet BarCS = ( List ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet BarCSLR = ( MSB ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet BarCSHR = ( MSB ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet BarCSLW = ( MSB ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet BarCSHW = ( MSB ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet Bar0 = ( BarReg ); //_ Attributes 1,16711808,User\PCIX\Bar\0
DataSet BarReg = ( List ); //_ Attributes 1,16711808,User\PCIX\Bar\Reg
DataSet BarCSList = ( List ); //_ Attributes 1,16711808,User\PCIX\Bar
DataSet DmaEnabled = ( List ); //_ Attributes 1,16711808,User\PCIX\HcCCR
DataSet ActiveChInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\ChCtl
DataSet TBit = ( Bit , Bit ); //_ Attributes 1,0,User\General
DataSet TBusOld = ( TBit , Variant ); //_ Attributes 1,0,User\General
DataSet RWActiveChInfo = ( ActiveChInfo , ActiveChInfo ); //_ Attributes 1,16711808,User\PCIX\ChCtl
DataSet DmaIE = ( Bit ); //_ Attributes 1,16711808,User\PCIX\DmaIER
DataSet RWDmaIE = ( DmaIE , DmaIE ); //_ Attributes 1,16711808,User\PCIX\DmaIER
DataSet DmaC = ( Bit ); //_ Attributes 1,16711808,User\PCIX\DmaCR
DataSet RWDmaC = ( DmaC , DmaC ); //_ Attributes 1,16711808,User\PCIX\DmaCR
DataSet RWDmaCLatched = ( DmaC , DmaC ); //_ Attributes 1,16711808,User\PCIX\DmaCR
DataSet Bar2 = ( List ); //_ Attributes 1,16711808,User\PCIX\Bar\2
DataSet DmaNxtCtl = ( List ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet DmaAddrCtl = ( List ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet DmaSzCtl = ( List ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet DmaRegInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet RWDmaRegInfo = ( DmaRegInfo , DmaRegInfo ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet DmaRegCtl = ( List ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet RWDmaRegCtl = ( DmaRegCtl , DmaRegCtl ); //_ Attributes 1,16711808,User\PCIX\DmaRegs
DataSet FifoCmd = ( List ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FifoCmds = ( List ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FpgaModes = ( LSB020 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet Bar1 = ( BarReg ); //_ Attributes 1,16711808,User\PCIX\Bar\1
DataSet ControlInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\RWCR
DataSet RWControlInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\RWCR
DataSet RWFifoRdys = ( FifoRdys , FifoRdys ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet RWFifoErrs = ( FifoErrs , FifoErrs ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet RWFifoRdyCnt = ( List , List ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet CFGDataSet = ( MSB512 ); //_ Attributes 1,4210816
DataSet RWFifoInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet FpgaProgModes = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaProgErrs = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaProgInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaProgBeg = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaProgEnd = ( LSB010 ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaProgCmd = ( FpgaProgEnd , FpgaProgBeg ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet FpgaToFifoInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\Fpgas
DataSet BarCtl = ( List ); //_ Attributes 1,16711808,User\PCIX\Bar\Reg
DataSet FifoRdyErrs = ( FifoErrs , FifoRdys ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet RWFifoRdyErrs = ( FifoRdyErrs , FifoRdyErrs ); //_ Attributes 1,16711808,User\PCIX\Fifos
DataSet BitBangInfo = ( List ); //_ Attributes 1,16711808,User\PCIX\BbPCR
DataSet XactReq = ( List ); //_ Attributes 1,16711808,User\PCIX\ChCtl
DataSet IFileObject = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet FileSeekConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet Small_Int = ( Nibble , Nibble ); //_ Attributes 2,128,System\Static
DataSet Ix86Atoms = ( Unsupported ); //_ Attributes 1,11141375,VIVAATOMLib,1
DataSet _DSBHC_Link = ( Unsupported ); //_ Attributes 1,11141375,SBHC_LinkLib,1
DataSet "_DSBHC_Link*" = ( Word , Word ); //_ Attributes 1,11141375,SBHC_LinkLib,9
DataSet 3Bit = ( DBit , Bit ); //_ Attributes 1,16777215,System\$LowLevel
DataSet Signed_Int = ( Variant ); //_ Attributes 1,16776960
DataSet Unsigned_Int = ( Variant ); //_ Attributes 1,8453888
DataSet Fixed_Point = ( List ); //_ Attributes 1,4227327
DataSet Floating_Point = ( List ); //_ Attributes 1,32896
DataSet 6Bit = ( 3Bit , 3Bit ); //_ Attributes 1,8421631,System\$LowLevel
DataSet 14BIT = ( Byte , 6Bit ); //_ Attributes 1,65535,System\$LowLevel
DataSet BeginConv = ( Bit ); //_ Attributes 1,33023,System\$LowLevel
DataSet "IVivaPort*" = ( Word , Word ); //_ Attributes 1,11141375,SBSPortIO,9
DataSet "MSB216*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB080*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet IWaveDisplay = ( Unsupported ); //_ Attributes 1,11141375,WaveDisplayProj1,1
DataSet IVivaString = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet "MSB392*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB135*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB088*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB019*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB022*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB050*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB042*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB058*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB036*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "ICheckBoxX*" = ( Word , Word ); //_ Attributes 1,11141375,Buttons,9
DataSet "IProgressBar*" = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,9
DataSet MousePointerConstants = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,3
DataSet "MSB097*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet SMALLINT = ( MSB004 , MSB004 ); //_ Attributes 2,0
DataSet IProgressBar = ( Unsupported ); //_ Attributes 1,11141375,MSComctlLib,1
DataSet SmInt = ( Nibble , Nibble ); //_ Attributes 2,0
DataSet "List*" = ( Word , Word ); //_ Attributes 1,11141375
DataSet "BIN024*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet 1Q8 = ( MSB009 , Bit ); //_ Attributes 4,10623166,System\Static
DataSet 2Q8 = ( MSB008 , DBit ); //_ Attributes 4,12262621,System\Static
DataSet 1Q14 = ( MSB014 , MSB002 ); //_ Attributes 4,15501559
DataSet "MSB152*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB045*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "BIN256*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "BIN008*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "BIN064*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "BIN136*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet Picture = ( Unsupported ); //_ Attributes 1,11141375,MSComctlLib,1
DataSet "Picture*" = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,9
DataSet "Picture**" = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,16393
DataSet AppearanceConstants = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,3
DataSet BorderStyleConstants = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,3
DataSet ICheckBoxX = ( Unsupported ); //_ Attributes 1,11141375,Buttons,1
DataSet IVivaPort = ( Unsupported ); //_ Attributes 1,11141375,SBSPortIO,1
DataSet "Word*" = ( Word , Word ); //_ Attributes 1,11141375,System\Static,16402
DataSet "MSB144*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB048*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB066*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB034*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet 1Q16 = ( MSB014 , MSB002 ); //_ Attributes 4,14650608,System\Static
DataSet 2Q16 = ( MSB013 , MSB003 ); //_ Attributes 4,8590490,System\Static
DataSet My_Signed = ( MSB064 , Bit ); //_ Attributes 2,11156617,User\Esmail
DataSet Float_6_14 = ( MSB014 , MSB006 ); //_ Attributes 8,4194368
DataSet Int_33 = ( MSB032 , Bit ); //_ Attributes 2,16744448,System\Static
DataSet Int_17 = ( MSB016 , Bit ); //_ Attributes 2,16744448,System\Static
DataSet 1Q9 = ( MSB007 , MSB002 ); //_ Attributes 4,14650608,System\Static
DataSet 1Q16_UN = ( MSB015 , Bit ); //_ Attributes 4,14650608,System\Static
DataSet 1Q9_UN = ( MSB008 , Bit ); //_ Attributes 4,14650608,System\Static
DataSet 2Q10 = ( MSB007 , MSB003 ); //_ Attributes 4,12262621,System\Static
DataSet 1Q10 = ( MSB008 , MSB002 ); //_ Attributes 4,14650608,System\Static
DataSet IBitmapGraph = ( Unsupported ); //_ Attributes 1,11141375,BitmapGraphProj1,1
DataSet "IBitmapGraph*" = ( Word , Word ); //_ Attributes 1,11141375,BitmapGraphProj1,9
DataSet "DInt*" = ( Word , Word ); //_ Attributes 2,11141375,System\Static,16387
DataSet "MSB018*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB026*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB027*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB304*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB075*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB054*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB057*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB107*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB167*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet 10Signed = ( MSB009 , Bit ); //_ Attributes 2,16711680
DataSet RotateStruct = ( Variant , Variant ); //_ Attributes 1,4227072
DataSet _DSBSDIMEIO = ( Unsupported ); //_ Attributes 1,11141375,SBSDIMEIOLib,1
DataSet "_DSBSDIMEIO*" = ( Word , Word ); //_ Attributes 1,11141375,SBSDIMEIOLib,9
DataSet "MSB128*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "BIN128*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "MSB056*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet IComm = ( Unsupported ); //_ Attributes 1,11141375,SBIJTAG,1
DataSet "IComm*" = ( Word , Word ); //_ Attributes 1,11141375,SBIJTAG,9
DataSet "MSB024*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "BIN1024*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "Byte**" = ( Word , Word ); //_ Attributes 1,11141375,System,16401
DataSet "BIN512**" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "MSB256*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB060*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB280*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB061*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB116*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB147*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB186*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB202*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB352*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB188*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB400*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB190*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB093*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB065*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB071*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB136*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB028*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB081*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB117*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB225*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB165*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB033*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB070*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB087*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "_DMouseControl2*" = ( Word , Word ); //_ Attributes 1,11141375,MouseControl2Lib,9
DataSet Fixed32point24 = ( MSB024 , MSB008 ); //_ Attributes 4,0
DataSet Fixed31by24 = ( MSB024 , MSB007 ); //_ Attributes 4,65280
DataSet "MSB031*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB038*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB192*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB108*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "BIN032*" = ( Word , Word ); //_ Attributes 1,11141375,System\$BIN,16385
DataSet "MSB095*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet int23 = ( MSB022 , Bit ); //_ Attributes 2,65280
DataSet int16 = ( MSB015 , Bit ); //_ Attributes 2,8421376
DataSet Fixec32 = ( Word , Word ); //_ Attributes 4,0
DataSet Fixed36 = ( MSB018 , MSB018 ); //_ Attributes 4,4227327
DataSet Fixed24X8 = ( MSB024 , MSB008 ); //_ Attributes 4,16744448
DataSet "MSB041*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB043*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB059*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet Mul_DeRef = ( Variant ); //_ Attributes 1,32768
DataSet JoinCount = ( Variant ); //_ Attributes 1,0
DataSet "MSB030*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB288*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB504*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB098*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB328*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB105*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB083*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB025*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB012*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB688*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB238*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB119*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "Signed Byte*" = ( Word , Word ); //_ Attributes 2,11141375,System\Com
DataSet IXYGraphForm = ( Unsupported ); //_ Attributes 1,11141375,XYGraphFormProj1,1
DataSet "MSB078*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB051*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB062*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet Float24 = ( MSB016 , MSB006 ); //_ Attributes 8,32768
DataSet Vertex = ( Variant , Variant ); //_ Attributes 1,8421376
DataSet Int10 = ( MSB009 , Bit ); //_ Attributes 2,8421376
DataSet Int12 = ( MSB011 , Bit ); //_ Attributes 2,16776960
DataSet "MSB052*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet 9signed = ( MSB008 , Bit ); //_ Attributes 2,0
DataSet "MSB272*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB432*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB133*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB067*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB456*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB035*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB384*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB512*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB480*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB416*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB224*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB063*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB608*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB148*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB896*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB229*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet 9singed = ( MSB008 , Bit ); //_ Attributes 2,65535
DataSet "MSB068*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB069*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB072*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet Font = ( Unsupported ); //_ Attributes 1,11141375,XYGraphFormProj1,1
DataSet "Font*" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,9
DataSet "Font**" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,16393
DataSet "Font***" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,16393
DataSet "MSB158*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB168*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB132*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB240*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB134*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB264*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB172*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB101*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB178*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB122*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB126*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB094*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB376*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB127*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB096*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet S13 = ( MSB012 , Bit ); //_ Attributes 2,12615808
DataSet Fix2x14 = ( MSB014 , MSB002 ); //_ Attributes 4,65280
DataSet Fix3x13 = ( MSB013 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix10x14 = ( MSB014 , MSB010 ); //_ Attributes 4,8421376
DataSet Fix12x14 = ( MSB014 , MSB012 ); //_ Attributes 4,8388863
DataSet Fixed18x14 = ( MSB018 , MSB014 ); //_ Attributes 4,16744448
DataSet s16 = ( MSB015 , Bit ); //_ Attributes 2,8453888
DataSet "MSB125*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet AXIWrite_DeRef = ( Variant ); //_ Attributes 1,4194432
DataSet AXIRead_DeRef = ( Variant ); //_ Attributes 1,16744448
DataSet "MSB106*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB210*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB212*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet MrgList = ( Variant ); //_ Attributes 1,0
DataSet AXIReadReg_DeRef = ( Variant ); //_ Attributes 1,0
DataSet S20 = ( MSB020 ); //_ Attributes 2,16744448
DataSet S19 = ( MSB019 ); //_ Attributes 2,12615808
DataSet Fixed2p36 = ( MSB036 , MSB002 ); //_ Attributes 4,0
DataSet "MSB408*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB226*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet "MSB230*" = ( Word , Word ); //_ Attributes 1,11141375,System\$MSB,16385
DataSet Int_32 = ( MSB031 , Bit ); //_ Attributes 2,16744448
DataSet Int26 = ( MSB025 , Bit ); //_ Attributes 2,33023
DataSet Int11 = ( MSB010 , Bit ); //_ Attributes 2,33023
DataSet Int21 = ( MSB020 , Bit ); //_ Attributes 2,33023
DataSet Int9 = ( MSB008 , Bit ); //_ Attributes 2,33023
DataSet SignMSB008 = ( MSB009 ); //_ Attributes 2,16744448
DataSet SignMSB011 = ( MSB011 ); //_ Attributes 2,12615680
DataSet SignMSB017 = ( MSB017 ); //_ Attributes 2,15461355
DataSet Int41 = ( MSB040 , Bit ); //_ Attributes 2,33023
DataSet Int48 = ( MSB047 , Bit ); //_ Attributes 2,33023
DataSet Int25 = ( MSB024 , Bit ); //_ Attributes 2,33023
DataSet Multiplier_DeRef = ( Variant ); //_ Attributes 1,12632256
DataSet Multiplier1_DeRef = ( Variant ); //_ Attributes 1,8421504
DataSet Add_DeRef = ( Variant ); //_ Attributes 1,8421440
DataSet Fix1p15 = ( MSB015 , Bit ); //_ Attributes 4,65280
DataSet Fix15p1 = ( Bit , MSB015 ); //_ Attributes 4,16744576
DataSet Fix16p0 = ( NULL , MSB016 ); //_ Attributes 4,16744576
DataSet Float16 = ( MSB011 , MSB005 ); //_ Attributes 8,4227072
DataSet Fix2p15 = ( MSB015 , MSB002 ); //_ Attributes 4,65280
DataSet Fixed5p15 = ( MSB015 , MSB005 ); //_ Attributes 4,32768
DataSet Fixed2P15 = ( MSB015 , MSB002 ); //_ Attributes 4,65280
DataSet Fixed1P15 = ( MSB015 , Bit ); //_ Attributes 4,32768
DataSet Fixed5P15 = ( MSB015 , MSB005 ); //_ Attributes 4,32768
DataSet Fixed4P12 = ( MSB012 , MSB004 ); //_ Attributes 4,32768
DataSet Fixed5P11 = ( MSB011 , MSB005 ); //_ Attributes 4,32768
DataSet Fixed21P11 = ( MSB011 , MSB021 ); //_ Attributes 4,32768
DataSet Fixed7P11 = ( MSB011 , MSB007 ); //_ Attributes 4,32768
DataSet 16Signed = ( MSB015 , Bit ); //_ Attributes 2,64
DataSet 20Signed = ( MSB019 , Bit ); //_ Attributes 2,128
DataSet Fixed6P10 = ( MSB010 , MSB006 ); //_ Attributes 4,32768
DataSet Fixed7P9 = ( MSB009 , MSB007 ); //_ Attributes 4,32768
DataSet Fixed8P8 = ( MSB008 , MSB008 ); //_ Attributes 4,32768
DataSet Fixed9P7 = ( MSB007 , MSB009 ); //_ Attributes 4,32768
DataSet Fixed10P6 = ( MSB006 , MSB010 ); //_ Attributes 4,32768
DataSet 32Signed = ( MSB031 , Bit ); //_ Attributes 2,4210816
DataSet 18Signed = ( MSB017 , Bit ); //_ Attributes 2,4210816
DataSet 28Signed = ( MSB027 , Bit ); //_ Attributes 2,4210816
DataSet 27Signed = ( MSB026 , Bit ); //_ Attributes 2,4210816
DataSet 26Signed = ( MSB025 , Bit ); //_ Attributes 2,4210816
DataSet 19Signed = ( MSB018 , Bit ); //_ Attributes 2,4210816
DataSet 43Signed = ( MSB042 , Bit ); //_ Attributes 2,4210816
DataSet Fixed2P14 = ( MSB014 , MSB002 ); //_ Attributes 4,32768
DataSet 38Signed = ( MSB037 , Bit ); //_ Attributes 2,4210816
DataSet 33Signed = ( MSB032 , Bit ); //_ Attributes 2,4210816
DataSet Fixed3P13 = ( MSB013 , MSB003 ); //_ Attributes 4,32768
DataSet Fixed15P7 = ( MSB007 , MSB015 ); //_ Attributes 4,32768
DataSet Fix6p10 = ( MSB010 , MSB006 ); //_ Attributes 4,8453888
DataSet Fix10p6 = ( MSB006 , MSB010 ); //_ Attributes 4,8453888
DataSet Fix16p16 = ( MSB016 , MSB016 ); //_ Attributes 4,8453888
DataSet Fixed3P3 = ( MSB003 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix11p5 = ( MSB005 , MSB011 ); //_ Attributes 4,65280
DataSet Fix12p4 = ( MSB004 , MSB012 ); //_ Attributes 4,65280
DataSet Fix13p3 = ( MSB003 , MSB013 ); //_ Attributes 4,65280
DataSet Fix14p2 = ( MSB002 , MSB014 ); //_ Attributes 4,65280
DataSet Fixed11P5 = ( MSB005 , MSB011 ); //_ Attributes 4,32768
DataSet 5Singed = ( MSB005 ); //_ Attributes 2,64
DataSet Fixed12P4 = ( MSB004 , MSB012 ); //_ Attributes 4,32768
DataSet int8 = ( MSB008 ); //_ Attributes 2,0
DataSet FIxed9P23 = ( MSB023 , MSB009 ); //_ Attributes 4,255
DataSet IDispatch = ( Unsupported ); //_ Attributes 1,11141375,StdVCL,1
DataSet IMemoX = ( Unsupported ); //_ Attributes 1,11141375,Edits,1
DataSet "IMemoX*" = ( Word , Word ); //_ Attributes 1,11141375,Edits,9
DataSet IEditX = ( Unsupported ); //_ Attributes 1,11141375,Edits,1
DataSet "IEditX*" = ( Word , Word ); //_ Attributes 1,11141375,Edits,9
DataSet IMemObject = ( Unsupported ); //_ Attributes 1,11141375,PTEROUTILLib,1
DataSet "IMemObject*" = ( Word , Word ); //_ Attributes 1,11141375,PTEROUTILLib,9
DataSet "Bool*" = ( Word , Word ); //_ Attributes 1,11141375,System\Com
DataSet "ComInt*" = ( Word , Word ); //_ Attributes 2,11141375,System\Com
DataSet "Int*" = ( Word , Word ); //_ Attributes 2,11141375,System\Static,16386
DataSet IDeviceRect = ( Unsupported ); //_ Attributes 1,11141375,IEXTagLib,1
DataSet "IDeviceRect*" = ( Word , Word ); //_ Attributes 1,11141375,IEXTagLib,9
DataSet 6P4 = ( MSB004 , MSB006 ); //_ Attributes 4,14116968,System\$MSB
DataSet MSB98304 = ( MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 ); //_ Attributes 1,0,System\$MSB
DataSet Fix3P13 = ( MSB013 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix3P15 = ( MSB015 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix12P15 = ( MSB015 , MSB012 ); //_ Attributes 4,16744576
DataSet Fixed17P15 = ( MSB015 , MSB017 ); //_ Attributes 4,32768
DataSet Fixed_1p15 = ( MSB015 , Bit ); //_ Attributes 4,64
DataSet Fixed_4p12 = ( MSB012 , MSB004 ); //_ Attributes 4,64
DataSet Fixed_5p11 = ( MSB011 , MSB005 ); //_ Attributes 4,64
DataSet Fixed_6p10 = ( MSB010 , MSB006 ); //_ Attributes 4,64
DataSet Fixed_7p9 = ( MSB009 , MSB007 ); //_ Attributes 4,64
DataSet Fixed_8p8 = ( MSB008 , MSB008 ); //_ Attributes 4,64
DataSet Fixed_9p7 = ( MSB007 , MSB009 ); //_ Attributes 4,64
DataSet Fixed_10p6 = ( MSB006 , MSB010 ); //_ Attributes 4,64
DataSet Fixed_11p5 = ( MSB005 , MSB011 ); //_ Attributes 4,64
DataSet Fixed_12p4 = ( MSB004 , MSB012 ); //_ Attributes 4,64
DataSet Fixed_2p14 = ( MSB014 , MSB002 ); //_ Attributes 4,0
DataSet Fixed_3p13 = ( MSB013 , MSB003 ); //_ Attributes 4,0
DataSet Fixed_13p3 = ( MSB003 , MSB013 ); //_ Attributes 4,0
DataSet Fixed3P15 = ( MSB015 , MSB003 ); //_ Attributes 4,32768
DataSet Fixed12P15 = ( MSB015 , MSB012 ); //_ Attributes 4,32768
DataSet Fixed8P24 = ( MSB024 , MSB008 ); //_ Attributes 4,0
DataSet Fixed5P13 = ( MSB013 , MSB005 ); //_ Attributes 4,0
DataSet Fix1p17 = ( MSB017 , Bit ); //_ Attributes 4,65280
DataSet Fix27p0 = ( NULL , MSB027 ); //_ Attributes 4,65280
DataSet Fix31p17 = ( MSB017 , MSB031 ); //_ Attributes 4,255
DataSet Fix13p32 = ( MSB032 , MSB013 ); //_ Attributes 4,255
DataSet Fix16p32 = ( MSB032 , MSB016 ); //_ Attributes 4,255
DataSet Fix9p0 = ( NULL , MSB009 ); //_ Attributes 4,255
DataSet Signed_MSB009 = ( MSB009 ); //_ Attributes 2,0
DataSet null1 = ( NULL , NULL ); //_ Attributes 1,15461355
DataSet BR = ( Variant , Variant ); //_ Attributes 1,0,Undefined
DataSet TR = ( Variant , Variant ); //_ Attributes 1,0,Undefined
DataSet Fixed1P10 = ( MSB010 , Bit ); //_ Attributes 4,16744703
DataSet 9p10 = ( MSB010 , MSB009 ); //_ Attributes 4,8421631
DataSet 1p12 = ( MSB012 , MSB ); //_ Attributes 4,16776960,numbers
DataSet Fix1p12 = ( MSB012 , Bit ); //_ Attributes 4,16776960,numbers
DataSet Fix14p12 = ( MSB012 , MSB014 ); //_ Attributes 4,16776960,numbers
DataSet Fix13p0 = ( NULL , MSB013 ); //_ Attributes 4,16776960,numbers
DataSet Fix14p15 = ( MSB015 , MSB014 ); //_ Attributes 4,16776960,numbers
DataSet Fix1p8 = ( MSB008 , Bit ); //_ Attributes 4,16776960,numbers
DataSet Fix17p8 = ( MSB008 , MSB017 ); //_ Attributes 4,16776960,numbers
DataSet Fix33p8 = ( MSB008 , MSB033 ); //_ Attributes 4,16776960
DataSet Fix20p12 = ( MSB012 , MSB020 ); //_ Attributes 8,16776960
DataSet Fix21p20 = ( MSB020 , MSB021 ); //_ Attributes 8,16776960
DataSet Fix9p16 = ( MSB016 , MSB009 ); //_ Attributes 4,12615680
DataSet Fix17p31 = ( MSB031 , MSB017 ); //_ Attributes 4,12615680
DataSet Fix12p20 = ( MSB020 , MSB012 ); //_ Attributes 4,4227327
DataSet Fix7p20 = ( MSB020 , MSB007 ); //_ Attributes 4,12615680
DataSet Fix16P36 = ( MSB036 , MSB016 ); //_ Attributes 4,12615680
DataSet 8P24 = ( MSB024 , MSB008 ); //_ Attributes 4,0
DataSet 6P26 = ( MSB026 , MSB006 ); //_ Attributes 4,0
DataSet 6P10 = ( MSB010 , MSB006 ); //_ Attributes 4,0
DataSet 12P15 = ( MSB015 , MSB012 ); //_ Attributes 4,0
DataSet Fix1p26 = ( MSB026 , Bit ); //_ Attributes 4,16744448
DataSet Fix1P26 = ( MSB026 , Bit ); //_ Attributes 4,0
DataSet Fix1p37 = ( MSB037 , Bit ); //_ Attributes 4,0
DataSet Fix2p36 = ( MSB036 , MSB002 ); //_ Attributes 4,0
DataSet Fix1p36 = ( MSB036 , Bit ); //_ Attributes 4,0
DataSet 8P0 = ( MSB008 ); //_ Attributes 4,16711680
DataSet Fixed_8p24 = ( MSB024 , MSB008 ); //_ Attributes 4,16776960,System\Static
DataSet Fixed_12p15 = ( MSB015 , MSB012 ); //_ Attributes 4,10485760,System\Static
DataSet Fixed_7p20 = ( MSB020 , MSB007 ); //_ Attributes 4,10485760,System\Static
DataSet Fixed_1p24 = ( MSB024 , Bit ); //_ Attributes 4,14116968,System\Static
DataSet 7p20 = ( MSB020 , MSB007 ); //_ Attributes 4,16776960
DataSet 8p24 = ( MSB024 , MSB008 ); //_ Attributes 4,16776960
DataSet Uint64 = ( MSB064 , MSB ); //_ Attributes 1,16711808,System\$MSB

Object Sheet_2
//_ Attributes WipSheet
{
 //_ Object Prototypes
 Object Output( Bit AXI2WriteNxtWR) ;  //_GUI 659,57
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:A( Bit AXI2WriteBusy) ;  //_GUI 670,63
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 687,67
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 677,66
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 666,63
 Object Output:B( Bit AXI2WriteDone) ;  //_GUI 698,69
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:C( Bit AXI2ReadNxt) ;  //_GUI 659,51
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:D( Bit AXI2ReadBusy) ;  //_GUI 689,54
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:E( MSB128 AXI2ReadData) ;  //_GUI 659,48
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit Pulse) OneShot:A( Bit I, Bit ClkG) ;  //_GUI 705,46
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 695,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 677,54
 Object Output:F( Bit AXI2ReadDone) ;  //_GUI 716,48
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 673,88
 Object ( Variant NxtIndex) AXIReadReg( Variant Data, Variant Index) ;  //_GUI 720,84
 Object ( MSB008 Index) Input;  //_GUI 713,88
 //_ Attributes Constant="2"
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 673,80
 Object ( MSB008 AXI2ReadNums) Input:A;  //_GUI 605,48
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( MSB032 AXI2ReadAddress) Input:B;  //_GUI 605,45
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit AXI2ReadGo) Input:C;  //_GUI 605,51
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 694,83
 Object ( Variant AXI_2_S_CLK) Input:D;  //_GUI 685,77
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit WaitRead2) Input:E;  //_GUI 605,54
 //_ Attributes Constant="0"
 Object ( Bit md_error2) Input:F;  //_GUI 605,69
 //_ Attributes Constant="0"
 Object ( Bit AXI2WriteGo) Input:G;  //_GUI 605,66
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( MSB128 AXI2WriteDataIn) Input:H;  //_GUI 605,57
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( MSB032 AXI2WriteAddress) Input:I;  //_GUI 605,60
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( MSB008 AXI2WriteNums) Input:J;  //_GUI 605,63
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit ReadActive, MSB128 ReadDataOut, Bit ReadReady
    , Bit BusyRead, Bit NextWrite, Bit WriteActive, Bit BusyWrite
    , MSB002 m_axi_rresp, Variant m_axi_bresp) "AXI_2_MASTER_128Bits_DRAM_V1.2"( MSB032 ReadAddress, MSB008 ReadNums
    , Bit GoRead, Bit WaitRead, MSB128 DataIn, MSB032 WriteAddress
    , MSB008 WriteNums, Bit GoWrite, Bit md_error) ;  //_GUI 616,44
 Object ( MSB128 Data, Bit NXT_Read, Bit Busy) "AXI_2_Read_Nums_128bits_V1.0"
    ( MSB032 Address, MSB008 Nums, Bit Go) ;  //_GUI 139,69
 Object ( MSB032 Addr) Input:K;  //_GUI 67,70
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite( Variant In1
    , Variant Index) ;  //_GUI 71,69
 Object ( MSB008 Index) Input:L;  //_GUI 67,73
 //_ Attributes Constant="20"
 Object ( MSB024 Nums) Input:M;  //_GUI 67,79
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite:A( Variant In1
    , Variant Index) ;  //_GUI 71,78
 Object ( MSB008 index) Input:N;  //_GUI 67,82
 //_ Attributes Constant="21"
 Object ( Bit Go) Input:O;  //_GUI 67,90
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite:B( Variant In1
    , Variant Index) ;  //_GUI 71,89
 Object ( MSB008 index) Input:P;  //_GUI 67,93
 //_ Attributes Constant="22"
 Object ( Variant Pulse) OneShot:B( Variant I, Bit ClkG) ;  //_GUI 88,89
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 301,69
 Object Output:G( Bit AXI_2_WriteBlocksLastGo) ;  //_GUI 460,37
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 449,58
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 450,45
 Object Text;  //_GUI 299,33,1*36K
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 492,47
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 492,50
 Object ( Bit CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR) ;  //_GUI 374,104
 Object ( MSB032 CBy) Input:Q;  //_GUI 369,105
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant NxtIndex) AXIReadReg:A( Variant Data, Variant Index) ;  //_GUI 398,107
 Object ( MSB008 Index) Input:R;  //_GUI 394,111
 //_ Attributes Constant="21"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 255,79
 Object ( Bit CO, Variant Count) Count:A( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR) ;  //_GUI 298,97
 Object ( MSB032 CBy) Input:S;  //_GUI 293,98
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant NxtIndex) AXIReadReg:B( Variant Data, Variant Index) ;  //_GUI 317,100
 Object ( MSB008 Index) Input:T;  //_GUI 313,104
 //_ Attributes Constant="19"
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 426,45
 Object ( Bit Bit) Input:U;  //_GUI 419,49
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Hi, Variant Lo) Hi_N:A( Variant Data
    , Variant Hi_N) ;  //_GUI 467,48
 Object ( MSB032 MSB032) Input:V;  //_GUI 462,52
 //_ Attributes PromoteToParentObject="False"
 Object ( Variant Out1) CollectMSB:A( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 331,34
 Object ( MSB023 M23) Input:W;  //_GUI 326,35
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Hi, Variant Lo) Hi_N:B( Variant Data
    , Variant Hi_N) ;  //_GUI 406,42
 Object ( MSB023 MSB023) Input:X;  //_GUI 400,46
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant OutAddr, Variant OutNums, Variant LastDone
    , Variant Done) "GenAddressBeforWrite1.2"( MSB032 Address, MSB024 Nums, Bit RowLastGo
    , Bit LastGo, Bit Go) ;  //_GUI 292,40
 Object ( Bit CO, Variant Count) Count:B( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR) ;  //_GUI 374,89
 Object ( MSB032 CBy) Input:Y;  //_GUI 369,90
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant NxtIndex) AXIReadReg:C( Variant Data, Variant Index) ;  //_GUI 398,92
 Object ( MSB008 Index) Input:Z;  //_GUI 394,96
 //_ Attributes Constant="20"
 Object Output:H( Bit AXIFIFOBusy2) ;  //_GUI 372,76
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Variant DataOut, Bit Clk, Bit Reset
    , Bit OnReady, Bit ProgFull, Bit Done, Bit Busy) StandardFIFO
    ( Variant DataIn, Variant NDepth, Bit ClkG, Bit Reset
    , Bit Go, Bit Wait) ;  //_GUI 369,42
 Object ( Variant DataOut, Bit Clk, Bit Reset
    , Bit OnReady, Bit ProgFull, Bit Done, Bit Busy) StandardFIFO:A
    ( Variant DataIn, Variant NDepth, Bit ClkG, Bit Reset
    , Bit Go, Bit Wait) ;  //_GUI 344,63
 Object ( Bit bit) Input:a;  //_GUI 339,67
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Bit bit) Input:b;  //_GUI 365,46
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( MSB032 Addr) Input:c;  //_GUI 217,39
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite:C( Variant In1
    , Variant Index) ;  //_GUI 221,38
 Object ( MSB008 Index) Input:d;  //_GUI 217,42
 //_ Attributes Constant="23"
 Object ( MSB024 Nums) Input:e;  //_GUI 217,47
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite:D( Variant In1
    , Variant Index) ;  //_GUI 221,46
 Object ( MSB008 index) Input:f;  //_GUI 217,50
 //_ Attributes Constant="24"
 Object ( MSB032 OutAddr, MSB024 OutNums, Bit RowLastDone
    , Variant LastDone, Bit Done) "SlicAddressBeforWrite_v1.1"( Bit IsSlic, MSB032 Address
    , MSB024 WidthNums, MSB024 LineNums, MSB016 Height, Bit Go) ;  //_GUI 262,40
 Object ( Bit IsSlic) Input:AA;  //_GUI 256,41
 //_ Attributes Constant="0"
 Object ( MSB024 LineNums) Input:BA;  //_GUI 257,50
 //_ Attributes Constant="1",PromoteToParentObject="False"
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 242,52
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 239,47
 Object ( MSB016 M16) Input:CA;  //_GUI 237,56
 //_ Attributes Constant="0"
 Object ( Bit NXT_Wr, Bit Busy) "AXI_2_Write_Nums_128bits_V1.0"( MSB128 DataIn
    , MSB032 Address, MSB008 Nums, Bit Go) ;  //_GUI 510,45
 Object ( MSB032 Address, MSB008 Size, Bit Done
    , Bit Busy) AXI_GenAddressForRead_2( MSB032 ReadAddress, MSB024 ReadNums, Bit Go
    , Bit Wait) ;  //_GUI 106,69

 //_ Behavior Topology
 Output.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".4;  
 Output:A.0 = Junction.1;  
 OneShot.0 = INVERT.0;  
 INVERT.0 = Junction.2;  //_GUI 667,69
 Junction.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".6;  
 Output:B.0 = OneShot.0;  
 Output:C.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".2;  
 Output:D.0 = Junction:A.1;  
 Output:E.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".1;  
 OneShot:A.0 = INVERT:A.0;  
 INVERT:A.0 = Junction:A.0;  //_GUI 678,48
 Junction:A.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".3;  
 Output:F.0 = OneShot:A.0;  
 Reg.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".8;  //_GUI 660,90, 660,70
 AXIReadReg.0 = CollectMSB.0;  
 AXIReadReg.1 = Input.0;  
 Reg:A.0 = "AXI_2_MASTER_128Bits_DRAM_V1.2".7;  //_GUI 663,82, 663,67
 CollectMSB.0 = Input:D.0;  //_GUI 693,85, 693,78
 CollectMSB.1 = Reg:A.0;  //_GUI 685,88, 685,83
 CollectMSB.2 = Reg.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".0 = Input:B.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".1 = Input:A.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".2 = Input:C.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".3 = Input:E.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".4 = Input:H.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".5 = Input:I.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".6 = Input:J.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".7 = Input:G.0;  
 "AXI_2_MASTER_128Bits_DRAM_V1.2".8 = Input:F.0;  
 "AXI_2_Read_Nums_128bits_V1.0".0 = AXI_GenAddressForRead_2.0;  
 "AXI_2_Read_Nums_128bits_V1.0".1 = AXI_GenAddressForRead_2.1;  
 "AXI_2_Read_Nums_128bits_V1.0".2 = AXI_GenAddressForRead_2.2;  //_GUI 136,80, 136,77
 AXIRegWrite.0 = Input:K.0;  
 AXIRegWrite.1 = Input:L.0;  
 AXIRegWrite:A.0 = Input:M.0;  
 AXIRegWrite:A.1 = Input:N.0;  
 AXIRegWrite:B.0 = Input:O.0;  
 AXIRegWrite:B.1 = Input:P.0;  
 OneShot:B.0 = AXIRegWrite:B.0;  
 RegOnGo.0 = "AXI_2_Read_Nums_128bits_V1.0".0;  
 RegOnGo.3 = Junction:C.1;  
 Output:G.0 = AND.0;  
 Junction:B.0 = StandardFIFO.5;  
 AND.0 = Hi_N.0;  
 AND.1 = Junction:B.0;  
 MSB.0 = Hi_N:A.0;  
 MSB:A.0 = Hi_N:A.1;  
 Count.0 = Input:Q.0;  
 Count.2 = StandardFIFO:A.6;  //_GUI 341,112, 341,83
 AXIReadReg:A.0 = Count.1;  
 AXIReadReg:A.1 = Input:R.0;  
 Junction:C.0 = "AXI_2_Read_Nums_128bits_V1.0".1;  //_GUI 243,80, 243,74
 Count:A.0 = Input:S.0;  
 Count:A.2 = Junction:C.2;  //_GUI 256,105
 AXIReadReg:B.0 = Count:A.1;  
 AXIReadReg:B.1 = Input:T.0;  
 Hi_N.0 = Hi_N:B.1;  
 Hi_N.1 = Input:U.0;  
 Hi_N:A.0 = Hi_N.1;  
 Hi_N:A.1 = Input:V.0;  
 CollectMSB:A.0 = Input:W.0;  
 CollectMSB:A.1 = "GenAddressBeforWrite1.2".2;  //_GUI 325,39, 325,48
 CollectMSB:A.2 = "GenAddressBeforWrite1.2".0;  
 CollectMSB:A.3 = "GenAddressBeforWrite1.2".1;  
 Hi_N:B.0 = StandardFIFO.0;  
 Hi_N:B.1 = Input:X.0;  
 "GenAddressBeforWrite1.2".0 = "SlicAddressBeforWrite_v1.1".0;  
 "GenAddressBeforWrite1.2".1 = "SlicAddressBeforWrite_v1.1".1;  
 "GenAddressBeforWrite1.2".2 = "SlicAddressBeforWrite_v1.1".2;  
 "GenAddressBeforWrite1.2".3 = "SlicAddressBeforWrite_v1.1".3;  
 "GenAddressBeforWrite1.2".4 = "SlicAddressBeforWrite_v1.1".4;  //_GUI 292,57
 Count:B.0 = Input:Y.0;  
 Count:B.2 = StandardFIFO:A.5;  //_GUI 366,97, 366,80
 AXIReadReg:C.0 = Count:B.1;  
 AXIReadReg:C.1 = Input:Z.0;  
 Output:H.0 = StandardFIFO:A.4;  
 StandardFIFO.0 = CollectMSB:A.0;  //_GUI 350,44, 350,37
 StandardFIFO.1 = Input:b.0;  
 StandardFIFO.4 = "GenAddressBeforWrite1.2".3;  //_GUI 360,59, 360,54
 StandardFIFO.5 = "AXI_2_Write_Nums_128bits_V1.0".1;  
 StandardFIFO:A.0 = RegOnGo.0;  //_GUI 319,65, 319,71
 StandardFIFO:A.1 = Input:a.0;  
 StandardFIFO:A.4 = RegOnGo.3;  
 StandardFIFO:A.5 = "AXI_2_Write_Nums_128bits_V1.0".0;  //_GUI 543,83, 543,48
 AXIRegWrite:C.0 = Input:c.0;  
 AXIRegWrite:C.1 = Input:d.0;  
 AXIRegWrite:D.0 = Input:e.0;  
 AXIRegWrite:D.1 = Input:f.0;  
 "SlicAddressBeforWrite_v1.1".0 = Input:AA.0;  
 "SlicAddressBeforWrite_v1.1".1 = AXIRegWrite:C.0;  //_GUI 251,45, 251,40
 "SlicAddressBeforWrite_v1.1".2 = Junction:D.1;  
 "SlicAddressBeforWrite_v1.1".3 = Input:BA.0;  
 "SlicAddressBeforWrite_v1.1".4 = Lo_N.1;  //_GUI 254,54, 254,57
 "SlicAddressBeforWrite_v1.1".5 = Junction:C.0;  //_GUI 256,57
 Lo_N.0 = Junction:D.2;  //_GUI 240,54
 Lo_N.1 = Input:CA.0;  
 Junction:D.0 = AXIRegWrite:D.0;  
 "AXI_2_Write_Nums_128bits_V1.0".0 = StandardFIFO:A.0;  //_GUI 506,47, 506,65
 "AXI_2_Write_Nums_128bits_V1.0".1 = MSB.0;  
 "AXI_2_Write_Nums_128bits_V1.0".2 = MSB:A.0;  
 "AXI_2_Write_Nums_128bits_V1.0".3 = Junction:B.1;  
 AXI_GenAddressForRead_2.0 = AXIRegWrite.0;  
 AXI_GenAddressForRead_2.1 = AXIRegWrite:A.0;  //_GUI 92,74, 92,80
 AXI_GenAddressForRead_2.2 = OneShot:B.0;  //_GUI 99,77
}

Object ( Variant Pulse) OneShot( Variant I, Bit ClkG) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant I) Input;  //_GUI 13,13
 Object ( Bit ClkG) Input:A;  //_GUI 13,29
 //_ Attributes Resource="Global"
 Object Output( Variant Pulse) ;  //_GUI 96,12
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,12
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 39,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 19,13
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 23,11
 Object ( Variant Pulse) OneShot( Variant I, Bit ClkG) ;  //_GUI 45,11
 Object ( Variant Pulse) OneShot:A( Variant I, Bit ClkG) ;  //_GUI 45,25
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 84,10

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = OneShot:A.0;  //_GUI 61,17, 61,28
 VariantOut.1 = OneShot.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 VariantIn.0 = Junction:A.1;  
 OneShot.0 = VariantIn.1;  
 OneShot.1 = Junction.0;  //_GUI 40,16
 OneShot:A.0 = VariantIn.0;  //_GUI 34,27
 OneShot:A.1 = Junction.1;  
 Cast.0 = Junction:A.0;  //_GUI 84,9, 20,9
 Cast.1 = VariantOut.0;  
}

Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers"
{
 // A single synchronous pulse is output after the input is clocked high.  Another pulse will not go out until the input is clocked low and then is clocked high again.  This object is frequently used between a Go input widget and an object's Go input node so that only a single Go is passed for each cycle of the Go widget.  Note that there is also a variant input/output version of the OneShot object that encapsulates a set of independent OneShot objects.
 //
 // Inputs:
 //
 // Bit I: Input
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Outputs:
 //
 // Bit Pulse: Pulse
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit I) Input;  //_GUI 29,24
 Object ( Bit ClkG) Input:A;  //_GUI 29,45
 //_ Attributes Resource="Global"
 Object Output( Bit Pulse) ;  //_GUI 87,49
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 91,28
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 40,24
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 31,33
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 41,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In2) ;  //_GUI 78,40
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 74,31
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 79,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 54,45
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 19,33
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 111,29
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 62,29

 //_ Behavior Topology
 Output.0 = Junction:B.2;  //_GUI 75,50
 AND.0 = Junction.1;  //_GUI 88,30, 88,25
 AND.1 = OR.0;  
 Junction.0 = Input.0;  
 INVERT.0 = OR:A.0;  
 AND:A.0 = Junction.2;  
 AND:A.1 = INVERT.0;  
 Junction:A.0 = Reg.0;  //_GUI 125,41, 125,32
 Junction:B.0 = Reg:A.0;  
 OR.0 = Junction:B.1;  
 OR.1 = Junction:A.1;  
 Junction:C.0 = Input:A.0;  
 OR:A.0 = Junction:B.0;  //_GUI 19,28, 75,28
 OR:A.1 = Junction:A.0;  //_GUI 19,41
 Reg.0 = AND.0;  
 Reg.1 = Junction:C.1;  //_GUI 103,34, 103,46
 Reg:A.0 = AND:A.0;  //_GUI 51,31
 Reg:A.1 = Junction:C.0;  //_GUI 55,34
}

Object ( Variant Q) Reg( Variant D, Bit ClkG) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers"
{
 // D Flip Flop (what goes in, comes out on each clock cycle)
 //
 // Inputs:
 //
 // Variant D:	The value to be registered on the next rising clock edge.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 10,17
 Object ( Bit ClkG) Input:A;  //_GUI 11,27
 //_ Attributes Resource="Global"
 Object Output( Variant Q) ;  //_GUI 100,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 21,15
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 63,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 39,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 16,17
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 43,15
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 43,23
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 85,14

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = Reg:A.0;  //_GUI 57,21, 57,26
 VariantOut.1 = Reg.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Reg.0 = VariantIn.1;  
 Reg.1 = Junction.0;  //_GUI 40,20
 Reg:A.0 = VariantIn.0;  //_GUI 37,25, 37,20
 Reg:A.1 = Junction.1;  
 Cast.0 = Junction:A.0;  //_GUI 76,16, 76,13, 17,13
 Cast.1 = VariantOut.0;  
}

Object ( Bit Q) Reg( Bit D, Bit ClkG) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="leaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit D) Input;  //_GUI 23,20
 Object ( Bit ClkG) Input:A;  //_GUI 23,23
 //_ Attributes Resource="Global"
 Object Output( Bit Q) ;  //_GUI 47,21
 Object ( Bit Q) RegClr( Bit D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 32,19

 //_ Behavior Topology
 Output.0 = RegClr.0;  
 RegClr.0 = Input.0;  
 RegClr.1 = Input:A.0;  
}

Object ( NULL Q) Reg( NULL D, Bit ClkG) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="NULL"
{
 // D Flip Flop (what goes in, comes out on each clock cycle)
 //
 // Inputs:
 //
 //   D - Data In
 //   ClkG - Clock
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 10,16
 Object ( Bit ClkG) Input:A;  //_GUI 11,27
 //_ Attributes Resource="Global"
 Object Output( NULL Q) ;  //_GUI 98,16

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant NxtIndex) AXIReadReg( Variant Data, Variant Index) 
{
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 42,53
 Object ( Variant Index) Input:A;  //_GUI 105,72
 //_ Attributes Constant="3"
 Object Output( Variant NxtIndex) ;  //_GUI 144,82
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 58,49
 Object ( MSB032 In) Input:B;  //_GUI 54,42
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 102,53
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 113,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,53
 Object ( AXIReadReg_DeRef Out) AXIReadReg_DeRefOut( Variant In1) ;  //_GUI 137,68
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 123,68
 Object ( Variant Out1) Inc( Variant In1) ;  //_GUI 125,80
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 114,72
 Object Output:A( AXIReadReg_DeRef AXIReadRegG) ;  //_GUI 162,70
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 75,48
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 122,92
 //_ Attributes System="X86CPU"
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 141,93
 //_ Attributes System="X86CPU"
 Object ( MSB004 MSB004) Input:C;  //_GUI 136,97
 //_ Attributes System="X86CPU",Constant="8",PromoteToParentObject="False"
 Object ( Bit Out1) INVERT( Bit In1) ;  //_GUI 155,93
 //_ Attributes System="X86CPU"
 Object Output:B( Bit Out) ;  //_GUI 168,95
 //_ Attributes Trap="Index error.",PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 117,82

 //_ Behavior Topology
 Output.0 = Inc.0;  
 Lo_N.0 = Input:B.0;  
 Lo_N.1 = Junction.1;  
 ListOut.0 = Junction.2;  //_GUI 102,65, 52,65
 ListOut.1 = Zero.0;  //_GUI 95,55, 95,51
 MSB.0 = ListOut.0;  
 Junction.0 = Input.0;  
 AXIReadReg_DeRefOut.0 = ListOut:A.0;  
 ListOut:A.0 = Junction:A.1;  
 ListOut:A.1 = MSB.0;  
 Inc.0 = Junction:B.1;  
 Junction:A.0 = Input:A.0;  
 Output:A.0 = AXIReadReg_DeRefOut.0;  
 Zero.0 = Lo_N.0;  
 BitLength.0 = Junction:B.2;  //_GUI 118,95
 Equal.0 = BitLength.0;  
 Equal.1 = Input:C.0;  
 INVERT.0 = Equal.0;  
 Output:B.0 = INVERT.0;  
 Junction:B.0 = Junction:A.2;  //_GUI 115,83
}

Object ( Variant NxtIndex) AXIReadReg( List Data, Variant Index) 
{
 //_ Object Prototypes
 Object ( List Data) Input;  //_GUI 33,30
 Object ( Variant Index) Input:A;  //_GUI 33,40
 //_ Attributes Constant="3"
 Object Output( Variant NxtIndex) ;  //_GUI 84,30
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 38,28
 Object ( Variant NxtIndex) AXIReadReg( Variant Data, Variant Index) ;  //_GUI 69,36
 Object ( Variant NxtIndex) AXIReadReg:A( Variant Data, Variant Index) ;  //_GUI 69,28

 //_ Behavior Topology
 Output.0 = AXIReadReg:A.0;  
 ListIn.0 = Input.0;  
 AXIReadReg.0 = ListIn.0;  //_GUI 57,38, 57,33
 AXIReadReg.1 = Input:A.0;  
 AXIReadReg:A.0 = ListIn.1;  
 AXIReadReg:A.1 = AXIReadReg.0;  //_GUI 69,36, 83,36
}

Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,32
 Object ( Variant In2) Input:A;  //_GUI 26,38
 Object ( Variant In3) Input:B;  //_GUI 26,41
 Object Output( Variant Out1) ;  //_GUI 68,33
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 33,37
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = CollectMSB:A.0;  
 CollectMSB.0 = Input:A.0;  
 CollectMSB.1 = Input:B.0;  
 CollectMSB:A.0 = Input.0;  
 CollectMSB:A.1 = CollectMSB.0;  //_GUI 48,36, 48,40
}

Object ( Bit ReadActive, MSB128 ReadDataOut, Bit ReadReady
    , Bit BusyRead, Bit NextWrite, Bit WriteActive, Bit BusyWrite
    , MSB002 m_axi_rresp, Variant m_axi_bresp) "AXI_2_MASTER_128Bits_DRAM_V1.2"( MSB032 ReadAddress, MSB008 ReadNums
    , Bit GoRead, Bit WaitRead, MSB128 DataIn, MSB032 WriteAddress
    , MSB008 WriteNums, Bit GoWrite, Bit md_error) 
//_ Attributes TreeGroup="Dram_128bit"
{
 //_ Object Prototypes
 Object ( MSB032 ReadAddress) Input;  //_GUI 20,22
 Object ( MSB008 ReadNums) Input:A;  //_GUI 20,26
 //_ Attributes WidgetLeft="20",WidgetTop="270",WidgetWidth="204",WidgetHeight="50",Widget="TextBox"
 Object ( Bit GoRead) Input:B;  //_GUI 20,37
 Object ( Bit WaitRead) Input:C;  //_GUI 269,77
 Object ( MSB128 DataIn) Input:D;  //_GUI 266,83
 Object ( MSB032 WriteAddress) Input:E;  //_GUI 20,100
 Object ( MSB008 WriteNums) Input:F;  //_GUI 20,103
 Object ( Bit GoWrite) Input:G;  //_GUI 20,113
 Object ( Bit md_error) Input:H;  //_GUI 274,172
 Object Output( Bit ReadActive) ;  //_GUI 330,68
 Object Output:A( MSB128 ReadDataOut) ;  //_GUI 330,71
 Object Output:B( Bit ReadReady) ;  //_GUI 330,74
 Object Output:C( Bit BusyRead) ;  //_GUI 232,77
 Object Output:D( Bit NextWrite) ;  //_GUI 330,80
 Object Output:E( Bit WriteActive) ;  //_GUI 334,164
 Object Output:F( Bit BusyWrite) ;  //_GUI 334,167
 Object Output:G( MSB002 m_axi_rresp) ;  //_GUI 334,170
 Object Output:H( Variant m_axi_bresp) ;  //_GUI 334,173
 Object Output:I( List AXI_2_DramReadDebug) ;  //_GUI 312,60
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 301,58
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 267,86
 Object Output:J( Bit AXI_2_DramWriteGoDebug) ;  //_GUI 345,115
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 334,113
 Object Output:K( List AXI_2_DramWriteDebug) ;  //_GUI 345,107
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 334,105
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 283,71
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 286,74
 Object ( Bit Q) StickyRegSync( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 120,36
 Object Output:L( Bit AXI_2_DramReadGoDebug) ;  //_GUI 334,50
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 274,109
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 271,114
 Object ( Bit Pulse) OneShot:A( Bit I, Bit ClkG) ;  //_GUI 287,48
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 279,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In1) ;  //_GUI 210,49
 Object Text;  //_GUI 235,128,last
 Object Text;  //_GUI 234,98,addr
 Object Text;  //_GUI 234,107,len
 Object Text;  //_GUI 234,114,write go
 Object Text;  //_GUI 259,160,busyWrite
 Object ( Bit Q) StickyRegSync:A( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 124,112
 Object Text;  //_GUI 38,168,1DDR Nums02DDRDDR Nums0GenAddressBeforWrite3GenAddressBeforReadGenAddressBeforWrite
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 83,99
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 98,102
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 79,113
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 93,113
 Object Output:M( Bit AXI_2_MASTER_ReadLast) ;  //_GUI 341,77
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit TransactionType) Input:I;  //_GUI 274,169
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Variant Q) RegEn:B( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 84,21
 Object ( Variant Q) RegEn:C( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 99,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 83,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 98,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 323,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In0) ;  //_GUI 323,83
 Object Output:N( Bit AXI_2_MASTER_WriteLast) ;  //_GUI 341,83
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( MSB002 m_axi_2_rresp, MSB128 DataOut, Bit ReadReady
    , Bit ReadLast, Bit NextWrite, Bit WriteLast, Variant m_axi_2_bresp) AXI_2_MASTER_128bits
    ( Bit DoRead, MSB032 m_axi_2_araddr, MSB008 m_axi_2_arlen, Bit WaitRead
    , Bit DoWrite, MSB128 WriteData, MSB032 m_axi_2_awaddr, MSB008 m_axi_2_awlen
    , Bit TransactionType, Bit md_2_error) ;  //_GUI 291,67
 Object Output:O( Bit AXI_2_BlocksWriteOverDone) ;  //_GUI 128,144
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 96,142
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 110,144
 Object ( Bit Q) StickyRegSync:B( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 73,141
 Object ( Bit AXI_2_WriteBlocksLastGo) Input:J;  //_GUI 37,142
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit AXI_2_MASTER_WriteLast) Input:K;  //_GUI 52,154
 //_ Attributes Resource="Global",PromoteToParentObject="False"

 //_ Behavior Topology
 Output:A.0 = AXI_2_MASTER_128bits.1;  
 Output:B.0 = AXI_2_MASTER_128bits.2;  
 Output:C.0 = Junction:F.2;  //_GUI 211,78
 Output:D.0 = AXI_2_MASTER_128bits.4;  
 Output:F.0 = Junction:D.2;  //_GUI 272,168
 Output:G.0 = AXI_2_MASTER_128bits.0;  //_GUI 326,171, 326,69
 Output:H.0 = AXI_2_MASTER_128bits.6;  //_GUI 322,174, 322,87
 Output:I.0 = ListOut.0;  
 ListOut.0 = Junction:B.0;  //_GUI 287,63
 ListOut.1 = Junction:A.0;  //_GUI 284,60
 Junction.0 = RegEn.0;  //_GUI 264,87, 264,102
 Output:J.0 = OneShot.0;  
 OneShot.0 = Junction:D.1;  
 Output:K.0 = ListOut:A.0;  
 ListOut:A.0 = Junction:C.1;  
 ListOut:A.1 = Junction.2;  //_GUI 268,107
 Junction:A.0 = RegEn:B.0;  //_GUI 254,72, 254,24
 Junction:B.0 = RegEn:C.0;  //_GUI 250,75, 250,28
 StickyRegSync.0 = Junction:J.1;  
 StickyRegSync.2 = Junction:K.0;  //_GUI 117,44, 117,35, 324,35
 Output:L.0 = OneShot:A.0;  
 Junction:C.0 = RegEn:A.0;  //_GUI 264,110, 264,105
 Junction:D.0 = StickyRegSync:A.0;  
 OneShot:A.0 = Junction:E.1;  
 Junction:E.0 = Junction:F.1;  
 Junction:F.0 = StickyRegSync.0;  //_GUI 211,39
 StickyRegSync:A.0 = Junction:H.1;  
 StickyRegSync:A.2 = Junction:L.2;  //_GUI 123,120, 123,125, 324,125
 RegEn.0 = Input:E.0;  
 RegEn.2 = Junction:G.0;  //_GUI 80,107
 RegEn:A.0 = Input:F.0;  
 RegEn:A.2 = Junction:H.0;  //_GUI 94,110
 Junction:G.0 = Input:G.0;  
 Junction:H.0 = Junction:G.1;  
 Output:M.0 = Junction:K.1;  
 RegEn:B.0 = Input.0;  
 RegEn:B.2 = Junction:I.0;  
 RegEn:C.0 = Input:A.0;  
 RegEn:C.2 = Junction:J.0;  
 Junction:I.0 = Input:B.0;  
 Junction:J.0 = Junction:I.1;  
 Junction:K.0 = AXI_2_MASTER_128bits.3;  
 Junction:L.0 = AXI_2_MASTER_128bits.5;  
 Output:N.0 = Junction:L.1;  
 AXI_2_MASTER_128bits.0 = Junction:E.2;  //_GUI 280,69
 AXI_2_MASTER_128bits.1 = Junction:A.1;  
 AXI_2_MASTER_128bits.2 = Junction:B.1;  
 AXI_2_MASTER_128bits.3 = Input:C.0;  
 AXI_2_MASTER_128bits.4 = Junction:D.0;  //_GUI 272,81
 AXI_2_MASTER_128bits.5 = Input:D.0;  
 AXI_2_MASTER_128bits.6 = Junction.1;  
 AXI_2_MASTER_128bits.7 = Junction:C.0;  //_GUI 275,90
 AXI_2_MASTER_128bits.8 = Input:I.0;  //_GUI 278,93
 AXI_2_MASTER_128bits.9 = Input:H.0;  //_GUI 281,96, 281,173
 Output:O.0 = Junction:M.1;  
 AND.0 = StickyRegSync:B.0;  
 AND.1 = Input:K.0;  //_GUI 94,147, 94,155
 Junction:M.0 = AND.0;  
 StickyRegSync:B.0 = Input:J.0;  
 StickyRegSync:B.2 = Junction:M.2;  //_GUI 67,149, 67,159, 111,159
}

Object ( MSB128 Data, Bit NXT_Read, Bit Busy) "AXI_2_Read_Nums_128bits_V1.0"
    ( MSB032 Address, MSB008 Nums, Bit Go) 
//_ Attributes TreeGroup="Dram_128bit"
{
 //_ Object Prototypes
 Object ( MSB032 Address) Input;  //_GUI 157,51
 Object ( MSB008 Nums) Input:A;  //_GUI 157,54
 Object ( Bit Go) Input:B;  //_GUI 157,60
 Object Output( MSB128 Data) ;  //_GUI 230,52
 Object Output:A( Bit NXT_Read) ;  //_GUI 230,55
 Object Output:B( Bit Busy) ;  //_GUI 171,63
 Object ( Bit AXI2ReadBusy) Input:C;  //_GUI 157,63
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:C( MSB032 AXI2ReadAddress) ;  //_GUI 171,51
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:D( MSB008 AXI2ReadNums) ;  //_GUI 171,54
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:E( Bit AXI2ReadGo) ;  //_GUI 171,60
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( MSB128 AXI2ReadData) Input:D;  //_GUI 223,52
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit AXI2ReadNxt) Input:E;  //_GUI 223,55
 //_ Attributes Resource="Global",PromoteToParentObject="False"

 //_ Behavior Topology
 Output.0 = Input:D.0;  
 Output:A.0 = Input:E.0;  
 Output:B.0 = Input:C.0;  
 Output:C.0 = Input.0;  
 Output:D.0 = Input:A.0;  
 Output:E.0 = Input:B.0;  
}

Object ( Variant Out1, Variant NxtIndex) AXIRegWrite( Variant In1
    , Variant Index) 
{
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 24,44
 //_ Attributes Constant="0"
 Object ( Variant Index) Input:A;  //_GUI 19,51
 //_ Attributes Constant="0"
 Object Output( Variant Out1) ;  //_GUI 96,31
 Object Output:A( Variant NxtIndex) ;  //_GUI 127,51
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 58,27
 Object ( Variant AXIRegWrite) Input:B;  //_GUI 25,18
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) Inc( Variant In1) ;  //_GUI 54,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,51
 Object ( Variant Data) List_Mux_Sel_vivado( Variant ListData, Variant Sel) ;  //_GUI 30,17

 //_ Behavior Topology
 Output.0 = Lo_N.1;  
 Output:A.0 = Inc.0;  
 Lo_N.0 = List_Mux_Sel_vivado.0;  //_GUI 50,29
 Lo_N.1 = Input.0;  //_GUI 58,45
 Inc.0 = Junction.1;  
 Junction.0 = Input:A.0;  
 List_Mux_Sel_vivado.0 = Input:B.0;  
 List_Mux_Sel_vivado.1 = Junction.0;  //_GUI 29,22
}

Object ( List Out1, Variant NxtIndex) AXIRegWrite( List In1
    , Variant Index) 
{
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 19,28
 //_ Attributes Constant="0"
 Object ( Variant Index) Input:A;  //_GUI 19,41
 //_ Attributes Constant="0"
 Object Output( List Out1) ;  //_GUI 125,28
 Object Output:A( Variant NxtIndex) ;  //_GUI 127,49
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 24,26
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 108,26
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite( Variant In1
    , Variant Index) ;  //_GUI 51,37
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite:A( Variant In1
    , Variant Index) ;  //_GUI 51,26

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = AXIRegWrite:A.1;  //_GUI 86,50, 86,31
 ListIn.0 = Input.0;  
 ListOut.0 = AXIRegWrite.0;  //_GUI 98,31, 98,39
 ListOut.1 = AXIRegWrite:A.0;  
 AXIRegWrite.0 = ListIn.0;  //_GUI 35,39
 AXIRegWrite.1 = Input:A.0;  
 AXIRegWrite:A.0 = ListIn.1;  
 AXIRegWrite:A.1 = AXIRegWrite.1;  //_GUI 47,31, 47,36, 72,36, 72,42
}

Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced"
{
 // Registers and holds D/Q on a Go/Done until the next Go/Done.  This is a superset of the standard GDBW protocol which is implemented in RegGDBW or GBDW_Clr which only guarantees valid data output while Done is high.
 //
 // Another difference is this object passes the Wait directly to the Busy rather than delaying one clock like RegGDBW.  The RegGDBW has an extra layer or two of logic in the Busy Wait chain, which makes it harder to meet timing specifications at higher clock frequencies or with long chains of them.
 //
 // The RegOnGo object will cause larger sections of the pipe to stall simultaneously rather than only stalling when they have unconsumed data.  This is not a disadvantage if the pipe is normally full during normal operation.
 //
 // This object is sometimes convenient to use when interfacing with Enable logic objects.  Often they require data to be held until the next Go.
 //
 // Inputs:
 //
 // Variant D:	The data to be registered.
 //
 // Bit ClkG:	The input clock.  If disconnected, defaults to the ClkG, the global user clock signal.
 //
 // Bit AClr:	An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go:	Go of the GDBW protocol.  D is registered when Go is high and Busy is low on a rising clock edge.
 //
 // Bit Wait:	Wait of the GDBW protocol.  Holds off Done.  If disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Variant Q:	The data in the register.  This data is held stable while Wait is high, then will only change upon a Go input.
 //
 // Bit AClr:	An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go:	Go of the GDBW protocol.  D is registered when Go is high and Busy is low on a rising clock edge.
 //
 // Bit Done:	Done of the GDBW protocol.
 //
 // Bit Busy:	Busy of the GDBW protocol.  Tells the Go to hold off.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 14,25
 Object ( Bit ClkG) Input:A;  //_GUI 14,38
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 14,41
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 19,52
 Object ( Bit Wait) Input:D;  //_GUI 45,60
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 67,26
 Object Output:A( Bit ClkG) ;  //_GUI 67,38
 Object Output:B( Bit AClr) ;  //_GUI 67,41
 Object Output:C( Bit Done) ;  //_GUI 51,52
 Object Output:D( Bit Busy) ;  //_GUI 25,60
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 53,41
 Object ( Bit GoOne, Bit Done, Bit Busy) GDBW_Clr_1cyc_BWpass
    ( Bit ClkG, Bit CLR, Bit Go, Bit Wait) ;  //_GUI 25,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 20,41
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 23,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 47,38
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 54,24
 Object Text;  //_GUI 24,70,One problem with the GDBW protocol is it is sometimes difficult to interface with Enable logic.  One reason for this is that the GDBW protocol says that data is only valid while Go/Done is high.  Often with enable logic we need the data to be valid durring and after the done and only change on the next done.  This is what the RegOnGo object does.Another advantage of the RegOnGo object (Which uses the GDBW_Clr_1cyc_BWPass object is the Busy Wait chain is a pass through which reduces back propigation delay.
 Object Text;  //_GUI 35,6,Register the Data on Go and not waiting.  Q is held on the done and after until the next done

 //_ Behavior Topology
 Output.0 = RegClr.0;  
 Output:A.0 = Junction:C.1;  
 Output:B.0 = Junction.1;  
 Output:C.0 = GDBW_Clr_1cyc_BWpass.1;  
 Output:D.0 = GDBW_Clr_1cyc_BWpass.2;  
 Junction.0 = Junction:A.1;  
 GDBW_Clr_1cyc_BWpass.0 = Junction:B.2;  //_GUI 24,47
 GDBW_Clr_1cyc_BWpass.1 = Junction:A.2;  //_GUI 21,50
 GDBW_Clr_1cyc_BWpass.2 = Input:C.0;  
 GDBW_Clr_1cyc_BWpass.3 = Input:D.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:A.0;  
 Junction:C.0 = Junction:B.1;  
 RegClr.0 = Input.0;  
 RegClr.1 = Junction:C.0;  //_GUI 48,29
 RegClr.2 = GDBW_Clr_1cyc_BWpass.0;  //_GUI 51,32, 51,48
 RegClr.3 = Junction.0;  
}

Object ( Bit Out1) MSB( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="Bit"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 9,25
 Object Output( Bit Out1) ;  //_GUI 33,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) MSB( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="NULL"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 9,25
 Object Output( NULL Out1) ;  //_GUI 33,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) MSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a MSB pattern, producing a MSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 132,33
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 105,23
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 122,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,38
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,9
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 21,32
 Object ( Bit In2) Input:A;  //_GUI 27,60
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), 65535, >)"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 45,60
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 91,38
 Object ( Variant Out1) $Cast:A( Variant Data, MSB Type) ;  //_GUI 105,36
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 72,32
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 72,40
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Cast.0 = $Select:A.0;  //_GUI 93,28, 93,12
 $Select.0 = $Cast.0;  //_GUI 115,33
 $Select.1 = $Cast:A.0;  //_GUI 115,36
 $Select.2 = Junction:B.1;  //_GUI 122,61
 VariantIn.0 = $Select:B.0;  //_GUI 49,41
 $Select:A.0 = Junction.1;  
 $Select:A.2 = Junction:A.1;  //_GUI 22,17
 $Select:B.1 = Junction.2;  //_GUI 31,30
 $Select:B.2 = Junction:A.2;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,50, 46,50
 Junction:B.0 = Input:A.0;  
 VariantOut.0 = MSB:A.0;  
 VariantOut.1 = MSB.0;  //_GUI 87,40, 87,35
 $Cast:A.0 = VariantOut.0;  
 MSB.0 = VariantIn.1;  //_GUI 68,35, 68,40
 MSB:A.0 = VariantIn.0;  
}

Object ( Variant Out1) MSB( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="list"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a MSB pattern, producing a MSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 88,8
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 60,8
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 74,6
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 41,2
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 41,10
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 22,8

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantOut.0 = MSB:A.0;  
 VariantOut.1 = MSB.0;  //_GUI 56,10, 56,5
 $Cast.0 = VariantOut.0;  
 MSB.0 = ListIn.1;  //_GUI 37,5, 37,10
 MSB:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( Bit CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers"
{
 // Standard counter.  This object could also be considered an accumulator.  Larger counters at higher frequencies may not pass timing specifications.  In that case you could daisy chain smaller Count objects together or use a synchronous adder.  Note that there is also a List EN version of the Count object which creates a list of independent counters.
 //
 // Inputs:
 //
 // Variant CBy: Count by.  The dataset of CBy is the size of the internal accumuator.  The value of CBy is what is added if EN is high.  CBy can have a different value each time EN is high.  CBy can also be a List of Variants in which case they have a nested behavior.  A roll over of one will increment the next most significant counter in the list.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit EN: Enable.  If disconnected defaults to 1.
 //
 // Bit CLR: Asynchronous clear.  If disconnected
 // defaults to 0.
 //
 // Outputs:
 //
 // Bit CO: Carry Out.  If the internal accumulator rolls over, this bit goes high.
 //
 // Variant Count: Count.  The result of the count.  This is the output of the internal accumulator register and has the same dataset as CBy.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx, BINxxx, Signed (no OFL), Fixed (no OFL) and List.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 9,33
 Object ( Bit ClkG) Input:A;  //_GUI 76,45
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 76,48
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 76,51
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 142,19
 Object Output:A( Variant Count) ;  //_GUI 147,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 111,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 88,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 90,39
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 92,42
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 96,32
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 96,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 36,33
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 51,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 18,33
 Object ( Bit CO, Bit OFL, Variant S) $ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 64,29
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 131,30
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 117,17
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 23,31

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 Junction.0 = RegClr.0;  
 Junction:A.0 = Input:A.0;  //_GUI 89,46
 Junction:B.0 = Input:B.0;  //_GUI 91,49
 Junction:C.0 = Input:C.0;  //_GUI 93,52
 RegClr.0 = $ADSU.2;  //_GUI 85,34, 85,37
 RegClr.1 = Junction:A.2;  
 RegClr.2 = Junction:B.2;  
 RegClr.3 = Junction:C.2;  
 RegClr:A.0 = $ADSU.0;  //_GUI 85,19, 85,31
 RegClr:A.1 = Junction:A.1;  //_GUI 89,22
 RegClr:A.2 = Junction:B.1;  //_GUI 91,25
 RegClr:A.3 = Junction:C.1;  //_GUI 93,28
 Junction:D.0 = MSB.0;  
 Cast.0 = Junction:D.0;  //_GUI 37,25
 Cast.1 = Junction.0;  //_GUI 47,28, 47,12, 112,12
 Junction:E.0 = Input.0;  
 $ADSU.0 = Cast.0;  //_GUI 64,26
 $ADSU.1 = Junction:D.1;  
 Context.0 = Junction:E.0;  //_GUI 131,3, 19,3
 Context.1 = Junction.1;  
 VouchBit.0 = RegClr:A.0;  
 MSB.0 = Junction:E.1;  
}

Object ( List CO, List Count) Count( Variant CBy
    , Bit ClkG, List EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="Var/List"
{
 // This is a multi-bit EN version of the Count object, which creates a list of counters with independent enable inputs (EN).
 //
 // Inputs:
 //
 // Var/List CBy:Count by.  If this is a Variant (MSBxxx, LSBxxx or BINxxx datasets), this is the size and CBy value for each of the counters.  If this is a list, each counter can have a different CBy dataset and value.
 //
 // Bit ClkG:Global clock if disconnected or a specific clock if connected
 //
 // Var/List EN:A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  If EN and CBy are both lists, they must have the same list structure.
 //
 // Bit CLR:Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Outputs:
 //
 // List CO:List of Carry Out bits.  If the internal accumulator rolls over, this bit goes high.  Has the same list structure as EN.
 //
 // List Count:List of Count outputs.  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 15,19
 Object ( Bit ClkG) Input:A;  //_GUI 15,22
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 15,26
 Object ( Bit CLR) Input:C;  //_GUI 15,31
 Object Output( List CO) ;  //_GUI 92,20
 Object Output:A( List Count) ;  //_GUI 92,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 40,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 48,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 51,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 77,18
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 79,31
 Object ( Variant CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) ;  //_GUI 55,18
 Object ( Variant CO, Variant Count) Count:A( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) ;  //_GUI 55,34

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:B.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = Input.0;  
 ListOut.0 = Count:A.0;  //_GUI 71,23, 71,36
 ListOut.1 = Count.0;  
 ListOut:A.0 = Count:A.1;  //_GUI 73,36, 73,39
 ListOut:A.1 = Count.1;  //_GUI 67,33
 Count.0 = Junction:B.1;  
 Count.1 = Junction:A.1;  
 Count.2 = ListIn.1;  
 Count.3 = Junction.1;  //_GUI 47,29, 47,32
 Count:A.0 = Junction:B.2;  //_GUI 52,36
 Count:A.1 = Junction:A.2;  //_GUI 49,39
 Count:A.2 = ListIn.0;  //_GUI 44,42, 44,29
 Count:A.3 = Junction.2;  //_GUI 41,45
}

Object ( List CO, List Count) Count( List CBy
    , Bit ClkG, List EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="List/List"
{
 // This is a multi-bit EN version of the Count object, which creates a list of counters with independent enable inputs (EN).
 //
 // Inputs:
 //
 // Var/List CBy:Count by.  If this is a Variant (MSBxxx, LSBxxx or BINxxx datasets), this is the size and CBy value for each of the counters.  If this is a list, each counter can have a different CBy dataset and value.
 //
 // Bit ClkG:Global clock if disconnected or a specific clock if connected
 //
 // Var/List EN:A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  If EN and CBy are both lists, they must have the same list structure.
 //
 // Bit CLR:Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Outputs:
 //
 // List CO:List of Carry Out bits.  If the internal accumulator rolls over, this bit goes high.  Has the same list structure as EN.
 //
 // List Count:List of Count outputs.  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List CBy) Input;  //_GUI 15,10
 Object ( Bit ClkG) Input:A;  //_GUI 15,17
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 15,23
 Object ( Bit CLR) Input:C;  //_GUI 15,29
 Object Output( List CO) ;  //_GUI 95,10
 Object Output:A( List Count) ;  //_GUI 95,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 41,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 45,17
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,8
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 82,31
 Object ( Variant CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) ;  //_GUI 58,8
 Object ( Variant CO, Variant Count) Count:A( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) ;  //_GUI 58,34
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 29,8

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:B.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:A.0;  
 ListOut.0 = Count:A.0;  //_GUI 74,13, 74,36
 ListOut.1 = Count.0;  
 ListOut:A.0 = Count:A.1;  //_GUI 76,36, 76,39
 ListOut:A.1 = Count.1;  //_GUI 70,33
 Count.0 = ListIn:A.1;  
 Count.1 = Junction:A.1;  //_GUI 51,13, 51,18
 Count.2 = ListIn.1;  //_GUI 53,16, 53,23
 Count.3 = Junction.1;  //_GUI 55,19, 55,30
 Count:A.0 = ListIn:A.0;  //_GUI 48,36, 48,13
 Count:A.1 = Junction:A.2;  //_GUI 46,39
 Count:A.2 = ListIn.0;  //_GUI 44,42, 44,26
 Count:A.3 = Junction.2;  //_GUI 42,45
 ListIn:A.0 = Input.0;  
}

Object ( Variant CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced"
{
 // This is a multi-bit EN version of the Count object, which creates a list of counters with independent enable inputs (EN).
 //
 // Inputs:
 //
 // Var/List CBy:Count by.  If this is a Variant (MSBxxx, LSBxxx or BINxxx datasets), this is the size and CBy value for each of the counters.  If this is a list, each counter can have a different CBy dataset and value.
 //
 // Bit ClkG:Global clock if disconnected or a specific clock if connected
 //
 // Var/List EN:A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  If EN and CBy are both lists, they must have the same list structure.
 //
 // Bit CLR:Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Outputs:
 //
 // List CO:List of Carry Out bits.  If the internal accumulator rolls over, this bit goes high.  Has the same list structure as EN.
 //
 // List Count:List of Count outputs.  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 15,19
 Object ( Bit ClkG) Input:A;  //_GUI 15,22
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 15,26
 Object ( Bit CLR) Input:C;  //_GUI 15,31
 Object Output( Variant CO) ;  //_GUI 55,20
 Object Output:A( Variant Count) ;  //_GUI 55,23
 Object ( Variant CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) ;  //_GUI 40,19
 Object ( List Out1) Bit_List( Variant In1) ;  //_GUI 28,24

 //_ Behavior Topology
 Output.0 = Count.0;  
 Output:A.0 = Count.1;  
 Count.0 = Input.0;  //_GUI 40,20
 Count.1 = Input:A.0;  //_GUI 40,23
 Count.2 = Bit_List.0;  
 Count.3 = Input:C.0;  //_GUI 40,32
 Bit_List.0 = Input:B.0;  
}

Object ( NULL CO, NULL Count) Count( NULL CBy
    , Bit ClkG, Variant EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="NULL/var"
{
 // This is a multi-bit EN version of the Count object, which creates a list of counters with independent enable inputs (EN).
 //
 // Inputs:
 //
 // Var/List CBy:Count by.  If this is a Variant (MSBxxx, LSBxxx or BINxxx datasets), this is the size and CBy value for each of the counters.  If this is a list, each counter can have a different CBy dataset and value.
 //
 // Bit ClkG:Global clock if disconnected or a specific clock if connected
 //
 // Var/List EN:A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  If EN and CBy are both lists, they must have the same list structure.
 //
 // Bit CLR:Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Outputs:
 //
 // List CO:List of Carry Out bits.  If the internal accumulator rolls over, this bit goes high.  Has the same list structure as EN.
 //
 // List Count:List of Count outputs.  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL CBy) Input;  //_GUI 15,17
 Object ( Bit ClkG) Input:A;  //_GUI 15,22
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 15,26
 Object ( Bit CLR) Input:C;  //_GUI 15,31
 Object Output( NULL CO) ;  //_GUI 56,17
 Object Output:A( NULL Count) ;  //_GUI 55,21
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 47,17

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 48,22
 Junction.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N most-significant bits and the bitlength - N least-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Hi_N - the bitlength of this parameter specifies N - the number of bits in the hi data set.
 //
 // Outputs:
 // Hi - the N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - the bitlength - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 30,23
 Object ( Variant Hi_N) Input:A;  //_GUI 32,37
 Object Output( Variant Hi) ;  //_GUI 88,22
 Object Output:A( Variant Lo) ;  //_GUI 88,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 38,21
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 40,35
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 52,35
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 50,21
 Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Variant Hi_N) ;  //_GUI 76,21
 //_ Attributes Documentation="Variant/Variant"

 //_ Behavior Topology
 Output.0 = $Hi_N.0;  
 Output:A.0 = $Hi_N.1;  
 MSB.0 = Input.0;  
 LSB.0 = Input:A.0;  
 VariantIn.0 = LSB.0;  
 VariantIn:A.0 = MSB.0;  
 $Hi_N.0 = VariantIn:A.1;  
 $Hi_N.1 = VariantIn:A.0;  
 $Hi_N.2 = VariantIn.1;  //_GUI 73,29, 73,37
}

Object ( Bit Hi, NULL Lo) Hi_N( Bit Data
    , Bit Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,27
 Object ( Bit Hi_N) Input:A;  //_GUI 40,47
 Object Output( Bit Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 90,35
 Object ( NULL Out1) NULL;  //_GUI 72,33

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
}

Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Bit Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Bit"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( Bit Hi_N) Input:A;  //_GUI 40,47
 Object Output( Variant Hi) ;  //_GUI 82,26
 Object Output:A( Variant Lo) ;  //_GUI 82,36
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 46,25

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  //_GUI 72,37, 72,30
 VariantIn.0 = MSB.0;  
 MSB.0 = Input.0;  
}

Object ( Variant Hi, NULL Lo) Hi_N( Bit Data
    , Variant Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Var"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,28
 Object ( Variant Hi_N) Input:A;  //_GUI 35,44
 Object Output( Variant Hi) ;  //_GUI 97,15
 Object Output:A( NULL Lo) ;  //_GUI 98,60
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 47,42
 Object ( NULL Out1) NULL;  //_GUI 83,58
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 66,43
 //_ Attributes Documentation="ztlist"

 //_ Behavior Topology
 Output.0 = UExtnd.1;  //_GUI 85,16, 85,48
 Output:A.0 = NULL.0;  
 LSB.0 = Input:A.0;  
 UExtnd.0 = LSB.0;  
 UExtnd.1 = Input.0;  //_GUI 60,48, 60,29
}

Object ( NULL Hi, Variant Lo) Hi_N( Variant Data
    , NULL Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( NULL Hi_N) Input:A;  //_GUI 40,47
 Object Output( NULL Hi) ;  //_GUI 90,27
 Object Output:A( Variant Lo) ;  //_GUI 90,35
 Object ( NULL Out1) NULL;  //_GUI 78,25

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  //_GUI 67,36, 67,28
}

Object ( NULL Hi, NULL Lo) Hi_N( NULL Data
    , NULL Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 38,27
 Object ( NULL Hi_N) Input:A;  //_GUI 39,36
 Object Output( NULL Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 90,33
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,27

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,34
 Junction.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) Hi_N( NULL Data
    , Variant Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 38,27
 Object ( Variant Hi_N) Input:A;  //_GUI 39,36
 Object Output( NULL Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 90,33
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,27

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,34
 Junction.0 = Input.0;  
}

Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,27
 Object ( Variant In2) Input:A;  //_GUI 28,31
 Object ( Variant In3) Input:B;  //_GUI 28,34
 Object ( Variant In4) Input:C;  //_GUI 28,37
 Object Output( Variant Out1) ;  //_GUI 65,28
 Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 34,30
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 50,26

 //_ Behavior Topology
 Output.0 = CollectMSB:A.0;  
 CollectMSB.0 = Input:A.0;  
 CollectMSB.1 = Input:B.0;  
 CollectMSB.2 = Input:C.0;  
 CollectMSB:A.0 = Input.0;  
 CollectMSB:A.1 = CollectMSB.0;  //_GUI 49,31, 49,33
}

Object ( Variant OutAddr, Variant OutNums, Variant LastDone
    , Variant Done) "GenAddressBeforWrite1.2"( MSB032 Address, MSB024 Nums, Bit RowLastGo
    , Bit LastGo, Bit Go) 
{
 //_ Object Prototypes
 Object ( MSB032 Address) Input;  //_GUI 48,87
 //_ Attributes Default="4000"
 Object ( MSB024 Nums) Input:A;  //_GUI 48,90
 //_ Attributes Default="15"
 Object ( Bit RowLastGo) Input:B;  //_GUI 48,93
 Object ( Bit LastGo) Input:C;  //_GUI 48,96
 Object ( Bit Go) Input:D;  //_GUI 41,157
 Object Output( Variant OutAddr) ;  //_GUI 352,46
 Object Output:A( Variant OutNums) ;  //_GUI 355,105
 Object Output:B( Variant LastDone) ;  //_GUI 356,143
 Object Output:C( Variant Done) ;  //_GUI 356,173
 Object Text;  //_GUI 84,193,NumsNums 0V1.1V1.21RowLastGo 2AddressNumsgoFIFO
 Object ( Bit CO, Bit OFL, Variant Count) FastUpDownCount
    ( Variant CBy, Variant Init, Bit ClkG, Bit Up
    , Bit EN, Bit InitEn) ;  //_GUI 229,65
 Object ( Bit FirstGo) FirstGo( Bit ClkG, Bit SCLR
    , Bit Go) ;  //_GUI 195,79
 Object ( Variant CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR) ;  //_GUI 234,101
 Object ( MSB008 MSB008) Input:E;  //_GUI 229,102
 //_ Attributes Constant="1",PromoteToParentObject="False"
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 271,71
 Object ( MSB012 MSB012) Input:F;  //_GUI 266,75
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 290,73
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 233,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 190,71
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 210,81
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 211,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 210,50
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 289,62
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 265,72
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In3) ;  //_GUI 265,64
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 307,63
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 176,153
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 176,69
 Object ( Variant Out1) AND:C( Variant In1, Variant In2) ;  //_GUI 320,155
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 321,64
 Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 295,181
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 265,182
 Object ( MSB032 FixAddress) Input:G;  //_GUI 169,70
 //_ Attributes Constant="0XFFFFFFF0",PromoteToParentObject="False"
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 215,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In2) ;  //_GUI 265,111
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 204,132
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo:A( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 204,149
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In2) ;  //_GUI 219,173
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In3) ;  //_GUI 219,162
 Object ( MSB032 MSB032) Input:H;  //_GUI 222,66
 //_ Attributes PromoteToParentObject="False",Constant="16"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 198,159
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 194,155
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 223,159
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In3) ;  //_GUI 223,108
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 268,188
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:M
    ( Variant In3) ;  //_GUI 285,185
 Object ( Variant S) Add( Variant A, Variant B) ;  //_GUI 197,67
 Object ( MSB032 MSB032) Input:I;  //_GUI 192,68
 //_ Attributes PromoteToParentObject="False",Constant="16"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 350,157
 Object ( Variant Out1) NotZero:A( Variant In1) ;  //_GUI 156,152
 Object ( Variant Out1) OR:B( Variant In1, Variant In2) ;  //_GUI 310,124
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo:B( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 204,115
 Object ( Variant Out1) OR:C( Variant In1, Variant In2) ;  //_GUI 176,110
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In3) ;  //_GUI 219,145
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:P
    ( Variant In0) ;  //_GUI 199,142
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Q
    ( Variant In3) ;  //_GUI 170,125
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In0) ;  //_GUI 199,125
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In0) ;  //_GUI 251,142
 Object ( Variant Out1) AND:D( Variant In1, Variant In2) ;  //_GUI 336,141
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In0) ;  //_GUI 335,157
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In0) ;  //_GUI 174,142
 Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 53,86
 Object ( MSB032 MSB032) Input:J;  //_GUI 109,48
 //_ Attributes PromoteToParentObject="False"
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 120,44
 Object ( Variant Hi, Variant Lo) Hi_N:A( Variant Data
    , Variant Hi_N) ;  //_GUI 141,47
 Object ( MSB024 MSB024) Input:K;  //_GUI 131,51
 //_ Attributes PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 125,78
 Object ( Variant DataOut, Bit ClkRd, Bit Reset
    , Bit Done, Bit Busy) FIFO( Variant DataIn, Variant Size
    , Bit ClkWr, Bit ClkRd, Bit Reset, Bit Go
    , Bit Wait) ;  //_GUI 98,141
 Object ( MSB009 MSB09) Input:L;  //_GUI 92,145
 //_ Attributes PromoteToParentObject="False"

 //_ Behavior Topology
 Output.0 = RegEn.0;  
 Output:A.0 = Count.1;  
 Output:B.0 = AND:D.0;  
 Output:C.0 = Junction:N.2;  //_GUI 351,174
 FastUpDownCount.0 = Input:H.0;  
 FastUpDownCount.1 = Add.0;  
 FastUpDownCount.4 = Junction:L.1;  //_GUI 224,79
 FastUpDownCount.5 = Junction:A.1;  
 FirstGo.1 = OR:C.0;  //_GUI 186,84
 FirstGo.2 = Junction:J.0;  
 Count.0 = Input:E.0;  
 Count.2 = Junction:L.2;  
 Count.3 = Junction:M.1;  //_GUI 234,116, 286,116
 Lo_N.0 = Junction:C.1;  
 Lo_N.1 = Input:F.0;  
 EqualZero.0 = Lo_N.1;  
 RegEn.0 = Mux.0;  //_GUI 228,46, 228,34
 RegEn.2 = OR:A.0;  
 Junction.0 = AND:B.0;  
 Junction:A.0 = FirstGo.0;  
 Mux.0 = Junction:D.1;  //_GUI 204,33, 204,26, 266,26
 Mux.1 = Junction.0;  //_GUI 191,36
 Mux.2 = Junction:B.1;  
 Junction:B.0 = Junction:A.0;  
 NotZero.0 = Junction:D.2;  
 Junction:C.0 = FastUpDownCount.2;  
 Junction:D.0 = Junction:C.0;  
 AND.0 = NotZero.0;  
 AND.1 = EqualZero.0;  //_GUI 307,76
 AND:A.0 = NotZero:A.0;  
 AND:A.1 = FIFO.3;  
 AND:B.0 = Input:G.0;  
 AND:B.1 = Hi_N.0;  //_GUI 136,74, 136,46
 AND:C.0 = OR.0;  //_GUI 320,133, 338,133, 338,67
 AND:C.1 = Junction:K.1;  
 OR.0 = AND.0;  
 OR.1 = OR:B.0;  //_GUI 320,69
 State.0 = Junction:E.1;  
 State.1 = Junction:M.2;  
 Junction:E.0 = Junction:F.2;  
 OR:A.0 = Junction:B.2;  
 OR:A.1 = Junction:F.1;  //_GUI 215,59, 254,59, 254,86, 266,86
 Junction:F.0 = Junction:N.0;  //_GUI 351,112
 RegOnGo.0 = Junction:P.0;  //_GUI 200,134
 RegOnGo.3 = Junction:P.1;  
 RegOnGo.4 = Junction:O.0;  
 RegOnGo:A.0 = Junction:I.0;  //_GUI 199,151
 RegOnGo:A.3 = Junction:I.1;  
 RegOnGo:A.4 = Junction:H.0;  
 Junction:G.0 = State.0;  //_GUI 314,174, 314,184
 Junction:H.0 = Junction:G.1;  
 Junction:I.0 = Junction:J.2;  //_GUI 195,160
 Junction:J.0 = AND:A.0;  
 Junction:K.0 = RegOnGo:A.3;  
 Junction:L.0 = Junction:K.0;  
 Reg.0 = Junction:E.2;  //_GUI 266,190
 Junction:M.0 = Reg.0;  //_GUI 286,191
 Add.0 = Input:I.0;  
 Add.1 = Junction.1;  
 Junction:N.0 = Junction:T.1;  
 NotZero:A.0 = Hi_N:A.0;  //_GUI 156,49
 OR:B.0 = RegOnGo:B.3;  
 OR:B.1 = Junction:S.0;  //_GUI 252,129
 RegOnGo:B.0 = Junction:R.0;  //_GUI 200,117
 RegOnGo:B.3 = Junction:R.1;  
 RegOnGo:B.4 = Junction:O.1;  //_GUI 220,129
 OR:C.0 = Junction:Q.1;  //_GUI 171,112
 OR:C.1 = Junction:U.0;  //_GUI 175,115
 Junction:O.0 = Junction:H.1;  
 Junction:P.0 = Junction:U.1;  
 Junction:Q.0 = ExposeMSB.0;  //_GUI 171,139, 143,139, 143,80
 Junction:R.0 = Junction:Q.2;  
 Junction:S.0 = RegOnGo.3;  
 AND:D.0 = Junction:S.1;  
 AND:D.1 = Junction:T.0;  
 Junction:T.0 = AND:C.0;  
 Junction:U.0 = ExposeMSB.1;  //_GUI 140,143, 140,83
 CollectMSB.0 = Input.0;  
 CollectMSB.1 = Input:A.0;  
 CollectMSB.2 = Input:B.0;  
 CollectMSB.3 = Input:C.0;  
 Hi_N.0 = FIFO.0;  //_GUI 115,46, 115,143
 Hi_N.1 = Input:J.0;  
 Hi_N:A.0 = Hi_N.1;  
 Hi_N:A.1 = Input:K.0;  
 ExposeMSB.0 = Hi_N:A.1;  //_GUI 121,81, 121,70, 153,70, 153,52
 FIFO.0 = CollectMSB.0;  //_GUI 72,143, 72,89
 FIFO.1 = Input:L.0;  
 FIFO.5 = Input:D.0;  
 FIFO.6 = Junction:G.0;  //_GUI 184,161, 184,174
}

Object ( Variant DataOut, Bit Clk, Bit Reset
    , Bit OnReady, Bit ProgFull, Bit Done, Bit Busy) StandardFIFO
    ( Variant DataIn, Variant NDepth, Bit ClkG, Bit Reset
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="LONGZHAN\\Common\\Memory"
{
 //_ Object Prototypes
 Object ( Variant DataIn) Input;  //_GUI 138,56
 Object ( Variant NDepth) Input:A;  //_GUI 138,59
 Object ( Bit ClkG) Input:B;  //_GUI 138,62
 //_ Attributes Resource="Global"
 Object ( Bit Reset) Input:C;  //_GUI 138,65
 Object ( Bit Go) Input:D;  //_GUI 138,74
 Object ( Bit Wait) Input:E;  //_GUI 173,88
 Object Output( Variant DataOut) ;  //_GUI 190,59
 Object Output:A( Bit Clk) ;  //_GUI 190,62
 Object Output:B( Bit Reset) ;  //_GUI 190,65
 Object Output:C( Bit OnReady) ;  //_GUI 190,68
 Object Output:D( Bit ProgFull) ;  //_GUI 190,71
 Object Output:E( Bit Done) ;  //_GUI 190,74
 Object Output:F( Bit Busy) ;  //_GUI 152,88
 Object ( Variant DataOut, Bit Clk, Bit Reset
    , Bit OnReady, Bit ProgFull, Bit Done, Bit Busy) TransformerFIFO
    ( Variant DataIn, Bit ClkG, Bit Reset, Variant Size
    , MSB003 S, Bit Go, Bit Wait) ;  //_GUI 160,58
 Object ( MSB003 S) Input:F;  //_GUI 138,71
 //_ Attributes Constant="0",PromoteToParentObject="False"

 //_ Behavior Topology
 Output.0 = TransformerFIFO.0;  
 Output:A.0 = TransformerFIFO.1;  
 Output:B.0 = TransformerFIFO.2;  
 Output:C.0 = TransformerFIFO.3;  
 Output:D.0 = TransformerFIFO.4;  
 Output:E.0 = TransformerFIFO.5;  
 Output:F.0 = TransformerFIFO.6;  //_GUI 146,89, 146,78
 TransformerFIFO.0 = Input.0;  //_GUI 151,60, 151,57
 TransformerFIFO.1 = Input:B.0;  
 TransformerFIFO.2 = Input:C.0;  
 TransformerFIFO.3 = Input:A.0;  //_GUI 148,69, 148,60
 TransformerFIFO.4 = Input:F.0;  
 TransformerFIFO.5 = Input:D.0;  
 TransformerFIFO.6 = Input:E.0;  //_GUI 185,78, 185,89
}

Object ( MSB032 OutAddr, MSB024 OutNums, Bit RowLastDone
    , Variant LastDone, Bit Done) "SlicAddressBeforWrite_v1.1"( Bit IsSlic, MSB032 Address
    , MSB024 WidthNums, MSB024 LineNums, MSB016 Height, Bit Go) 
//_ Attributes TreeGroup="A_LHJ"
{
 //_ Object Prototypes
 Object ( Bit IsSlic) Input;  //_GUI 12,29
 //_ Attributes Default="1"
 Object ( MSB032 Address) Input:A;  //_GUI 13,62
 //_ Attributes Default="4000"
 Object ( MSB024 WidthNums) Input:B;  //_GUI 13,65
 //_ Attributes Default="5"
 Object ( MSB024 LineNums) Input:C;  //_GUI 13,68
 Object ( MSB016 Height) Input:D;  //_GUI 13,71
 //_ Attributes Default="10"
 Object ( Bit Go) Input:E;  //_GUI 14,87
 Object Output( MSB032 OutAddr) ;  //_GUI 183,62
 Object Output:A( MSB024 OutNums) ;  //_GUI 183,65
 Object Output:B( Bit RowLastDone) ;  //_GUI 183,68
 Object Output:C( Variant LastDone) ;  //_GUI 183,71
 Object Output:D( Bit Done) ;  //_GUI 183,74
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 88,29
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 127,24
 Object ( MSB032 Out1, MSB032 Out2, MSB032 Out3) Junction
    ( MSB032 In0) ;  //_GUI 30,62
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 43,28
 Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5) ;  //_GUI 74,41
 Object ( Bit Bit) Input:F;  //_GUI 57,48
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( List Out1) PackMSB:A( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5) ;  //_GUI 112,61
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5) UnPackMSB( Variant In1) ;  //_GUI 141,61
 Object ( MSB024 Out1, MSB024 Out2, MSB024 Out3) Junction:A
    ( MSB024 In0) ;  //_GUI 33,65
 Object ( Bit Done, Bit Busy) GoForN( Variant Iterations
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) ;  //_GUI 40,90
 Object ( Variant Q) Reg:B( Variant D, Bit ClkG) ;  //_GUI 43,35
 Object ( Variant Q) Reg:C( Variant D, Bit ClkG) ;  //_GUI 43,43
 Object ( Variant Q) Reg:D( Variant D, Bit ClkG) ;  //_GUI 43,52
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 56,54
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 57,96
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 36,100
 Object ( Variant B, Variant A) DMux( Variant I
    , Bit S) ;  //_GUI 21,86
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 20,29
 Object ( Variant Q) Reg:E( Variant D, Bit ClkG) ;  //_GUI 88,42
 Object ( Variant OutAddr, Variant OutNums, Bit RowLastDone
    , Bit LastDone, Bit Done) SlicAddressForWrite( MSB032 WriteAddress, MSB024 WidthNums
    , MSB024 LineNums, MSB016 Height, Bit Go) ;  //_GUI 83,61

 //_ Behavior Topology
 Output.0 = UnPackMSB.0;  
 Output:A.0 = UnPackMSB.1;  
 Output:B.0 = UnPackMSB.2;  
 Output:C.0 = UnPackMSB.3;  
 Output:D.0 = UnPackMSB.4;  
 Reg.0 = Reg:A.0;  
 Mux.0 = Reg:E.0;  //_GUI 101,26, 101,45
 Mux.1 = PackMSB:A.0;  //_GUI 127,64
 Mux.2 = Reg.0;  
 Junction.0 = Input:A.0;  
 Reg:A.0 = Junction:D.1;  
 PackMSB.0 = Reg:B.0;  //_GUI 58,43, 58,38
 PackMSB.1 = Reg:C.0;  
 PackMSB.2 = Input:F.0;  
 PackMSB.3 = AND.0;  //_GUI 73,52, 73,99
 PackMSB.4 = Junction:B.1;  
 PackMSB:A.0 = SlicAddressForWrite.0;  
 PackMSB:A.1 = SlicAddressForWrite.1;  
 PackMSB:A.2 = SlicAddressForWrite.2;  
 PackMSB:A.3 = SlicAddressForWrite.3;  
 PackMSB:A.4 = SlicAddressForWrite.4;  
 UnPackMSB.0 = Mux.0;  //_GUI 137,64
 Junction:A.0 = Input:B.0;  
 GoForN.0 = Junction:A.2;  //_GUI 34,92
 GoForN.3 = Junction:C.1;  
 Reg:B.0 = Junction.0;  //_GUI 31,37
 Reg:C.0 = Junction:A.0;  //_GUI 34,45
 Reg:D.0 = Junction:C.0;  //_GUI 37,54
 Junction:B.0 = Reg:D.0;  
 AND.0 = Junction:B.2;  
 AND.1 = GoForN.0;  
 Junction:C.0 = DMux.1;  //_GUI 31,101
 DMux.0 = Input:E.0;  
 DMux.1 = Junction:D.2;  
 Junction:D.0 = Input.0;  
 Reg:E.0 = PackMSB.0;  
 SlicAddressForWrite.0 = Junction.1;  
 SlicAddressForWrite.1 = Junction:A.1;  
 SlicAddressForWrite.2 = Input:C.0;  
 SlicAddressForWrite.3 = Input:D.0;  
 SlicAddressForWrite.4 = DMux.0;  //_GUI 31,75
}

Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N least-significant bits and the bitlength - N most-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Lo_N - the bitlength of this parameter specifies N - the number of bits in the lo data set.
 //
 // Outputs:
 // Hi - the bitlength - N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,33
 Object ( Variant Lo_N) Input:A;  //_GUI 29,42
 Object Output( Variant Hi) ;  //_GUI 95,32
 Object Output:A( Variant Lo) ;  //_GUI 95,35
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 35,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 61,40
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 57,31
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 45,31
 Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Variant Lo_N) ;  //_GUI 83,31
 //_ Attributes Documentation="Variant/Variant"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 49,40

 //_ Behavior Topology
 Output.0 = $Lo_N.0;  
 Output:A.0 = $Lo_N.1;  
 LSB.0 = Input:A.0;  
 VariantIn.0 = Zero.0;  
 VariantIn:A.0 = LSB:A.0;  
 LSB:A.0 = Input.0;  
 $Lo_N.0 = VariantIn:A.1;  
 $Lo_N.1 = VariantIn:A.0;  
 $Lo_N.2 = VariantIn.1;  //_GUI 79,39, 79,42
 Zero.0 = LSB.0;  
}

Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Bit Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Bit"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( Bit Lo_N) Input:A;  //_GUI 40,47
 Object Output( Variant Hi) ;  //_GUI 75,26
 Object Output:A( Variant Lo) ;  //_GUI 82,36
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,25
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 46,25

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  //_GUI 72,37, 72,30
 VariantIn.0 = LSB.0;  
 LSB.0 = Input.0;  
}

Object ( NULL Hi, Bit Lo) Lo_N( Bit Data
    , Bit Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,27
 Object ( Bit Lo_N) Input:A;  //_GUI 40,47
 Object Output( NULL Hi) ;  //_GUI 90,25
 Object Output:A( Bit Lo) ;  //_GUI 82,36
 Object ( NULL Out1) NULL;  //_GUI 78,23

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  //_GUI 71,37, 71,28
}

Object ( NULL Hi, Variant Lo) Lo_N( Bit Data
    , Variant Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Var"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,28
 Object ( Variant Lo_N) Input:A;  //_GUI 40,44
 Object Output( NULL Hi) ;  //_GUI 102,25
 Object Output:A( Variant Lo) ;  //_GUI 94,47
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 48,42
 Object ( NULL Out1) NULL;  //_GUI 87,23
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 67,43
 //_ Attributes Documentation="ztlist"

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = UExtnd.1;  
 MSB.0 = Input:A.0;  
 UExtnd.0 = MSB.0;  
 UExtnd.1 = Input.0;  //_GUI 60,48, 60,29
}

Object ( Variant Hi, NULL Lo) Lo_N( Variant Data
    , NULL Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( NULL Lo_N) Input:A;  //_GUI 40,47
 Object Output( Variant Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 82,36
 Object ( NULL Out1) NULL;  //_GUI 70,34

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
}

Object ( NULL Hi, NULL Lo) Lo_N( NULL Data
    , NULL Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/NULL"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N least-significant bits and the bitlength - N most-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Lo_N - the bitlength of this parameter specifies N - the number of bits in the lo data set.
 //
 // Outputs:
 // Hi - the bitlength - N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 29,32
 Object ( NULL Lo_N) Input:A;  //_GUI 29,35
 Object Output( NULL Hi) ;  //_GUI 95,32
 Object Output:A( NULL Lo) ;  //_GUI 95,35
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 72,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 73,36
 Junction.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) Lo_N( NULL Data
    , Variant Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/Var"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N least-significant bits and the bitlength - N most-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Lo_N - the bitlength of this parameter specifies N - the number of bits in the lo data set.
 //
 // Outputs:
 // Hi - the bitlength - N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 29,32
 Object ( Variant Lo_N) Input:A;  //_GUI 29,35
 Object Output( NULL Hi) ;  //_GUI 95,32
 Object Output:A( NULL Lo) ;  //_GUI 95,35
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 72,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 73,36
 Junction.0 = Input.0;  
}

Object ( Bit NXT_Wr, Bit Busy) "AXI_2_Write_Nums_128bits_V1.0"( MSB128 DataIn
    , MSB032 Address, MSB008 Nums, Bit Go) 
//_ Attributes TreeGroup="Dram_128bit"
{
 //_ Object Prototypes
 Object ( MSB128 DataIn) Input;  //_GUI 174,72
 Object ( MSB032 Address) Input:A;  //_GUI 174,75
 Object ( MSB008 Nums) Input:B;  //_GUI 174,78
 Object ( Bit Go) Input:C;  //_GUI 174,81
 Object Output( Bit NXT_Wr) ;  //_GUI 263,80
 Object Output:A( Bit Busy) ;  //_GUI 188,84
 Object ( Bit AXI2WriteBusy) Input:D;  //_GUI 174,84
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:B( MSB128 AXI2WriteDataIn) ;  //_GUI 188,72
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:C( MSB032 AXI2WriteAddress) ;  //_GUI 188,75
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:D( MSB008 AXI2WriteNums) ;  //_GUI 188,78
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:E( Bit AXI2WriteGo) ;  //_GUI 188,81
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit AXI2WriteNxtWR) Input:E;  //_GUI 257,80
 //_ Attributes Resource="Global",PromoteToParentObject="False"

 //_ Behavior Topology
 Output.0 = Input:E.0;  
 Output:A.0 = Input:D.0;  
 Output:B.0 = Input.0;  
 Output:C.0 = Input:A.0;  
 Output:D.0 = Input:B.0;  
 Output:E.0 = Input:C.0;  
}

Object ( MSB032 Address, MSB008 Size, Bit Done
    , Bit Busy) AXI_GenAddressForRead_2( MSB032 ReadAddress, MSB024 ReadNums, Bit Go
    , Bit Wait) 
{
 //_ Object Prototypes
 Object ( MSB032 ReadAddress) Input;  //_GUI 46,28
 Object ( MSB024 ReadNums) Input:A;  //_GUI 46,31
 Object ( Bit Go) Input:B;  //_GUI 38,37
 Object ( Bit Wait) Input:C;  //_GUI 73,61
 Object Output( MSB032 Address) ;  //_GUI 78,28
 Object Output:A( MSB008 Size) ;  //_GUI 78,31
 Object Output:B( Bit Done) ;  //_GUI 78,37
 Object Output:C( Bit Busy) ;  //_GUI 51,61
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 44,37
 Object ( MSB032 Address, MSB008 Size, Bit Done
    , Bit Busy) "GenAddressBeforRead_2_V1.0"( MSB032 ReadAddress, MSB024 ReadNums, Bit ReadAllBlocksLastGo
    , Bit Go, Bit Wait) ;  //_GUI 50,27

 //_ Behavior Topology
 Output.0 = "GenAddressBeforRead_2_V1.0".0;  
 Output:A.0 = "GenAddressBeforRead_2_V1.0".1;  
 Output:B.0 = "GenAddressBeforRead_2_V1.0".2;  
 Output:C.0 = "GenAddressBeforRead_2_V1.0".3;  //_GUI 50,62
 Junction.0 = Input:B.0;  
 "GenAddressBeforRead_2_V1.0".0 = Input.0;  
 "GenAddressBeforRead_2_V1.0".1 = Input:A.0;  
 "GenAddressBeforRead_2_V1.0".2 = Junction.0;  //_GUI 45,35
 "GenAddressBeforRead_2_V1.0".3 = Junction.1;  
 "GenAddressBeforRead_2_V1.0".4 = Input:C.0;  //_GUI 78,62
}

Object ( Variant Out1) Cast( Variant Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters"
{
 // The Cast operator is used to provide type information in the synthesizor when ambiguities exist, or when the type information could not be known any other way.  There are only two places where Cast should be used. ($Cast should never be used.)
 //
 // Feedback:
 // In a feedback situation, the input type cannot possibly be known until the output type has been propogated.  The Cast object before the input provides type information in this loop.  It is safest to place a Convert object (2-1 footprint) before the Cast since the Cast object cannot do any conversions - not even LSB -> MSB.  As the pattern of your data sets may change in an operator, using the Convert object before a Cast is always the safest bet.  See Count as an example.
 //
 // Ambiguous Collection:
 // In a recursive object that utilizes Variant Exposers and Collectors, you may encouter a situation where the two child data sets may be collected into several parent data sets.  The use of a Cast object (taking its Type from the original data set before the Exposer) after a Variant Collector guarantees collection into the correct data set.  This is seen in countless library objects.  It is actually recommended that a Cast always follow a Variant Collector.
 //
 // Inputs:
 //
 // Variant Type: The resulting dataset
 //
 // Variant Data: The input data and dataset (always the same dataset as Type)
 //
 // Outputs:
 //
 // Variant output: Data with dataset Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 26,19
 Object ( Variant Data) Input:A;  //_GUI 26,22
 Object Output( Variant Out1) ;  //_GUI 44,20
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 32,18

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 $Cast.0 = Input:A.0;  
 $Cast.1 = Input.0;  
}

Object ( Floating Out1) Cast( Floating Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Floating"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 17,22
 Object ( Variant Data) Input:A;  //_GUI 16,36
 Object Output( Floating Out1) ;  //_GUI 142,28
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 80,25
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 80,36
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 28,20
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 127,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 45,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 111,26
 Object Text;  //_GUI 86,10,We break up the Floating data set until we get to the Nums inside.  These are then casted using the primitive $Cast.
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 25,34
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 46,36
 Object Text;  //_GUI 21,47,contextual followed by a list: the null on the top of the first variant splitter is how the contextual works

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 $Cast.0 = VariantIn:A.1;  //_GUI 67,30, 67,38
 $Cast.1 = ListIn.1;  //_GUI 76,27, 76,22
 $Cast:A.0 = VariantIn:A.0;  
 $Cast:A.1 = ListIn.0;  //_GUI 74,38, 74,25
 FloatingIn.0 = Input.0;  
 FloatingOut.0 = ListOut.0;  
 ListIn.0 = FloatingIn.0;  
 ListOut.0 = $Cast:A.0;  //_GUI 104,31, 104,39
 ListOut.1 = $Cast.0;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = VariantIn.0;  
}

Object ( Fixed Out1) Cast( Fixed Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Fixed"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Type) Input;  //_GUI 7,20
 Object ( Variant Data) Input:A;  //_GUI 8,34
 Object Output( Fixed Out1) ;  //_GUI 121,26
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 70,23
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 70,34
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 19,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 88,24
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 105,24
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 39,34
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 20,32

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 $Cast.0 = VariantIn.1;  //_GUI 57,28, 57,36
 $Cast.1 = ListIn.1;  //_GUI 66,25, 66,20
 $Cast:A.0 = VariantIn.0;  
 $Cast:A.1 = ListIn.0;  //_GUI 64,36, 64,23
 FixedIn.0 = Input.0;  
 ListIn.0 = FixedIn.0;  
 ListOut.0 = $Cast:A.0;  //_GUI 85,29, 85,37
 ListOut.1 = $Cast.0;  
 FixedOut.0 = ListOut.0;  
 VariantIn.0 = VariantIn:A.0;  
 VariantIn:A.0 = Input:A.0;  
}

Object ( Complex Out1) Cast( Complex Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Complex"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex Type) Input;  //_GUI 7,20
 Object ( Variant Data) Input:A;  //_GUI 8,34
 Object Output( Complex Out1) ;  //_GUI 132,26
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 70,23
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 70,34
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 19,18
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 116,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 41,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 102,24
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 41,34
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 20,32

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 $Cast.0 = VariantIn.1;  //_GUI 57,28, 57,36
 $Cast.1 = ListIn.1;  //_GUI 66,25, 66,20
 $Cast:A.0 = VariantIn.0;  
 $Cast:A.1 = ListIn.0;  //_GUI 64,36, 64,23
 ComplexIn.0 = Input.0;  
 ComplexOut.0 = ListOut.0;  
 ListIn.0 = ComplexIn.0;  
 ListOut.0 = $Cast:A.0;  //_GUI 94,29, 94,37
 ListOut.1 = $Cast.0;  
 VariantIn.0 = VariantIn:A.0;  
 VariantIn:A.0 = Input:A.0;  
}

Object ( List Out1) Cast( List Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="List"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // If given Static Data Sets, this object will perform a $Cast.
 //
 // Date:
 // 17 May 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 24,19
 Object ( Variant Data) Input:A;  //_GUI 25,31
 Object Output( List Out1) ;  //_GUI 88,20
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 59,29
 Object ( Variant Out1) Cast:A( Variant Type, Variant Data) ;  //_GUI 59,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 32,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 31,17
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 75,18

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Cast.0 = ListIn.0;  //_GUI 53,31, 53,22
 Cast.1 = VariantIn.0;  
 Cast:A.0 = ListIn.1;  
 Cast:A.1 = VariantIn.1;  //_GUI 48,22, 48,31
 VariantIn.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Cast.0;  //_GUI 72,23, 72,32
 ListOut.1 = Cast:A.0;  
}

Object ( Signed Out1) Cast( Signed Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Signed"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Type) Input;  //_GUI 17,22
 Object ( Variant Data) Input:A;  //_GUI 18,37
 Object Output( Signed Out1) ;  //_GUI 100,37
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 70,35
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 28,20
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,35
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 85,35

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 $Cast.0 = VariantIn.0;  
 $Cast.1 = SignedIn.0;  //_GUI 60,37, 60,23
 SignedIn.0 = Input.0;  
 VariantIn.0 = Input:A.0;  
 SignedOut.0 = $Cast.0;  
}

Object ( NULL Out1) Cast( NULL Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="NULL"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 18,26
 Object ( Variant Data) Input:A;  //_GUI 18,33
 Object Output( NULL Out1) ;  //_GUI 174,26

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) Cast( NULL Type, NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Cast",Documentation="NULL/NULL"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 18,26
 Object ( NULL Data) Input:A;  //_GUI 18,33
 Object Output( NULL Out1) ;  //_GUI 174,26

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Q) RegClr( NULL D, Bit ClkG
    , Bit EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="NULL/bit/bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 20,21
 Object ( Bit ClkG) Input:A;  //_GUI 21,38
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 21,41
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 21,44
 //_ Attributes Constant="0"
 Object Output( NULL Q) ;  //_GUI 111,21

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // Variant D:	The value to be registered on the next rising clock edge if En is high.
 //
 // Variant ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit EN:	Enable D to be registered on the next clock edge if EN is high.  If disconnected, defaults to constant 1.
 //
 // Bit CLR:	Asynchronously clears the contents of the register.  Overrides EN.  If disconnected, defaults to constant 0.
 //
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,22
 Object ( Bit ClkG) Input:A;  //_GUI 21,38
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 21,41
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 21,44
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 111,21
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,20
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 81,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 55,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 52,41
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 49,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 26,22
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 60,20
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 60,34
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 98,19

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:C.1;  
 VariantOut.0 = RegClr:A.0;  //_GUI 75,26, 75,37
 VariantOut.1 = RegClr.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:C.0;  
 Junction:C.0 = Input.0;  
 RegClr.0 = VariantIn.1;  
 RegClr.1 = Junction.0;  //_GUI 56,25
 RegClr.2 = Junction:A.0;  //_GUI 53,28
 RegClr.3 = Junction:B.0;  //_GUI 50,31
 RegClr:A.0 = VariantIn.0;  //_GUI 47,36, 47,25
 RegClr:A.1 = Junction.1;  
 RegClr:A.2 = Junction:A.1;  
 RegClr:A.3 = Junction:B.1;  
 Cast.0 = Junction:C.0;  //_GUI 95,21, 95,18, 27,18
 Cast.1 = VariantOut.0;  
}

Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="var/bit/var/bit"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // Variant D:	A set of bits to be registered on the next rising clock edge if its associated En bit is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Variant EN:	Enable D to be registered on the next clock edge if EN is high.  If the same dataset as D then allows each bit in D to have a separate and independent enable bit.
 //
 // Bit CLR:	Asynchronously clears the contents of the register.  Overrides EN.  If disconnected, defaults to constant 0.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,22
 Object ( Bit ClkG) Input:A;  //_GUI 21,38
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 21,43
 Object ( Bit CLR) Input:C;  //_GUI 22,54
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 111,21
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,20
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 81,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 55,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 49,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 26,22
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 28,41
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 61,34
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 60,20

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:B.1;  
 VariantOut.0 = RegClr.0;  //_GUI 75,26, 75,37
 VariantOut.1 = RegClr:A.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:C.0;  //_GUI 46,45, 46,55
 Junction:B.0 = Input.0;  
 Cast.0 = Junction:B.0;  //_GUI 95,21, 95,18, 27,18
 Cast.1 = VariantOut.0;  
 VariantIn:A.0 = Input:B.0;  
 RegClr.0 = VariantIn.0;  //_GUI 47,36, 47,25
 RegClr.1 = Junction.1;  
 RegClr.2 = VariantIn:A.0;  //_GUI 43,42, 43,46
 RegClr.3 = Junction:A.1;  
 RegClr:A.0 = VariantIn.1;  
 RegClr:A.1 = Junction.0;  //_GUI 56,25
 RegClr:A.2 = VariantIn:A.1;  //_GUI 39,28
 RegClr:A.3 = Junction:A.0;  //_GUI 50,31
}

Object ( Bit Q) RegClr( Bit D, Bit ClkG
    , Bit EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="leaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit D) Input;  //_GUI 36,21
 Object ( Bit ClkG) Input:A;  //_GUI 36,24
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 36,27
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 36,33
 //_ Attributes Constant="0"
 Object Output( Bit Q) ;  //_GUI 79,21
 Object ( Bit In) Input:D;  //_GUI 62,42
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 68,42
 //_ Attributes Trap="Error: RegClr not using FF."

 //_ Behavior Topology
 Output:A.0 = Input:D.0;  
}

Object ( List Q) RegClr( List D, Bit ClkG
    , List EN, List CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="list/bit/list/list"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // List D:	The list of values to be registered on the next rising clock edge if its En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // List EN:	Enable D to be registered on the next clock edge if EN is high.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent enable bit.
 //
 // List CLR:	Asynchronously clears the contents of the register.  Overrides EN.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent clear bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 37,29
 Object ( Bit ClkG) Input:A;  //_GUI 24,47
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 24,50
 Object ( List CLR) Input:C;  //_GUI 24,53
 Object Output( List Q) ;  //_GUI 120,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 63,47
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,27
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 100,28
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 37,39
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 40,58
 Object ( Variant Q) RegClr( Variant D, Variant ClkG
    , Variant EN, Variant CLR) ;  //_GUI 76,27
 //_ Attributes Documentation="var/bit/var/bit"
 Object ( Variant Q) RegClr:A( Variant D, Variant ClkG
    , Variant EN, Variant CLR) ;  //_GUI 76,43
 //_ Attributes Documentation="var/bit/var/bit"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = RegClr:A.0;  //_GUI 90,33, 90,46
 ListOut.1 = RegClr.0;  
 ListIn:A.0 = Input:B.0;  //_GUI 37,51
 ListIn:B.0 = Input:C.0;  //_GUI 29,61, 29,54
 RegClr.0 = ListIn.1;  
 RegClr.1 = Junction.0;  //_GUI 64,32
 RegClr.2 = ListIn:A.1;  //_GUI 54,35, 54,41
 RegClr.3 = ListIn:B.1;  //_GUI 69,38, 69,60
 RegClr:A.0 = ListIn.0;  //_GUI 60,45, 60,32
 RegClr:A.1 = Junction.1;  
 RegClr:A.2 = ListIn:A.0;  //_GUI 48,51
 RegClr:A.3 = ListIn:B.0;  //_GUI 76,63
}

Object ( List Q) RegClr( List D, List ClkG
    , List EN, List CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="list/list/list/list"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // List D:	The list of values to be registered on the next rising clock edge if its En is high.
 //
 // List ClkG:	The clock for the operation.  usually a list of bits.  If the same list struct as D then allows each element in D to have a separate and independent clock bit.
 //
 // List EN:	Enable D to be registered on the next clock edge if EN is high.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent enable bit.
 //
 // List CLR:	Asynchronously clears the contents of the register.  Overrides EN.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent clear bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 37,29
 Object ( List ClkG) Input:A;  //_GUI 24,47
 Object ( List EN) Input:B;  //_GUI 24,50
 Object ( List CLR) Input:C;  //_GUI 24,53
 Object Output( List Q) ;  //_GUI 120,30
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,27
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 100,28
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 32,33
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 40,58
 Object ( Variant Out1, Variant Out2) ListIn:C( List In) ;  //_GUI 46,41
 Object ( Variant Q) RegClr( Variant D, Variant ClkG
    , Variant EN, Variant CLR) ;  //_GUI 76,43
 Object ( Variant Q) RegClr:A( Variant D, Variant ClkG
    , Variant EN, Variant CLR) ;  //_GUI 76,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = RegClr.0;  //_GUI 90,33, 90,46
 ListOut.1 = RegClr:A.0;  
 ListIn:A.0 = Input:B.0;  //_GUI 32,51
 ListIn:B.0 = Input:C.0;  //_GUI 29,61, 29,54
 ListIn:C.0 = Input:A.0;  //_GUI 29,44, 29,48
 RegClr.0 = ListIn.0;  //_GUI 60,45, 60,32
 RegClr.1 = ListIn:C.0;  //_GUI 67,48, 67,46
 RegClr.2 = ListIn:A.0;  //_GUI 43,51
 RegClr.3 = ListIn:B.0;  //_GUI 76,63
 RegClr:A.0 = ListIn.1;  
 RegClr:A.1 = ListIn:C.1;  //_GUI 65,32, 65,43
 RegClr:A.2 = ListIn:A.1;  
 RegClr:A.3 = ListIn:B.1;  //_GUI 69,38, 69,60
}

Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Variant CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="var/bit/var/var"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // Variant D:	The set of bits to be registered on the next rising clock edge if its associated En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Variant EN:	Enable D to be registered on the next clock edge if EN is high.  If the same dataset as D then allows each bit in D to have a separate and independent enable bit.
 //
 // Variant CLR:	Asynchronously clears the contents of the register.  Overrides EN.  If the same dataset as D then allows each bit in D to have a separate and independent clear bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,41
 Object ( Bit ClkG) Input:A;  //_GUI 20,49
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 20,55
 Object ( Variant CLR) Input:C;  //_GUI 20,66
 Object Output( Variant Q) ;  //_GUI 103,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,39
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 73,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,41
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 90,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 47,49
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 29,53
 Object ( Variant Out1, Variant Out2) VariantIn:B( Variant In) ;  //_GUI 29,64
 Object ( Variant Q) RegClr( Variant D, Variant ClkG
    , Variant EN, Variant CLR) ;  //_GUI 58,24
 Object ( Variant Q) RegClr:A( Variant D, Variant ClkG
    , Variant EN, Variant CLR) ;  //_GUI 58,88

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = RegClr:A.0;  //_GUI 71,30, 71,91
 VariantOut.1 = RegClr.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 87,25, 87,18, 27,18
 Cast.1 = VariantOut.0;  
 Junction:A.0 = Input:A.0;  
 VariantIn:A.0 = Input:B.0;  
 VariantIn:B.0 = Input:C.0;  
 RegClr.0 = VariantIn.1;  //_GUI 45,26, 45,41
 RegClr.1 = Junction:A.0;  //_GUI 48,29
 RegClr.2 = VariantIn:A.1;  //_GUI 51,32, 51,55
 RegClr.3 = VariantIn:B.1;  //_GUI 54,35, 54,66
 RegClr:A.0 = VariantIn.0;  //_GUI 45,90, 45,44
 RegClr:A.1 = Junction:A.2;  //_GUI 48,93
 RegClr:A.2 = VariantIn:A.0;  //_GUI 51,96, 51,58
 RegClr:A.3 = VariantIn:B.0;  //_GUI 54,99, 54,69
}

Object ( NULL Q) RegClr( NULL D, Bit ClkG
    , NULL EN, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="NULL/bit/NULL/bit"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 //   D - Data In
 //   ClkG - Clock
 //   EN - Clock Enable
 //   CLR - Asynchronous Clear
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 20,41
 Object ( Bit ClkG) Input:A;  //_GUI 20,49
 //_ Attributes Resource="Global"
 Object ( NULL EN) Input:B;  //_GUI 20,55
 Object ( Bit CLR) Input:C;  //_GUI 20,65
 Object Output( NULL Q) ;  //_GUI 103,41

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Q) RegClr( NULL D, Bit ClkG
    , NULL EN, NULL CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="NULL/bit/NULL/NULL"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 //   D - Data In
 //   ClkG - Clock
 //   EN - Clock Enable
 //   CLR - Asynchronous Clear
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 20,41
 Object ( Bit ClkG) Input:A;  //_GUI 20,49
 //_ Attributes Resource="Global"
 Object ( NULL EN) Input:B;  //_GUI 20,55
 Object ( NULL CLR) Input:C;  //_GUI 20,65
 Object Output( NULL Q) ;  //_GUI 103,41

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) Inc( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronously increments the input value.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant input: Number
 //
 // Outputs:
 //
 // output: Number + 1.  No indication of carry out or overflow is given.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed and List.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 16,19
 Object Output( Variant Out1) ;  //_GUI 91,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,19
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 42,23
 Object ( Variant S) Add( Variant A, Variant B) ;  //_GUI 71,21

 //_ Behavior Topology
 Output.0 = Add.0;  
 Junction.0 = Input.0;  
 One.0 = Junction.2;  //_GUI 31,26
 Add.0 = Junction.1;  //_GUI 59,23, 59,20
 Add.1 = One.0;  
}

Object ( Bit Out1) Zero( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Bit"
{
 // DDescription:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 37,30
 Object Output( Bit Out1) ;  //_GUI 57,41
 Object ( Bit In) Input:A;  //_GUI 38,41
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) Zero( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 106,23
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,22
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 51,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,25
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 90,21

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = Zero:A.0;  //_GUI 68,28, 68,35
 VariantOut.1 = Zero.0;  
 Zero.0 = VariantIn.1;  
 Zero:A.0 = VariantIn.0;  //_GUI 47,35, 47,28
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 89,23, 89,21, 27,21
 Cast.1 = VariantOut.0;  
}

Object ( Signed Out1) Zero( Signed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Signed"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 32,23
 Object Output( Signed Out1) ;  //_GUI 82,23
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 38,21
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 67,21
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 52,21

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = Zero.0;  
 Zero.0 = SignedIn.0;  
}

Object ( Floating Out1) Zero( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Floating"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 43,37
 Object Output( Floating Out1) ;  //_GUI 154,37
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 91,42
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 91,34
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 50,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 69,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 120,35
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 136,35

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 Zero.0 = ListIn.0;  //_GUI 86,45, 86,40
 Zero:A.0 = ListIn.1;  
 FloatingIn.0 = Input.0;  
 ListIn.0 = FloatingIn.0;  
 ListOut.0 = Zero.0;  //_GUI 108,40, 108,45
 ListOut.1 = Zero:A.0;  
 FloatingOut.0 = ListOut.0;  
}

Object ( Fixed Out1) Zero( Fixed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Fixed"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 31,31
 Object Output( Fixed Out1) ;  //_GUI 144,31
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 85,35
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 41,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 57,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 108,29
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 124,29
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 85,28

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 Zero.0 = ListIn.0;  //_GUI 77,38, 77,34
 FixedIn.0 = Input.0;  
 ListIn.0 = FixedIn.0;  
 ListOut.0 = Zero.0;  //_GUI 103,34, 103,38
 ListOut.1 = Zero:A.0;  
 FixedOut.0 = ListOut.0;  
 Zero:A.0 = ListIn.1;  
}

Object ( Complex Out1) Zero( Complex In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Complex"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 26,29
 Object Output( Complex Out1) ;  //_GUI 125,29
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 110,27
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 32,27
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 67,34
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 67,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,27
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 95,27

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 ComplexOut.0 = ListOut.0;  
 ComplexIn.0 = Input.0;  
 Zero.0 = ListIn.0;  //_GUI 62,37, 62,32
 Zero:A.0 = ListIn.1;  
 ListIn.0 = ComplexIn.0;  
 ListOut.0 = Zero.0;  //_GUI 84,32, 84,37
 ListOut.1 = Zero:A.0;  
}

Object ( List Out1) Zero( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="List"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,25
 Object Output( List Out1) ;  //_GUI 91,25
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 75,23
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,32
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 50,22

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Zero.0;  //_GUI 68,28, 68,35
 ListOut.1 = Zero:A.0;  
 Zero.0 = ListIn.0;  //_GUI 47,35, 47,28
 Zero:A.0 = ListIn.1;  
}

Object ( NULL Out1) Zero( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="NULL"
{
 // PDescription:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,23
 Object Output( NULL Out1) ;  //_GUI 106,23

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) BitLength( Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns the bitlength of the incoming data set as a numberic constant.  The output data set will have the smallest bitlength possible to represent the constant value.  This means the ouput will always have a leading 1.
 //
 // Inputs:
 //
 // Variant Type: The dataset for which a bit length will be computed.
 //
 // Outputs:
 //
 // Variant output: The bit length of Type as a numeric constant.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 18,20
 Object Output( Variant Out1) ;  //_GUI 57,20
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 26,18
 Object Text;  //_GUI 22,27,The Type input is filtered through an MSB in order to produce a simple data set out of Lists, Contextual data sets, etc.  The $BitLength object then returns the length of this data set.
 Object ( Variant Out1) $BitLength( Variant Type) ;  //_GUI 40,18

 //_ Behavior Topology
 Output.0 = $BitLength.0;  
 MSB.0 = Input.0;  
 $BitLength.0 = MSB.0;  
}

Object ( Bit Out1) BitLength( Bit Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 // Returns the bitlength of the incoming data set as a numberic constant.  The output data set will have the smallest bitlength possible to represent the constant value.  This means the ouput will always have a leading 1.
 //
 // Inputs:
 //
 // Variant Type: The dataset for which a bit length will be computed.
 //
 // Outputs:
 //
 // Variant output: The bit length of Type as a numeric constant.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 18,20
 Object Output( Bit Out1) ;  //_GUI 53,20
 Object ( Bit In) Input:A;  //_GUI 45,20
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) BitLength( NULL Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL"
{
 // Returns the bitlength of the incoming data set as a numberic constant.  The output data set will have the smallest bitlength possible to represent the constant value.  This means the ouput will always have a leading 1.
 //
 // Inputs:
 //
 // Variant Type: The dataset for which a bit length will be computed.
 //
 // Outputs:
 //
 // Variant output: The bit length of Type as a numeric constant.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 18,20
 Object Output( Bit Out1) ;  //_GUI 57,20
 Object ( Bit Type) Input:A;  //_GUI 48,20
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) Equal( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,17
 Object ( Variant In2) Input:A;  //_GUI 13,20
 Object Output( Bit Out1) ;  //_GUI 73,18
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 42,16
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 60,16
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 26,16

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 NotZero.0 = XOR.0;  
 INVERT.0 = NotZero.0;  
 XOR.0 = Input.0;  
 XOR.1 = Input:A.0;  
}

Object ( Bit Out1) Equal( Floating In1, Floating In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="Floating"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 13,17
 Object ( Floating In2) Input:A;  //_GUI 13,58
 Object Output( Bit Out1) ;  //_GUI 124,38
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 81,30
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 103,36
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 67,38
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 41,56
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 41,15
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 93,31
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 67,45
 Object Text;  //_GUI 13,96,so -0 == +0 or all types of NaN == NaN or all the bits are equal
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating
    ( Floating In1) ;  //_GUI 20,56
 //_ Attributes Documentation="with NaN"
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating:A
    ( Floating In1) ;  //_GUI 20,15
 //_ Attributes Documentation="with NaN"

 //_ Behavior Topology
 Output.0 = OR.0;  
 AND.0 = ExposeFloating:A.5;  
 AND.1 = ExposeFloating.5;  //_GUI 81,73
 OR.0 = OR:A.0;  
 OR.1 = Equal.0;  
 Equal.0 = CollectBIN:A.0;  //_GUI 60,40, 60,18
 Equal.1 = CollectBIN.0;  //_GUI 60,43, 60,59
 CollectBIN.0 = ExposeFloating.0;  
 CollectBIN.1 = ExposeFloating.1;  
 CollectBIN.2 = ExposeFloating.3;  //_GUI 38,64, 38,67
 CollectBIN:A.0 = ExposeFloating:A.0;  
 CollectBIN:A.1 = ExposeFloating:A.1;  
 CollectBIN:A.2 = ExposeFloating:A.3;  //_GUI 38,23, 38,26
 OR:A.0 = AND.0;  
 OR:A.1 = AND:A.0;  //_GUI 93,48
 AND:A.0 = ExposeFloating:A.10;  
 AND:A.1 = ExposeFloating.10;  //_GUI 67,88
 ExposeFloating.0 = Input:A.0;  
 ExposeFloating:A.0 = Input.0;  
}

Object ( Bit Out1) Equal( NULL In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="NULL"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,17
 Object ( NULL In2) Input:A;  //_GUI 13,22
 Object Output( Bit Out1) ;  //_GUI 56,28
 Object ( Bit In) Input:B;  //_GUI 41,28
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) Equal( Variant In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="var/NULL"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,17
 Object ( NULL In2) Input:A;  //_GUI 13,22
 Object Output( Bit Out1) ;  //_GUI 56,28
 Object ( Bit In) Input:B;  //_GUI 41,28
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) Equal( NULL In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="NULL/var"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,17
 Object ( Variant In2) Input:A;  //_GUI 13,22
 Object Output( Bit Out1) ;  //_GUI 56,28
 Object ( Bit In) Input:B;  //_GUI 41,28
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) Equal( List In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="list"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 13,17
 Object ( List In2) Input:A;  //_GUI 13,28
 Object Output( Bit Out1) ;  //_GUI 67,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,15
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 21,26
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 40,15
 Object ( Bit Out1) Equal:A( Variant In1, Variant In2) ;  //_GUI 40,26
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,20

 //_ Behavior Topology
 Output.0 = AND.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 Equal.0 = ListIn.1;  
 Equal.1 = ListIn:A.1;  //_GUI 36,20, 36,28
 Equal:A.0 = ListIn.0;  //_GUI 40,24, 32,24
 Equal:A.1 = ListIn:A.0;  
 AND.0 = Equal.0;  //_GUI 52,22, 52,18
 AND.1 = Equal:A.0;  //_GUI 52,25, 52,29
}

Object ( Variant Out1) INVERT( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async"
{
 // Description:
 // Inverts the input data.
 //
 // Inputs:
 // In1:  data
 //
 // Outputs:
 // Out1:  inverted data.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,22
 Object Output( Variant Out1) ;  //_GUI 109,20
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 70,20
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 29,20
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 49,16
 Object ( Variant Out1) INVERT:A( Variant In1) ;  //_GUI 54,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 24,22
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 92,18

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = INVERT:A.0;  
 VariantOut.1 = INVERT.0;  //_GUI 66,22, 66,19
 VariantIn.0 = Junction.1;  
 INVERT.0 = VariantIn.1;  //_GUI 45,19, 45,22
 INVERT:A.0 = VariantIn.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 86,20, 86,13, 25,13
 Cast.1 = VariantOut.0;  
}

Object ( NULL Out1) INVERT( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$INVERT",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,20
 Object Output( NULL Out1) ;  //_GUI 109,20

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,24
 Object ( Variant In3) Input:A;  //_GUI 22,27
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 30,23
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 44,23

 //_ Behavior Topology
 Output.0 = MSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 MSB.0 = ListOut.0;  
}

Object ( NULL mMSBOut) CollectMSB( NULL Hi, NULL Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out",Documentation="Null/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( NULL mMSBOut) ;  //_GUI 41,14

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 26,15, 26,14
}

Object ( Variant Out1) CollectMSB( NULL In3, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out",Documentation="null/var"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In3) Input;  //_GUI 22,22
 Object ( Variant In2) Input:A;  //_GUI 22,25
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 44,23

 //_ Behavior Topology
 Output.0 = MSB.0;  
 MSB.0 = Input:A.0;  
}

Object ( Variant Out1) CollectMSB( Variant In2, NULL In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out",Documentation="var/null"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,25
 Object ( NULL In3) Input:A;  //_GUI 22,27
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 44,23

 //_ Behavior Topology
 Output.0 = MSB.0;  
 MSB.0 = Input.0;  
}

Object ( Bit Q) StickyRegSync( Bit D, Bit ClkG
    , Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="bit/bit"
{
 // The StickyReg starts out in a 0 state.  When the D input goes high, the StickyReg will enter a 1 state (on the positive clock edge).  It will remain in this state until an SCLR (synchronous) is received.
 //
 // Inputs:
 // D (Bit) - values of 1 will 'stick'
 // CLR - asynchronous clear
 //
 // Outputs:
 // Q - current state
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit D) Input;  //_GUI 26,32
 Object ( Bit ClkG) Input:A;  //_GUI 39,42
 //_ Attributes Resource="Global"
 Object ( Bit SCLR) Input:B;  //_GUI 39,45
 //_ Attributes Constant="0"
 Object Output( Bit Q) ;  //_GUI 130,39
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 67,32
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 47,31
 Object ( Bit B) Input:C;  //_GUI 61,36
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 90,39
 Object ( Bit Out) $Cast( Variant Data, Bit Type) ;  //_GUI 108,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 37,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 123,39

 //_ Behavior Topology
 Output.0 = Junction:A.1;  
 Mux.0 = OR.0;  
 Mux.1 = Input:C.0;  
 Mux.2 = Input:B.0;  //_GUI 66,40, 66,46
 OR.0 = Junction.1;  
 OR.1 = Junction:A.0;  //_GUI 45,36, 45,26, 124,26
 Reg.0 = Mux.0;  //_GUI 85,41, 85,35
 Reg.1 = Input:A.0;  //_GUI 60,44, 60,43
 $Cast.0 = Reg.0;  
 $Cast.1 = Junction.0;  //_GUI 108,17, 38,17
 Junction.0 = Input.0;  
 Junction:A.0 = $Cast.0;  
}

Object ( Variant Q) StickyRegSync( Variant D, Bit ClkG
    , Variant SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="var/var"
{
 // Same as StickyReg except with a synchronous clear instead of an asynchronous clear. Also supports a multi-bit overload where D, CLR, and Q are variants of the same dataset in which each bit is stickied and cleared independent of one another.
 //
 // Inputs:
 //
 // Bit/Var D:	The bit to be stickied.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit/Var CLR:	Synchronously clears the contents of the sticky register.
 //
 // Outputs:
 //
 // Bit/Var Q:	The sticky output.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 34,17
 Object ( Bit ClkG) Input:A;  //_GUI 33,26
 //_ Attributes Resource="Global"
 Object ( Variant SCLR) Input:B;  //_GUI 32,31
 Object Output( Variant Q) ;  //_GUI 137,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,15
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 109,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 48,17
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 58,29
 Object ( Variant Q) StickyRegSync( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,15
 Object ( Variant Q) StickyRegSync:A( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,28
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 75,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 124,14

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = StickyRegSync:A.0;  //_GUI 103,21, 103,31
 VariantOut.1 = StickyRegSync.0;  
 Junction.0 = Input.0;  
 VariantIn:A.0 = Input:B.0;  
 StickyRegSync.0 = VariantIn.1;  
 StickyRegSync.1 = Junction:A.0;  //_GUI 76,20
 StickyRegSync.2 = VariantIn:A.1;  //_GUI 71,23, 71,31
 StickyRegSync:A.0 = VariantIn.0;  //_GUI 73,30, 73,20
 StickyRegSync:A.1 = Junction:A.2;  //_GUI 76,33
 StickyRegSync:A.2 = VariantIn:A.0;  //_GUI 73,36, 73,34
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction.0;  //_GUI 122,16, 122,9, 49,9
 Cast.1 = VariantOut.0;  
}

Object ( Variant Q) StickyRegSync( Variant D, Bit ClkG
    , Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="var/bit"
{
 // Same as StickyReg except with a synchronous clear instead of an asynchronous clear. Also supports a multi-bit overload where D, CLR, and Q are variants of the same dataset in which each bit is stickied and cleared independent of one another.
 //
 // Inputs:
 //
 // Bit/Var D:	The bit to be stickied.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit/Var CLR:	Synchronously clears the contents of the sticky register.
 //
 // Outputs:
 //
 // Bit/Var Q:	The sticky output.
 //
 // Revision 1 - 11/08/05 New var/bit overload
 // Fulfilled Bug 560
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 34,17
 Object ( Bit ClkG) Input:A;  //_GUI 33,26
 //_ Attributes Resource="Global"
 Object ( Bit SCLR) Input:B;  //_GUI 32,35
 Object Output( Variant Q) ;  //_GUI 137,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,15
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 109,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 48,17
 Object ( Variant Q) StickyRegSync( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,15
 Object ( Variant Q) StickyRegSync:A( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,28
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 75,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 124,14
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 70,35

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = StickyRegSync:A.0;  //_GUI 103,21, 103,31
 VariantOut.1 = StickyRegSync.0;  
 Junction.0 = Input.0;  
 StickyRegSync.0 = VariantIn.1;  
 StickyRegSync.1 = Junction:A.0;  //_GUI 76,20
 StickyRegSync.2 = Junction:B.0;  //_GUI 71,23
 StickyRegSync:A.0 = VariantIn.0;  //_GUI 73,30, 73,20
 StickyRegSync:A.1 = Junction:A.2;  //_GUI 76,33
 StickyRegSync:A.2 = Junction:B.1;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction.0;  //_GUI 122,16, 122,9, 49,9
 Cast.1 = VariantOut.0;  
 Junction:B.0 = Input:B.0;  
}

Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Icon="add"
{
 // D Flip Flop with clock enable
 //
 // Inputs:
 //
 // Variant D:	The value to be registered on the next rising clock edge if EN is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit EN:	Enable D to be registered on the next clock edge if EN is high.  If disconnected, defaults to a value of 1.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 16,20
 Object ( Bit ClkG) Input:A;  //_GUI 16,33
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 16,36
 //_ Attributes Constant="1"
 Object Output( Variant Q) ;  //_GUI 99,19
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,18
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 69,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 47,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 44,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 22,20
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 51,18
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 51,29
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 86,17

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:B.1;  
 VariantOut.0 = RegEn:A.0;  //_GUI 65,24, 65,32
 VariantOut.1 = RegEn.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input.0;  
 RegEn.0 = VariantIn.1;  
 RegEn.1 = Junction.0;  //_GUI 48,23
 RegEn.2 = Junction:A.0;  //_GUI 45,26
 RegEn:A.0 = VariantIn.0;  //_GUI 42,31, 42,23
 RegEn:A.1 = Junction.1;  
 RegEn:A.2 = Junction:A.1;  
 Cast.0 = Junction:B.0;  //_GUI 83,19, 83,16, 23,16
 Cast.1 = VariantOut.0;  
}

Object ( List Q) RegEn( List D, Bit ClkG
    , List EN) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Icon="add",Documentation="List/List"
{
 // D Flip Flop with clock enable
 //
 // Inputs:
 //
 // List D:	The value to be registered on the next rising clock edge if En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // List EN:	This is usually a list of bits. Enable D to be registered on the next clock edge if EN is high.  Must have the same number of elements as D. This allows each element in D to have a separate and independent enable bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 01 Jan 2003
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 21,23
 Object ( Bit ClkG) Input:A;  //_GUI 22,32
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 21,41
 Object Output( List Q) ;  //_GUI 103,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,21
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 89,22
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,39
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 64,21
 //_ Attributes Documentation="Template"
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 64,36
 //_ Attributes Documentation="Template"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 56,32

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = RegEn:A.0;  //_GUI 77,27, 77,39
 ListOut.1 = RegEn.0;  
 ListIn:A.0 = Input:B.0;  
 RegEn.0 = ListIn.1;  
 RegEn.1 = Junction.0;  //_GUI 57,26
 RegEn.2 = ListIn:A.1;  //_GUI 50,29, 50,41
 RegEn:A.0 = ListIn.0;  //_GUI 44,38, 44,26
 RegEn:A.1 = Junction.2;  //_GUI 57,41
 RegEn:A.2 = ListIn:A.0;  
 Junction.0 = Input:A.0;  
}

Object ( Bit Q) RegEn( Bit D, Bit ClkG
    , Bit EN) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Icon="add",Documentation="leaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit D) Input;  //_GUI 23,20
 Object ( Bit ClkG) Input:A;  //_GUI 23,23
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 23,26
 //_ Attributes Constant="1"
 Object Output( Bit Q) ;  //_GUI 47,21
 Object ( Bit Q) RegClr( Bit D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 32,19

 //_ Behavior Topology
 Output.0 = RegClr.0;  
 RegClr.0 = Input.0;  
 RegClr.1 = Input:A.0;  
 RegClr.2 = Input:B.0;  
}

Object ( List Q) RegEn( Variant D, Bit ClkG
    , List EN) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Icon="add",Documentation="Var/List"
{
 // D Flip Flop with clock enable
 //
 // Inputs:
 //
 // Variant D:	The value to be registered on the next rising clock edge if En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // List EN:	This is usually a list of bits. Enable D to be registered on the next clock edge if EN is high.  This creates one copy of D for each element of EN and each is enabled separately.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 22,22
 Object ( Bit ClkG) Input:A;  //_GUI 22,32
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 21,41
 Object Output( List Q) ;  //_GUI 103,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 89,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,39
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 64,21
 //_ Attributes Documentation="Template"
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Variant EN) ;  //_GUI 64,36
 //_ Attributes Documentation="Template"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 56,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 43,22

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = RegEn:A.0;  //_GUI 77,27, 77,39
 ListOut.1 = RegEn.0;  
 ListIn.0 = Input:B.0;  
 RegEn.0 = Junction:A.1;  
 RegEn.1 = Junction.0;  //_GUI 57,26
 RegEn.2 = ListIn.1;  //_GUI 50,29, 50,41
 RegEn:A.0 = Junction:A.2;  //_GUI 44,38
 RegEn:A.1 = Junction.2;  //_GUI 57,41
 RegEn:A.2 = ListIn.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
}

Object ( NULL Q) RegEn( NULL D, Bit ClkG
    , Variant EN) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Icon="add",Documentation="NULL"
{
 // D Flip Flop with clock enable
 //
 // Inputs:
 //
 //   D - Data In
 //   ClkG - Global Clock
 //   EN - Clock Enable
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 16,19
 Object ( Bit ClkG) Input:A;  //_GUI 16,33
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 16,36
 Object Output( NULL Q) ;  //_GUI 99,19

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( MSB002 m_axi_2_rresp, MSB128 DataOut, Bit ReadReady
    , Bit ReadLast, Bit NextWrite, Bit WriteLast, Variant m_axi_2_bresp) AXI_2_MASTER_128bits
    ( Bit DoRead, MSB032 m_axi_2_araddr, MSB008 m_axi_2_arlen, Bit WaitRead
    , Bit DoWrite, MSB128 WriteData, MSB032 m_axi_2_awaddr, MSB008 m_axi_2_awlen
    , Bit TransactionType, Bit md_2_error) 
//_ Attributes TreeGroup="BotMisc"
{
 //_ Object Prototypes
 Object ( Bit DoRead) Input;  //_GUI 199,42
 Object ( MSB032 m_axi_2_araddr) Input:A;  //_GUI 165,53
 Object ( MSB008 m_axi_2_arlen) Input:B;  //_GUI 165,57
 Object ( Bit WaitRead) Input:C;  //_GUI 296,62
 Object ( Bit DoWrite) Input:D;  //_GUI 162,151
 Object ( MSB128 WriteData) Input:E;  //_GUI 158,174
 Object ( MSB032 m_axi_2_awaddr) Input:F;  //_GUI 158,178
 //_ Attributes WidgetHex="True"
 Object ( MSB008 m_axi_2_awlen) Input:G;  //_GUI 158,181
 Object ( Bit TransactionType) Input:H;  //_GUI 133,216
 Object ( Bit md_2_error) Input:I;  //_GUI 235,258
 Object Output( MSB002 m_axi_2_rresp) ;  //_GUI 138,40
 Object Output:A( MSB128 DataOut) ;  //_GUI 304,41
 //_ Attributes WidgetHex="True"
 Object Output:B( Bit ReadReady) ;  //_GUI 303,56
 Object Output:C( Bit ReadLast) ;  //_GUI 252,83
 Object Output:D( Bit NextWrite) ;  //_GUI 320,175
 Object Output:E( Bit WriteLast) ;  //_GUI 311,191
 Object Output:F( Variant m_axi_2_bresp) ;  //_GUI 182,221
 Object ( MSB002 m_axi_2_arburst) Input:J;  //_GUI 117,66
 //_ Attributes Constant="1",PromoteToParentObject="False"
 Object ( MSB003 m_axi_2_arprot) Input:K;  //_GUI 117,69
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( MSB004 m_axi_2_arcache) Input:L;  //_GUI 117,72
 //_ Attributes Constant="3",PromoteToParentObject="False"
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 137,85
 Object Output:G( Variant m_axi_2_arburst) ;  //_GUI 170,89
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 122,62
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackMSB( Variant In1) ;  //_GUI 154,85
 Object ( MSB003 m_axi_2_arsize) Input:M;  //_GUI 117,77
 //_ Attributes Constant="1",PromoteToParentObject="False"
 Object ( MSB002 m_axi_2_arburst) Input:N;  //_GUI 117,80
 //_ Attributes Constant="1",PromoteToParentObject="False"
 Object ( MSB003 m_axi_2_arprot) Input:O;  //_GUI 117,83
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( MSB004 m_axi_2_arcache) Input:P;  //_GUI 117,86
 //_ Attributes Constant="3",PromoteToParentObject="False"
 Object ( List Out1) PackMSB:A( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 122,76
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 203,41
 Object ( Bit m_axi_2_aclk) Input:Q;  //_GUI 129,32
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 238,61
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 219,43
 Object ( Variant State) State:A( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 238,42
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 267,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 256,44
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 282,54
 Object Output:H( Variant m_axi_2_rready) ;  //_GUI 335,67
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackMSB:A( Variant In1) ;  //_GUI 154,101
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 149,87
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 300,67
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 257,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 281,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 279,55
 Object ( Variant O) Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 317,65
 Object ( Bit A) Input:R;  //_GUI 313,66
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 232,65
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 321,84
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 266,63
 Object ( Variant O) Mux:B( Variant A, Variant B
    , Bit S) ;  //_GUI 204,63
 Object ( Bit A) Input:S;  //_GUI 200,64
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Bit Q) StickyRegSync( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 282,85
 Object ( Bit m_axi_2_bvalid) Input:T;  //_GUI 149,226
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( MSB002 m_axi_2_bresp) Input:U;  //_GUI 149,220
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( MSB002 m_axi_2_rresp) Input:V;  //_GUI 127,40
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:I( MSB008 m_axi_2_arlen) ;  //_GUI 173,57
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:J( Variant m_axi_2_arsize) ;  //_GUI 170,86
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:K( Variant m_axi_2_arvalid) ;  //_GUI 260,44
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 159,219
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 219,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In1) ;  //_GUI 228,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In1) ;  //_GUI 228,71
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 272,90
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In1) ;  //_GUI 228,94
 Object ( MSB128 " m_axi_2_rdata") Input:W;  //_GUI 295,41
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:L( MSB032 m_axi_2_araddr) ;  //_GUI 173,53
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Bit m_axi_2_rvalid) Input:X;  //_GUI 216,77
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Bit m_axi_2_arready) Input:Y;  //_GUI 230,46
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 220,65
 Object Output:M( Variant m_axi_2_awsize) ;  //_GUI 169,102
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 240,81
 Object ( Bit m_axi_2_rlast) Input:Z;  //_GUI 184,66
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 302,83
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In1) ;  //_GUI 281,83
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 191,65
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In1) ;  //_GUI 281,80
 Object Output:N( Variant m_axi_2_awburst) ;  //_GUI 169,105
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 193,181
 Object ( Bit 0) Input:a;  //_GUI 184,182
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Output:O( Variant m_axi_2_awprot) ;  //_GUI 169,108
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:P( Variant m_axi_2_awcache) ;  //_GUI 169,111
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:Q( Bit AXI_2_S_CLK) ;  //_GUI 134,32
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object Output:R( Variant m_axi_2_arcache) ;  //_GUI 170,95
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:S( Variant m_axi_2_arprot) ;  //_GUI 170,92
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( MSB003 m_axi_2_arsize) Input:b;  //_GUI 117,63
 //_ Attributes Constant="4",PromoteToParentObject="False"
 Object ( Bit " m_axi_2_aresetn") Input:c;  //_GUI 196,24
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:T( Bit md_error_2) ;  //_GUI 243,258
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:U( Variant m_axi_2_wstrb) ;  //_GUI 260,140
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( MSB016 m_axi_2_wstrb) Input:d;  //_GUI 243,139
 //_ Attributes Constant="65535",PromoteToParentObject="False"
 Object ( Bit m_axi_2_awready) Input:e;  //_GUI 211,155
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:V( Variant m_axi_2_awvalid) ;  //_GUI 268,153
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:W( MSB032 m_axi_2_awaddr) ;  //_GUI 166,178
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:X( MSB008 m_axi_2_awlen) ;  //_GUI 175,181
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Bit m_axi_2_wready) Input:f;  //_GUI 263,177
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:Y( Bit m_axi_2_wvalid) ;  //_GUI 284,168
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:Z( MSB128 m_axi_2_wdata) ;  //_GUI 177,174
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:a( Bit m_axi_2_wlast) ;  //_GUI 269,186
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object Output:b( Variant m_axi_2_bready) ;  //_GUI 260,127
 //_ Attributes System="PE1",Resource="Generic",PromoteToParentObject="False"
 Object ( Bit m_axi_2_bready) Input:AA;  //_GUI 243,126
 //_ Attributes Constant="1",PromoteToParentObject="False"
 Object ( Bit Pulse) OneShot:A( Bit I, Bit ClkG) ;  //_GUI 176,150
 Object ( Variant State) State:B( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 236,151
 Object ( Variant State) State:C( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 236,168
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 225,152
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 263,166
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 251,153
 Object ( Bit LastDone, Bit Done, Bit Busy) DoneForN
    ( Variant Iterations, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 236,184
 Object ( MSB008 Out1, MSB008 Out2, MSB008 Out3) Junction:O
    ( MSB008 In0) ;  //_GUI 170,181
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In1) ;  //_GUI 225,169
 Object ( Bit Out) AND:E( Bit In1, Bit In2) ;  //_GUI 276,173
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In0) ;  //_GUI 264,186
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 289,173
 Object ( Bit Out) INVERT:D( Bit In1) ;  //_GUI 252,165
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In0) ;  //_GUI 275,168
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In0) ;  //_GUI 299,175
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:T
    ( Bit In1) ;  //_GUI 228,178
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:U
    ( Bit In1) ;  //_GUI 228,161
 Object ( Variant O) Mux:C( Variant A, Variant B
    , Bit S) ;  //_GUI 247,138
 Object ( MSB016 m_axi_2_wstrb) Input:BA;  //_GUI 243,142
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:V
    ( Bit In1) ;  //_GUI 228,145
 Object ( Variant O) Mux:D( Variant A, Variant B
    , Bit S) ;  //_GUI 247,125
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In1) ;  //_GUI 228,132
 Object ( Bit m_axi_2_bready) Input:CA;  //_GUI 243,129
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Variant Out1) Inc( Variant In1) ;  //_GUI 207,181

 //_ Behavior Topology
 Output.0 = Input:V.0;  
 Output:A.0 = Input:W.0;  
 Output:B.0 = AND:A.0;  
 Output:C.0 = VouchBit.0;  
 Output:D.0 = Junction:S.1;  
 Output:E.0 = Junction:Q.2;  //_GUI 265,192
 Output:F.0 = RegEn.0;  
 Mux.0 = PackMSB.0;  //_GUI 136,87, 136,65
 Mux.1 = PackMSB:A.0;  //_GUI 134,90, 134,79
 Mux.2 = Input:H.0;  
 Output:G.0 = UnPackMSB.1;  
 PackMSB.0 = Input:b.0;  
 PackMSB.1 = Input:J.0;  
 PackMSB.2 = Input:K.0;  
 PackMSB.3 = Input:L.0;  
 UnPackMSB.0 = Junction:B.1;  
 PackMSB:A.0 = Input:M.0;  
 PackMSB:A.1 = Input:N.0;  
 PackMSB:A.2 = Input:O.0;  
 PackMSB:A.3 = Input:P.0;  
 OneShot.0 = Input.0;  
 State.0 = Junction.2;  //_GUI 220,63
 State.1 = Junction:E.1;  
 State.3 = Junction:H.1;  
 Junction.0 = OneShot.0;  
 State:A.0 = Junction.1;  
 State:A.1 = Input:Y.0;  
 State:A.3 = Junction:G.1;  
 AND.0 = INVERT:A.0;  
 AND.1 = Junction:F.0;  
 Junction:A.0 = State:A.0;  
 AND:A.0 = Junction:D.1;  
 AND:A.1 = Junction:C.0;  
 Output:H.0 = Mux:A.0;  
 UnPackMSB:A.0 = Junction:B.2;  //_GUI 150,104
 Junction:B.0 = Mux.0;  
 INVERT.0 = Input:C.0;  
 INVERT:A.0 = Junction:A.2;  
 Junction:C.0 = Input:X.0;  
 Junction:D.0 = AND.0;  
 Mux:A.0 = Input:R.0;  
 Mux:A.1 = INVERT.0;  
 Mux:A.2 = Junction:D.2;  //_GUI 280,73
 Junction:E.0 = Junction:J.1;  
 AND:B.0 = OR:A.0;  
 AND:B.1 = Junction:F.2;  //_GUI 316,89, 316,75, 267,75
 Junction:F.0 = State.0;  
 Mux:B.0 = Input:S.0;  
 Mux:B.1 = AND:C.0;  
 Mux:B.2 = AND:B.0;  //_GUI 204,103, 331,103
 StickyRegSync.0 = Junction:K.2;  
 StickyRegSync.2 = OR.0;  
 Output:I.0 = Input:B.0;  
 Output:J.0 = UnPackMSB.0;  
 Output:K.0 = Junction:A.1;  
 RegEn.0 = Input:U.0;  
 RegEn.2 = Input:T.0;  
 INVERT:B.0 = Input:c.0;  
 Junction:G.0 = INVERT:B.0;  
 Junction:H.0 = Junction:G.2;  
 OR.0 = Junction:E.2;  //_GUI 233,92
 OR.1 = Junction:I.1;  
 Junction:I.0 = Junction:H.2;  
 Output:L.0 = Input:A.0;  
 Junction:J.0 = Mux:B.0;  
 Output:M.0 = UnPackMSB:A.0;  
 VouchBit.0 = Junction:J.2;  //_GUI 221,84
 OR:A.0 = Junction:K.1;  //_GUI 292,85, 292,84
 OR:A.1 = StickyRegSync.0;  
 Junction:K.0 = Junction:L.2;  
 AND:C.0 = Input:Z.0;  
 AND:C.1 = Junction:L.0;  //_GUI 188,70, 188,89, 269,89, 269,81
 Junction:L.0 = Junction:C.2;  
 Output:N.0 = UnPackMSB:A.1;  
 CollectMSB.0 = Input:a.0;  
 CollectMSB.1 = Junction:O.2;  //_GUI 171,186
 Output:O.0 = UnPackMSB:A.2;  
 Output:P.0 = UnPackMSB:A.3;  
 Output:Q.0 = Input:Q.0;  
 Output:R.0 = UnPackMSB.3;  
 Output:S.0 = UnPackMSB.2;  
 Output:T.0 = Input:I.0;  
 Output:U.0 = Mux:C.0;  
 Output:V.0 = Junction:N.1;  
 Output:W.0 = Input:F.0;  
 Output:X.0 = Junction:O.1;  
 Output:Y.0 = Junction:R.1;  
 Output:Z.0 = Input:E.0;  
 Output:a.0 = Junction:Q.1;  
 Output:b.0 = Mux:D.0;  
 OneShot:A.0 = Input:D.0;  
 State:B.0 = Junction:M.1;  
 State:B.1 = Input:e.0;  
 State:B.3 = Junction:U.1;  
 State:C.0 = Junction:P.1;  
 State:C.1 = Junction:Q.0;  //_GUI 233,173, 233,183, 265,183
 State:C.3 = Junction:T.1;  
 Junction:M.0 = OneShot:A.0;  
 AND:D.0 = INVERT:D.0;  
 AND:D.1 = State:C.0;  
 Junction:N.0 = State:B.0;  
 DoneForN.0 = Inc.0;  //_GUI 225,186, 225,184
 DoneForN.2 = Junction:T.2;  //_GUI 229,192
 DoneForN.3 = Junction:P.2;  //_GUI 226,195
 DoneForN.4 = Junction:S.2;  //_GUI 300,198
 Junction:O.0 = Input:G.0;  
 Junction:P.0 = Junction:M.2;  
 AND:E.0 = Junction:R.2;  
 AND:E.1 = Input:f.0;  
 Junction:Q.0 = DoneForN.0;  
 INVERT:C.0 = AND:E.0;  
 INVERT:D.0 = Junction:N.2;  
 Junction:R.0 = AND:D.0;  
 Junction:S.0 = INVERT:C.0;  
 Junction:T.0 = Junction:U.2;  
 Junction:U.0 = Junction:V.2;  
 Mux:C.0 = Input:d.0;  
 Mux:C.1 = Input:BA.0;  
 Mux:C.2 = Junction:V.1;  
 Junction:V.0 = Junction:W.2;  
 Mux:D.0 = Input:AA.0;  
 Mux:D.1 = Input:CA.0;  
 Mux:D.2 = Junction:W.1;  
 Junction:W.0 = Junction:I.2;  
 Inc.0 = CollectMSB.0;  
}

Object ( Variant Data) List_Mux_Sel_vivado( Variant ListData, Variant Sel) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\Async"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 14,27
 //_ Attributes Constant="0"
 Object ( Variant Sel) Input:A;  //_GUI 15,41
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 150,36
 Object ( Variant Out1) "2^N_List"( Variant In1) ;  //_GUI 21,25
 Object Text;  //_GUI 18,14,Bring the number of elements up to a power of two.
 Object ( Variant Size) ListSize( Variant List) ;  //_GUI 54,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,27
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 66,32
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 85,33
 //_ Attributes Documentation="ztlist"
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 123,48
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 133,34
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 115,33
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 102,35
 Object ( Variant Out1) 2MinList( Variant In1) ;  //_GUI 39,25
 //_ Attributes Documentation="var"
 Object Text;  //_GUI 38,17,Make at least two elements

 //_ Behavior Topology
 Output.0 = AND.0;  
 "2^N_List".0 = Input.0;  
 ListSize.0 = Junction.2;  //_GUI 52,35
 Junction.0 = 2MinList.0;  
 MaskToNum.0 = ListSize.0;  
 UExtnd.0 = MaskToNum.0;  
 UExtnd.1 = Input:A.0;  //_GUI 85,42
 INVERT.0 = UExtnd.0;  //_GUI 99,51, 99,35
 AND.0 = $List_Mux_Sel.0;  
 AND.1 = INVERT.0;  
 $List_Mux_Sel.0 = Junction.1;  //_GUI 115,28
 $List_Mux_Sel.1 = MSB.0;  
 MSB.0 = UExtnd.1;  
 2MinList.0 = "2^N_List".0;  
}

Object ( Variant Data) List_Mux_Sel_vivado( Variant ListData, NULL Sel) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,11
 //_ Attributes Constant="0"
 Object ( NULL Sel) Input:A;  //_GUI 23,24
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 82,11
 Object Text;  //_GUI 25,6,The leaf for a 1-dimention mux where the Sel was not a ZTList.
 Object Text;  //_GUI 18,33,We are not selecting, so pass the data through.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit GoOne, Bit Done, Bit Busy) GDBW_Clr_1cyc_BWpass
    ( Bit ClkG, Bit CLR, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal"
{
 // This GDBW (Go Done Busy Wait) helper object implements the GDBW protocol for use in a single cycle situation and where the Busy Wait chain is desired to be a pass through.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit ClkG) Input;  //_GUI 17,14
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:A;  //_GUI 17,19
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:B;  //_GUI 16,31
 Object ( Bit Wait) Input:C;  //_GUI 90,67
 Object Output( Bit GoOne) ;  //_GUI 86,24
 Object Output:A( Bit Done) ;  //_GUI 86,34
 Object Output:B( Bit Busy) ;  //_GUI 16,66
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 62,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 35,34
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 74,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In1) ;  //_GUI 35,38
 Object Text;  //_GUI 46,48,Register the done (High or Low) when we are not waiting.  This way we hold the done state if they start to wait (and can't receive it).
 Object Text;  //_GUI 84,38,We must drop the done if told to Wait.
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 40,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In2) ;  //_GUI 17,62
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 22,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 52,32
 Object Text;  //_GUI 31,70,An advantage of the GDBW_Clr_1cyc_BWPass object over the GDBW_Clr object is the Busy Wait chain is a pass through which reduces back propigation delay.  The disadvantage is that the Go is not queued on a Wait, but is passed through immediately, causing a stall to the entire Busy Wait chain. If during normal operation, the pipeline is normaly full anyway, there is no advantage to using GDBW_Clr because the Busy Wait must be propigated immediately anyway and the extra logic to queue the Go is not utilized and imposes unnecessary logic level latency.

 //_ Behavior Topology
 Output.0 = Junction:C.0;  //_GUI 53,25
 Output:A.0 = AND.0;  
 Output:B.0 = Junction:B.0;  //_GUI 16,63
 RegClr.0 = Junction:C.1;  
 RegClr.1 = Input.0;  //_GUI 59,36, 59,15
 RegClr.2 = Junction:A.1;  
 RegClr.3 = Input:A.0;  //_GUI 56,42, 56,20
 Junction.0 = INVERT.0;  
 AND.0 = RegClr.0;  
 AND.1 = Junction:A.2;  //_GUI 74,46, 36,46
 Junction:A.0 = Junction.2;  
 AND:A.0 = Input:B.0;  
 AND:A.1 = Junction.1;  
 Junction:B.0 = Input:C.0;  //_GUI 94,63
 INVERT.0 = Junction:B.1;  //_GUI 18,35
 Junction:C.0 = AND:A.0;  
}

Object ( Bit CO, Bit OFL, Variant S) $ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Icon="Add",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 19,12
 Object ( Variant B) Input:A;  //_GUI 19,36
 Object ( Bit ADD) Input:B;  //_GUI 27,48
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 27,51
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 120,21
 Object Output:A( Bit OFL) ;  //_GUI 120,27
 Object Output:B( Variant S) ;  //_GUI 125,41
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 24,34
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 33,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 53,48
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 27,12
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 94,41
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 111,39
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 110,25
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 83,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 109,21
 Object ( Variant CO, Variant S) $$ADSU( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 62,41
 //_ Attributes Documentation="bit"
 Object ( Variant CO, Variant S) $$ADSU:A( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 84,20
 //_ Attributes Documentation="bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 74,40
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 96,19

 //_ Behavior Topology
 Output.0 = Junction:C.1;  
 Output:A.0 = XOR.0;  
 Output:B.0 = Cast.0;  
 PopMsb.0 = Input:A.0;  
 PopMsb:A.0 = Junction:A.1;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 PushMsb.0 = $$ADSU:A.1;  
 PushMsb.1 = $$ADSU.1;  
 Cast.0 = Junction:A.0;  //_GUI 107,41, 107,6, 28,6
 Cast.1 = PushMsb.0;  
 XOR.0 = Junction:C.2;  
 XOR.1 = Junction:B.2;  //_GUI 110,36
 Junction:B.0 = VouchBit.0;  
 Junction:C.0 = VouchBit:A.0;  
 $$ADSU.0 = PopMsb:A.1;  //_GUI 59,43, 59,15
 $$ADSU.1 = PopMsb.1;  //_GUI 48,46, 48,39
 $$ADSU.2 = Junction.1;  
 $$ADSU.3 = Input:C.0;  
 $$ADSU:A.0 = PopMsb:A.0;  //_GUI 84,12
 $$ADSU:A.1 = PopMsb.0;  //_GUI 34,25
 $$ADSU:A.2 = Junction.0;  //_GUI 54,28
 $$ADSU:A.3 = Junction:B.1;  
 VouchBit.0 = $$ADSU.0;  
 VouchBit:A.0 = $$ADSU:A.0;  
}

Object ( Bit CO, Bit OFL, Bit S) $ADSU
    ( Bit A, Bit B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Icon="Add",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 14,20
 Object ( Bit B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,35
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 113,17
 Object Output:A( Bit OFL) ;  //_GUI 113,23
 Object Output:B( Bit S) ;  //_GUI 115,29
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 20,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 36,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 86,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 82,31
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 92,27
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:A( Bit In1, Bit In2) ;  //_GUI 64,20
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:B( Bit In1, Bit In2) ;  //_GUI 48,19
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit In) Input:D;  //_GUI 107,23
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit O) $Mux( Bit A, Bit B
    , Bit S) ;  //_GUI 95,15
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 Output:A.0 = Input:D.0;  
 Output:B.0 = XOR.0;  
 INVERT.0 = Input:B.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = XOR:A.0;  
 Junction:B.0 = Input:C.0;  //_GUI 83,41
 XOR.0 = Junction:A.2;  //_GUI 87,29
 XOR.1 = Junction:B.2;  
 XOR:A.0 = XOR:B.0;  
 XOR:A.1 = INVERT.0;  //_GUI 64,36
 XOR:B.0 = Junction.1;  
 XOR:B.1 = Input:A.0;  
 $Mux.0 = Junction.0;  //_GUI 37,17
 $Mux.1 = Junction:B.1;  //_GUI 83,20
 $Mux.2 = Junction:A.1;  
}

Object ( Variant Out1) Context( Variant Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters"
{
 // Changes the context, or meaning, of a set of bits.  Not to be used to change the size of a dataset (use Convert for this).  An example use of Context would be to change a dataset of MSB008 into a 4 element LSB ordered list of BIN002 elements.
 //
 // Inputs:
 //
 // Variant Type: The resulting dataset
 //
 // Variant Data: The input data and dataset
 //
 // Outputs:
 //
 // Variant output: Data with dataset Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 20,9
 Object ( Variant Data) Input:A;  //_GUI 20,34
 Object Output( Variant Out1) ;  //_GUI 153,44
 Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) ;  //_GUI 97,35
 //_ Attributes Documentation="Bit"
 Object Output:A( Bit Trap) ;  //_GUI 148,36
 //_ Attributes Trap="Data larger than context"
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 124,34
 //_ Attributes Documentation="NULL"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 136,34
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 134,42
 Object ( Bit "Type and B fixed length") Input:B;  //_GUI 27,63
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), M, 65535, <)"
 Object ( Bit "Bitlen(A) same as Bitlen(B)") Input:C;  //_GUI 27,66
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), =)"
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 31,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 40,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 40,57
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 97,44
 Object Text;  //_GUI 37,73,We bypass teh $Context operator in the case where we already have the correct dataset.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 47,9
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 67,8
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 55,28
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 67,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 50,34
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 63,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 54,53
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 63,46

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Context.0 = $Select:A.0;  //_GUI 81,37, 81,11
 $Context.1 = $Select:C.0;  //_GUI 73,40
 Output:A.0 = INVERT.0;  
 IsNULL.0 = $Context.0;  
 INVERT.0 = IsNULL.0;  
 $Select.0 = $Context.1;  //_GUI 121,44, 121,40
 $Select.1 = $Cast.0;  
 $Select.2 = Junction:A.2;  //_GUI 134,58
 AND.0 = Input:B.0;  
 AND.1 = Input:C.0;  
 Junction.0 = Junction:A.1;  
 Junction:A.0 = AND.0;  
 $Cast.0 = $Select:D.0;  
 $Cast.1 = $Select:B.0;  //_GUI 77,46
 Junction:B.0 = Input.0;  
 $Select:A.0 = Junction:B.1;  
 $Select:A.2 = Junction:C.0;  //_GUI 56,16
 Junction:C.0 = Junction.1;  //_GUI 41,29
 $Select:B.1 = Junction:B.2;  //_GUI 48,26
 $Select:B.2 = Junction:C.1;  
 Junction:D.0 = Input:A.0;  
 $Select:C.0 = Junction:D.1;  
 $Select:C.2 = Junction:E.0;  //_GUI 55,41
 Junction:E.0 = Junction.2;  
 $Select:D.1 = Junction:D.2;  //_GUI 51,51
 $Select:D.2 = Junction:E.1;  
}

Object ( Bit Out1) VouchBit( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // The purpose of this object is to vouch for a transport that it will resolve to a Bit.  This is done by (1) forcing the output dataset to a Bit and (2) producing a compile time error if the variant input transport becomes anything other than a bit.  Can be used in feedback loops and in front of Bit output horns.
 //
 // If an output dataset of an object is a bit, but internally the bit output horn connects to a variant transport, often, when this object is resolved, the bit output dataset is lost and becomes a variant, then is later resolved back to a bit.  Most of the time, this works fine, but sometimes in feedback situations the transport is unsuccessful at resolving back into a bit.  The VouchBit object is used to clear up this problem.
 //
 // This object is better than a $Cast, which, if the variant input becomes something other than a bit, the $Cast will force it to be a bit, whereas with the VouchBit, if the variant input becomes anything other than a bit, an error is produced.
 //
 // Inputs:
 //
 // Bit input: Transport to be vouched for as a Bit.
 //
 // Outputs:
 //
 // Bit output: The Bit output.
 //
 // Revision 1
 // Revision 2 - 07/20/06 Just a pass through with the input changed to a Bit. Let the more recent Viva type checking produce the errors.  Will behave correctly if an old overload with a Var input is referenced, you will just get a slightly different error message, but an error, none the less.  The new implementation should compile significantly faster.
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 17,29
 Object Output( Bit Out1) ;  //_GUI 42,29

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) VouchBit( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // This object tells anything downstream that the transport is a bit.  If the variant input becomes anything other than a bit, a user trap is generated.
 //
 // Basically you are vouching that the variant transport will become a bit.
 //
 // If an output dataset of an object is a bit, but internally the bit output horn connects to a variant transport, often, when this object is resolved, the bit output dataset is lost and becomes a variant, then is later resolved back to a bit.  Most of the time, this works fine, but sometimes in feedback situations the transport is unsuccessfull at resolving back into a bit.  The VouchBit object is used to clear up this problem.
 //
 // Place this object between a variant transport and its bit output horn.
 //
 // This object is better than a $Cast, which, if the variant input becomes something other than a bit, the $Cast will force it to be a bit.  Whereas with the VouchBit, if the variant input becomes anything other than a bit, a user trap is produced.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 17,28
 Object Output( Bit Out1) ;  //_GUI 61,27
 Object Output:A( Bit Trap) ;  //_GUI 61,14
 //_ Attributes Trap="Input did not resolve to a Bit"
 Object ( Bit In) Input:A;  //_GUI 55,27
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit In) Input:B;  //_GUI 55,14
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( List Out1) Bit_List( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,14
 Object Output( List Out1) ;  //_GUI 62,14
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 48,12
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 20,12
 Object ( Variant Out1) Bit_List( Variant In1) ;  //_GUI 35,9
 Object ( Variant Out1) Bit_List:A( Variant In1) ;  //_GUI 35,16

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Bit_List:A.0;  //_GUI 47,17, 47,19
 ListOut.1 = Bit_List.0;  //_GUI 47,14, 47,12
 VariantIn.0 = Input.0;  
 Bit_List.0 = VariantIn.1;  //_GUI 34,12, 34,14
 Bit_List:A.0 = VariantIn.0;  //_GUI 34,19, 34,17
}

Object ( Bit Data) Bit_List( Bit Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="bit"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 14,14
 Object Output( Bit Data) ;  //_GUI 62,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) Bit_List( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 14,14
 Object Output( NULL Out1) ;  //_GUI 25,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) Bit_List( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 14,14
 Object Output( List Out1) ;  //_GUI 62,14
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 48,12
 Object ( Variant Out1) Bit_List( Variant In1) ;  //_GUI 35,9
 Object ( Variant Out1) Bit_List:A( Variant In1) ;  //_GUI 35,16
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,12

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Bit_List:A.0;  //_GUI 47,17, 47,19
 ListOut.1 = Bit_List.0;  //_GUI 47,14, 47,12
 Bit_List.0 = ListIn.1;  //_GUI 34,12, 34,14
 Bit_List:A.0 = ListIn.0;  //_GUI 34,19, 34,17
 ListIn.0 = Input.0;  
}

Object ( NULL Out1) LSB( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="NULL"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 9,25
 Object Output( NULL Out1) ;  //_GUI 32,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) LSB( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="Bit"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 9,25
 Object Output( Bit Out1) ;  //_GUI 33,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) LSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a LSB pattern, producing a LSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 132,33
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 105,23
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 122,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,38
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,9
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 21,32
 Object ( Bit In2) Input:A;  //_GUI 27,60
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), 65535, >)"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 45,60
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 91,38
 Object ( Variant Out1) $Cast:A( Variant Data, LSB Type) ;  //_GUI 105,36
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 72,32
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 72,40
 //_ Attributes Documentation="NULL"

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Cast.0 = $Select:A.0;  //_GUI 93,28, 93,12
 $Select.0 = $Cast.0;  //_GUI 115,33
 $Select.1 = $Cast:A.0;  //_GUI 115,36
 $Select.2 = Junction:B.1;  //_GUI 122,61
 VariantIn.0 = $Select:B.0;  //_GUI 49,41
 $Select:A.0 = Junction.1;  
 $Select:A.2 = Junction:A.1;  //_GUI 22,17
 $Select:B.1 = Junction.2;  //_GUI 31,30
 $Select:B.2 = Junction:A.2;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,50, 46,50
 Junction:B.0 = Input:A.0;  
 VariantOut.0 = LSB:A.0;  
 VariantOut.1 = LSB.0;  //_GUI 87,40, 87,35
 $Cast:A.0 = VariantOut.0;  
 LSB.0 = VariantIn.1;  //_GUI 68,35, 68,40
 LSB:A.0 = VariantIn.0;  
}

Object ( Variant Out1) LSB( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="list"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a LSB pattern, producing a LSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 84,8
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 58,8
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 72,6
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 39,2
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 39,10
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,8

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantOut.0 = LSB:A.0;  
 VariantOut.1 = LSB.0;  //_GUI 54,10, 54,5
 $Cast.0 = VariantOut.0;  
 LSB.0 = ListIn.1;  //_GUI 35,5, 35,10
 LSB:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Variant Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Variant"
{
 // Date:
 // 02 Jan 2003
 //
 //
 //
 // Recursive object that used in Hi_N implementation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 52,27
 Object ( Variant Lo) Input:A;  //_GUI 38,38
 Object ( Variant Hi_N) Input:B;  //_GUI 53,51
 Object Output( Variant Hi) ;  //_GUI 110,37
 Object Output:A( Variant Lo) ;  //_GUI 110,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 44,36
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 60,49
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 77,24
 Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Variant Hi_N) ;  //_GUI 93,36
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $Hi_N.0;  
 Output:A.0 = $Hi_N.1;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = Input:B.0;  
 VariantOut.0 = VariantIn.1;  //_GUI 60,31, 60,38
 VariantOut.1 = Input.0;  
 $Cast.0 = VariantOut.0;  
 $Hi_N.0 = $Cast.0;  //_GUI 87,38
 $Hi_N.1 = VariantIn.0;  
 $Hi_N.2 = VariantIn:A.1;  //_GUI 76,44, 76,51
}

Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Bit Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="VariantLeaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 52,27
 Object ( Variant Lo) Input:A;  //_GUI 38,38
 Object ( Bit Hi_N) Input:B;  //_GUI 65,50
 Object Output( Variant Hi) ;  //_GUI 110,35
 Object Output:A( Variant Lo) ;  //_GUI 110,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 44,36
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 78,24

 //_ Behavior Topology
 Output.0 = $Cast.0;  //_GUI 98,36, 98,27
 Output:A.0 = VariantIn.0;  
 VariantIn.0 = Input:A.0;  
 VariantOut.0 = VariantIn.1;  //_GUI 60,31, 60,38
 VariantOut.1 = Input.0;  
 $Cast.0 = VariantOut.0;  
}

Object ( Variant Hi, NULL Lo) $Hi_N( Variant Hi
    , Bit Lo, Bit Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit Leaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 40,26
 Object ( Bit Lo) Input:A;  //_GUI 40,41
 Object ( Bit Hi_N) Input:B;  //_GUI 45,52
 Object Output( Variant Hi) ;  //_GUI 89,25
 Object Output:A( NULL Lo) ;  //_GUI 93,38
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 74,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 56,25
 Object ( NULL Out1) NULL;  //_GUI 76,36

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = NULL.0;  
 $Cast.0 = VariantOut.0;  
 VariantOut.0 = Input:A.0;  //_GUI 50,30, 50,42
 VariantOut.1 = Input.0;  
}

Object ( Variant Hi, NULL Lo) $Hi_N( Variant Hi
    , Bit Lo, Variant Hi_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="ErrorLeaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 44,12
 Object ( Bit Lo) Input:A;  //_GUI 40,39
 Object ( Variant Hi_N) Input:B;  //_GUI 45,52
 Object Output( Variant Hi) ;  //_GUI 126,24
 Object Output:A( NULL Lo) ;  //_GUI 114,38
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 98,22
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 112,22
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 51,50
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 60,11
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 76,9
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 67,49
 Object ( NULL Out1) NULL;  //_GUI 98,36

 //_ Behavior Topology
 Output.0 = MSB.0;  
 Output:A.0 = NULL.0;  
 ListOut.0 = Zero.0;  //_GUI 90,27, 90,52
 ListOut.1 = $Cast.0;  //_GUI 90,24, 90,12
 MSB.0 = ListOut.0;  
 VariantIn.0 = Input:B.0;  
 VariantOut.0 = Input:A.0;  //_GUI 55,16, 55,40
 VariantOut.1 = Input.0;  
 $Cast.0 = VariantOut.0;  
 Zero.0 = VariantIn.1;  
}

Object ( NULL Out1) NULL
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object creates a NULL dataset (transport) instance.  The only supported way to instantiate a NULL dataset is to drop this object on your sheet.  Any other way is potentially erroneous.
 //
 // Inputs:
 //
 // None
 //
 // Outputs:
 //
 // NULL output: Outputs a NULL dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object Output( NULL Out1) ;  //_GUI 77,31
 Object ( NULL NULL_Remove) Input;  //_GUI 47,31
 //_ Attributes Resource="Global",PromoteToParentObject="False",WarnOnRemoval="False"

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="PadLeft"
{
 // This does an unsigned extend of the data when converting to a larger dataset size.  If shrinking the dataset, the OFL will go high if any of the discarded bits were high.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to unsign extend
 //
 // Outputs:
 //
 // Bit/List OFL: 1 if any removed bits were high.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,38
 Object ( Variant Data) Input:A;  //_GUI 7,51
 Object Output( Bit OFL) ;  //_GUI 215,29
 Object Output:A( Variant Out1) ;  //_GUI 204,37
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 104,50
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 169,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 38,64
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 120,49
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 94,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 34,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 38,67
 Object Text;  //_GUI 77,73,So if the data is shorter then the type, we need to tack on some zero fill on the top.
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 169,27
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 104,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 163,51
 Object Text;  //_GUI 41,10,If we lose non-zero data on the high end, that's an overflow.
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 117,33
 //_ Attributes Documentation="Bit"
 Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) ;  //_GUI 136,34
 //_ Attributes Documentation="Variant"
 Object ( Bit In) Input:B;  //_GUI 132,38
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 122,10,If the UExtend inputs Type and Data are the same sizes, the Hi output of Lo_N will be NULL.  In this case there is no overflow, so change it to a bit of value zero with ZeroNulls.
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 203,27
 Object ( Bit In) Input:C;  //_GUI 163,31
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 19,65
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 18,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 14,51
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 134,50
 //_ Attributes Documentation="ztl/var"
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 187,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In0) ;  //_GUI 51,47
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,46
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 55,64
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 51,25
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 55,42
 Object ( Variant Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,35

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 Lo_N.0 = $Select:E.0;  //_GUI 93,52, 93,38
 Lo_N.1 = Junction:A.1;  
 $Select.0 = Lo_N:A.1;  //_GUI 114,46
 $Select.1 = PushLsb.0;  //_GUI 161,49, 161,53
 $Select.2 = Junction:D.2;  
 Junction.0 = Junction:C.0;  
 Zero.0 = Lo_N.0;  
 Junction:A.0 = $Select:C.0;  //_GUI 84,55, 84,60
 Junction:B.0 = Junction:E.1;  
 Junction:C.0 = BitA_Ge_BitB.0;  
 $Select:A.0 = ZeroNulls.0;  //_GUI 149,29, 149,37
 $Select:A.1 = Input:C.0;  
 $Select:A.2 = Junction:D.1;  //_GUI 164,35
 Lo_N:A.0 = $Select:B.0;  //_GUI 87,36, 87,49
 Lo_N:A.1 = $Select:D.0;  //_GUI 98,39, 98,27
 Junction:D.0 = Junction:C.1;  //_GUI 164,68
 NotZero.0 = Lo_N:A.0;  
 ZeroNulls.0 = NotZero.0;  
 ZeroNulls.1 = Input:B.0;  
 VouchBit.0 = $Select:A.0;  
 BitA_Ge_BitB.0 = Junction:E.2;  
 BitA_Ge_BitB.1 = Junction:F.2;  //_GUI 15,70
 Junction:E.0 = Input.0;  
 Junction:F.0 = Input:A.0;  
 PushLsb.0 = Zero.0;  
 PushLsb.1 = Junction:A.2;  //_GUI 134,64, 95,64
 Context.0 = Junction:B.0;  //_GUI 187,8, 35,8
 Context.1 = $Select.0;  //_GUI 183,40, 183,47
 Junction:G.0 = Junction:F.1;  //_GUI 31,48, 31,52
 $Select:B.0 = Junction:G.1;  
 $Select:B.2 = Junction:H.0;  //_GUI 56,54
 Junction:H.0 = Junction.2;  
 $Select:C.1 = Junction:G.2;  //_GUI 52,62
 $Select:C.2 = Junction:H.1;  
 Junction:I.0 = Junction:B.1;  //_GUI 43,26, 43,39
 $Select:D.0 = Junction:I.1;  
 $Select:D.2 = Junction:J.0;  //_GUI 56,32
 Junction:J.0 = Junction.1;  //_GUI 39,43
 $Select:E.1 = Junction:I.2;  //_GUI 52,40
 $Select:E.2 = Junction:J.1;  
}

Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Bit Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Var/Bit"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 46,46
 Object ( Bit Data) Input:A;  //_GUI 48,56
 Object Output( Bit OFL) ;  //_GUI 89,46
 Object Output:A( Variant Out1) ;  //_GUI 97,49
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 54,44
 Object ( Bit C, Variant Out2) SHL( Variant In1
    , Bit C) ;  //_GUI 74,45
 //_ Attributes Documentation="Variant"
 Object Text;  //_GUI 42,65,This is an optimization for when the Data input is a Bit.  An Unsigned Extension can simply be done by by using a Rotate-Carry-Left into an zeroed-out data set.

 //_ Behavior Topology
 Output.0 = SHL.0;  
 Output:A.0 = SHL.1;  
 Zero.0 = Input.0;  
 SHL.0 = Zero.0;  
 SHL.1 = Input:A.0;  //_GUI 68,50, 68,57
}

Object ( List OFL, List Out1) UExtnd( Variant Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/List"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 54,29
 Object ( List Data) Input:A;  //_GUI 54,33
 Object Output( List OFL) ;  //_GUI 128,23
 Object Output:A( List Out1) ;  //_GUI 123,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 75,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 60,31
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 108,31
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 111,21
 Object ( Variant OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 79,43
 //_ Attributes Documentation="PadLeft"
 Object ( Variant OFL, Variant Out1) UExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 79,28
 //_ Attributes Documentation="PadLeft"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = UExtnd.1;  //_GUI 102,36, 102,48
 ListOut.1 = UExtnd:A.1;  
 ListOut:A.0 = UExtnd.0;  //_GUI 95,26, 95,45
 ListOut:A.1 = UExtnd:A.0;  //_GUI 89,23
 UExtnd.0 = Junction.2;  //_GUI 76,45
 UExtnd.1 = ListIn.0;  //_GUI 71,48
 UExtnd:A.0 = Junction.1;  
 UExtnd:A.1 = ListIn.1;  
}

Object ( Bit OFL, NULL Out1) UExtnd( NULL Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL/var"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( Variant Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,12
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 23,21

 //_ Behavior Topology
 Output.0 = NotZero.0;  //_GUI 35,13
 Output:A.0 = Input.0;  
 NotZero.0 = Input:A.0;  
}

Object ( Bit OFL, NULL Out1) UExtnd( NULL Type
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( Variant Out1) ;  //_GUI 53,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,15

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( List OFL, List Out1) UExtnd( List Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="list"
{
 // This does an unsigned extend of the data when converting to a larger dataset size.  If shrinking the dataset, the OFL will go high if any of the discarded bits were high.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to unsign extend
 //
 // Outputs:
 //
 // Bit/List OFL: 1 if any removed bits were high.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 6,15
 Object ( List Data) Input:A;  //_GUI 6,24
 Object Output( List OFL) ;  //_GUI 55,22
 Object Output:A( List Out1) ;  //_GUI 55,31
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 12,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 42,20
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 12,22
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 42,29
 Object ( Variant OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 26,29
 //_ Attributes Documentation="PadLeft"
 Object ( Variant OFL, Variant Out1) UExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 29,13
 //_ Attributes Documentation="PadLeft"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = UExtnd.0;  //_GUI 36,25
 ListOut.1 = UExtnd:A.0;  //_GUI 42,15
 ListIn:A.0 = Input:A.0;  
 ListOut:A.0 = UExtnd.1;  
 ListOut:A.1 = UExtnd:A.1;  //_GUI 39,31
 UExtnd.0 = ListIn.0;  //_GUI 26,18
 UExtnd.1 = ListIn:A.0;  //_GUI 23,34
 UExtnd:A.0 = ListIn.1;  
 UExtnd:A.1 = ListIn:A.1;  //_GUI 29,24
}

Object ( Bit CO, Bit OFL, Variant Count) FastUpDownCount
    ( Variant CBy, Variant Init, Bit ClkG, Bit Up
    , Bit EN, Bit InitEn) 
//_ Attributes TreeGroup="Dram_128bit"
{
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 29,45
 Object ( Variant Init) Input:A;  //_GUI 26,64
 Object ( Bit ClkG) Input:B;  //_GUI 26,71
 Object ( Bit Up) Input:C;  //_GUI 26,75
 //_ Attributes Constant="1"
 Object ( Bit EN) Input:D;  //_GUI 26,82
 //_ Attributes Constant="1"
 Object ( Bit InitEn) Input:E;  //_GUI 26,85
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 184,43
 Object Output:A( Bit OFL) ;  //_GUI 184,46
 Object Output:B( Variant Count) ;  //_GUI 157,60
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 115,44
 Object ( Variant Q) RegInit( Variant D, Variant Init
    , Bit ClkG, Bit En, Bit Init) ;  //_GUI 126,60
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 38,62
 Object ( Variant Q) RegInit:A( Variant D, Variant Init
    , Bit ClkG, Bit En, Bit Init) ;  //_GUI 126,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 35,45
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 38,43
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 143,58
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 111,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 138,62
 Object ( Variant Out1) Cast:A( Variant Type, Variant Data) ;  //_GUI 58,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 53,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 107,73
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 110,70
 Object ( Bit CO, Bit OFL, Variant S) $ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 74,41
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 93,41
 Object ( Variant Out1, Variant Out1) ExposeLSB( Variant In1) ;  //_GUI 148,42
 //_ Attributes Documentation="Error"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 170,44
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 170,41
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 113,67

 //_ Behavior Topology
 Output.0 = VouchBit:A.0;  
 Output:A.0 = VouchBit.0;  
 Output:B.0 = Cast.0;  
 Zero.0 = Junction:A.2;  //_GUI 112,47
 RegInit.0 = $ADSU.2;  //_GUI 91,62, 91,49
 RegInit.1 = MSB.0;  
 RegInit.2 = Junction:F.1;  
 RegInit.3 = Junction:E.1;  
 RegInit.4 = Junction:D.2;  
 MSB.0 = Input:A.0;  
 RegInit:A.0 = Junction:A.1;  
 RegInit:A.1 = Zero.0;  
 RegInit:A.2 = Junction:F.0;  //_GUI 114,50
 RegInit:A.3 = Junction:E.0;  //_GUI 111,53
 RegInit:A.4 = Junction:D.1;  //_GUI 108,56
 Junction.0 = Input.0;  
 MSB:A.0 = Junction.1;  
 Cast.0 = Junction.0;  //_GUI 143,21, 36,21
 Cast.1 = Junction:B.1;  
 Junction:A.0 = CollectLSB.0;  
 Junction:B.0 = RegInit.0;  
 Cast:A.0 = Junction:C.0;  //_GUI 54,39
 Cast:A.1 = Junction:B.0;  //_GUI 51,42, 51,24, 139,24
 Junction:C.0 = MSB:A.0;  
 Junction:D.0 = Input:E.0;  //_GUI 108,86
 Junction:E.0 = Input:D.0;  //_GUI 91,71, 91,83
 $ADSU.0 = Cast:A.0;  //_GUI 74,40
 $ADSU.1 = Junction:C.1;  
 $ADSU.2 = Input:C.0;  //_GUI 58,49, 58,76
 CollectLSB.0 = $ADSU.0;  
 CollectLSB.1 = $ADSU.1;  
 ExposeLSB.0 = RegInit:A.0;  
 VouchBit.0 = ExposeLSB.1;  
 VouchBit:A.0 = ExposeLSB.0;  
 Junction:F.0 = Input:B.0;  //_GUI 54,68, 54,72
}

Object ( Bit FirstGo) FirstGo( Bit ClkG, Bit SCLR
    , Bit Go) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced"
{
 // This object is used in the GDBW model if you need the Go signal to be first passed through and any subsequent Goes to be blocked until the object is cleared. This object is similar to a StickyPass with a synchronous clear.
 //
 // Inputs:
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit SCLR: Synchronous clear.
 //
 // Bit Go: Only the first Go is passed through until an SCLR.
 //
 // Outputs:
 //
 // Bit FirstGo: Only the first Go is passed through until an SCLR.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit ClkG) Input;  //_GUI 11,17
 //_ Attributes Resource="Global"
 Object ( Bit SCLR) Input:A;  //_GUI 11,20
 Object ( Bit Go) Input:B;  //_GUI 11,25
 Object Output( Bit FirstGo) ;  //_GUI 107,13
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 20,14
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 83,13
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 95,11
 Object ( Bit Q) RegSclr( Bit D, Bit ClkG
    , Bit EN, Bit SCLR) ;  //_GUI 69,13
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 61,14

 //_ Behavior Topology
 Output.0 = AND.0;  
 Junction.0 = Input:B.0;  //_GUI 18,15, 18,26
 INVERT.0 = RegSclr.0;  
 AND.0 = Junction.0;  //_GUI 95,11, 21,11
 AND.1 = INVERT.0;  
 RegSclr.0 = Junction:A.1;  
 RegSclr.1 = Input.0;  
 RegSclr.2 = Junction:A.2;  //_GUI 62,21
 RegSclr.3 = Input:A.0;  //_GUI 49,24, 49,21
 Junction:A.0 = Junction.1;  
}

Object ( Bit Out1) EqualZero( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 4,20
 Object Output( Bit Out1) ;  //_GUI 46,20
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 30,18
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 14,18

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 INVERT.0 = NotZero.0;  
 NotZero.0 = Input.0;  
}

Object ( Bit Out1) EqualZero( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="NULL"
{
 // Date:
 // 11 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 25,16
 Object Output( Bit Out1) ;  //_GUI 47,16
 Object ( Bit In) Input:A;  //_GUI 41,16
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 16,27,Treat a NULL input as a constant zero value.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) EqualZero( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="Bit"
{
 // Date:
 // 11 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 68,37
 Object Output( Bit Out1) ;  //_GUI 90,37
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 75,35

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 INVERT.0 = Input.0;  
}

Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\Async"
{
 // Multiplexer
 //
 // INPUTS:
 //
 // Variant A: The first input to select between.
 //
 // Variant B: The second input to select between.  A and B must have the same dataset.
 //
 // Variant Sel: A number to select which input to output.  0 for A and 1 for B.
 //
 // OUTPUTS:
 //
 // Variant O:	The multiplexed output.  Has the same dataset as input A.
 //
 // August 25, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,28
 Object ( Variant B) Input:A;  //_GUI 22,31
 Object ( Bit S) Input:B;  //_GUI 22,34
 Object Output( Variant O) ;  //_GUI 71,29
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 52,27
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 33,27
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 $Mux.0 = Symmetrize.0;  
 $Mux.1 = Symmetrize.1;  
 $Mux.2 = Input:B.0;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( Variant O) Mux( Variant A, NULL B
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,13
 Object ( NULL B) Input:A;  //_GUI 22,23
 Object ( Bit S) Input:B;  //_GUI 22,31
 Object Output( Variant O) ;  //_GUI 61,14
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 49,12
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 30,29

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = INVERT.0;  //_GUI 43,17, 43,32
 INVERT.0 = Input:B.0;  
}

Object ( Variant O) Mux( NULL A, Variant B
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 19,18
 Object ( Variant B) Input:A;  //_GUI 19,21
 Object ( Bit S) Input:B;  //_GUI 19,24
 Object Output( Variant O) ;  //_GUI 43,22
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 31,20

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input:A.0;  
 AND.1 = Input:B.0;  
}

Object ( Bit Out1) NotZero( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async"
{
 // Returns 1 if input data does not equal zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,20
 Object Output( Bit Out1) ;  //_GUI 53,20
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 26,18
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 40,18

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 OR-NInput.0 = Input.0;  
 VouchBit.0 = OR-NInput.0;  
}

Object ( NULL Out1) NotZero( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="NULL"
{
 // NotZero - Variant Select Case
 //
 // Returns 1 if input data does not equal zero.
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 14,17
 Object Output( NULL Out1) ;  //_GUI 33,17

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) NotZero( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="Bit"
{
 // NotZero - Variant Select Case
 //
 // Returns 1 if input data does not equal zero.
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 14,17
 Object Output( Bit Out1) ;  //_GUI 33,17

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) NotZero( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\$Internal",Documentation="Floating"
{
 // Returns 1 if input data does not equal zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 13,20
 Object Output( Bit Out1) ;  //_GUI 83,23
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 55,21
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 21,18
 Object Text;  //_GUI 31,11,-0 == 0
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 40,21
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 70,21

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 OR-NInput.0 = CollectLSB.0;  
 ExposeFloating.0 = Input.0;  
 CollectLSB.0 = ExposeFloating.1;  
 CollectLSB.1 = ExposeFloating.2;  
 VouchBit.0 = OR-NInput.0;  
}

Object ( Variant Out1) AND( Variant In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,16
 Object ( NULL In2) Input:A;  //_GUI 27,22
 Object Output( Variant Out1) ;  //_GUI 44,16
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,14
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( Variant Out1) AND( NULL In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="NULL/Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 26,9
 Object ( Variant In1) Input:A;  //_GUI 26,16
 Object Output( Variant Out1) ;  //_GUI 44,16
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,14
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input:A.0;  
}

Object ( Variant Out1) AND( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\AND"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 12,24
 Object ( Variant In2) Input:A;  //_GUI 12,27
 Object Output( Variant Out1) ;  //_GUI 57,25
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 42,23
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 28,23
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $AND.0;  
 $AND.0 = Symmetrize.0;  
 $AND.1 = Symmetrize.1;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( Variant Out1) AND( Bit In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Bit\\Variant"
{
 // AND - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,26
 Object Output( Variant Out1) ;  //_GUI 120,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 73,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,24
 Object ( Variant Out1) AND( Bit In1, Variant In2) ;  //_GUI 57,24
 Object ( Variant Out1) AND:A( Bit In1, Variant In2) ;  //_GUI 57,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 24,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 95,15

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = AND.0;  //_GUI 71,22, 71,27
 VariantOut.1 = AND:A.0;  
 VariantIn.0 = Junction:A.1;  
 AND.0 = Junction.2;  //_GUI 52,26, 52,23, 43,23
 AND.1 = VariantIn.0;  
 AND:A.0 = Junction.1;  
 AND:A.1 = VariantIn.1;  //_GUI 49,21, 49,26
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction:A.2;  //_GUI 92,17, 92,33, 25,33
 Cast.1 = VariantOut.0;  
}

Object ( Variant Out1) AND( Variant In2, Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Variant\\Bit"
{
 // AND - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,18
 Object ( Bit In1) Input:A;  //_GUI 12,28
 Object Output( Variant Out1) ;  //_GUI 98,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 20,16
 Object ( Variant Out1) AND( Variant In2, Bit In1) ;  //_GUI 48,16
 Object ( Variant Out1) AND:A( Variant In2, Bit In1) ;  //_GUI 48,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 43,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 17,18
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 81,15

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = AND:A.0;  //_GUI 63,22, 63,27
 VariantOut.1 = AND.0;  
 VariantIn.0 = Junction:A.1;  
 AND.0 = VariantIn.1;  
 AND.1 = Junction.0;  //_GUI 44,21
 AND:A.0 = VariantIn.0;  //_GUI 39,26, 39,21
 AND:A.1 = Junction.1;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 79,17, 79,12, 18,12
 Cast.1 = VariantOut.0;  
}

Object ( List Out1) AND( List In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = AND.0;  //_GUI 65,29, 65,32
 ListOut.1 = AND:A.0;  //_GUI 66,26, 66,23
 AND.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 AND.1 = Junction.1;  
 AND:A.0 = ListIn.1;  
 AND:A.1 = Junction.0;  //_GUI 46,25
}

Object ( List Out1) AND( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var\\List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = AND:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = AND.0;  
 AND.0 = Junction.1;  
 AND.1 = ListIn.1;  //_GUI 41,21, 41,26
 AND:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 AND:A.1 = ListIn.0;  
}

Object ( NULL Out1) AND( NULL In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 26,16
 Object ( NULL In2) Input:A;  //_GUI 27,22
 Object Output( NULL Out1) ;  //_GUI 44,16

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) AND( List In2, Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Bit In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = AND.0;  //_GUI 65,29, 65,32
 ListOut.1 = AND:A.0;  //_GUI 66,26, 66,23
 AND.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 AND.1 = Junction.1;  
 AND:A.0 = ListIn.1;  
 AND:A.1 = Junction.0;  //_GUI 46,25
}

Object ( List Out1) AND( Bit In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Bit\\List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = AND:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = AND.0;  
 AND.0 = Junction.1;  
 AND.1 = ListIn.1;  //_GUI 41,21, 41,26
 AND:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 AND:A.1 = ListIn.0;  
}

Object ( Variant Out1) AND( List In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\List"
{
 // updated Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 11,25
 Object Output( Variant Out1) ;  //_GUI 44,23
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 19,21
 //_ Attributes Documentation="List\\List"
 Object Text;  //_GUI 11,31,Will warn if lists are different sizes.

 //_ Behavior Topology
 Output.0 = $AND_SameLists.0;  
 $AND_SameLists.0 = Input.0;  
 $AND_SameLists.1 = Input:A.0;  
}

Object ( Bit Out1) AND( Bit In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Bit/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Bit Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) AND( NULL In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Null/Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Bit In2) Input:A;  //_GUI 21,22
 Object Output( Bit Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers"
{
 // Inputs to Enter and Leave the State.  The current State is output.  One state per bit.
 //
 // Inputs:
 //
 // Variant Enter: Enter state if clocked high
 //
 // Variant Leave: Leave state if clocked high and Enter is low.  Enter and Leave must have the same dataset.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit CLR: Asynchronous clear.  Has a value of 0 if disconnected
 //
 // Outputs:
 //
 // Variant State: Current state.  Bits are individually controlled by respective Enter and Leave inputs.  Will have the same dataset as Enter and Leave.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx,  BINxxx and Bit.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Enter) Input;  //_GUI 32,24
 Object ( Variant Leave) Input:A;  //_GUI 31,38
 Object ( Bit ClkG) Input:B;  //_GUI 31,55
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:C;  //_GUI 39,67
 //_ Attributes Constant="0"
 Object Output( Variant State) ;  //_GUI 99,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 40,24
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 46,34
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 87,29

 //_ Behavior Topology
 Output.0 = RegClr.0;  
 Junction.0 = Input.0;  
 OR.0 = Junction.2;  //_GUI 41,36
 OR.1 = Input:A.0;  
 RegClr.0 = Junction.1;  //_GUI 65,31, 65,25
 RegClr.1 = Input:B.0;  //_GUI 64,34, 64,56
 RegClr.2 = OR.0;  
 RegClr.3 = Input:C.0;  //_GUI 79,40, 79,68
}

Object ( Variant S) Add( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronous addition.
 //
 // Because this is an asynchronou
 // s object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Number
 //
 // Variant B: Number
 //
 // Outputs:
 //
 // Variant S: The Sum of A and B.  If the dataset of A and B are the same, then the dataset of S will also be the same.  If the dataset of A and B are different, the dataset of S will be the result of a Symmetrize of the two inputs.  In this case a compile-time warning is generated indicating the input datasets were different.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed, Complex and List. If one input is a list and the other is not, the other is duplicated into an equivalent list of the one.  A and B can not have mixed datasets except with respect to size or for the cases of MSB, LSB and BIN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 15,15
 Object ( Variant B) Input:A;  //_GUI 15,18
 Object Output( Variant S) ;  //_GUI 48,18
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 26,14
 //_ Attributes Documentation="List"

 //_ Behavior Topology
 Output.0 = Add.1;  
 Add.0 = Input.0;  
 Add.1 = Input:A.0;  
}

Object ( Variant Out1) OR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\OR"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 17,35
 Object ( Variant In2) Input:A;  //_GUI 17,38
 Object Output( Variant Out1) ;  //_GUI 66,36
 Object ( Variant Out1) $OR( Variant In1, Variant In2) ;  //_GUI 46,34
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 29,34
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $OR.0;  
 $OR.0 = Symmetrize.0;  
 $OR.1 = Symmetrize.1;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( List Out1) OR( List In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List/List"
{
 // OR - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 21,15
 Object ( List In2) Input:A;  //_GUI 21,25
 Object Output( List Out1) ;  //_GUI 93,19
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 76,17
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,23
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,13
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,23
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 70,22, 70,26
 ListOut.1 = $OR_SameLists.0;  //_GUI 72,19, 72,16
 ListIn:A.0 = Input:A.0;  
 $OR_SameLists.0 = ListIn.1;  
 $OR_SameLists.1 = ListIn:A.1;  //_GUI 49,18, 49,22, 44,22, 44,25
 $OR_SameLists:A.0 = ListIn.0;  //_GUI 47,25, 47,18
 $OR_SameLists:A.1 = ListIn:A.0;  
}

Object ( List Out1) OR( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var/List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,14
 Object ( List In2) Input:A;  //_GUI 21,25
 Object Output( List Out1) ;  //_GUI 93,19
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 56,23
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 57,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 76,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 46,14

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 OR.0 = Junction.2;  //_GUI 47,25
 OR.1 = ListIn.0;  
 OR:A.0 = Junction.1;  
 OR:A.1 = ListIn.1;  //_GUI 52,18, 52,22, 43,22, 43,25
 ListOut.0 = OR.0;  //_GUI 70,22, 70,26
 ListOut.1 = OR:A.0;  //_GUI 72,19, 72,16
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
}

Object ( List Out1) OR( List In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List/Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 21,15
 Object ( Variant In2) Input:A;  //_GUI 26,27
 Object Output( List Out1) ;  //_GUI 94,16
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 56,23
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 57,13
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 77,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 50,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 OR.0 = ListIn.0;  //_GUI 45,25, 45,18
 OR.1 = Junction.1;  
 OR:A.0 = ListIn.1;  
 OR:A.1 = Junction.0;  //_GUI 51,18
 ListIn.0 = Input.0;  
 ListOut.0 = OR.0;  //_GUI 70,19, 70,26
 ListOut.1 = OR:A.0;  
 Junction.0 = Input:A.0;  
}

Object ( Variant Out1) OR( Variant In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) OR( NULL In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Null/Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Variant In2) Input:A;  //_GUI 21,22
 Object Output( Variant Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( NULL Out1) OR( NULL In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Null/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( NULL Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) OR( List In2, Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List\\Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Bit In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 51,20
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 51,29

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = OR:A.0;  //_GUI 65,29, 65,32
 ListOut.1 = OR.0;  //_GUI 66,26, 66,23
 OR.0 = ListIn.1;  
 OR.1 = Junction.0;  //_GUI 46,25
 OR:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 OR:A.1 = Junction.1;  
}

Object ( List Out1) OR( Bit In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Bit\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 48,16
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 48,24

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = OR:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = OR.0;  
 OR.0 = Junction.1;  
 OR.1 = ListIn.1;  //_GUI 41,21, 41,26
 OR:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 OR:A.1 = ListIn.0;  
}

Object ( Variant Out1) OR( Bit In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Bit\\Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,26
 Object Output( Variant Out1) ;  //_GUI 120,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 73,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 24,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 95,15
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 57,16
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 57,24

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = OR:A.0;  //_GUI 71,22, 71,27
 VariantOut.1 = OR.0;  
 VariantIn.0 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction:A.2;  //_GUI 92,17, 92,33, 25,33
 Cast.1 = VariantOut.0;  
 OR.0 = Junction.1;  
 OR.1 = VariantIn.1;  //_GUI 49,21, 49,26
 OR:A.0 = Junction.2;  //_GUI 52,26, 52,23, 43,23
 OR:A.1 = VariantIn.0;  
}

Object ( Variant Out1) OR( Variant In2, Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Variant\\Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,18
 Object ( Bit In1) Input:A;  //_GUI 12,28
 Object Output( Variant Out1) ;  //_GUI 98,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 20,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 43,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 17,18
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 81,15
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 48,16
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 48,24

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = OR:A.0;  //_GUI 63,22, 63,27
 VariantOut.1 = OR.0;  
 VariantIn.0 = Junction:A.1;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 79,17, 79,12, 18,12
 Cast.1 = VariantOut.0;  
 OR.0 = VariantIn.1;  
 OR.1 = Junction.0;  //_GUI 44,21
 OR:A.0 = VariantIn.0;  //_GUI 39,26, 39,21
 OR:A.1 = Junction.1;  
}

Object ( Bit Out1) OR( Bit In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Bit/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Bit Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) OR( NULL In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Null/Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Bit In2) Input:A;  //_GUI 21,22
 Object Output( Bit Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1, NULL Out1) ExposeMSB( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In",Documentation="bit"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 36,32
 Object Output( Bit Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1) NULL;  //_GUI 53,36

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
}

Object ( Variant Out1, Variant Out2) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,33
 Object Output( Variant Out1) ;  //_GUI 68,32
 Object Output:A( Variant Out2) ;  //_GUI 68,35
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 36,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  
 MSB.0 = Input.0;  
 VariantIn.0 = MSB.0;  
}

Object ( NULL Out1, NULL Out1) ExposeMSB( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In",Documentation="NULL"
{
 // Date:
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 36,32
 Object Output( NULL Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,39
 Junction.0 = Input.0;  
}

Object ( Variant DataOut, Bit ClkRd, Bit Reset
    , Bit Done, Bit Busy) FIFO( Variant DataIn, Variant Size
    , Bit ClkWr, Bit ClkRd, Bit Reset, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory"
{
 // A First In First Out (FIFO) queue that can span two clock domains.  Utilizes the standard GDBW protocol.
 //
 // Tested at 32bits wide by 16 elements deep at 200MHz and tested at 64 bits wide by 512 bits deep at 133MHz.
 //
 // Inputs:
 //
 // Variant DataIn:	The data to be queued. (ClkWr domain)
 //
 // Variant Size:	A dataset of N bits will produce a queue size of (2^N)-1 elements.
 //
 // Bit ClkWr:	The clock for the write side of the FIFO.
 //
 // Bit ClkRd:	The clock for the read side of the FIFO.
 //
 // Bit Reset:	Asynchronous reset for the FIFO.  Resets counters, not memory contents.
 //
 // Bit Go:	Go of the GDBW protocol.  A list of GOs will produce a list of independent FIFOs.  The Go signal is in the write clock domain.
 //
 // Bit Wait:	Wait of the GDBW protocol.  If a list, must match GO.  The Wait signal is in the read clock domain.  When high, holds off Dones (reads).
 //
 // Outputs:
 //
 // Var DataOut:	Data coming out of the FIFO.  Is valid while Done is high. (ClkRd domain)
 //
 // Bit ClkRd:	The read clock output.
 //
 // Bit Reset:	The asynchronous reset output.
 //
 // Bit Done:	Done of the GDBW protocol.  High when DataOut is valid.  The Done signal is in the read clock domain.
 //
 // Bit Busy:	Busy of the GDBW protocol.  Tells upstream not to Go.  The Busy signal is in the write clock domain.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant DataIn) Input;  //_GUI 58,30
 Object ( Variant Size) Input:A;  //_GUI 58,33
 Object ( Bit ClkWr) Input:B;  //_GUI 58,39
 Object ( Bit ClkRd) Input:C;  //_GUI 58,42
 Object ( Bit Reset) Input:D;  //_GUI 58,45
 Object ( Bit Go) Input:E;  //_GUI 58,48
 Object ( Bit Wait) Input:F;  //_GUI 109,54
 Object Output( Variant DataOut) ;  //_GUI 110,30
 Object Output:A( Bit ClkRd) ;  //_GUI 110,33
 Object Output:B( Bit Reset) ;  //_GUI 110,36
 Object Output:C( Bit Done) ;  //_GUI 110,48
 Object Output:D( Bit Busy) ;  //_GUI 130,65
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 118,63
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 71,39
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 65,45
 Object ( Bit AlmBits) Input:G;  //_GUI 71,36
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 106,63
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 68,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 102,73
 Object ( Variant DataOut, Variant WrRdyCnt, Variant RdRdyCnt
    , Bit AlmFull, Bit AlmEmpty, Bit Empty, Bit Done
    , Bit Busy) FIFO( Variant DataIn, Variant Size, Variant AlmBits
    , Bit ClkWr, Bit ClkRd, Bit Reset, Bit Go
    , Bit Wait) ;  //_GUI 77,29

 //_ Behavior Topology
 Output.0 = FIFO.0;  
 Output:A.0 = Junction:B.2;  //_GUI 100,34, 100,71, 69,71
 Output:B.0 = Junction:C.0;  //_GUI 103,37
 Output:C.0 = FIFO.6;  
 Output:D.0 = VouchBit.0;  
 VouchBit.0 = RegClr.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:D.0;  
 RegClr.0 = FIFO.3;  //_GUI 97,65, 97,40
 RegClr.1 = Junction.2;  //_GUI 72,68
 RegClr.3 = Junction:C.1;  
 Junction:B.0 = Input:C.0;  
 Junction:C.0 = Junction:A.2;  //_GUI 66,74
 FIFO.0 = Input.0;  
 FIFO.1 = Input:A.0;  
 FIFO.2 = Input:G.0;  
 FIFO.3 = Junction.1;  
 FIFO.4 = Junction:B.1;  
 FIFO.5 = Junction:A.1;  
 FIFO.6 = Input:E.0;  
 FIFO.7 = Input:F.0;  //_GUI 113,52
}

Object ( Variant DataOut, Bit Clk, Bit Reset
    , Bit OnReady, Bit ProgFull, Bit Done, Bit Busy) TransformerFIFO
    ( Variant DataIn, Bit ClkG, Bit Reset, Variant NDepth
    , MSB003 S, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="LONGZHAN\\Common\\Memory"
{
 //_ Object Prototypes
 Object ( Variant DataIn) Input;  //_GUI 97,38
 Object ( Bit ClkG) Input:A;  //_GUI 85,47
 //_ Attributes Resource="Global"
 Object ( Bit Reset) Input:B;  //_GUI 85,53
 //_ Attributes Constant="0"
 Object ( Variant NDepth) Input:C;  //_GUI 70,56
 Object ( MSB003 S) Input:D;  //_GUI 72,65
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 80,70
 Object ( Bit Wait) Input:F;  //_GUI 148,75
 Object Output( Variant DataOut) ;  //_GUI 191,20
 Object Output:A( Bit Clk) ;  //_GUI 191,23
 Object Output:B( Bit Reset) ;  //_GUI 191,26
 Object Output:C( Bit OnReady) ;  //_GUI 191,31
 Object Output:D( Bit ProgFull) ;  //_GUI 191,41
 Object Output:E( Bit Done) ;  //_GUI 191,56
 Object Output:F( Bit Busy) ;  //_GUI 169,73
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 145,71
 Object ( Variant DataOut, Variant WrRdyCnt, Variant RdRdyCnt
    , Bit AlmFull, Bit AlmEmpty, Bit Empty, Bit Done
    , Bit Busy) FIFO( Variant DataIn, Variant Size, Variant AlmBits
    , Bit ClkWr, Bit ClkRd, Bit Reset, Bit Go
    , Bit Wait) ;  //_GUI 116,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 110,47
 Object ( Bit AlmBits) Input:G;  //_GUI 110,44
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 141,81
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 157,71
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 135,47
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 171,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In1) ;  //_GUI 110,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In1) ;  //_GUI 110,50
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 77,55
 Object ( MSB008 MSB008) Input:H;  //_GUI 70,59
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 104,53

 //_ Behavior Topology
 Output.0 = FIFO.0;  //_GUI 136,21, 136,39
 Output:A.0 = Junction:C.2;  //_GUI 139,24, 139,79, 111,79
 Output:B.0 = Junction:A.0;  //_GUI 142,27
 Output:C.0 = INVERT.0;  
 Output:D.0 = Junction:B.0;  //_GUI 136,42
 Output:E.0 = FIFO.6;  
 Output:F.0 = VouchBit.0;  
 RegClr.0 = Junction:B.2;  //_GUI 136,73
 RegClr.1 = Junction:C.1;  
 RegClr.3 = Junction:A.1;  
 FIFO.0 = Input.0;  
 FIFO.1 = CollectMSB.0;  //_GUI 92,42, 92,58
 FIFO.2 = Input:G.0;  
 FIFO.3 = Junction.1;  
 FIFO.4 = Junction:D.1;  
 FIFO.5 = Junction:E.1;  
 FIFO.6 = Input:E.0;  //_GUI 95,57, 95,71
 FIFO.7 = Input:F.0;  //_GUI 152,60
 Junction.0 = Input:A.0;  
 Junction:A.0 = Junction:E.2;  //_GUI 105,82
 VouchBit.0 = RegClr.0;  
 Junction:B.0 = FIFO.3;  
 INVERT.0 = FIFO.5;  //_GUI 151,32, 151,54
 Junction:C.0 = Junction:D.2;  
 Junction:D.0 = Junction.2;  
 CollectMSB.0 = Input:C.0;  
 CollectMSB.1 = Input:H.0;  
 Junction:E.0 = Input:B.0;  
}

Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\PackMSB",Icon="Exposer_Out"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 16,19
 Object ( Variant In2) Input:A;  //_GUI 17,26
 Object ( Variant In3) Input:B;  //_GUI 17,29
 Object ( Variant In4) Input:C;  //_GUI 17,32
 Object ( Variant In5) Input:D;  //_GUI 17,35
 Object Output( List Out1) ;  //_GUI 68,20
 Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 31,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 47,18

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackMSB.0 = Input:A.0;  
 PackMSB.1 = Input:B.0;  
 PackMSB.2 = Input:C.0;  
 PackMSB.3 = Input:D.0;  
 ListOut.0 = PackMSB.0;  //_GUI 44,23, 44,28
 ListOut.1 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5) UnPackMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\UnPackMSB",Icon="Exposer_In"
{
 // Unpacks an MSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 23,24
 Object Output( Variant Out1) ;  //_GUI 65,23
 Object Output:A( Variant Out2) ;  //_GUI 65,28
 Object Output:B( Variant Out3) ;  //_GUI 65,31
 Object Output:C( Variant Out4) ;  //_GUI 65,34
 Object Output:D( Variant Out5) ;  //_GUI 65,37
 Object ( Variant Out1, Variant Out2) UnPackMSB( Variant In1) ;  //_GUI 29,22
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackMSB:A( Variant In1) ;  //_GUI 48,27

 //_ Behavior Topology
 Output.0 = UnPackMSB.0;  
 Output:A.0 = UnPackMSB:A.0;  
 Output:B.0 = UnPackMSB:A.1;  
 Output:C.0 = UnPackMSB:A.2;  
 Output:D.0 = UnPackMSB:A.3;  
 UnPackMSB.0 = Input.0;  
 UnPackMSB:A.0 = UnPackMSB.1;  //_GUI 46,30, 46,27
}

Object ( Bit Done, Bit Busy) GoForN( Variant Iterations
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers"
{
 // Consumes N GOs before a Done is output.  Uses the standard GDBW model.  Larger iterations at higher frequencies may not pass timing specifications
 //
 // Inputs:
 //
 // Variant  Iterations: This value indicates the number of iterations or Goes that are consumed before a Done is output.  This value is only read in on the first Go then is ignored for the rest of the Go iterations after which it will be read in again on the next Go. A Go with an Iterations value of 0 will produce no Done at all.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit Go: Go
 //
 // Bit Wait: Wait. Has a value of 0 if disconnected.  Holds off the Done.
 //
 // Outputs:
 //
 // Bit Done: Done.  Is high on the last Go iteration.
 //
 // Bit Busy: Busy.  Tells the Go to hold off.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Iterations) Input;  //_GUI 22,18
 Object ( Bit ClkG) Input:A;  //_GUI 22,24
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 22,27
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 22,30
 Object ( Bit Wait) Input:D;  //_GUI 49,39
 //_ Attributes Constant="0"
 Object Output( Bit Done) ;  //_GUI 56,30
 Object Output:A( Bit Busy) ;  //_GUI 33,42
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 56,19
 Object ( Variant Iteration, Bit FirstGoBusy, Bit Active
    , Bit Done, Bit Busy) GoForN_Down( Variant Iterations, Bit IsFirstGo
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) ;  //_GUI 33,17

 //_ Behavior Topology
 Output.0 = GoForN_Down.3;  
 Output:A.0 = GoForN_Down.4;  
 INVERT.0 = GoForN_Down.1;  
 GoForN_Down.0 = Input.0;  
 GoForN_Down.1 = INVERT.0;  //_GUI 29,22, 29,14, 69,14, 69,22
 GoForN_Down.2 = Input:A.0;  
 GoForN_Down.3 = Input:B.0;  
 GoForN_Down.4 = Input:C.0;  
 GoForN_Down.5 = Input:D.0;  //_GUI 54,40
}

Object ( Variant B, Variant A) DMux( Variant I
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\Async",Documentation="var/bit"
{
 // A 1-2 de-multiplexer.
 //
 // Inputs:
 //
 // Variant I: The data de-multiplex.
 //
 // Bit S: The select bit to select which output to send I to.
 //
 // Outputs:
 //
 // Variant B: I is sent to B if S is 1, zero otherwise.
 //
 // Variant A: I is sent to A if S is 0, zero otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant I) Input;  //_GUI 62,25
 Object ( Bit S) Input:A;  //_GUI 62,37
 Object Output( Variant B) ;  //_GUI 100,26
 Object Output:A( Variant A) ;  //_GUI 100,35
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 88,24
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 88,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 70,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 84,25
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 74,35

 //_ Behavior Topology
 Output.0 = AND.0;  
 Output:A.0 = AND:A.0;  
 AND.0 = Junction:A.1;  
 AND.1 = Junction.0;  //_GUI 71,29
 AND:A.0 = Junction:A.2;  //_GUI 85,35
 AND:A.1 = INVERT.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 INVERT.0 = Junction.1;  
}

Object ( Variant OutAddr, Variant OutNums, Bit RowLastDone
    , Bit LastDone, Bit Done) SlicAddressForWrite( MSB032 WriteAddress, MSB024 WidthNums
    , MSB024 LineNums, MSB016 Height, Bit Go) 
//_ Attributes TreeGroup="A_LHJ"
{
 //_ Object Prototypes
 Object ( MSB032 WriteAddress) Input;  //_GUI 26,19
 //_ Attributes Default="4000"
 Object ( MSB024 WidthNums) Input:A;  //_GUI 26,41
 //_ Attributes WidgetLeft="20",WidgetTop="55",WidgetWidth="204",WidgetHeight="50",Widget="TextBox",Default="5"
 Object ( MSB024 LineNums) Input:B;  //_GUI 26,55
 //_ Attributes WidgetLeft="20",WidgetWidth="204",WidgetHeight="50",Widget="TextBox",Default="16"
 Object ( MSB016 Height) Input:C;  //_GUI 26,62
 //_ Attributes WidgetLeft="20",WidgetWidth="204",WidgetHeight="44",Widget="TextBox",Default="10",WidgetTop="110"
 Object ( Bit Go) Input:D;  //_GUI 26,105
 //_ Attributes WidgetTop="160",WidgetLeft="20"
 Object Output( Variant OutAddr) ;  //_GUI 247,21
 Object Output:A( Variant OutNums) ;  //_GUI 247,26
 Object Output:B( Bit RowLastDone) ;  //_GUI 248,51
 Object Output:C( Bit LastDone) ;  //_GUI 249,69
 Object Output:D( Bit Done) ;  //_GUI 248,107
 Object ( Bit Done, Bit Busy) GoForN( Variant Iterations
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) ;  //_GUI 184,61
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 43,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 126,50
 Object ( MSB024 Out1, MSB024 Out2, MSB024 Out3) Junction:B
    ( MSB024 In0) ;  //_GUI 97,41
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 61,25
 Object ( Bit CO, Bit OFL, Variant Count) FastUpDownCount
    ( Variant CBy, Variant Init, Bit ClkG, Bit Up
    , Bit EN, Bit InitEn) ;  //_GUI 144,82
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 133,84
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 130,83
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 90,78
 Object ( MSB004 MSB004) Input:E;  //_GUI 85,79
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Variant S) Add( Variant A, Variant B) ;  //_GUI 169,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 126,71
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 111,81
 Object Text;  //_GUI 86,93,5Nums * 2 * 16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 43,105
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 103,104
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 188,105
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 211,49
 Object ( Variant Q) Reg:B( Variant D, Bit ClkG) ;  //_GUI 186,49
 Object ( Variant Q) Reg:C( Variant D, Bit ClkG) ;  //_GUI 186,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 223,51
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 225,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 241,69
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In2) ;  //_GUI 180,121
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In2) ;  //_GUI 139,121
 Object ( Variant Q) Reg:D( Variant D, Bit ClkG) ;  //_GUI 231,112
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In2) ;  //_GUI 68,121
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 207,107
 Object ( Bit FirstGo) FirstGo( Bit ClkG, Bit SCLR
    , Bit Go) ;  //_GUI 44,23
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 83,18
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 103,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:M
    ( Variant In3) ;  //_GUI 82,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 82,47
 Object ( MSB004 MSB004) Input:F;  //_GUI 106,85
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( Bit Done, Bit Busy) GoForN:A( Variant Iterations
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) ;  //_GUI 102,40

 //_ Behavior Topology
 Output.0 = Reg:C.0;  //_GUI 196,22
 Output:A.0 = RegClr:A.0;  
 Output:B.0 = Junction:G.1;  
 Output:C.0 = Junction:H.1;  
 Output:D.0 = Junction:L.1;  
 GoForN.0 = Input:C.0;  
 GoForN.2 = Junction:I.1;  //_GUI 181,69
 GoForN.3 = Junction:E.1;  
 Junction.0 = Junction:F.0;  
 Junction:A.0 = GoForN:A.0;  
 Junction:B.0 = Input:A.0;  
 Junction:C.0 = FirstGo.0;  
 FastUpDownCount.0 = Junction:D.1;  
 FastUpDownCount.1 = Zero.0;  
 FastUpDownCount.4 = Junction:E.2;  //_GUI 127,96
 FastUpDownCount.5 = Junction:J.1;  //_GUI 140,99
 Zero.0 = Junction:D.2;  //_GUI 131,87
 Junction:D.0 = CollectMSB:A.0;  
 CollectMSB.0 = Input:E.0;  
 CollectMSB.1 = Input:B.0;  //_GUI 73,83, 73,56
 Add.0 = RegClr.0;  
 Add.1 = FastUpDownCount.2;  //_GUI 169,90
 Junction:E.0 = Junction:A.2;  
 CollectMSB:A.0 = CollectMSB.0;  //_GUI 109,83, 109,81
 CollectMSB:A.1 = Input:F.0;  
 Junction:F.0 = Input:D.0;  
 Reg.0 = Junction:F.1;  
 Reg:A.0 = Reg.0;  
 AND.0 = Reg:B.0;  //_GUI 196,51
 AND.1 = Junction:L.0;  //_GUI 208,54
 Reg:B.0 = Junction:A.1;  
 Reg:C.0 = Add.0;  
 Junction:G.0 = AND.0;  
 AND:A.0 = Junction:G.2;  //_GUI 224,69
 AND:A.1 = GoForN.0;  
 Junction:H.0 = AND:A.0;  
 Junction:I.0 = Reg:D.0;  //_GUI 242,122, 242,115
 Junction:J.0 = Junction:I.0;  
 Reg:D.0 = Junction:H.2;  //_GUI 229,114, 229,110, 242,110
 Junction:K.0 = Junction:J.0;  
 Junction:L.0 = Reg:A.0;  
 FirstGo.1 = Junction:K.0;  //_GUI 35,28, 35,122
 FirstGo.2 = Junction.1;  
 RegClr.0 = Input.0;  
 RegClr.2 = Junction:C.1;  
 RegClr.3 = Junction:M.1;  
 RegClr:A.0 = Junction:B.0;  //_GUI 98,26
 RegClr:A.2 = Junction:C.2;  //_GUI 62,32
 RegClr:A.3 = Junction:M.2;  
 Junction:M.0 = Junction:N.0;  
 Junction:N.0 = Junction:K.1;  //_GUI 69,48
 GoForN:A.0 = Junction:B.1;  
 GoForN:A.2 = Junction:N.1;  
 GoForN:A.3 = Junction.2;  
}

Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Variant Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Variant"
{
 // Date:
 // 04 Oct 2002
 //
 //
 //
 // Recursive object that used in Lo_N implementation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 15,23
 Object ( Variant Lo) Input:A;  //_GUI 16,39
 Object ( Variant Lo_N) Input:B;  //_GUI 47,48
 Object Output( Variant Hi) ;  //_GUI 109,25
 Object Output:A( Variant Lo) ;  //_GUI 109,28
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 56,46
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 44,29
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 57,27
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 23,21
 Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Variant Lo_N) ;  //_GUI 90,24
 //_ Attributes Documentation="Variant/Variant"

 //_ Behavior Topology
 Output.0 = $Lo_N.0;  
 Output:A.0 = $Lo_N.1;  
 VariantIn.0 = Input:B.0;  
 VariantOut.0 = Input:A.0;  //_GUI 40,34, 40,40
 VariantOut.1 = VariantIn:A.0;  //_GUI 37,31, 37,26
 $Cast.0 = VariantOut.0;  
 VariantIn:A.0 = Input.0;  
 $Lo_N.0 = VariantIn:A.1;  //_GUI 72,26, 72,23
 $Lo_N.1 = $Cast.0;  //_GUI 80,29, 80,30
 $Lo_N.2 = VariantIn.1;  //_GUI 70,32, 70,48
}

Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Bit Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant Leaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 38,27
 Object ( Variant Lo) Input:A;  //_GUI 40,40
 Object ( Bit Lo_N) Input:B;  //_GUI 45,52
 Object Output( Variant Hi) ;  //_GUI 63,26
 Object Output:A( Variant Lo) ;  //_GUI 96,36
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,36
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 46,25
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 81,34

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = $Cast.0;  
 VariantOut.0 = Input:A.0;  
 VariantOut.1 = VariantIn.0;  //_GUI 60,38, 60,30
 VariantIn.0 = Input.0;  
 $Cast.0 = VariantOut.0;  
}

Object ( NULL Hi, Variant Lo) $Lo_N( Bit Hi
    , Variant Lo, Bit Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit Leaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Hi) Input;  //_GUI 38,29
 Object ( Variant Lo) Input:A;  //_GUI 40,40
 Object ( Bit Lo_N) Input:B;  //_GUI 45,52
 Object Output( NULL Hi) ;  //_GUI 86,26
 Object Output:A( Variant Lo) ;  //_GUI 96,36
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,36
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 81,34
 Object ( NULL Out1) NULL;  //_GUI 69,24

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = $Cast.0;  
 VariantOut.0 = Input:A.0;  
 VariantOut.1 = Input.0;  //_GUI 60,38, 60,30
 $Cast.0 = VariantOut.0;  
}

Object ( NULL Hi, Variant Lo) $Lo_N( Bit Hi
    , Variant Lo, Variant Lo_N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="ErrorLeaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Hi) Input;  //_GUI 38,28
 Object ( Variant Lo) Input:A;  //_GUI 40,40
 Object ( Variant Lo_N) Input:B;  //_GUI 45,52
 Object Output( NULL Hi) ;  //_GUI 86,26
 Object Output:A( Variant Lo) ;  //_GUI 127,34
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,36
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 81,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 99,32
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 113,32
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 51,50
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 70,49
 Object ( NULL Out1) NULL;  //_GUI 69,24

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = MSB.0;  
 VariantOut.0 = Input:A.0;  
 VariantOut.1 = Input.0;  //_GUI 59,38, 59,29
 $Cast.0 = VariantOut.0;  
 ListOut.0 = $Cast.0;  
 ListOut.1 = Zero.0;  //_GUI 93,34, 93,52
 MSB.0 = ListOut.0;  
 VariantIn.0 = Input:B.0;  
 Zero.0 = VariantIn.1;  
}

Object ( MSB032 Address, MSB008 Size, Bit Done
    , Bit Busy) "GenAddressBeforRead_2_V1.0"( MSB032 ReadAddress, MSB024 ReadNums, Bit ReadAllBlocksLastGo
    , Bit Go, Bit Wait) 
{
 //_ Object Prototypes
 Object ( MSB032 ReadAddress) Input;  //_GUI 30,17
 Object ( MSB024 ReadNums) Input:A;  //_GUI 30,20
 //_ Attributes WidgetLeft="20",WidgetTop="270",WidgetWidth="204",WidgetHeight="50",Widget="TextBox"
 Object ( Bit ReadAllBlocksLastGo) Input:B;  //_GUI 25,111
 Object ( Bit Go) Input:C;  //_GUI 30,116
 Object ( Bit Wait) Input:D;  //_GUI 122,152
 Object Output( MSB032 Address) ;  //_GUI 150,17
 Object Output:A( MSB008 Size) ;  //_GUI 150,20
 Object Output:B( Bit Done) ;  //_GUI 150,29
 Object Output:C( Bit Busy) ;  //_GUI 105,64
 Object ( Variant Address, Variant Size, Variant LastDone
    , Bit Done) DramAddressGen( MSB032 Address, MSB024 Nums, Bit Last
    , Bit Start, Bit Wait) ;  //_GUI 90,16
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 126,45
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 64,24
 Object ( MSB024 Out1, MSB024 Out2, MSB024 Out3) Junction
    ( MSB024 In0) ;  //_GUI 38,20
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 39,23
 Object ( Bit Q) StickyRegSync( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 83,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 76,26
 Object Output:D( Bit AXI_2_BlocksReadOverDone) ;  //_GUI 181,95
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit Q) StickyRegSync:A( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 86,110
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 157,93
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 169,95
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 122,94
 Object ( Bit Q) StickyRegSync:B( Bit D, Bit ClkG
    , Bit SCLR) ;  //_GUI 86,94
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 108,92
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 60,80
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 76,101
 Object ( Bit AXI_2_MASTER_ReadLast) Input:E;  //_GUI 53,80
 //_ Attributes Resource="Global",PromoteToParentObject="False"
 Object ( Bit AXIFIFOBusy2) Input:F;  //_GUI 114,46
 //_ Attributes Resource="Global",PromoteToParentObject="False"

 //_ Behavior Topology
 Output.0 = DramAddressGen.0;  
 Output:A.0 = DramAddressGen.1;  
 Output:B.0 = DramAddressGen.3;  
 Output:C.0 = StickyRegSync.0;  
 DramAddressGen.0 = Input.0;  
 DramAddressGen.1 = Junction.1;  
 DramAddressGen.2 = Junction:D.0;  //_GUI 61,24
 DramAddressGen.3 = Junction:A.1;  
 DramAddressGen.4 = OR.0;  //_GUI 137,33, 137,48
 OR.0 = Input:F.0;  
 OR.1 = Input:D.0;  
 AND.0 = NotZero.0;  
 AND.1 = Input:C.0;  //_GUI 64,117
 Junction.0 = Input:A.0;  
 NotZero.0 = Junction.2;  
 StickyRegSync.0 = Junction:A.2;  //_GUI 77,64
 StickyRegSync.2 = Junction:E.1;  //_GUI 77,70
 Junction:A.0 = AND.0;  
 Output:D.0 = Junction:B.1;  
 StickyRegSync:A.0 = Input:B.0;  
 StickyRegSync:A.2 = Junction:B.2;  //_GUI 77,118, 77,123, 170,123
 AND:A.0 = Junction:C.1;  
 AND:A.1 = StickyRegSync:A.0;  //_GUI 157,113
 Junction:B.0 = AND:A.0;  
 Junction:C.0 = AND:B.0;  
 StickyRegSync:B.0 = DramAddressGen.2;  //_GUI 82,96, 82,76, 148,76, 148,24
 StickyRegSync:B.2 = Junction:E.2;  
 AND:B.0 = Junction:D.1;  //_GUI 108,81
 AND:B.1 = StickyRegSync:B.0;  
 Junction:D.0 = Input:E.0;  
 Junction:E.0 = Junction:C.2;  //_GUI 77,108, 123,108
}

Object ( Bit Out1) One( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Bit"
{
 // One - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 47,30
 Object Output( Bit Out1) ;  //_GUI 64,37
 Object ( Bit In) Input:A;  //_GUI 47,37
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Floating Out1) One( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Floating"
{
 // One - Variant Select Case
 //
 // Date:
 // 11 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 9,29
 Object Output( Floating Out1) ;  //_GUI 104,29
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 45,32
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 41,14
 Object Text;  //_GUI 41,40,Mantissa is set to Zero.
 Object Text;  //_GUI 51,20,Exponent is bit pattern 01111...
 Object Text;  //_GUI 42,9,Sign is Zero
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 16,27
 Object ( Floating Out1) CollectFloating( Bit Sign, Variant BExp
    , Variant Mant) ;  //_GUI 87,27
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 55,24

 //_ Behavior Topology
 Output.0 = CollectFloating.0;  
 Zero.0 = ExposeFloating.2;  
 Zero:A.0 = ExposeFloating.0;  //_GUI 36,17, 36,29
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = Zero:A.0;  //_GUI 83,29, 83,17
 CollectFloating.1 = MakeBias.0;  //_GUI 80,32, 80,27
 CollectFloating.2 = Zero.0;  
 MakeBias.0 = ExposeFloating.1;  //_GUI 39,27, 39,32
}

Object ( Fixed Out1) One( Fixed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Fixed"
{
 // One - Variant Select Case
 //
 // Date:
 // 11 Nov  2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 12,19
 Object Output( Fixed Out1) ;  //_GUI 69,19
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 37,23
 Object Text;  //_GUI 38,34,Fraction portion is Zero.
 Object Text;  //_GUI 38,10,Whole portion is One
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 37,16
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 18,17
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 53,17

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 34,26, 34,22
 One.0 = ExposeFixed.0;  
 ExposeFixed.0 = Input.0;  
 CollectFixed.0 = One.0;  
 CollectFixed.1 = Zero.0;  //_GUI 50,22, 50,26
}

Object ( Signed Out1) One( Signed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Signed"
{
 // One - Signed case
 //
 // Date:
 // Added trap May 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 13,22
 Object Output( Signed Out1) ;  //_GUI 72,22
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 19,20
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 57,20
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 43,20
 Object ( Bit Out1) IsBit( Variant Type) ;  //_GUI 38,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,22
 Object Output:A( Bit Trap) ;  //_GUI 54,34
 //_ Attributes Trap="Signed dataset has sign bit only."

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = One.0;  
 One.0 = Junction.1;  
 IsBit.0 = Junction.2;  //_GUI 35,35
 Junction.0 = SignedIn.0;  
 Output:A.0 = IsBit.0;  
}

Object ( List Out1) One( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="List"
{
 // One - Variant Select Case
 //
 // Sets all Values in Vector to One.
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 10,20
 Object Output( List Out1) ;  //_GUI 64,20
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 17,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 50,18
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 34,24
 Object ( Variant Out1) One:A( Variant In1) ;  //_GUI 34,17

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = One.0;  //_GUI 47,23, 47,27
 ListOut.1 = One:A.0;  
 One.0 = ListIn.0;  //_GUI 31,27, 31,23
 One:A.0 = ListIn.1;  
}

Object ( Variant Out1) One( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps"
{
 // Polymorphic Constant One - will prodoce a logically correct one for any data set given on the input.
 //
 // Date:
 // 17 May 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 27,30
 Object Output( Variant Out1) ;  //_GUI 122,28
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 65,27
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 88,28
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 38,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 33,30
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 109,26
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 64,38

 //_ Behavior Topology
 Output.0 = Cast.0;  
 Zero.0 = VariantIn.1;  
 VariantOut.0 = One.0;  //_GUI 83,33, 83,41
 VariantOut.1 = Zero.0;  
 VariantIn.0 = Junction.1;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 105,28, 105,25, 34,25
 Cast.1 = VariantOut.0;  
 One.0 = VariantIn.0;  //_GUI 57,41, 57,33
}

Object ( Complex Out1) One( Complex In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Complex"
{
 // One - Variant Select Case
 //
 // Sets all Values in Vector to One.
 //
 // Date:
 // 11 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 13,16
 Object Output( Complex Out1) ;  //_GUI 75,16
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 40,13
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 40,22
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 19,14
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 56,14

 //_ Behavior Topology
 Output.0 = CollectComplex.0;  
 One.0 = ExposeComplex.0;  
 Zero.0 = ExposeComplex.1;  //_GUI 37,25, 37,19
 ExposeComplex.0 = Input.0;  
 CollectComplex.0 = One.0;  
 CollectComplex.1 = Zero.0;  //_GUI 54,19, 54,25
}

Object ( NULL Out1) One( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="NULL"
{
 // One - Variant Select Case
 //
 // Date:
 // 11 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,22
 Object Output( NULL Out1) ;  //_GUI 24,22

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) $BitLength( Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 23,16
 Object Output( Variant Out1) ;  //_GUI 57,23
 Object ( MSB032 In) Input:A;  //_GUI 24,23
 //_ Attributes PromoteToParentObject="False",Constant="$(NodeInfo:0:BitLen)"
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 37,21
 Object Text;  //_GUI 25,30,The Macro ##N2.B returns the bitlength of the Type input.  This is then filtered through a Min_Rep to trim the data set while removing leading 0s.

 //_ Behavior Topology
 Output.0 = Min_Rep.0;  
 Min_Rep.0 = Input:A.0;  
}

Object ( Bit Out1) $BitLength( Bit Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 23,16
 Object Output( Bit Out1) ;  //_GUI 44,22
 Object ( Bit In) Input:A;  //_GUI 36,22
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) XOR( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit/Bit"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 19,17
 Object ( Bit In2) Input:A;  //_GUI 19,28
 Object Output( Bit Out1) ;  //_GUI 86,19
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 37,16
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 74,17
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 37,24
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 49,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 28,17
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 31,28

 //_ Behavior Topology
 Output.0 = AND.0;  
 OR.0 = Junction.1;  
 OR.1 = Junction:A.0;  //_GUI 32,21
 AND.0 = OR.0;  
 AND.1 = INVERT.0;  //_GUI 65,22, 65,27
 AND:A.0 = Junction.2;  //_GUI 29,26
 AND:A.1 = Junction:A.1;  
 INVERT.0 = AND:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
}

Object ( Variant Out1) XOR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Note that there is a subtle difference between the behavior of XOR with a Var/NULL input and the InvertEn object with a NULL on Data and Bit on En.  An XOR with Var/NULL will pass through the Var where the InvertEn with a NULL Data and a Bit En will pass through the NULL.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,30
 Object ( Variant In2) Input:A;  //_GUI 13,33
 Object Output( Variant Out1) ;  //_GUI 64,31
 Object ( Variant Out1) $XOR( Variant In1, Variant In2) ;  //_GUI 44,29
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 23,29
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $XOR.0;  
 $XOR.0 = Symmetrize.0;  
 $XOR.1 = Symmetrize.1;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( List Out1) XOR( List In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List/List"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 31,28
 Object ( List In2) Input:A;  //_GUI 31,37
 Object Output( List Out1) ;  //_GUI 105,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,26
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 40,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 87,27
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 64,26
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 64,35
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 84,32, 84,38
 ListOut.1 = $XOR_SameLists.0;  
 $XOR_SameLists.0 = ListIn.1;  
 $XOR_SameLists.1 = ListIn:A.1;  //_GUI 62,31, 62,34, 55,34, 55,37
 $XOR_SameLists:A.0 = ListIn.0;  //_GUI 58,37, 58,31
 $XOR_SameLists:A.1 = ListIn:A.0;  
}

Object ( List Out1) XOR( List In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List/Variant"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 31,28
 Object ( Variant In2) Input:A;  //_GUI 31,39
 Object Output( List Out1) ;  //_GUI 101,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 64,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,26
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 83,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,39

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 XOR.0 = ListIn.1;  
 XOR.1 = Junction.0;  //_GUI 61,31
 XOR:A.0 = ListIn.0;  //_GUI 58,37, 58,31
 XOR:A.1 = Junction.1;  
 ListIn.0 = Input.0;  
 ListOut.0 = XOR:A.0;  //_GUI 80,32, 80,38
 ListOut.1 = XOR.0;  
 Junction.0 = Input:A.0;  
}

Object ( List Out1) XOR( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Variant/List"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 31,27
 Object ( List In2) Input:A;  //_GUI 31,37
 Object Output( List Out1) ;  //_GUI 101,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 64,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 83,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 57,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 XOR.0 = Junction.1;  
 XOR.1 = ListIn.1;  //_GUI 62,31, 62,34, 55,34, 55,37
 XOR:A.0 = Junction.2;  //_GUI 58,37
 XOR:A.1 = ListIn.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = XOR:A.0;  //_GUI 80,32, 80,38
 ListOut.1 = XOR.0;  
 Junction.0 = Input.0;  
}

Object ( Variant Out1) XOR( Bit In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="bit/var"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,28
 Object ( Variant In2) Input:A;  //_GUI 12,35
 Object Output( Variant Out1) ;  //_GUI 83,31
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 46,27
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 24,33
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 58,31
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 71,29
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 46,33
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 19,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 40,28

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 XOR.0 = Junction:A.1;  
 XOR.1 = VariantIn.1;  //_GUI 37,32, 37,35
 VariantIn.0 = Junction.1;  
 VariantOut.0 = XOR:A.0;  
 VariantOut.1 = XOR.0;  //_GUI 58,32, 56,32
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction.0;  //_GUI 71,23, 20,23
 XOR:A.0 = Junction:A.2;  //_GUI 41,35
 XOR:A.1 = VariantIn.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
}

Object ( Variant Out1) XOR( Variant In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="var/bit"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,30
 Object ( Bit In2) Input:A;  //_GUI 12,35
 Object Output( Variant Out1) ;  //_GUI 91,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 54,25
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 24,28
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 66,29
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 54,31
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 47,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 19,30
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 79,27

 //_ Behavior Topology
 Output.0 = Cast.0;  
 XOR.0 = VariantIn.1;  //_GUI 42,27, 42,30
 XOR.1 = Junction.0;  //_GUI 48,30
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = XOR:A.0;  
 VariantOut.1 = XOR.0;  //_GUI 66,30, 64,30
 XOR:A.0 = VariantIn.0;  
 XOR:A.1 = Junction.1;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 79,19, 20,19
 Cast.1 = VariantOut.0;  
}

Object ( Variant Out1) XOR( Variant In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Var/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) XOR( NULL In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Null/Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Variant In2) Input:A;  //_GUI 21,22
 Object Output( Variant Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( NULL Out1) XOR( NULL In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Null/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( NULL Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) XOR( List In2, Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List\\Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Bit In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = XOR:A.0;  //_GUI 65,29, 65,32
 ListOut.1 = XOR.0;  //_GUI 66,26, 66,23
 XOR.0 = ListIn.1;  
 XOR.1 = Junction.0;  //_GUI 46,25
 XOR:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 XOR:A.1 = Junction.1;  
}

Object ( List Out1) XOR( Bit In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = XOR:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = XOR.0;  
 XOR.0 = Junction.1;  
 XOR.1 = ListIn.1;  //_GUI 41,21, 41,26
 XOR:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 XOR:A.1 = ListIn.0;  
}

Object ( Bit Out1) XOR( Bit In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Bit Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) XOR( NULL In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Null/Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Bit In2) Input:A;  //_GUI 21,22
 Object Output( Bit Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) CollectBIN( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out"
{
 // Collects inputs into a BIN data set
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,34
 Object ( Variant In2) Input:A;  //_GUI 26,38
 Object ( Variant In3) Input:B;  //_GUI 26,41
 Object Output( Variant Out1) ;  //_GUI 71,35
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) ;  //_GUI 34,37
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2) ;  //_GUI 48,33

 //_ Behavior Topology
 Output.0 = CollectBIN:A.0;  
 CollectBIN.0 = Input:A.0;  
 CollectBIN.1 = Input:B.0;  
 CollectBIN:A.0 = Input.0;  
 CollectBIN:A.1 = CollectBIN.0;  //_GUI 47,38, 47,40
}

Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating
    ( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Async\\Advanced",Documentation="with NaN"
{
 // This object exposes the Sign portion, the Biased Exponent portion and the Mantissa (high bit implied) portion of a value from a Floating dataset.
 //
 // Inputs:
 //
 // Floating Floating: The Floating value to expose.
 //
 // Outputs:
 //
 // Variant Sign: The sign bit.
 //
 // Variant BExp: The biased exponent.
 //
 // Variant Exp: The unbiased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Variant IMant: The mantissa (or significand) with the most significant bit (the implied bit).
 //
 // Bit Zero: The input value is a zero (positive or negative)
 //
 // Bit Denormalized: The input value is denormalized (BExp = 0 & Mant != 0)
 //
 // Bit Infinity: The input value is positive or negative infinity (BExp = AllHigh & Mant = 0)
 //
 // Bit QNaN: Quiet Not a Number (BExp = AllHigh & MSB(Mant) = 1)
 //
 // Bit SNaN: Signaled Not a Number (BExp = AllHigh & MSB(Mant) = 0 & Mant != 0)
 //
 // Bit NaN: Either QNaN or SnaN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 11,20
 Object Output( Bit Sign) ;  //_GUI 116,6
 Object Output:A( Variant BExp) ;  //_GUI 116,11
 Object Output:B( Variant Exp) ;  //_GUI 144,18
 Object Output:C( Variant Mant) ;  //_GUI 146,22
 Object Output:D( Variant IMant) ;  //_GUI 140,29
 Object Output:E( Bit Zero) ;  //_GUI 129,39
 Object Output:F( Bit Denormalized) ;  //_GUI 118,57
 Object Output:G( Bit Infinity) ;  //_GUI 118,63
 Object Output:H( Bit QNaN) ;  //_GUI 134,79
 Object Output:I( Bit SNaN) ;  //_GUI 135,91
 Object Output:J( Bit NaN) ;  //_GUI 135,99
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 35,18
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 49,11
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out11) ExposeMSB:A( Variant In1) ;  //_GUI 55,80
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 66,15
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 125,97
 Object Text;  //_GUI 131,10,(Biased exponent)
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 111,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 97,38
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 93,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 66,38
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 67,69
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 75,90
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 71,36
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 75,47
 Object Text;  //_GUI 15,110,Infinity = all the exponent bits high and the significand bits lowNaN = QNaN or SNaNQNaN = all the exponent bits high and the MSB significand bit highSNaN = all the exponent bits high and the MSB significand bit low (other significand bits high)Zero = all bits low, not counting the sign bit
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 92,49
 Object ( Bit Out1) EqualZero:B( Variant In1) ;  //_GUI 77,69
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 90,71
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In1) ;  //_GUI 51,49
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 95,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 117,79
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 91,88
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In1) ;  //_GUI 90,78
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 120,91
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 74,81
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In1) ;  //_GUI 92,56
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 104,89
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 75,97
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 17,18
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 67,4
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 127,27
 Object ( Bit OFL, Variant Out1) RemoveBias( Variant In1) ;  //_GUI 100,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 91,15
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 98,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:M
    ( Variant In1) ;  //_GUI 51,31
 Object ( Variant Out1) AND:E( Variant In1, Variant In2) ;  //_GUI 132,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In0) ;  //_GUI 118,28

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = Junction:L.0;  //_GUI 92,12
 Output:B.0 = AND:E.0;  
 Output:C.0 = Junction.1;  
 Output:D.0 = PushMsb.0;  
 Output:E.0 = AND.0;  
 Output:F.0 = Junction:B.2;  //_GUI 98,58
 Output:G.0 = AND:A.0;  
 Output:H.0 = Junction:G.1;  
 Output:I.0 = Junction:I.1;  
 Output:J.0 = OR.0;  
 ListIn.0 = FloatingIn.0;  
 ExposeMSB.0 = ListIn.1;  //_GUI 46,14
 ExposeMSB:A.0 = Junction:F.2;  //_GUI 52,83
 Junction.0 = ListIn.0;  
 Junction:A.0 = ExposeMSB.1;  
 OR.0 = Junction:I.2;  //_GUI 121,99
 OR.1 = Junction:G.2;  //_GUI 118,102
 AND.0 = Junction:B.1;  
 AND.1 = Junction:D.1;  //_GUI 111,50
 Junction:B.0 = EqualZero.0;  
 AND:A.0 = Junction:K.2;  
 AND:A.1 = Junction:E.0;  //_GUI 91,66
 Junction:C.0 = Junction:A.2;  
 INVERT.0 = Junction:C.2;  
 INVERT:A.0 = Junction:J.2;  
 EqualZero.0 = Junction:C.1;  
 EqualZero:A.0 = Junction:F.1;  
 Junction:D.0 = EqualZero:A.0;  
 EqualZero:B.0 = INVERT.0;  
 Junction:E.0 = EqualZero:B.0;  
 Junction:F.0 = Junction:M.2;  
 AND:B.0 = Junction:H.1;  
 AND:B.1 = Junction:J.1;  
 Junction:G.0 = AND:B.0;  
 AND:C.0 = Junction:H.2;  
 AND:C.1 = INVERT:A.0;  
 Junction:H.0 = Junction:E.2;  
 Junction:I.0 = AND:D.0;  
 Junction:J.0 = ExposeMSB:A.0;  
 Junction:K.0 = Junction:D.2;  
 AND:D.0 = AND:C.0;  
 AND:D.1 = INVERT:B.0;  //_GUI 104,100
 INVERT:B.0 = Junction:K.0;  //_GUI 46,100, 46,57
 FloatingIn.0 = Input.0;  
 $Cast.0 = ExposeMSB.0;  //_GUI 63,9, 63,13
 PushMsb.0 = Junction:N.1;  
 PushMsb.1 = Junction:M.1;  
 RemoveBias.0 = Junction:L.1;  
 Junction:L.0 = Junction:A.1;  
 INVERT:C.0 = Junction:B.0;  
 Junction:M.0 = Junction.2;  
 AND:E.0 = RemoveBias.1;  
 AND:E.1 = Junction:N.0;  //_GUI 119,21
 Junction:N.0 = INVERT:C.0;  
}

Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\PackMSB",Icon="Exposer_Out"
{
 // Packs input elements into an MSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,16
 Object ( Variant In2) Input:A;  //_GUI 14,22
 Object ( Variant In3) Input:B;  //_GUI 14,25
 Object ( Variant In4) Input:C;  //_GUI 14,28
 Object Output( List Out1) ;  //_GUI 63,17
 Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 28,21
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 49,15

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackMSB.0 = Input:A.0;  
 PackMSB.1 = Input:B.0;  
 PackMSB.2 = Input:C.0;  
 ListOut.0 = PackMSB.0;  //_GUI 43,20, 43,24
 ListOut.1 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\UnPackMSB",Icon="Exposer_In"
{
 // Unpacks an MSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,24
 Object Output( Variant Out1) ;  //_GUI 65,23
 Object Output:A( Variant Out2) ;  //_GUI 65,28
 Object Output:B( Variant Out3) ;  //_GUI 65,31
 Object Output:C( Variant Out4) ;  //_GUI 65,34
 Object ( Variant Out1, Variant Out2) UnPackMSB( Variant In1) ;  //_GUI 28,22
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackMSB:A
    ( Variant In1) ;  //_GUI 46,27

 //_ Behavior Topology
 Output.0 = UnPackMSB.0;  
 Output:A.0 = UnPackMSB:A.0;  
 Output:B.0 = UnPackMSB:A.1;  
 Output:C.0 = UnPackMSB:A.2;  
 UnPackMSB.0 = Input.0;  
 UnPackMSB:A.0 = UnPackMSB.1;  //_GUI 46,27
}

Object ( Bit LastDone, Bit Done, Bit Busy) DoneForN
    ( Variant Iterations, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers"
{
 // Produces N Dones for every one Go.  Uses the standard GDBW model.  Larger iterations at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant Iterations: This value indicates the number of iterations or Dones to produce for every
 // Go.  A Go with an Iterations value of 0 will produce no Done at all.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit Go: Go.  Start producing N Dones.
 //
 // Bit Wait: Wait. Has a value of 0 if disconnected.  Holds off the Dones
 //
 // Outputs:
 //
 // Bit LastDone Indicates when the last Done is occurring.
 //
 // Bit Done: Done.  N of these are produced for every Go.
 //
 // Bit Busy: Busy.  Tells Go to hold off.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Iterations) Input;  //_GUI 15,14
 Object ( Bit ClkG) Input:A;  //_GUI 15,17
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 15,20
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 15,23
 Object ( Bit Wait) Input:D;  //_GUI 35,35
 //_ Attributes Constant="0"
 Object Output( Bit LastDone) ;  //_GUI 41,17
 Object Output:A( Bit Done) ;  //_GUI 41,23
 Object Output:B( Bit Busy) ;  //_GUI 21,31
 Object ( Variant Iteration, Bit LastDone, Bit Active
    , Bit Done, Bit Busy) DoneForN_Down( Variant Iterations, Bit ClkG
    , Bit CLR, Bit Go, Bit Wait) ;  //_GUI 21,13

 //_ Behavior Topology
 Output.0 = DoneForN_Down.1;  
 Output:A.0 = DoneForN_Down.3;  
 Output:B.0 = DoneForN_Down.4;  
 DoneForN_Down.0 = Input.0;  
 DoneForN_Down.1 = Input:A.0;  
 DoneForN_Down.2 = Input:B.0;  
 DoneForN_Down.3 = Input:C.0;  
 DoneForN_Down.4 = Input:D.0;  
}

Object ( Variant Out1) "2^N_List"( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Takes in a list of any order and adds zeroed MSB elements on the MSB end until there are two to the power of N elements.  The list is output in LSB order.  If the input is a single element list (a variant) then the output is the same.  This is because 1 = 2^N where N = 0.
 //
 // Inputs:
 //
 // Variant input: The input list.
 //
 // Outputs:
 //
 // Variant output: The output list where the number of elements is rounded up to the nearest two to the N elements by adding zeroed elements of the MSB element of the input list onto the MSB end of the output list which is put into LSB order.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 10,14
 Object Output( Variant Out1) ;  //_GUI 39,14
 Object ( Variant Out1) "2^N_LSBList"( List In1) ;  //_GUI 21,12
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = "2^N_LSBList".0;  
 "2^N_LSBList".0 = Input.0;  
}

Object ( Variant Out1) "2^N_List"( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // Takes in a list of any order and adds zeroed MSB elements on the MSB end until there are two to the power of N elements.  The list is output in LSB order.  If the input is a single element list (a variant) then the output is the same.  This is because 1 = 2^N where N = 0.
 //
 // Inputs:
 //
 // Variant input: The input list.
 //
 // Outputs:
 //
 // Variant output: The output list where the number of elements is rounded up to the nearest two to the N elements by adding zeroed elements of the MSB element of the input list onto the MSB end of the output list which is put into LSB order.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 12,24
 Object Output( Variant Out1) ;  //_GUI 41,24
 Object Text;  //_GUI 13,7,A Variant input means this is a single element list.  A single element list has 2^N elements where N is 0. Therefore just pass the single element list through.  If you want at least 2 elements, call 2MinList afterwords.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Size) ListSize( Variant List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object returns the number of elements in the list as the number of bits in the output dataset.
 //
 // Note:  Lists can have elements of NULL, which will be counted the same as any other element.  There is an ambiguity between an empty list (NULL) and a single element list where the element is NULL. Both cases will be counted as having 0 elements.
 //
 // Inputs:
 //
 // Variant List: The list to size.
 //
 // Outputs:
 //
 // Variant Size: The number of bits in this LSBxxx dataset represents the number of elements in the input List.  This output could also be a Bit if the input is a single element list (a Variant).  This output could also be a NULL (zero bits) if the input is an empty list (a NULL).  This output has the value of zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 11,16
 Object Output( Variant Size) ;  //_GUI 35,16
 Object ( Bit In) Input:A;  //_GUI 27,16
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Size) ListSize( List List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="List"
{
 // This object returns the number of elements in the list as the number of bits in the output dataset.
 //
 // Note:  Lists can have elements of NULL, which will be counted the same as any other element.  There is an ambiguity between an empty list (NULL) and a single element list where the element is NULL. Both cases will be counted as having 0 elements.
 //
 // Inputs:
 //
 // Variant List: The list to size.
 //
 // Outputs:
 //
 // Variant Size: The number of bits in this LSBxxx dataset represents the number of elements in the input List.  This output could also be a Bit if the input is a single element list (a Variant).  This output could also be a NULL (zero bits) if the input is an empty list (a NULL).  This output has the value of zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 18,24
 Object Output( Variant Size) ;  //_GUI 89,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 62,22
 Object Text;  //_GUI 27,37,This object returns a data set with as many bits as the List has elements.
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 76,22
 Object ( Variant Size) $ListSize( Variant List) ;  //_GUI 47,16
 //_ Attributes Documentation="List"
 Object ( Variant Size) $ListSize:A( Variant List) ;  //_GUI 46,24
 //_ Attributes Documentation="List"
 Object Text;  //_GUI 27,45,We have the $ListSize layer so we can distinguish empty elements (and count them) from empty lists (and not count them).

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $ListSize:A.0;  
 ListOut.1 = $ListSize.0;  //_GUI 57,24
 LSB.0 = ListOut.0;  
 $ListSize.0 = ListIn.1;  //_GUI 44,19, 44,24
 $ListSize:A.0 = ListIn.0;  
}

Object ( NULL Size) ListSize( NULL List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object returns the number of elements in the list as the number of bits in the output dataset.
 //
 // Note:  Lists can have elements of NULL, which will be counted the same as any other element.  There is an ambiguity between an empty list (NULL) and a single element list where the element is NULL. Both cases will be counted as having 0 elements.
 //
 // Inputs:
 //
 // Variant List: The list to size.
 //
 // Outputs:
 //
 // Variant Size: The number of bits in this LSBxxx dataset represents the number of elements in the input List.  This output could also be a Bit if the input is a single element list (a Variant).  This output could also be a NULL (zero bits) if the input is an empty list (a NULL).  This output has the value of zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL List) Input;  //_GUI 13,21
 Object Output( NULL Size) ;  //_GUI 40,21
 Object Text;  //_GUI 14,27,Assume this is an empty list.  In doing so we won't detect a single emenemt list where the element is a NULL

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Num) MaskToNum( Variant Mask) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal"
{
 // This object replaces the traditional EncodeRev object.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Mask) Input;  //_GUI 45,20
 Object Output( Variant Num) ;  //_GUI 168,21
 Object Text;  //_GUI 11,71,uint32_t HcGetPeNumFromMask(uint32_t peMask){      int x;      for(x = 0; x < sizeof(peMask)*8; x++)                 if ( (1<<x) & peMask) return(x);      return(NO_PE);}
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 76,18
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 152,19
 Object Text;  //_GUI 44,4,We begin by converting our bits to a BIN type, whose bitlength is an exact power of 2.
 Object Text;  //_GUI 102,51,At each step of the recursion, we break the BIN type in half and determine  one bit at a time of our output data set beginning with the most-significant.  At each stage of the recursion, the top bit will be set to 1 if the top-half of the BIN data set contains the 1 we are searching for.
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 108,23
 Object ( Bit In) Input:A;  //_GUI 114,35
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 107,19
 Object ( Variant Out1) $MaskToNum( Variant Data, Variant Lower) ;  //_GUI 128,18
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $MaskToNum:A( Variant Data, Variant Lower) ;  //_GUI 125,31
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) "Pad2^N"( Variant In1) ;  //_GUI 52,18

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = "Pad2^N".0;  
 OR.0 = $MaskToNum.0;  
 OR.1 = $MaskToNum:A.0;  //_GUI 145,24, 145,34
 NotZero.0 = Junction.2;  
 Junction.0 = VariantIn.1;  
 $MaskToNum.0 = Junction.1;  
 $MaskToNum.1 = NotZero.0;  //_GUI 125,23, 125,26
 $MaskToNum:A.0 = VariantIn.0;  //_GUI 99,33, 99,23
 $MaskToNum:A.1 = Input:A.0;  
 "Pad2^N".0 = Input.0;  
}

Object ( NULL Num) MaskToNum( Bit Mask) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Mask) Input;  //_GUI 45,20
 Object Output( NULL Num) ;  //_GUI 82,23
 Object Text;  //_GUI 49,31,If the Encode receives only one input bit, the value can only be zero. This is NULL to give symmetry to the numToMask operation.
 Object ( NULL Out1) NULL;  //_GUI 64,21

 //_ Behavior Topology
 Output.0 = NULL.0;  
}

Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,25
 Object ( Variant Sel) Input:A;  //_GUI 15,41
 Object Output( Variant Data) ;  //_GUI 132,32
 Object ( Variant Hi, Variant Lo) Bisect( Variant In1) ;  //_GUI 47,23
 //_ Attributes Documentation="zterm"
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 86,29
 Object ( Variant MSB, Variant Out1) PopMsb( Variant In1) ;  //_GUI 62,39
 //_ Attributes Documentation="zterm"
 Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 104,30
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $List_Mux_Sel.0;  
 Bisect.0 = Input.0;  
 Mux.0 = Bisect.1;  //_GUI 86,28
 Mux.1 = Bisect.0;  //_GUI 66,34, 66,25
 Mux.2 = PopMsb.0;  //_GUI 86,41
 PopMsb.0 = Input:A.0;  
 $List_Mux_Sel.0 = Mux.0;  
 $List_Mux_Sel.1 = PopMsb.1;  //_GUI 104,44
}

Object ( Variant Data) $List_Mux_Sel( Variant ListData, NULL Sel) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,25
 Object ( NULL Sel) Input:A;  //_GUI 15,41
 Object Output( Variant Data) ;  //_GUI 131,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) 2MinList( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 // Makes the list at least 2 elements long.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 25,25
 Object Output( List Out1) ;  //_GUI 60,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 47,21
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 35,20
 //_ Attributes Documentation="ztlist"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,25
 Object Text;  //_GUI 23,7,A variant is a single element list.  Make it a 2 element list by adding an element (of the same dataset) on the most significant end with a value of zero

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Junction.1;  
 ListOut.1 = Zero.0;  
 Zero.0 = Junction.0;  //_GUI 32,23
 Junction.0 = Input.0;  
}

Object ( List Out1) 2MinList( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Makes the list at least 2 elements long.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 25,25
 Object Output( List Out1) ;  //_GUI 60,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 47,21
 Object Text;  //_GUI 23,7,A NULL is a 0 element list.  We don't know the original dataset of the list, so just pick a bit. Make it a 2 element list by adding two elements.
 Object ( Bit In) Input:A;  //_GUI 37,22
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 43,22

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Junction.2;  //_GUI 44,26
 ListOut.1 = Junction.1;  
 Junction.0 = Input:A.0;  
}

Object ( List Out1) 2MinList( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Makes the list at least 2 elements long.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 27,23
 Object Output( List Out1) ;  //_GUI 60,23
 Object Text;  //_GUI 26,10,A list dataset is guaranteed to have at least two elements, so, do nothing to it.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant MSB, Variant Out2) PopMsb( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="list"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 36,18
 Object Output:A( Variant Out2) ;  //_GUI 36,21
 Object ( Variant MSB, Variant Out2) ListPopMsb( Variant In1) ;  //_GUI 21,17
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListPopMsb.0;  
 Output:A.0 = ListPopMsb.1;  
 ListPopMsb.0 = Input.0;  
}

Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 48,18
 Object Output:A( Variant Out2) ;  //_GUI 48,21
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 23,17
 //_ Attributes Documentation="Error"

 //_ Behavior Topology
 Output.0 = ExposeMSB.0;  
 Output:A.0 = ExposeMSB.1;  
 ExposeMSB.0 = Input.0;  
}

Object ( Bit MSB, NULL Out1) PopMsb( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="bit"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 15,19
 Object Output( Bit MSB) ;  //_GUI 39,10
 Object Output:A( NULL Out1) ;  //_GUI 39,17
 Object ( NULL Out1) NULL;  //_GUI 27,15

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 23,11, 23,20
 Output:A.0 = NULL.0;  
}

Object ( NULL MSB, NULL Out1) PopMsb( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,17
 Object Output( NULL MSB) ;  //_GUI 39,10
 Object Output:A( NULL Out1) ;  //_GUI 39,17
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 22,17

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 23,11
 Output:A.0 = Junction.1;  
 Junction.0 = Input.0;  
}

Object ( Variant Out1) PushMsb( Variant MSB, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 25,24
 Object ( NULL In2) Input:A;  //_GUI 25,31
 Object Output( Variant Out1) ;  //_GUI 82,24

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 17,12
 Object ( Variant In2) Input:A;  //_GUI 17,15
 Object Output( Variant Out1) ;  //_GUI 54,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 27,11
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 41,11

 //_ Behavior Topology
 Output.0 = MSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 MSB.0 = ListOut.0;  
}

Object ( List Out1) PushMsb( Variant MSB, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/list"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 27,24
 Object ( List In2) Input:A;  //_GUI 27,27
 Object Output( List Out1) ;  //_GUI 83,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 66,23
 Object ( List MsbList) MsbList( List AnyList) ;  //_GUI 37,25
 //_ Attributes Documentation="list"
 Object Text;  //_GUI 28,36,If MSB input is a list, this will put that as the most signficant element of the AnyList. This object always outputs an MSB ordered list on the top level. If you want this to concatenate two lists and give a single list output, call Msb_List instead. For doing multiddimensionial lists, use the ZTList operators instead.

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = MsbList.0;  
 ListOut.1 = Input.0;  
 MsbList.0 = Input:A.0;  
}

Object ( Variant Out1) PushMsb( NULL MSB, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL MSB) Input;  //_GUI 25,24
 Object ( Variant In2) Input:A;  //_GUI 25,31
 Object Output( Variant Out1) ;  //_GUI 82,24
 Object Text;  //_GUI 28,41,Adding no MSB bits to, say, an MSB005 will result in no change to the original data set.

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 56,25, 56,32
}

Object ( NULL Out1) PushMsb( NULL MSB, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL MSB) Input;  //_GUI 25,24
 Object ( NULL In2) Input:A;  //_GUI 25,31
 Object Output( NULL Out1) ;  //_GUI 82,24

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit CO, Bit S) $$ADSU( Bit A
    , Bit B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 14,20
 Object ( Bit B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,26
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,29
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 50,20
 Object Output:A( Bit S) ;  //_GUI 50,23
 Object ( Variant CO, Variant S) $$ADSU_logic( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 21,19
 //_ Attributes Documentation="bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 38,18
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 38,21

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = VouchBit:A.0;  
 $$ADSU_logic.0 = Input.0;  
 $$ADSU_logic.1 = Input:A.0;  
 $$ADSU_logic.2 = Input:B.0;  
 $$ADSU_logic.3 = Input:C.0;  
 VouchBit.0 = $$ADSU_logic.0;  
 VouchBit:A.0 = $$ADSU_logic.1;  
}

Object ( Bit CO, Variant S) $$ADSU( Variant A
    , Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,32
 Object ( Variant B) Input:A;  //_GUI 23,40
 Object ( Bit ADD) Input:B;  //_GUI 26,46
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 27,52
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 145,24
 Object Output:A( Variant S) ;  //_GUI 145,42
 Object ( Variant Out1) $Cast( Variant Data, Variant Type) ;  //_GUI 131,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 33,30
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 110,42
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 33,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 71,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,32
 Object ( Variant CO, Variant S) $$ADSU( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,42
 //_ Attributes Documentation="bit"
 Object ( Variant CO, Variant S) $$ADSU:A( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,23
 //_ Attributes Documentation="bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 128,22

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = $Cast.0;  
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction:A.0;  //_GUI 125,42, 125,19, 30,19
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $$ADSU.1;  
 VariantOut.1 = $$ADSU:A.1;  //_GUI 110,28
 VariantIn:A.0 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 $$ADSU.0 = VariantIn.0;  //_GUI 79,44, 79,35
 $$ADSU.1 = VariantIn:A.0;  //_GUI 76,47, 76,43
 $$ADSU.2 = Junction.2;  //_GUI 72,50
 $$ADSU.3 = Input:C.0;  
 $$ADSU:A.0 = VariantIn.1;  //_GUI 66,25, 66,32
 $$ADSU:A.1 = VariantIn:A.1;  //_GUI 69,28, 69,40
 $$ADSU:A.2 = Junction.0;  //_GUI 72,31
 $$ADSU:A.3 = $$ADSU.0;  //_GUI 83,39, 93,39
 VouchBit.0 = $$ADSU:A.0;  
}

Object ( NULL CO, NULL S) $$ADSU( NULL A
    , NULL B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 14,17
 Object ( NULL B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( NULL CO) ;  //_GUI 124,17
 Object Output:A( NULL S) ;  //_GUI 124,23

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit O) $Mux( Bit A, Bit B
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="Bit"
{
 // Mux - Variant Select Case
 //
 // Date:
 // 07 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 9,12
 Object ( Bit B) Input:A;  //_GUI 9,21
 Object ( Bit S) Input:B;  //_GUI 9,24
 Object Output( Bit O) ;  //_GUI 78,14
 Object ( Bit Out1) INVERT( Bit In1) ;  //_GUI 22,15
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 45,11
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 46,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 19,24
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 61,12

 //_ Behavior Topology
 Output.0 = OR.0;  
 INVERT.0 = Junction.0;  //_GUI 20,18
 AND.0 = Input.0;  
 AND.1 = INVERT.0;  //_GUI 40,16, 40,18
 AND:A.0 = Input:A.0;  
 AND:A.1 = Junction.1;  
 Junction.0 = Input:B.0;  
 OR.0 = AND.0;  
 OR.1 = AND:A.0;  //_GUI 61,20, 56,20
}

Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="Variant"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,23
 Object ( Variant B) Input:A;  //_GUI 22,31
 Object ( Bit S) Input:B;  //_GUI 22,39
 Object Output( Variant O) ;  //_GUI 120,22
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 34,21
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 88,22
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 34,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 61,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 106,20
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 66,21
 //_ Attributes Documentation="Variant"
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 66,32
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $Mux:A.0;  //_GUI 82,27, 82,35
 VariantOut.1 = $Mux.0;  
 VariantIn:A.0 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 103,22, 103,19, 30,19
 Cast.1 = VariantOut.0;  
 $Mux.0 = VariantIn.1;  
 $Mux.1 = VariantIn:A.1;  //_GUI 57,26, 57,31
 $Mux.2 = Junction.0;  //_GUI 62,29
 $Mux:A.0 = VariantIn.0;  //_GUI 54,34, 54,26
 $Mux:A.1 = VariantIn:A.0;  //_GUI 50,37, 50,34
 $Mux:A.2 = Junction.1;  
}

Object ( NULL O) $Mux( NULL A, NULL B
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="NULL"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 22,22
 Object ( NULL B) Input:A;  //_GUI 22,31
 Object ( Bit S) Input:B;  //_GUI 22,39
 Object Output( NULL O) ;  //_GUI 120,22

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Var"
{
 // Date:
 // 8/9/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Context) Input;  //_GUI 32,21
 Object ( Variant Data) Input:A;  //_GUI 32,33
 Object Output( Variant Data) ;  //_GUI 142,20
 Object Output:A( Variant Context) ;  //_GUI 142,29
 Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) ;  //_GUI 93,19
 //_ Attributes Documentation="Leaf"
 Object ( Variant Data, Variant Context) $Context:A( Variant Context
    , Variant Data) ;  //_GUI 61,29
 //_ Attributes Documentation="Leaf"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 42,19
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 112,29
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 127,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 38,21

 //_ Behavior Topology
 Output.0 = $Context.0;  
 Output:A.0 = Cast.0;  
 $Context.0 = VariantIn.1;  
 $Context.1 = $Context:A.0;  //_GUI 81,24, 81,31
 $Context:A.0 = VariantIn.0;  //_GUI 56,31, 56,24
 $Context:A.1 = Input:A.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = $Context:A.1;  
 VariantOut.1 = $Context.1;  //_GUI 110,31, 110,24
 Cast.0 = Junction.0;  //_GUI 127,15, 39,15
 Cast.1 = VariantOut.0;  
 Junction.0 = Input.0;  
}

Object ( Variant Data, List Context) $Context( List Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="List"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Context) Input;  //_GUI 34,21
 Object ( Variant Data) Input:A;  //_GUI 34,33
 Object Output( Variant Data) ;  //_GUI 127,20
 Object Output:A( List Context) ;  //_GUI 128,31
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 42,19
 Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) ;  //_GUI 93,19
 //_ Attributes Documentation="Leaf"
 Object ( Variant Data, Variant Context) $Context:A( Variant Context
    , Variant Data) ;  //_GUI 61,29
 //_ Attributes Documentation="Leaf"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 112,29

 //_ Behavior Topology
 Output.0 = $Context.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 $Context.0 = ListIn.1;  
 $Context.1 = $Context:A.0;  //_GUI 81,24, 81,31
 $Context:A.0 = ListIn.0;  //_GUI 56,31, 56,24
 $Context:A.1 = Input:A.0;  
 ListOut.0 = $Context:A.1;  
 ListOut.1 = $Context.1;  //_GUI 110,31, 110,24
}

Object ( Variant Data, Variant Context) $Context( Bit Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Bit"
{
 // Date:
 // 08/09/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Context) Input;  //_GUI 28,24
 Object ( Variant Data) Input:A;  //_GUI 28,29
 Object Output( Variant Data) ;  //_GUI 68,21
 Object Output:A( Variant Context) ;  //_GUI 68,24
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 43,20

 //_ Behavior Topology
 Output.0 = Lo_N.0;  
 Output:A.0 = Lo_N.1;  
 Lo_N.0 = Input:A.0;  //_GUI 40,22, 40,30
 Lo_N.1 = Input.0;  
}

Object ( Variant Data, Floating Context) $Context( Floating Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Context) Input;  //_GUI 39,20
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 157,16
 Object Output:A( Floating Context) ;  //_GUI 157,20
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 63,18
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 106,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 128,18
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 142,18
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Floating Number.  Our goal is to recreate a Contextual Floating out of these bits.  We begin by taking off the bottom N bits, where N is the bitlength of our Mantissa.  We then take off the next M bits, where M is the bitlength of the Characteristic.  This step is necessary just in case any leading 0s were added the context-free data set.Arial,9,0,0
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 48,18

 //_ Behavior Topology
 Output.0 = Lo_N:A.0;  
 Output:A.0 = FloatingOut.0;  
 ListIn.0 = FloatingIn.0;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = ListIn.0;  //_GUI 79,37, 79,23
 Lo_N:A.0 = Lo_N.0;  //_GUI 102,17, 102,34
 Lo_N:A.1 = ListIn.1;  
 ListOut.0 = Lo_N.1;  //_GUI 118,23, 118,37
 ListOut.1 = Lo_N:A.1;  
 FloatingOut.0 = ListOut.0;  
 FloatingIn.0 = Input.0;  
}

Object ( Variant Data, Fixed Context) $Context( Fixed Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Fixed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Context) Input;  //_GUI 39,20
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 157,16
 Object Output:A( Fixed Context) ;  //_GUI 157,20
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 106,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 128,18
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Fixed Number.  Our goal is to recreate a Contextual Fixed out of these bits.  We begin by taking off the bottom N bits, where N is the bitlength of our fractional portion.  We then take off the next M bits, where M is the bitlength of the whole portion.  This step is necessary just in case any leading 0s were added the context-free data set.Arial,9,0,0
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 48,18
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 143,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 63,18

 //_ Behavior Topology
 Output.0 = Lo_N:A.0;  
 Output:A.0 = FixedOut.0;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = ListIn.0;  //_GUI 79,37, 79,23
 Lo_N:A.0 = Lo_N.0;  //_GUI 102,17, 102,34
 Lo_N:A.1 = ListIn.1;  
 ListOut.0 = Lo_N.1;  //_GUI 118,23, 118,37
 ListOut.1 = Lo_N:A.1;  
 FixedIn.0 = Input.0;  
 FixedOut.0 = ListOut.0;  
 ListIn.0 = FixedIn.0;  
}

Object ( Variant Data, Complex Context) $Context( Complex Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex Context) Input;  //_GUI 39,20
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 181,16
 Object Output:A( Complex Context) ;  //_GUI 181,20
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 106,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 145,18
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Complex Number.  Our goal is to recreate a Contextual Complex out of these bits.  We begin by taking off the bottom N bits, where N is the bitlength of our imaginary portion.  We then take off the next M bits, where M is the bitlength of the real portion.  This step is necessary just in case any leading 0s were added the context-free data set.Arial,9,0,0
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 48,18
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 161,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 63,18
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 128,32
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 78,29
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 122,22
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 90,19

 //_ Behavior Topology
 Output.0 = Lo_N:A.0;  
 Output:A.0 = ComplexOut.0;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = Junction.2;  //_GUI 79,37
 Lo_N:A.0 = Lo_N.0;  //_GUI 102,17, 102,34
 Lo_N:A.1 = Junction:A.1;  
 ListOut.0 = Context.0;  //_GUI 138,23
 ListOut.1 = Context:A.0;  //_GUI 132,20
 ComplexIn.0 = Input.0;  
 ComplexOut.0 = ListOut.0;  
 ListIn.0 = ComplexIn.0;  
 Context.0 = Junction.1;  //_GUI 128,30
 Context.1 = Lo_N.1;  
 Junction.0 = ListIn.0;  //_GUI 79,23
 Context:A.0 = Junction:A.2;  //_GUI 91,24
 Context:A.1 = Lo_N:A.1;  //_GUI 116,27
 Junction:A.0 = ListIn.1;  
}

Object ( Variant Data, Signed Context) $Context( Signed Context
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Signed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Context) Input;  //_GUI 39,24
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 119,33
 Object Output:A( Signed Context) ;  //_GUI 119,36
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Signed Number.  Our goal is to recreate a Contextual Signed out of these bits.  We only take as many bits out of the Data data set as our Signed Type specifies.  This is done to strip any leading 0s that may have been added to the context-free number, thus maintaing the 2's complement nature of the Signed number.Arial,9,0,0
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 48,22
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 104,34
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32

 //_ Behavior Topology
 Output.0 = Lo_N.0;  
 Output:A.0 = SignedOut.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = Lo_N.1;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = SignedIn.0;  //_GUI 79,37, 79,25
}

Object ( Variant Data, Variant Context) $Context( Variant Context
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL"
{
 // Date:
 // 8/10/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Context) Input;  //_GUI 32,21
 Object ( NULL Data) Input:A;  //_GUI 32,33
 Object Output( Variant Data) ;  //_GUI 52,23
 Object Output:A( Variant Context) ;  //_GUI 52,32
 Object ( Bit In) Input:B;  //_GUI 44,43
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:B( Bit Trap) ;  //_GUI 50,43
 //_ Attributes Trap="Data ran out before context was filled"

 //_ Behavior Topology
 Output:B.0 = Input:B.0;  
}

Object ( Bit Out1) IsNULL( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL"
{
 // Returns true if the input dataset is a NULL dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be NULL.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is NULL, 0 otherwise.
 //
 // Date:
 // February 5, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 46,30
 Object Output( Bit Out1) ;  //_GUI 84,40
 Object ( Bit In) Input:A;  //_GUI 47,40
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsNULL( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a NULL dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be NULL.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is NULL, 0 otherwise.
 //
 // Date:  February 5, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 43,27
 Object Output( Bit Out1) ;  //_GUI 81,37
 Object ( Bit In) Input:A;  //_GUI 44,37
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Replaces a NULL with a zero value of the dataset of Type.  Otherwise, passes the input through unchanged.
 //
 // Inputs:
 //
 // Variant Data:  Data passed through, as is, unless it is a NULL input.
 //
 // Variant Type:  The dataset that a NULL input dataset is replaced with in the output.
 //
 // Outputs:
 //
 // Variant Data: Input Data or replaced NULL.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 26,25
 Object ( Variant Type) Input:A;  //_GUI 26,31
 Object Output( Variant Data) ;  //_GUI 53,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data) ZeroNulls( NULL Data, Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Null"
{
 // Replaces a NULL with a zero value of the dataset of Type.  Otherwise, passes the input through unchanged.
 //
 // Inputs:
 //
 // Variant Data:  Data passed through, as is, unless it is a NULL input.
 //
 // Variant Type:  The dataset that a NULL input dataset is replaced with in the output.
 //
 // Outputs:
 //
 // Variant Data: Input Data or replaced NULL.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 26,25
 Object ( Variant Type) Input:A;  //_GUI 26,31
 Object Output( Variant Data) ;  //_GUI 53,25
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 41,23

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input:A.0;  //_GUI 35,26, 35,32
}

Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Ge_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Ge_BitB.0 = MSB.0;  
 $BitA_Ge_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Ge_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Ge_BitB.0 = Input.0;  
 $BitA_Ge_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 17,12
 Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Ge_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Ge_BitB.0 = MSB.0;  
 $BitA_Ge_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 9,27,( 0 >= 0 )
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant Out1) PushLsb( NULL In1, Variant LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,14
 Object ( Variant LSB) Input:A;  //_GUI 19,17
 Object Output( Variant Out1) ;  //_GUI 38,15

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 31,16, 31,18
}

Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,14
 Object ( Variant LSB) Input:A;  //_GUI 19,17
 Object Output( Variant Out1) ;  //_GUI 57,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 29,13
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 43,13
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 LSB.0 = ListOut.0;  
}

Object ( NULL Out1) PushLsb( NULL In1, NULL LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,14
 Object ( NULL LSB) Input:A;  //_GUI 19,17
 Object Output( NULL Out1) ;  //_GUI 38,15

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 31,16, 31,18
}

Object ( Variant Out1) PushLsb( Variant In1, NULL LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,15
 Object ( NULL LSB) Input:A;  //_GUI 19,18
 Object Output( Variant Out1) ;  //_GUI 38,15

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) PushLsb( List In1, Variant LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="list/var"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 27,27
 Object ( Variant LSB) Input:A;  //_GUI 27,30
 Object Output( List Out1) ;  //_GUI 84,28
 Object Text;  //_GUI 30,42,If LSB input is a list, this will put that as the most signficant element of the AnyList. This object always outputs an LSB ordered list on the top level. If you want this to concatenate two lists and give a single list output, call Lsb_List instead. For doing multiddimensionial lists, use the ZTList operators instead.
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 65,26
 Object ( List LsbList) LsbList( List AnyList) ;  //_GUI 38,25
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = LsbList.0;  
 LsbList.0 = Input.0;  
}

Object ( Bit C, Bit Out2) SHL( Bit In1
    , Bit C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="Bit"
{
 // Bit case for SHL
 //
 // Date Last Modified:
 // 26 June 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,14
 Object ( Bit C) Input:A;  //_GUI 12,27
 //_ Attributes Constant="0"
 Object Output( Bit C) ;  //_GUI 51,14
 Object Output:A( Bit Out2) ;  //_GUI 50,27

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit C, Variant Out2) SHL( Variant In1
    , Bit C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters",Documentation="Bit_Carry"
{
 // Shift Left with Carry
 //
 // This object simply realigns bits and does not consume any physical resources.
 //
 // Inputs:
 // In1- Input Data
 // C- Carry-In Bit
 //
 // Outputs:
 // C- Carry-Out Bit
 // Out2- Output Data
 //
 // Date Last Modified:
 // Mar/2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,33
 Object ( Bit C) Input:A;  //_GUI 15,42
 //_ Attributes Constant="0"
 Object Output( Bit C) ;  //_GUI 108,23
 Object Output:A( Variant Out2) ;  //_GUI 109,38
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 77,21
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 40,32
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 65,38
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 78,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 29,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 60,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 24,33
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 94,36

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = Context.0;  
 $Cast.0 = Hi_N.0;  //_GUI 50,26
 $Cast.1 = Junction:A.0;  //_GUI 61,23
 Hi_N.0 = Junction:B.1;  
 Hi_N.1 = Junction.0;  //_GUI 30,37
 ListOut.0 = Junction:A.1;  
 ListOut.1 = Hi_N.1;  //_GUI 58,40, 58,37
 LSB.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Junction.1;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:B.0;  //_GUI 94,11, 25,11
 Context.1 = LSB.0;  
}

Object ( Variant C, Variant Out2) SHL( Variant In1
    , Variant C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters",Documentation="Var_Carry"
{
 // Shift Left with Carry
 //
 // This object simply realigns bits and does not consume any physical resources.  The input data will be shifted one bit for every bit in the C dataset.
 //
 // Inputs:
 // In1- Input Data
 // C- Carry-In Bits
 //
 // Outputs:
 // C- Carry-Out Bits
 // Out2- Output Data
 //
 // Date Last Modified:
 // Mar/2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 39,48
 Object ( Variant C) Input:A;  //_GUI 39,57
 Object Output( Variant C) ;  //_GUI 132,38
 Object Output:A( Variant Out2) ;  //_GUI 133,53
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 64,47
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 89,53
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 102,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 84,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 48,48
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 101,36
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 118,51

 //_ Behavior Topology
 Output.0 = Context.0;  
 Output:A.0 = Context:A.0;  
 Hi_N.0 = Junction:B.1;  
 Hi_N.1 = Junction.0;  //_GUI 54,52
 ListOut.0 = Junction:A.1;  
 ListOut.1 = Hi_N.1;  //_GUI 82,55, 82,52
 LSB.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Junction.1;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:A.0;  //_GUI 85,38
 Context.1 = Hi_N.0;  //_GUI 74,41
 Context:A.0 = Junction:B.0;  //_GUI 118,26, 49,26
 Context:A.1 = LSB.0;  
}

Object ( NULL C, Variant Out2) SHL( Variant In1
    , NULL C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 39,48
 Object ( NULL C) Input:A;  //_GUI 39,57
 Object Output( NULL C) ;  //_GUI 132,36
 Object Output:A( Variant Out2) ;  //_GUI 133,53

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 63,37, 63,58
 Output:A.0 = Input.0;  //_GUI 86,54, 86,49
}

Object ( Bit C, Floating Out2) SHL( Floating In1
    , Variant C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 10,17
 Object ( Variant C) Input:A;  //_GUI 16,38
 Object Output( Bit C) ;  //_GUI 143,19
 Object Output:A( Floating Out2) ;  //_GUI 156,29
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 78,18
 Object ( Variant Out1) BitLength( Variant In1) ;  //_GUI 26,36
 //_ Attributes Documentation="zterm"
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 22,15
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 122,27
 Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) ;  //_GUI 49,18

 //_ Behavior Topology
 Output.0 = ADSU.0;  
 Output:A.0 = CollectFloating.0;  
 ADSU.0 = SymmetrizeNW.0;  
 ADSU.1 = SymmetrizeNW.1;  
 BitLength.0 = Input:A.0;  
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 106,29, 106,17
 CollectFloating.1 = ADSU.2;  //_GUI 96,32
 CollectFloating.2 = ExposeFloating.2;  //_GUI 38,35
 SymmetrizeNW.0 = ExposeFloating.1;  
 SymmetrizeNW.1 = BitLength.0;  //_GUI 44,23, 44,39
}

Object ( Variant Q) RegInit( Variant D, Variant Init
    , Bit ClkG, Bit En, Bit Init) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers"
{
 // Register with option to set initial value.
 //
 // Inputs:
 //
 // Variant D: The value to be registered on the next rising clock edge if En is high and Init (bit) is low.
 //
 // Variant Init: The value to be registered on the next rising clock edge if Init (bit) is high.  This value is not preloaded after chip reset.  The dataset must be the same as D.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit En:	Enable D to be registered on the next clock edge if EN is high and Init (bit) is low.  If disconnected, defaults to a value of 1.
 //
 // Bit Init:	Enable Init (Variant) to be registered on the next clock edge if this signal is high.If disconnected, defaults to a value of 0.
 //
 //
 // Outputs:
 // Q - current contents of register
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 31,27
 Object ( Variant Init) Input:A;  //_GUI 31,30
 Object ( Bit ClkG) Input:B;  //_GUI 27,38
 //_ Attributes Resource="Global"
 Object ( Bit En) Input:C;  //_GUI 32,51
 //_ Attributes Constant="1"
 Object ( Bit Init) Input:D;  //_GUI 32,54
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 98,37
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 42,26
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 58,40
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 38,54
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 81,35

 //_ Behavior Topology
 Output.0 = RegEn.0;  
 Mux.0 = Input.0;  
 Mux.1 = Input:A.0;  
 Mux.2 = Junction.0;  //_GUI 39,34
 OR.0 = Input:C.0;  //_GUI 54,42, 54,52
 OR.1 = Junction.1;  //_GUI 56,45, 56,55
 Junction.0 = Input:D.0;  
 RegEn.0 = Mux.0;  //_GUI 78,37, 78,29
 RegEn.1 = Input:B.0;  //_GUI 80,40, 80,39
 RegEn.2 = OR.0;  
}

Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out"
{
 // Date:
 // 12 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 26,22
 Object ( Variant In3) Input:A;  //_GUI 26,25
 Object Output( Variant Out1) ;  //_GUI 62,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 35,21
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 50,21
 Object Text;  //_GUI 31,33,The data sets of the inputs are arbitrary.  The LSB  operator will arrange all bits in the list into an LSB data set.

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 LSB.0 = ListOut.0;  
}

Object ( Variant mLSBOut) CollectLSB( Variant Hi, NULL Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out",Documentation="Var/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( Variant mLSBOut) ;  //_GUI 41,14
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 28,12

 //_ Behavior Topology
 Output.0 = LSB.0;  
 LSB.0 = Input.0;  //_GUI 20,15, 20,14
}

Object ( Variant mLSBOut) CollectLSB( NULL Hi, Variant Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out",Documentation="Null/Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( Variant Lo) Input:A;  //_GUI 7,16
 Object Output( Variant mLSBOut) ;  //_GUI 41,14
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 28,12

 //_ Behavior Topology
 Output.0 = LSB.0;  
 LSB.0 = Input:A.0;  //_GUI 20,15, 20,17
}

Object ( NULL mLSBOut) CollectLSB( NULL Hi, NULL Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out",Documentation="Null/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( NULL mLSBOut) ;  //_GUI 41,14

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 26,15, 26,14
}

Object ( NULL Out1, Bit Out1) ExposeLSB( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\ExposeLSB",Icon="Exposer_In",Documentation="bit"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 41,29
 Object Output( NULL Out1) ;  //_GUI 69,21
 Object Output:A( Bit Out1) ;  //_GUI 68,29
 Object ( NULL Out1) NULL;  //_GUI 49,19

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2) ExposeLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\ExposeLSB",Icon="Exposer_In"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 24,31
 Object Output( Variant Out1) ;  //_GUI 57,30
 Object Output:A( Variant Out2) ;  //_GUI 57,33
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 43,29
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 31,29

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  
 VariantIn.0 = LSB.0;  
 LSB.0 = Input.0;  
}

Object ( NULL Out1, NULL Out1) ExposeLSB( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\ExposeLSB",Icon="Exposer_In",Documentation="NULL"
{
 // Date:
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 36,32
 Object Output( NULL Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,39
 Junction.0 = Input.0;  
}

Object ( Bit Q) RegSclr( Bit D, Bit ClkG
    , Bit EN, Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="Bit/Bit/Bit/Bit"
{
 //_ Object Prototypes
 Object ( Bit D) Input;  //_GUI 71,43
 Object ( Bit ClkG) Input:A;  //_GUI 71,49
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 71,52
 Object ( Bit SCLR) Input:C;  //_GUI 71,55
 Object Output( Bit Q) ;  //_GUI 133,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 82,43
 Object ( Variant Q) RegInit( Variant D, Variant Init
    , Bit ClkG, Bit En, Bit Init) ;  //_GUI 106,42
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 89,44
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 123,42

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Junction.0 = Input.0;  
 RegInit.0 = Junction.1;  
 RegInit.1 = Zero.0;  
 RegInit.2 = Input:A.0;  
 RegInit.3 = Input:B.0;  
 RegInit.4 = Input:C.0;  
 Zero.0 = Junction.2;  //_GUI 83,47
 VouchBit.0 = RegInit.0;  
}

Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Bit EN, Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="Var/Bit/Bit/Bit"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // Variant D:	The value to be registered on the next rising clock edge if En is high.
 //
 // Variant ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit EN:	Enable D to be registered on the next clock edge if EN is high.  If disconnected, defaults to constant 1.
 //
 // Bit CLR:	Asynchronously clears the contents of the register.  Overrides EN.  If disconnected, defaults to constant 0.
 //
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,22
 Object ( Bit ClkG) Input:A;  //_GUI 21,38
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 21,41
 //_ Attributes Constant="1"
 Object ( Bit SCLR) Input:C;  //_GUI 21,44
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 111,21
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,20
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 81,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 55,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 52,41
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 49,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 26,22
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 98,19
 Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Bit EN, Bit SCLR) ;  //_GUI 60,20
 Object ( Variant Q) RegSclr:A( Variant D, Bit ClkG
    , Bit EN, Bit SCLR) ;  //_GUI 60,34

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:C.1;  
 VariantOut.0 = RegSclr:A.0;  //_GUI 75,26, 75,37
 VariantOut.1 = RegSclr.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:C.0;  
 Junction:C.0 = Input.0;  
 Cast.0 = Junction:C.0;  //_GUI 95,21, 95,18, 27,18
 Cast.1 = VariantOut.0;  
 RegSclr.0 = VariantIn.1;  
 RegSclr.1 = Junction.0;  //_GUI 56,25
 RegSclr.2 = Junction:A.0;  //_GUI 53,28
 RegSclr.3 = Junction:B.0;  //_GUI 50,31
 RegSclr:A.0 = VariantIn.0;  //_GUI 47,36, 47,25
 RegSclr:A.1 = Junction.1;  
 RegSclr:A.2 = Junction:A.1;  
 RegSclr:A.3 = Junction:B.1;  
}

Object ( NULL Q) RegSclr( NULL D, Bit ClkG
    , Bit EN, Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="NULL/bit/bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 20,21
 Object ( Bit ClkG) Input:A;  //_GUI 21,38
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 21,41
 //_ Attributes Constant="1"
 Object ( Bit SCLR) Input:C;  //_GUI 21,44
 //_ Attributes Constant="0"
 Object Output( NULL Q) ;  //_GUI 111,21

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Variant EN, Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="Var/Bit/Var/Bit"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // Variant D:	A set of bits to be registered on the next rising clock edge if its associated En bit is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Variant EN:	Enable D to be registered on the next clock edge if EN is high.  If the same dataset as D then allows each bit in D to have a separate and independent enable bit.
 //
 // Bit CLR:	Asynchronously clears the contents of the register.  Overrides EN.  If disconnected, defaults to constant 0.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,22
 Object ( Bit ClkG) Input:A;  //_GUI 21,38
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 21,43
 Object ( Bit SCLR) Input:C;  //_GUI 22,54
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 111,21
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,20
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 81,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 55,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 49,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 26,22
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 28,41
 Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Bit EN, Bit SCLR) ;  //_GUI 60,20
 Object ( Variant Q) RegSclr:A( Variant D, Bit ClkG
    , Variant EN, Bit SCLR) ;  //_GUI 60,34

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:B.1;  
 VariantOut.0 = RegSclr:A.0;  //_GUI 75,26, 75,37
 VariantOut.1 = RegSclr.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:C.0;  //_GUI 46,45, 46,55
 Junction:B.0 = Input.0;  
 Cast.0 = Junction:B.0;  //_GUI 95,21, 95,18, 27,18
 Cast.1 = VariantOut.0;  
 VariantIn:A.0 = Input:B.0;  
 RegSclr.0 = VariantIn.1;  
 RegSclr.1 = Junction.0;  //_GUI 56,25
 RegSclr.2 = VariantIn:A.1;  //_GUI 39,28
 RegSclr.3 = Junction:A.0;  //_GUI 50,31
 RegSclr:A.0 = VariantIn.0;  //_GUI 47,36, 47,25
 RegSclr:A.1 = Junction.1;  
 RegSclr:A.2 = VariantIn:A.0;  //_GUI 43,42, 43,46
 RegSclr:A.3 = Junction:A.1;  
}

Object ( List Q) RegSclr( List D, Bit ClkG
    , List EN, List SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="List/Bit/List/List"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // List D:	The list of values to be registered on the next rising clock edge if its En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // List EN:	Enable D to be registered on the next clock edge if EN is high.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent enable bit.
 //
 // List CLR:	Asynchronously clears the contents of the register.  Overrides EN.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent clear bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 37,29
 Object ( Bit ClkG) Input:A;  //_GUI 24,47
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 24,50
 Object ( List SCLR) Input:C;  //_GUI 24,53
 Object Output( List Q) ;  //_GUI 120,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 63,47
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,27
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 100,28
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 37,39
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 40,58
 Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) ;  //_GUI 76,27
 Object ( Variant Q) RegSclr:A( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) ;  //_GUI 76,43

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = RegSclr:A.0;  //_GUI 90,33, 90,46
 ListOut.1 = RegSclr.0;  
 ListIn:A.0 = Input:B.0;  //_GUI 37,51
 ListIn:B.0 = Input:C.0;  //_GUI 29,61, 29,54
 RegSclr.0 = ListIn.1;  
 RegSclr.1 = Junction.0;  //_GUI 64,32
 RegSclr.2 = ListIn:A.1;  //_GUI 54,35, 54,41
 RegSclr.3 = ListIn:B.1;  //_GUI 69,38, 69,60
 RegSclr:A.0 = ListIn.0;  //_GUI 60,45, 60,32
 RegSclr:A.1 = Junction.1;  
 RegSclr:A.2 = ListIn:A.0;  //_GUI 48,51
 RegSclr:A.3 = ListIn:B.0;  //_GUI 76,63
}

Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="Var/Bit/Var/Var"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // Variant D:	The set of bits to be registered on the next rising clock edge if its associated En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Variant EN:	Enable D to be registered on the next clock edge if EN is high.  If the same dataset as D then allows each bit in D to have a separate and independent enable bit.
 //
 // Variant CLR:	Asynchronously clears the contents of the register.  Overrides EN.  If the same dataset as D then allows each bit in D to have a separate and independent clear bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,41
 Object ( Bit ClkG) Input:A;  //_GUI 20,49
 //_ Attributes Resource="Global"
 Object ( Variant EN) Input:B;  //_GUI 20,55
 Object ( Variant SCLR) Input:C;  //_GUI 20,66
 Object Output( Variant Q) ;  //_GUI 103,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,39
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 73,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,41
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 90,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 47,49
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 29,53
 Object ( Variant Out1, Variant Out2) VariantIn:B( Variant In) ;  //_GUI 29,64
 Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) ;  //_GUI 58,24
 Object ( Variant Q) RegSclr:A( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) ;  //_GUI 58,88

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = RegSclr:A.0;  //_GUI 71,30, 71,91
 VariantOut.1 = RegSclr.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 87,25, 87,18, 27,18
 Cast.1 = VariantOut.0;  
 Junction:A.0 = Input:A.0;  
 VariantIn:A.0 = Input:B.0;  
 VariantIn:B.0 = Input:C.0;  
 RegSclr.0 = VariantIn.1;  //_GUI 45,26, 45,41
 RegSclr.1 = Junction:A.0;  //_GUI 48,29
 RegSclr.2 = VariantIn:A.1;  //_GUI 51,32, 51,55
 RegSclr.3 = VariantIn:B.1;  //_GUI 54,35, 54,66
 RegSclr:A.0 = VariantIn.0;  //_GUI 45,90, 45,44
 RegSclr:A.1 = Junction:A.2;  //_GUI 48,93
 RegSclr:A.2 = VariantIn:A.0;  //_GUI 51,96, 51,58
 RegSclr:A.3 = VariantIn:B.0;  //_GUI 54,99, 54,69
}

Object ( NULL Q) RegSclr( NULL D, Bit ClkG
    , NULL EN, Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="NULL/Bit/NULL/Bit"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 //   D - Data In
 //   ClkG - Clock
 //   EN - Clock Enable
 //   CLR - Asynchronous Clear
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 20,41
 Object ( Bit ClkG) Input:A;  //_GUI 20,49
 //_ Attributes Resource="Global"
 Object ( NULL EN) Input:B;  //_GUI 20,55
 Object ( Bit SCLR) Input:C;  //_GUI 20,65
 Object Output( NULL Q) ;  //_GUI 103,41

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Q) RegSclr( NULL D, Bit ClkG
    , NULL EN, NULL SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="NULL/Bit/NULL/NULL"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 //   D - Data In
 //   ClkG - Clock
 //   EN - Clock Enable
 //   CLR - Asynchronous Clear
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 20,41
 Object ( Bit ClkG) Input:A;  //_GUI 20,49
 //_ Attributes Resource="Global"
 Object ( NULL EN) Input:B;  //_GUI 20,55
 Object ( NULL SCLR) Input:C;  //_GUI 20,65
 Object Output( NULL Q) ;  //_GUI 103,41

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Q) RegSclr( List D, Bit ClkG
    , List EN, Bit SCLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers",Documentation="List/Bit/List/Bit"
{
 // D Flip Flop with clock enable and asynchrous clear
 //
 // Inputs:
 //
 // List D:	The list of values to be registered on the next rising clock edge if its En is high.
 //
 // Bit ClkG:	The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // List EN:	Enable D to be registered on the next clock edge if EN is high.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent enable bit.
 //
 // List CLR:	Asynchronously clears the contents of the register.  Overrides EN.  Usually a list of bits. If the same list struct as D then allows each element in D to have a separate and independent clear bit.
 //
 // Outputs:
 //
 //   Q - Data Out
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Author:
 // Samuel Brown
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 32,13
 Object ( Bit ClkG) Input:A;  //_GUI 19,31
 //_ Attributes Resource="Global"
 Object ( List EN) Input:B;  //_GUI 19,34
 Object ( Bit SCLR) Input:C;  //_GUI 19,37
 Object Output( List Q) ;  //_GUI 115,14
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 58,31
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 41,11
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 95,12
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 32,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 63,37
 Object ( Variant Q) RegSclr( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) ;  //_GUI 71,11
 Object ( Variant Q) RegSclr:A( Variant D, Bit ClkG
    , Variant EN, Variant SCLR) ;  //_GUI 71,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = RegSclr:A.0;  //_GUI 85,17, 85,30
 ListOut.1 = RegSclr.0;  
 ListIn:A.0 = Input:B.0;  //_GUI 32,35
 Junction:A.0 = Input:C.0;  
 RegSclr.0 = ListIn.1;  
 RegSclr.1 = Junction.0;  //_GUI 59,16
 RegSclr.2 = ListIn:A.1;  //_GUI 49,19, 49,25
 RegSclr.3 = Junction:A.0;  //_GUI 64,22
 RegSclr:A.0 = ListIn.0;  //_GUI 55,29, 55,16
 RegSclr:A.1 = Junction.1;  
 RegSclr:A.2 = ListIn:A.0;  //_GUI 43,35
 RegSclr:A.3 = Junction:A.1;  
}

Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires and possibly inverters.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,21
 Object ( Variant In2) Input:A;  //_GUI 10,24
 Object Output( Variant Out1) ;  //_GUI 41,21
 Object Output:A( Variant Out2) ;  //_GUI 41,24
 Object Text;  //_GUI 25,41,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Bit In) Input:B;  //_GUI 20,27
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 26,20
 Object Text;  //_GUI 17,33,Warn by default.

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 $Symmetrize.0 = Input.0;  
 $Symmetrize.1 = Input:A.0;  
 $Symmetrize.2 = Input:B.0;  
}

Object ( Bit Out1) OR-NInput( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="bit"
{
 // All bits are ORed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ORing all input bits.
 //
 // Revision 2 - 11/08/05 documentation AND to OR
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) OR-NInput( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\Advanced"
{
 // All bits are ORed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ORing all input bits.
 //
 // Revision 2 - 11/08/05 documentation AND to OR
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 59,31
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 32,29
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 17,29
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 47,29

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 $OR-NInput.0 = ExposeBIN.0;  
 $OR-NInput.1 = ExposeBIN.1;  
 ExposeBIN.0 = Input.0;  
 VouchBit.0 = $OR-NInput.0;  
}

Object ( NULL Out1) OR-NInput( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="NULL"
{
 // All bits are ORed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ORing all input bits.
 //
 // Revision 2 - 11/08/05 documentation AND to OR
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 10,31
 Object Output( NULL Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the Sign portion, the Biased Exponent portion and the Mantissa (high bit implied) portion of a value from a Floating dataset.
 //
 // Inputs:
 //
 // Variant input: The Floating value to expose.
 //
 // Outputs:
 //
 // Variant Sign: The sign bit.
 //
 // Variant BExp: The biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 11,20
 Object Output( Bit Sign) ;  //_GUI 80,8
 Object Output:A( Variant BExp) ;  //_GUI 80,15
 Object Output:B( Variant Mant) ;  //_GUI 80,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,18
 Object Text;  //_GUI 92,14,(Biased exponent)
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 49,11
 //_ Attributes Documentation="Error"
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 17,18
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 67,6

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = ExposeMSB.1;  
 Output:B.0 = ListIn.0;  
 ListIn.0 = FloatingIn.0;  
 ExposeMSB.0 = ListIn.1;  //_GUI 46,14, 46,20
 FloatingIn.0 = Input.0;  
 VouchBit.0 = ExposeMSB.0;  //_GUI 63,9, 63,13
}

Object ( Variant Out1) $AND( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="Variant"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,15
 Object ( Variant In2) Input:A;  //_GUI 15,25
 Object Output( Variant Out1) ;  //_GUI 110,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 28,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,17
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 28,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 22,15
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 93,15
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 55,13
 Object ( Variant Out1) $AND:A( Variant In1, Variant In2) ;  //_GUI 55,23

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Input:A.0;  
 VariantOut.0 = $AND:A.0;  //_GUI 68,22, 68,26
 VariantOut.1 = $AND.0;  //_GUI 68,19, 68,16
 VariantIn:A.0 = Junction.1;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 89,17, 89,9, 23,9
 Cast.1 = VariantOut.0;  
 $AND.0 = VariantIn:A.1;  
 $AND.1 = VariantIn.1;  //_GUI 49,18, 49,22, 44,22, 44,25
 $AND:A.0 = VariantIn:A.0;  //_GUI 47,25, 47,18
 $AND:A.1 = VariantIn.0;  
}

Object ( Bit Out1) $AND( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="Leaf"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 28,15
 Object ( Bit In2) Input:A;  //_GUI 28,18
 Object Output( Bit Out1) ;  //_GUI 54,16
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 37,14

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
}

Object ( List Out1) $AND( List In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="List\\Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $AND:A( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $AND:A.0;  //_GUI 65,29, 65,32
 ListOut.1 = $AND.0;  //_GUI 66,26, 66,23
 $AND.0 = ListIn.1;  
 $AND.1 = Junction.0;  //_GUI 46,25
 $AND:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $AND:A.1 = Junction.1;  
}

Object ( List Out1) $AND( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="Var\\List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $AND:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = $AND.0;  
 $AND.0 = Junction.1;  
 $AND.1 = ListIn.1;  //_GUI 41,21, 41,26
 $AND:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $AND:A.1 = ListIn.0;  
}

Object ( List Out1) $AND_SameLists( List In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\List"
{
 // Added Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 19,31
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $AND_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $AND_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $AND_SameLists.0;  //_GUI 74,26, 74,23
 ListIn:A.0 = Input:A.0;  
 $AND_SameLists.0 = ListIn.1;  
 $AND_SameLists.1 = ListIn:A.1;  //_GUI 43,25, 43,33
 $AND_SameLists:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $AND_SameLists:A.1 = ListIn:A.0;  //_GUI 51,36
}

Object ( List Out1) $AND_SameLists( List In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Bit In) Input:B;  //_GUI 22,39
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 28,39
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $AND_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $AND_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $AND_SameLists.0;  //_GUI 74,26, 74,23
 Output:A.0 = Input:B.0;  
 $AND_SameLists.0 = ListIn.1;  
 $AND_SameLists.1 = Junction.0;  //_GUI 46,25
 $AND_SameLists:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 $AND_SameLists:A.1 = Junction.1;  
}

Object ( List Out1) $AND_SameLists( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,17
 Object ( Bit In) Input:B;  //_GUI 30,34
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 36,34
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 48,16
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $AND_SameLists:A( Variant In2, Variant In1) ;  //_GUI 48,24
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $AND_SameLists:A.0;  //_GUI 71,22, 71,27
 ListOut.1 = $AND_SameLists.0;  
 Output:A.0 = Input:B.0;  
 $AND_SameLists.0 = Junction.1;  
 $AND_SameLists.1 = ListIn.1;  //_GUI 41,21, 41,26
 $AND_SameLists:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $AND_SameLists:A.1 = ListIn.0;  
}

Object ( Variant Out1) $AND_SameLists( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,20
 Object Output( Variant Out1) ;  //_GUI 30,18
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 18,16
 //_ Attributes Documentation="Var/NULL"

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
}

Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async"
{
 // Same as Add (2,1) except has an extra OFL output.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Value
 //
 // Variant B: Value
 //
 // Outputs:
 //
 // Bit OFL: Overflow used to detect an overflow error
 //
 // Variant S: The sum of A and B.
 //
 // Dataset Coverage:
 //
 // Unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating and Complex (OFL is OR of both real and imaginary portions) and lists of these (S and OFL are lists).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx and BINxxx).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx, and BINxxx) or undefinded behavior will occur.  If different sizes then the inputs are symmetrized with a warning.  If one of A or B is a list and the other is not, the other is duplicated into a list matching the one then the respective list elements are added.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 14,14
 Object ( Variant B) Input:A;  //_GUI 14,17
 Object Output( Variant OFL) ;  //_GUI 64,14
 Object Output:A( Variant S) ;  //_GUI 64,17
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 46,13
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 25,13

 //_ Behavior Topology
 Output.0 = $ResolveError.0;  
 Output:A.0 = $ResolveError.1;  
 $ResolveError.0 = ADSU.0;  
 $ResolveError.1 = ADSU.1;  
 $ResolveError.2 = ADSU.2;  
 ADSU.0 = Input.0;  
 ADSU.1 = Input:A.0;  
}

Object ( List OFL, List S) Add( List A
    , Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 21,18
 Object ( Variant B) Input:A;  //_GUI 21,29
 Object Output( List OFL) ;  //_GUI 97,18
 Object Output:A( List S) ;  //_GUI 97,27
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 34,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 46,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 82,16
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 82,25
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 57,16
 Object ( Variant OFL, Variant S) Add:A( Variant A
    , Variant B) ;  //_GUI 57,25

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 Junction.0 = Input:A.0;  
 ListOut.0 = Add:A.0;  //_GUI 78,21, 78,27
 ListOut.1 = Add.0;  
 ListOut:A.0 = Add:A.1;  
 ListOut:A.1 = Add.1;  //_GUI 82,24, 74,24
 Add.0 = ListIn.1;  
 Add.1 = Junction.0;  //_GUI 51,21, 51,27, 47,27
 Add:A.0 = ListIn.0;  //_GUI 54,27, 54,24, 48,24, 48,21
 Add:A.1 = Junction.1;  
}

Object ( List OFL, List S) Add( Variant A
    , List B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="Variant/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 25,17
 Object ( List B) Input:A;  //_GUI 25,27
 Object Output( List OFL) ;  //_GUI 97,18
 Object Output:A( List S) ;  //_GUI 97,27
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 33,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,17
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 82,16
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 82,25
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 57,16
 Object ( Variant OFL, Variant S) Add:A( Variant A
    , Variant B) ;  //_GUI 57,25

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
 ListOut.0 = Add:A.0;  //_GUI 78,21, 78,27
 ListOut.1 = Add.0;  
 ListOut:A.0 = Add:A.1;  
 ListOut:A.1 = Add.1;  //_GUI 82,24, 74,24
 Add.0 = Junction.1;  
 Add.1 = ListIn.1;  //_GUI 51,21, 51,27
 Add:A.0 = Junction.2;  //_GUI 54,27, 54,24, 48,24
 Add:A.1 = ListIn.0;  
}

Object ( List OFL, List S) Add( List A
    , List B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 10,13
 Object ( List B) Input:A;  //_GUI 10,22
 Object Output( List OFL) ;  //_GUI 86,13
 Object Output:A( List S) ;  //_GUI 86,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 22,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,11
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 22,11
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 71,20
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 46,11
 Object ( Variant OFL, Variant S) Add:A( Variant A
    , Variant B) ;  //_GUI 46,20

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = Add:A.0;  //_GUI 67,16, 67,22
 ListOut.1 = Add.0;  
 ListIn:A.0 = Input.0;  
 ListOut:A.0 = Add:A.1;  
 ListOut:A.1 = Add.1;  //_GUI 71,19, 63,19
 Add.0 = ListIn:A.1;  
 Add.1 = ListIn.1;  //_GUI 40,16, 40,22
 Add:A.0 = ListIn:A.0;  //_GUI 43,22, 43,19, 37,19, 37,16
 Add:A.1 = ListIn.0;  
}

Object ( Variant Out1) $OR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Icon="OR",Documentation="Variant"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,15
 Object ( Variant In2) Input:A;  //_GUI 16,25
 Object Output( Variant Out1) ;  //_GUI 116,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 28,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,17
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 28,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 22,15
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 98,15
 Object ( Variant Out1) $OR( Variant In1, Variant In2) ;  //_GUI 57,13
 Object ( Variant Out1) $OR:A( Variant In1, Variant In2) ;  //_GUI 58,23

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Input:A.0;  
 VariantOut.0 = $OR:A.0;  //_GUI 72,22, 72,26
 VariantOut.1 = $OR.0;  //_GUI 70,19, 70,16
 VariantIn:A.0 = Junction.1;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 92,17, 92,8, 23,8
 Cast.1 = VariantOut.0;  
 $OR.0 = VariantIn:A.1;  
 $OR.1 = VariantIn.1;  //_GUI 49,18, 49,22, 44,22, 44,25
 $OR:A.0 = VariantIn:A.0;  //_GUI 47,25, 47,18
 $OR:A.1 = VariantIn.0;  
}

Object ( Bit Out1) $OR( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Icon="OR",Documentation="Leaf"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 15,15
 Object ( Bit In2) Input:A;  //_GUI 15,18
 Object Output( Bit Out1) ;  //_GUI 38,16
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 22,14

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
}

Object ( List Out1) $OR_SameLists( List In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List\\List"
{
 // Added Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 19,31
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $OR_SameLists.0;  //_GUI 74,26, 74,23
 ListIn:A.0 = Input:A.0;  
 $OR_SameLists.0 = ListIn.1;  
 $OR_SameLists.1 = ListIn:A.1;  //_GUI 43,25, 43,33
 $OR_SameLists:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $OR_SameLists:A.1 = ListIn:A.0;  //_GUI 51,36
}

Object ( List Out1) $OR_SameLists( List In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Bit In) Input:B;  //_GUI 22,39
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 28,39
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $OR_SameLists.0;  //_GUI 74,26, 74,23
 Output:A.0 = Input:B.0;  
 $OR_SameLists.0 = ListIn.1;  
 $OR_SameLists.1 = Junction.0;  //_GUI 46,25
 $OR_SameLists:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 $OR_SameLists:A.1 = Junction.1;  
}

Object ( List Out1) $OR_SameLists( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,17
 Object ( Bit In) Input:B;  //_GUI 30,34
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 36,34
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 48,16
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 48,24
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 71,22, 71,27
 ListOut.1 = $OR_SameLists.0;  
 Output:A.0 = Input:B.0;  
 $OR_SameLists.0 = Junction.1;  
 $OR_SameLists.1 = ListIn.1;  //_GUI 41,21, 41,26
 $OR_SameLists:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $OR_SameLists:A.1 = ListIn.0;  
}

Object ( Variant Out1) $OR_SameLists( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,20
 Object Output( Variant Out1) ;  //_GUI 30,18
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 18,16

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
}

Object ( List DataOut, List WrRdyCnt, List RdRdyCnt
    , List AlmFull, List AlmEmpty, List Empty, List Done
    , List Busy) FIFO( List DataIn, Variant Size, Variant AlmBits
    , Bit ClkWr, Bit ClkRd, Bit Reset, List Go
    , List Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\Advanced",Documentation="list/list"
{
 // This FIFO allows the write side and the read side to be in different clock domains, a GDBW interface, and a more advanced interface than the FIFO object in the non-Advanced folder.  Only use DataIn, Go and Busy to write to the FIFO.  Only use DataOut, Done and Wait to read from the FIFO.  All other outputs should not be depended upon to perform the actual reads or writes but can be used as hints to the state of the FIFO.  The variation in the specified clock delay is due to the Size of the FIFO, the user clock frequency and the read and write clocks being different frequencies.
 //
 // This device has been tested at 32 bits wide by 16 elements deep at 166MHz and 64 bits wide by 512 elements deep at 100MHz.
 //
 // Inputs:
 //
 // Var/List DataIn:	Write data (ClkWr domain)
 //
 // Var Size:	The number of bits in the data type defines the size of the memory allocated (number of FIFO elements = 2^NumberOfBits(Size)).  Size is forced to a minimum of 4 bits.
 //
 // Var AlmBits:	Defines when the AlmFull and AlmEmpty bits come on.
 //
 // Bit ClkWr:	Write clock
 //
 // Bit ClkRd:	Read clock
 //
 // Bit Reset:	Clears the FIFO and any errors.  If disconnected, defaults to 0.
 //
 // Bit/List Go:	Go of GDBW.  If a List than creates a List of independent FIFOs. (ClkWr domain)
 //
 // Bit/List Wait:	Wait of GDBW.  Holds off Dones.  Same dataset as Go.  If this Wait connects to a Variant Busy then the transport may need to be Cast to a List or get sent through VouchBitWait for it to successfully compile.  Or you can drop the specific Bit or List object reference version. (ClkRd domain)
 //
 // Outputs:
 //
 // Var/List DataOut:	Read data.  Valid when Done high. (ClkRd domain)
 //
 // Var/List WrRdyCnt:	The number of free elements ready to be written into.  2 to 5 clocks behind GO.  5 to 8 clocks behind Done.  The dataset is MSBxxx where the number of bits is one more than the number of bits of the Size input. (ClkWr domain)
 //
 // Var/List RdRdyCnt:	The number of elements ready to be read out.  5 to 8 clocks behind Go.  2 to 5 clocks behind Done.  The dataset is MSBxxx where the number of bits is one more than the number of bits of the Size input. (ClkRd domain)
 //
 // Bit/List AlmFull:	The FIFO is almost full (2^AlmBits - 1 from full).  No delay from Go.  About 4 delay from Done. (ClkWr domain)
 //
 // Bit/List AlmEmpty:	The FIFO is almost empty (2^AlmBits + 1 from empty).  About 2 delay from Go.  No delay from Done. (ClkRd domain)
 //
 // Bit/List Empty:	The FIFO is empty.  About 2 clock delay from Go.  No delay from Done. (ClkRd domain)
 //
 // Bit/List Done:	Done of GDBW.  Indicates DataOut is valid. (ClkRd domain)
 //
 // Bit/List Busy:	Busy of GDBW.  The FIFO is full.  No delay from Go.  About 3 delay from Done. (ClkWr domain)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List DataIn) Input;  //_GUI 29,45
 Object ( Variant Size) Input:A;  //_GUI 29,52
 Object ( Variant AlmBits) Input:B;  //_GUI 29,55
 Object ( Bit ClkWr) Input:C;  //_GUI 29,58
 Object ( Bit ClkRd) Input:D;  //_GUI 29,61
 Object ( Bit Reset) Input:E;  //_GUI 29,64
 Object ( List Go) Input:F;  //_GUI 29,69
 Object ( List Wait) Input:G;  //_GUI 123,96
 Object Output( List DataOut) ;  //_GUI 135,34
 Object Output:A( List WrRdyCnt) ;  //_GUI 135,42
 Object Output:B( List RdRdyCnt) ;  //_GUI 135,50
 Object Output:C( List AlmFull) ;  //_GUI 135,58
 Object Output:D( List AlmEmpty) ;  //_GUI 135,66
 Object Output:E( List Empty) ;  //_GUI 135,74
 Object Output:F( List Done) ;  //_GUI 135,82
 Object Output:G( List Busy) ;  //_GUI 37,83
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 57,58
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 60,61
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 63,64
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 24,81
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 122,40
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 122,80
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 35,43
 Object ( List Out) ListOut:C( Variant In1, Variant In2) ;  //_GUI 122,48
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 129,94
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 51,52
 Object ( List Out) ListOut:D( Variant In1, Variant In2) ;  //_GUI 122,56
 Object ( List Out) ListOut:E( Variant In1, Variant In2) ;  //_GUI 122,32
 Object ( List Out) ListOut:F( Variant In1, Variant In2) ;  //_GUI 122,64
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 54,55
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 35,67
 Object ( List Out) ListOut:G( Variant In1, Variant In2) ;  //_GUI 122,72
 Object ( Variant DataOut, Variant WrRdyCnt, Variant RdRdyCnt
    , Variant AlmFull, Variant AlmEmpty, Variant Empty, Variant Done
    , Variant Busy) FIFO( Variant DataIn, Variant Size, Variant AlmBits
    , Bit ClkWr, Bit ClkRd, Bit Reset, Variant Go
    , Variant Wait) ;  //_GUI 74,6
 Object ( Variant DataOut, Variant WrRdyCnt, Variant RdRdyCnt
    , Variant AlmFull, Variant AlmEmpty, Variant Empty, Variant Done
    , Variant Busy) FIFO:A( Variant DataIn, Variant Size, Variant AlmBits
    , Bit ClkWr, Bit ClkRd, Bit Reset, Variant Go
    , Variant Wait) ;  //_GUI 74,105

 //_ Behavior Topology
 Output.0 = ListOut:E.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = ListOut:C.0;  
 Output:C.0 = ListOut:D.0;  
 Output:D.0 = ListOut:F.0;  
 Output:E.0 = ListOut:G.0;  
 Output:F.0 = ListOut:B.0;  
 Output:G.0 = ListOut.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:D.0;  
 Junction:B.0 = Input:E.0;  
 ListOut.0 = FIFO:A.7;  //_GUI 17,86, 17,79, 70,79, 70,128
 ListOut.1 = FIFO.7;  //_GUI 21,83, 21,76, 70,76, 70,29
 ListOut:A.0 = FIFO:A.1;  //_GUI 113,45, 113,110
 ListOut:A.1 = FIFO.1;  //_GUI 113,42, 113,11
 ListOut:B.0 = FIFO:A.6;  //_GUI 98,85, 98,125
 ListOut:B.1 = FIFO.6;  //_GUI 98,82, 98,26
 ListIn.0 = Input.0;  
 ListOut:C.0 = FIFO:A.2;  //_GUI 110,53, 110,113
 ListOut:C.1 = FIFO.2;  //_GUI 110,50, 110,14
 ListIn:A.0 = Input:G.0;  
 Junction:C.0 = Input:A.0;  
 ListOut:D.0 = FIFO:A.3;  //_GUI 107,61, 107,116
 ListOut:D.1 = FIFO.3;  //_GUI 107,58, 107,17
 ListOut:E.0 = FIFO:A.0;  //_GUI 116,37, 116,107
 ListOut:E.1 = FIFO.0;  //_GUI 116,34, 116,8
 ListOut:F.0 = FIFO:A.4;  //_GUI 104,69, 104,119
 ListOut:F.1 = FIFO.4;  //_GUI 104,66, 104,20
 Junction:D.0 = Input:B.0;  
 ListIn:B.0 = Input:F.0;  
 ListOut:G.0 = FIFO:A.5;  //_GUI 101,77, 101,122
 ListOut:G.1 = FIFO.5;  //_GUI 101,74, 101,23
 FIFO.0 = ListIn.1;  //_GUI 49,8, 49,45
 FIFO.1 = Junction:C.0;  //_GUI 52,11
 FIFO.2 = Junction:D.0;  //_GUI 55,14
 FIFO.3 = Junction.0;  //_GUI 58,17
 FIFO.4 = Junction:A.0;  //_GUI 61,20
 FIFO.5 = Junction:B.0;  //_GUI 64,23
 FIFO.6 = ListIn:B.1;  //_GUI 67,26, 67,69
 FIFO.7 = ListIn:A.1;  //_GUI 95,29, 95,89, 143,89, 143,96
 FIFO:A.0 = ListIn.0;  //_GUI 49,107, 49,48
 FIFO:A.1 = Junction:C.2;  //_GUI 52,110
 FIFO:A.2 = Junction:D.2;  //_GUI 55,113
 FIFO:A.3 = Junction.2;  //_GUI 58,116
 FIFO:A.4 = Junction:A.2;  //_GUI 61,119
 FIFO:A.5 = Junction:B.2;  //_GUI 64,122
 FIFO:A.6 = ListIn:B.0;  //_GUI 67,125, 67,72
 FIFO:A.7 = ListIn:A.0;  //_GUI 95,128, 95,92, 147,92, 147,99
}

Object ( Variant DataOut, Variant WrRdyCnt, Variant RdRdyCnt
    , Bit AlmFull, Bit AlmEmpty, Bit Empty, Bit Done
    , Bit Busy) FIFO( Variant DataIn, Variant Size, Variant AlmBits
    , Bit ClkWr, Bit ClkRd, Bit Reset, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\Advanced"
{
 // This FIFO allows the write side and the read side to be in different clock domains, a GDBW interface, and a more advanced interface than the FIFO object in the non-Advanced folder.  Only use DataIn, Go and Busy to write to the FIFO.  Only use DataOut, Done and Wait to read from the FIFO.  All other outputs should not be depended upon to perform the actual reads or writes but can be used as hints to the state of the FIFO.  The variation in the specified clock delay is due to the Size of the FIFO, the user clock frequency and the read and write clocks being different frequencies.
 //
 // This device has been tested at 32 bits wide by 16 elements deep at 166MHz and 64 bits wide by 512 elements deep at 100MHz.
 //
 // Inputs:
 //
 // Var/List DataIn:	Write data (ClkWr domain)
 //
 // Var Size:	The number of bits in the data type defines the size of the memory allocated (number of FIFO elements = 2^NumberOfBits(Size)).  Size is forced to a minimum of 4 bits.
 //
 // Var AlmBits:	Defines when the AlmFull and AlmEmpty bits come on.
 //
 // Bit ClkWr:	Write clock
 //
 // Bit ClkRd:	Read clock
 //
 // Bit Reset:	Clears the FIFO and any errors.  If disconnected, defaults to 0.
 //
 // Bit/List Go:	Go of GDBW.  If a List than creates a List of independent FIFOs. (ClkWr domain)
 //
 // Bit/List Wait:	Wait of GDBW.  Holds off Dones.  Same dataset as Go.  If this Wait connects to a Variant Busy then the transport may need to be Cast to a List or get sent through VouchBitWait for it to successfully compile.  Or you can drop the specific Bit or List object reference version. (ClkRd domain)
 //
 // Outputs:
 //
 // Var/List DataOut:	Read data.  Valid when Done high. (ClkRd domain)
 //
 // Var/List WrRdyCnt:	The number of free elements ready to be written into.  2 to 5 clocks behind GO.  5 to 8 clocks behind Done.  The dataset is MSBxxx where the number of bits is one more than the number of bits of the Size input. (ClkWr domain)
 //
 // Var/List RdRdyCnt:	The number of elements ready to be read out.  5 to 8 clocks behind Go.  2 to 5 clocks behind Done.  The dataset is MSBxxx where the number of bits is one more than the number of bits of the Size input. (ClkRd domain)
 //
 // Bit/List AlmFull:	The FIFO is almost full (2^AlmBits - 1 from full).  No delay from Go.  About 4 delay from Done. (ClkWr domain)
 //
 // Bit/List AlmEmpty:	The FIFO is almost empty (2^AlmBits + 1 from empty).  About 2 delay from Go.  No delay from Done. (ClkRd domain)
 //
 // Bit/List Empty:	The FIFO is empty.  About 2 clock delay from Go.  No delay from Done. (ClkRd domain)
 //
 // Bit/List Done:	Done of GDBW.  Indicates DataOut is valid. (ClkRd domain)
 //
 // Bit/List Busy:	Busy of GDBW.  The FIFO is full.  No delay from Go.  About 3 delay from Done. (ClkWr domain)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant DataIn) Input;  //_GUI 26,81
 Object ( Variant Size) Input:A;  //_GUI 26,84
 Object ( Variant AlmBits) Input:B;  //_GUI 26,87
 Object ( Bit ClkWr) Input:C;  //_GUI 26,90
 Object ( Bit ClkRd) Input:D;  //_GUI 26,96
 Object ( Bit Reset) Input:E;  //_GUI 26,102
 Object ( Bit Go) Input:F;  //_GUI 26,118
 Object ( Bit Wait) Input:G;  //_GUI 24,151
 Object Output( Variant DataOut) ;  //_GUI 288,2
 Object Output:A( Variant WrRdyCnt) ;  //_GUI 288,9
 Object Output:B( Variant RdRdyCnt) ;  //_GUI 288,61
 Object Output:C( Bit AlmFull) ;  //_GUI 272,96
 Object Output:D( Bit AlmEmpty) ;  //_GUI 272,102
 Object Output:E( Bit Empty) ;  //_GUI 272,107
 Object Output:F( Bit Done) ;  //_GUI 273,120
 Object Output:G( Bit Busy) ;  //_GUI 254,156
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 97,176
 Object ( MSB004 Type) Input:H;  //_GUI 74,174
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 41,175
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 58,176
 Object ( Bit In2) Input:I;  //_GUI 45,183
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:1:BitLen), 3, >)"
 Object Output:H( Bit Trap) ;  //_GUI 107,188
 //_ Attributes Trap="Rounding the address size up to 4bits because that is the smallest addressable memory chunk."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 85,183
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 94,186
 Object Text;  //_GUI 43,161,Minimum address size is defined here.  If address is less than AddrMin then it makes it the minimum size.
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 252,118
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 94,117
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In1) ;  //_GUI 161,156
 Object ( Bit OFL, Variant Out1) Convert( Variant Type
    , Variant Data) ;  //_GUI 81,173
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 82,119
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 116,102
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 237,154
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 118,149
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 169,117
 Object Text;  //_GUI 13,155,Don't default Wait to 0 because must use this to control when data comes out.
 Object ( Variant RdData, Variant WrRdyCnt, Bit WrBsy
    , Bit WrAlmBsy, Bit WrErr, Variant RdRdyCnt, Bit RdBsy
    , Bit RdAlmBsy, Bit RdErr) FIFO_Basic( Variant WrData, Variant AddrBits
    , Variant BsyBits, Bit WrClk, Bit WrEn, Bit RdClk
    , Bit RdEn, Bit CLR) ;  //_GUI 137,80
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 172,143
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 175,146
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 178,6
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 179,73
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 175,83
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 231,61
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 209,119
 Object ( Variant CO, Variant OFL, Variant S
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) ADSU
    ( Variant A, Variant B, Bit Add, Bit CI
    , Bit ClkG, Bit AClr, Variant Go, Bit Wait) ;  //_GUI 252,59
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 184,146
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 181,143
 Object ( Bit In) Input:J;  //_GUI 242,78
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 251,86,Add one to the read ready count if we have something on deck
 Object Text;  //_GUI 178,21,Needed to pass timing
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 119,96
 Object ( Bit OnDeckRdy, Bit FifoRdEn, Bit OnDeckErr) OnDeck
    ( Bit FifoRdRdy, Bit GetNextRd, Bit ClrErr, Bit Clk
    , Bit CLR) ;  //_GUI 185,118
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 266,120
 Object ( Bit Out) INVERT:D( Bit In1) ;  //_GUI 225,107
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In3) ;  //_GUI 209,109
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In0) ;  //_GUI 52,183
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 119,90
 Object ( Variant S) $AbsorbCO( Bit CO, Bit OFL
    , Variant S) ;  //_GUI 273,59
 Object ( Variant Q) RegClr:B( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 224,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In0) ;  //_GUI 215,146
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In0) ;  //_GUI 212,143
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:P
    ( Variant In0) ;  //_GUI 227,63
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 240,9
 //_ Attributes Documentation="Bit"
 Object ( Variant CO, Variant OFL, Variant S
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) ADSU:A
    ( Variant A, Variant B, Bit Add, Bit CI
    , Bit ClkG, Bit AClr, Variant Go, Bit Wait) ;  //_GUI 252,7
 Object ( Bit In) Input:K;  //_GUI 242,26
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant S) $AbsorbCO:A( Bit CO, Bit OFL
    , Variant S) ;  //_GUI 273,7
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In3) ;  //_GUI 246,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In0) ;  //_GUI 172,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In3) ;  //_GUI 215,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:T
    ( Bit In0) ;  //_GUI 212,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In0) ;  //_GUI 237,8
 Object ( Bit Out) INVERT:E( Bit In1) ;  //_GUI 240,15
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:V
    ( Bit In3) ;  //_GUI 209,68
 Object ( Variant Q, Variant Value) RegClrDepthVal( Variant D
    , Bit ClkG, Bit EN, Bit CLR, Variant depth) ;  //_GUI 222,16
 Object ( LSB003 In) Input:L;  //_GUI 218,29
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 260,105
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In0) ;  //_GUI 165,99
 Object Text;  //_GUI 178,67,Needed to pass timing
 Object Text;  //_GUI 220,82,Allign OnDeckRdy with RdRdyCnt
 Object Text;  //_GUI 218,10,Allign OnDeckRdy with WrRdyCnt
 Object Text;  //_GUI 251,34,Add one to the write ready count if we don't have something on deck
 Object Text;  //_GUI 275,19,Increase the dataset by one so we can represent 0 to 2^Size
 Object Text;  //_GUI 274,71,Increase the dataset by one so we can represent 0 to 2^Size
 Object Text;  //_GUI 185,111,Prefetch the data when available.
 Object Text;  //_GUI 138,110,(2^Size)-1 elements in the FIFO plus one prefetched in the registers equals 2^Size elements.
 Object Text;  //_GUI 278,109,Empty when OnDeckBsy and RdBsy
 Object Text;  //_GUI 279,123,Done when OnDeckRdy and not Waiting
 Object Text;  //_GUI 81,126,Use Go when not Busy

 //_ Behavior Topology
 Output.0 = FIFO_Basic.0;  //_GUI 156,3
 Output:A.0 = $AbsorbCO:A.0;  
 Output:B.0 = $AbsorbCO.0;  
 Output:C.0 = FIFO_Basic.3;  //_GUI 169,97, 169,91
 Output:D.0 = FIFO_Basic.7;  
 Output:E.0 = AND:B.0;  
 Output:F.0 = Junction:J.1;  
 Output:G.0 = VouchBit.0;  
 $Select.0 = Convert.1;  
 $Select.1 = $SelectOut.1;  
 $Select.2 = Junction.1;  
 MSB.0 = Input:A.0;  //_GUI 36,178, 36,85
 $SelectOut.0 = MSB.0;  
 $SelectOut.1 = Junction:L.0;  //_GUI 53,181
 Output:H.0 = INVERT.0;  
 Junction.0 = Junction:L.1;  
 INVERT.0 = Junction.2;  //_GUI 86,189
 AND.0 = Junction:F.1;  
 AND.1 = INVERT:B.0;  //_GUI 250,123, 250,152
 AND:A.0 = Input:F.0;  
 AND:A.1 = INVERT:A.0;  
 Junction:A.0 = FIFO_Basic.2;  //_GUI 162,88
 Convert.0 = Input:H.0;  
 Convert.1 = $SelectOut.0;  
 INVERT:A.0 = Junction:A.0;  //_GUI 78,122, 78,157
 Junction:B.0 = Input:E.0;  
 VouchBit.0 = Junction:A.1;  
 INVERT:B.0 = Input:G.0;  
 INVERT:C.0 = Junction:W.2;  //_GUI 166,120
 FIFO_Basic.0 = Input.0;  
 FIFO_Basic.1 = $Select.0;  //_GUI 109,85, 109,179
 FIFO_Basic.2 = Input:B.0;  
 FIFO_Basic.3 = Junction:M.1;  
 FIFO_Basic.4 = AND:A.0;  //_GUI 123,94, 123,120
 FIFO_Basic.5 = Junction:I.1;  
 FIFO_Basic.6 = OnDeck.1;  //_GUI 132,100, 132,136, 210,136, 210,123
 FIFO_Basic.7 = Junction:B.1;  
 Junction:C.0 = Junction:I.2;  //_GUI 120,144
 Junction:D.0 = Junction:B.2;  //_GUI 117,147
 RegClr.0 = FIFO_Basic.1;  //_GUI 159,8, 159,85
 RegClr.1 = Junction:R.0;  //_GUI 173,11
 RegClr.3 = Junction:E.1;  //_GUI 176,17
 RegClr:A.0 = FIFO_Basic.5;  //_GUI 165,75, 165,97
 RegClr:A.1 = Junction:C.0;  //_GUI 173,78
 RegClr:A.3 = Junction:E.2;  
 Junction:E.0 = Junction:D.0;  
 Zero.0 = Junction:P.1;  
 Junction:F.0 = OnDeck.0;  
 ADSU.0 = Junction:P.0;  //_GUI 228,61
 ADSU.1 = Zero.0;  
 ADSU.3 = RegClr:B.0;  
 ADSU.4 = Junction:O.1;  //_GUI 244,73, 244,144
 ADSU.5 = Junction:Q.2;  
 ADSU.6 = Input:J.0;  
 Junction:G.0 = Junction:D.1;  
 Junction:H.0 = Junction:C.1;  
 Junction:I.0 = Input:D.0;  
 OnDeck.0 = INVERT:C.0;  
 OnDeck.1 = Junction:J.2;  //_GUI 179,123, 179,138, 267,138
 OnDeck.3 = Junction:H.0;  //_GUI 182,129
 OnDeck.4 = Junction:G.0;  
 Junction:J.0 = AND.0;  
 INVERT:D.0 = Junction:K.2;  
 Junction:K.0 = Junction:F.0;  
 Junction:L.0 = Input:I.0;  
 Junction:M.0 = Input:C.0;  
 $AbsorbCO.0 = ADSU.0;  
 $AbsorbCO.1 = ADSU.1;  
 $AbsorbCO.2 = ADSU.2;  
 RegClr:B.0 = Junction:V.2;  
 RegClr:B.1 = Junction:O.0;  //_GUI 213,72
 RegClr:B.3 = Junction:S.2;  
 Junction:N.0 = Junction:G.1;  
 Junction:O.0 = Junction:H.1;  
 Junction:P.0 = RegClr:A.0;  //_GUI 192,64, 192,76
 Zero:A.0 = Junction:U.2;  //_GUI 238,12
 ADSU:A.0 = Junction:U.1;  
 ADSU:A.1 = Zero:A.0;  
 ADSU:A.3 = INVERT:E.0;  
 ADSU:A.4 = Junction:T.1;  //_GUI 244,21, 244,33
 ADSU:A.5 = Junction:Q.1;  //_GUI 247,24
 ADSU:A.6 = Input:K.0;  
 $AbsorbCO:A.0 = ADSU:A.0;  
 $AbsorbCO:A.1 = ADSU:A.1;  
 $AbsorbCO:A.2 = ADSU:A.2;  
 Junction:Q.0 = Junction:N.1;  //_GUI 247,147
 Junction:R.0 = Junction:M.0;  //_GUI 120,33
 Junction:S.0 = Junction:N.0;  
 Junction:T.0 = Junction:R.1;  
 Junction:U.0 = RegClr.0;  
 INVERT:E.0 = RegClrDepthVal.0;  
 Junction:V.0 = Junction:K.1;  
 RegClrDepthVal.0 = Junction:V.1;  //_GUI 210,18
 RegClrDepthVal.1 = Junction:T.0;  //_GUI 213,21
 RegClrDepthVal.3 = Junction:S.1;  //_GUI 216,27
 RegClrDepthVal.4 = Input:L.0;  
 AND:B.0 = Junction:W.1;  //_GUI 256,107, 256,100
 AND:B.1 = INVERT:D.0;  
 Junction:W.0 = FIFO_Basic.6;  
}

Object ( Variant Out1, NULL Out2) UnPackMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\UnPackMSB",Icon="Exposer_In",Documentation="var"
{
 // Unpacks an MSB-shaped List into its data elements.
 //
 // Revision 2 - 12/07/2006
 // Used to var split, now pass through with NULL. See Bug 508
 // Revision 1 - 11/13/2002
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,21
 Object Output( Variant Out1) ;  //_GUI 46,21
 Object Output:A( NULL Out2) ;  //_GUI 46,28
 Object ( Bit In) Input:A;  //_GUI 25,13
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:B( Bit Warning) ;  //_GUI 36,13
 //_ Attributes Trap="UnPackMSB - Attempt to UnPack non-List data set."
 Object Text;  //_GUI 14,39,A List should be propogated to this object, in which case the List overload will be instantiated.  In this case however, we have received a non-List type.  We simply pass it along on the lower output, remove the upper output by casting it to NULL and raise a warning message.
 Object ( NULL Out1) NULL;  //_GUI 30,26

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
 Output:B.0 = Input:A.0;  
}

Object ( Variant Out1, Variant Out2) UnPackMSB( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\UnPackMSB",Icon="Exposer_In"
{
 // Unpacks an MSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 13,24
 Object Output( Variant Out1) ;  //_GUI 38,23
 Object Output:A( Variant Out2) ;  //_GUI 38,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,22

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( Variant Iteration, Bit FirstGoBusy, Bit Active
    , Bit Done, Bit Busy) GoForN_Down( Variant Iterations, Bit IsFirstGo
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced"
{
 // Consumes N GOs before a Done is output.  Uses the standard GDBW model.  Outputs the Go iteration count decrementing from N-1 to 0. Larger datasets for Iterations at higher frequencies may not pass timing specifications.  This device also supports nested iteration loops.
 //
 // Inputs:
 //
 // Var/List Iterations: This value indicates the number of iterations or Goes that are consumed before a Done is output.  This value is only read in on the first Go then is ignored for the rest of the Go iterations after which it will be read in again on the next Go. A Go with an Iterations value of 0 will produce no Done at all.  Iterations can be a list which yields nested loops, each loop with its own Iteration and Done. Each time a nest level rolls over, it rereads its Iterations. The least significant element in Iterations is the inner loop.
 //
 // Bit IsFirstGo: Must be high on the first Go of the iteration count or the object will not start counting Goes.  If IsFirstGo is high before the previous iteration set is complete, IsFirstGo is ignored. In other words it can't be used to start a new set of Iterations before the current is complete.  Often this input is just connected to the inverse of the FirstGoBusy
 // output.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected
 //
 // Bit Go: Goes are counted.
 //
 // Bit Wait: Has a value of 0 if disconnected.  Holds off the Done.
 //
 // Outputs:
 //
 // Var/List Iteration: The Go iteration value.  Same dataset as the Iterations input.  The iteration value after the first Go is N-1. The iteration value after the last Go (and Done) is 0. For nested loops, there is one Iteration counter for each nest level.
 //
 // Bit FirstGoBusy: Is high while the current iteration set is in process.  Tells IsFirstGo to hold off.
 //
 // Bit Active: Same behavior as the FirstGoBusy signal except it does not drop during the last Go.
 //
 // Bit/List Done: Is high after the last Go iteration. One for each nest level.
 //
 // Bit Busy: Tells the Go to hold off.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx, BINxxx and List
 //
 // Revision 1
 // Revision 2 - 7/19/06 improved speed, added documentation for List overload.
 // 12/18/06 Changed List overload documentation (see List overload)
 //_ Object Prototypes
 Object ( Variant Iterations) Input;  //_GUI 34,26
 Object ( Bit IsFirstGo) Input:A;  //_GUI 32,89
 Object ( Bit ClkG) Input:B;  //_GUI 32,133
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 32,136
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 32,139
 Object ( Bit Wait) Input:E;  //_GUI 126,140
 //_ Attributes Constant="0"
 Object Output( Variant Iteration) ;  //_GUI 206,25
 Object Output:A( Bit FirstGoBusy) ;  //_GUI 204,83
 Object Output:B( Bit Active) ;  //_GUI 204,88
 Object Output:C( Bit Done) ;  //_GUI 204,104
 Object Output:D( Bit Busy) ;  //_GUI 203,161
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 124,23
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 99,53
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 124,38
 Object ( Bit Out1) EqualOne( Variant In1) ;  //_GUI 89,39
 Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 127,83
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 142,83
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 137,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 140,25
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 140,138
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 161,136
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 188,81
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 176,80
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 117,45
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 161,158
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In1) ;  //_GUI 157,137
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 135,140
 Object Text;  //_GUI 130,79,Going
 Object Text;  //_GUI 138,34,Iteration=0
 Object Text;  //_GUI 171,140,WasLastGo
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 188,102
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 182,85
 Object Text;  //_GUI 192,130,Done when WasLastGo and Going
 Object Text;  //_GUI 191,63,FirstGoBusy when Going and not WasLastGo
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 200,83
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 46,84
 Object Text;  //_GUI 80,86,FirstGo
 Object Text;  //_GUI 59,90,FirstGo when (Iterations!=0) & Go & IsFirstGo & !FirstGoBusy
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 69,60
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In1) ;  //_GUI 157,70
 Object Text;  //_GUI 89,62,EN Reg when FirstGo OR (Go & Going & (Iteration != 0))
 Object Text;  //_GUI 124,131,Enter on FIrstGo Leave on Done
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 154,85
 Object ( Variant Out1) Dec( Variant In1) ;  //_GUI 89,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In3) ;  //_GUI 120,48
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 120,93
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 114,90
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In3) ;  //_GUI 114,42
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 173,159
 Object Text;  //_GUI 184,151,Busy when Going & (Iteration=0) & Waiting
 Object Text;  //_GUI 162,144,WasLastGo when (Iteration=0) & not Waiting
 Object Text;  //_GUI 87,48,Eq One is the same as Eq zero after the next EN
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 73,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 67,26
 Object Text;  //_GUI 136,46,By registering the EqualOne we eliminate the need for an EqualZero on the output of the Iteration register.  This improves our runtime speed
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In3) ;  //_GUI 38,92
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In3) ;  //_GUI 81,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In0) ;  //_GUI 40,26
 Object ( Variant Out1) AND:E( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 56,82
 Object ( Variant Out1) AND:F( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 87,55
 Object ( Bit Out1) VouchBit:B( Variant In1) ;  //_GUI 68,82
 Object Text;  //_GUI 71,29,Select Iterations on FirstGo
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In0) ;  //_GUI 81,84
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 41,29
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 101,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In1) ;  //_GUI 182,88
 Object ( Variant O) Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 102,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In3) ;  //_GUI 81,44
 Object ( Bit Out1) EqualOne:A( Variant In1) ;  //_GUI 89,36
 Object ( Variant Out1) Dec:A( Variant In1) ;  //_GUI 89,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:S
    ( Variant In1) ;  //_GUI 85,23
 Object Text;  //_GUI 88,11,Put Mux after Dec to shorten datapath of Go
 Object ( Bit Out) AND:G( Bit In1, Bit In2) ;  //_GUI 163,104
 Object ( Bit Out) INVERT:D( Bit In1) ;  //_GUI 141,103
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:T
    ( Bit In1) ;  //_GUI 157,108
 Object ( Bit Out) AND:H( Bit In1, Bit In2) ;  //_GUI 188,115
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:U
    ( Bit In1) ;  //_GUI 182,103
 Object ( Bit Out) AND:I( Bit In1, Bit In2) ;  //_GUI 163,97
 Object ( Bit Out) INVERT:E( Bit In1) ;  //_GUI 141,96
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:V
    ( Bit In3) ;  //_GUI 135,105
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In1) ;  //_GUI 157,101

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction:E.1;  
 Output:B.0 = Junction:Q.1;  
 Output:C.0 = AND:C.0;  
 Output:D.0 = AND:D.0;  
 RegClr.0 = Mux.0;  
 RegClr.1 = Junction:K.1;  //_GUI 115,28
 RegClr.2 = Junction:A.1;  //_GUI 118,31
 RegClr.3 = Junction:H.1;  //_GUI 121,34
 OR.0 = Junction:N.2;  
 OR.1 = AND:F.0;  
 RegClr:A.0 = Mux:A.0;  
 RegClr:A.1 = Junction:K.2;  
 RegClr:A.2 = Junction:A.2;  
 RegClr:A.3 = Junction:H.2;  
 EqualOne.0 = Junction:L.2;  //_GUI 68,42
 State.0 = Junction:P.1;  
 State.1 = AND:H.0;  //_GUI 125,88, 125,129, 201,129, 201,118
 State.2 = Junction:J.2;  
 State.3 = Junction:I.2;  
 VouchBit.0 = State.0;  
 VouchBit:A.0 = RegClr:A.0;  
 Junction.0 = RegClr.0;  
 INVERT.0 = Junction:C.1;  
 AND.0 = Junction:B.1;  
 AND.1 = INVERT.0;  
 AND:A.0 = INVERT:A.0;  
 AND:A.1 = Junction:D.1;  
 INVERT:A.0 = AND:I.0;  //_GUI 175,83, 175,100
 Junction:A.0 = OR.0;  //_GUI 118,56
 AND:B.0 = Junction:B.2;  //_GUI 158,160
 AND:B.1 = Junction:C.2;  //_GUI 136,163
 Junction:B.0 = Junction:T.2;  
 Junction:C.0 = Input:E.0;  
 AND:C.0 = Junction:U.1;  
 AND:C.1 = AND:G.0;  
 Junction:D.0 = Junction:G.1;  
 Junction:E.0 = AND:A.0;  
 INVERT:B.0 = Junction:E.0;  //_GUI 43,87, 43,76, 201,76
 INVERT:C.0 = Junction:F.0;  //_GUI 67,63, 67,71
 Junction:F.0 = VouchBit:A.0;  //_GUI 158,41
 Junction:G.0 = VouchBit.0;  
 Dec.0 = Junction:S.1;  
 Junction:H.0 = Junction:I.1;  
 Junction:I.0 = Input:C.0;  //_GUI 121,137
 Junction:J.0 = Input:B.0;  //_GUI 115,134
 Junction:K.0 = Junction:J.1;  
 AND:D.0 = AND:B.0;  
 AND:D.1 = Junction:G.2;  //_GUI 171,164, 171,167, 155,167
 Cast.0 = Junction:L.0;  //_GUI 68,20
 Cast.1 = Junction.0;  //_GUI 71,23, 71,17, 141,17
 Junction:L.0 = Junction:O.1;  
 Junction:M.0 = Input:D.0;  //_GUI 39,140
 Junction:N.0 = Junction:P.0;  
 Junction:O.0 = Input.0;  
 AND:E.0 = NotZero.0;  //_GUI 54,84, 54,32
 AND:E.1 = INVERT:B.0;  
 AND:E.2 = Input:A.0;  
 AND:E.3 = Junction:M.2;  
 AND:F.0 = Junction:M.1;  //_GUI 39,57
 AND:F.1 = Junction:G.0;  //_GUI 65,60, 65,73, 155,73
 AND:F.2 = INVERT:C.0;  
 VouchBit:B.0 = AND:E.0;  
 Junction:P.0 = VouchBit:B.0;  
 NotZero.0 = Junction:O.2;  
 Mux.0 = Dec.0;  
 Mux.1 = Dec:A.0;  
 Mux.2 = Junction:R.1;  //_GUI 82,30
 Junction:Q.0 = Junction:D.2;  
 Mux:A.0 = EqualOne:A.0;  
 Mux:A.1 = EqualOne.0;  
 Mux:A.2 = Junction:R.2;  
 Junction:R.0 = Junction:N.1;  
 EqualOne:A.0 = Junction:S.2;  //_GUI 86,39
 Dec:A.0 = Junction:L.1;  
 Junction:S.0 = Cast.0;  //_GUI 86,21
 AND:G.0 = INVERT:D.0;  
 AND:G.1 = Junction:T.1;  
 INVERT:D.0 = Junction:V.2;  
 Junction:T.0 = Junction:W.2;  
 AND:H.0 = Junction:U.2;  //_GUI 183,117
 AND:H.1 = AND.0;  //_GUI 183,120, 183,139
 Junction:U.0 = Junction:Q.2;  
 AND:I.0 = INVERT:E.0;  
 AND:I.1 = Junction:W.1;  
 INVERT:E.0 = Junction:V.1;  //_GUI 136,99
 Junction:V.0 = Junction:C.0;  
 Junction:W.0 = Junction:F.2;  
}

Object ( List Iteration, Bit FirstGoBusy, Bit Active
    , List Done, Bit Busy) GoForN_Down( List Iterations, Bit IsFirstGo
    , Bit ClkG, Bit CLR, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced",Documentation="List"
{
 // Revision 2 - 12/18/06
 // Changed footprint from List I/Os of Iterations, IsFirstGo, Iteration, FirstGoBusy, Active and Done to List I/Os of Iterations, Iteration and Done.
 // Made to work properly (wasn't nesting loops).
 // Made so will work with larger than List of 2.
 // Revision 1
 //_ Object Prototypes
 Object ( List Iterations) Input;  //_GUI 13,10
 Object ( Bit IsFirstGo) Input:A;  //_GUI 13,21
 Object ( Bit ClkG) Input:B;  //_GUI 13,24
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:C;  //_GUI 13,27
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 13,30
 Object ( Bit Wait) Input:E;  //_GUI 123,101
 Object Output( List Iteration) ;  //_GUI 135,19
 Object Output:A( Bit FirstGoBusy) ;  //_GUI 135,25
 Object Output:B( Bit Active) ;  //_GUI 135,28
 Object Output:C( List Done) ;  //_GUI 128,83
 Object Output:D( Bit Busy) ;  //_GUI 81,100
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 31,27
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 28,30
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 122,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 25,8
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 67,28
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 50,30
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 65,58
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 53,63
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In1) ;  //_GUI 116,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 40,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 62,32
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 115,81
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 105,51
 Object ( Variant Iteration, Bit FirstGoBusy, Bit Active
    , Variant Done, Bit Busy) GoForN_Down( Variant Iterations, Bit IsFirstGo
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) ;  //_GUI 83,17
 Object ( Variant Iteration, Bit FirstGoBusy, Bit Active
    , Variant Done, Bit Busy) GoForN_Down:A( Variant Iterations, Bit IsFirstGo
    , Bit ClkG, Bit AClr, Bit Go, Bit Wait) ;  //_GUI 79,72

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = Junction:C.1;  
 Output:B.0 = GoForN_Down.2;  //_GUI 114,29, 114,25
 Output:C.0 = ListOut:A.0;  
 Output:D.0 = GoForN_Down:A.4;  //_GUI 74,101, 74,89
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:C.0;  
 Junction:B.0 = Input:D.0;  
 ListOut.0 = GoForN_Down:A.0;  //_GUI 120,22, 120,74
 ListOut.1 = GoForN_Down.0;  
 ListIn.0 = Input.0;  
 AND.0 = Junction:B.1;  //_GUI 45,30, 45,31
 AND.1 = Junction:E.1;  
 INVERT.0 = Junction:F.0;  //_GUI 47,33, 47,52
 Mux.0 = Junction:E.2;  //_GUI 63,60
 Mux.1 = Junction:D.2;  //_GUI 41,63
 Mux.2 = INVERT:A.0;  
 INVERT:A.0 = Junction:C.2;  //_GUI 51,66, 51,56, 117,56
 Junction:C.0 = GoForN_Down.1;  //_GUI 117,22
 Junction:D.0 = Input:A.0;  
 Junction:E.0 = INVERT.0;  
 ListOut:A.0 = GoForN_Down:A.3;  
 ListOut:A.1 = GoForN_Down.3;  //_GUI 110,83, 110,31
 Junction:F.0 = GoForN_Down:A.1;  //_GUI 106,77
 GoForN_Down.0 = ListIn.1;  //_GUI 42,19, 42,10
 GoForN_Down.1 = Junction:D.1;  
 GoForN_Down.2 = Junction.1;  
 GoForN_Down.3 = Junction:A.1;  
 GoForN_Down.4 = AND.0;  
 GoForN_Down.5 = Junction:F.1;  //_GUI 106,34
 GoForN_Down:A.0 = ListIn.0;  //_GUI 38,74, 38,13
 GoForN_Down:A.1 = Mux.0;  //_GUI 77,77, 77,61
 GoForN_Down:A.2 = Junction.2;  //_GUI 35,80
 GoForN_Down:A.3 = Junction:A.2;  //_GUI 32,83
 GoForN_Down:A.4 = Junction:B.2;  //_GUI 29,86
 GoForN_Down:A.5 = Input:E.0;  //_GUI 130,89, 130,102
}

Object ( Variant Address, Variant Size, Variant LastDone
    , Bit Done) DramAddressGen( MSB032 Address, MSB024 Nums, Bit Last
    , Bit Start, Bit Wait) 
{
 //_ Object Prototypes
 Object ( MSB032 Address) Input;  //_GUI 50,84
 Object ( MSB024 Nums) Input:A;  //_GUI 50,87
 //_ Attributes WidgetLeft="20",WidgetWidth="204",WidgetHeight="50",Widget="TextBox"
 Object ( Bit Last) Input:B;  //_GUI 53,134
 Object ( Bit Start) Input:C;  //_GUI 53,141
 Object ( Bit Wait) Input:D;  //_GUI 105,196
 Object Output( Variant Address) ;  //_GUI 277,84
 Object Output:A( Variant Size) ;  //_GUI 277,87
 Object Output:B( Variant LastDone) ;  //_GUI 277,94
 Object Output:C( Bit Done) ;  //_GUI 277,97
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 327,32
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 128,63
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 76,83
 Object ( Variant Out1) Dec( Variant In1) ;  //_GUI 59,85
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 104,141
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 111,140
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 160,86
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 220,86
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 238,87
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 257,83
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 156,65
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 176,29
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 299,29
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 302,42
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 269,54
 Object ( MSB004 MSB004) Input:E;  //_GUI 265,58
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 232,64
 Object ( Variant Out1) CollectMSB:B( Variant In2, Variant In3) ;  //_GUI 224,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 215,68
 Object ( MSB016 MSB016) Input:F;  //_GUI 225,65
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( MSB020 MSB020) Input:G;  //_GUI 218,54
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 97,40
 Object ( List Out1, List Out2, List Out3) Junction:C
    ( List In3) ;  //_GUI 92,59
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 108,68
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 104,69
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 217,96
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 158,135
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 107,55
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 209,90
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 234,109
 Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 243,140
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 77,129
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 89,130
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 101,132
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnBusy( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 111,122
 Object ( Variant "A<B", Variant "A=B", Variant "A>B") Compare
    ( Variant A, Variant B) ;  //_GUI 307,62
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 295,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 288,66
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 222,107
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 206,96
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 207,109
 Object ( Variant Out1) Inc( Variant In1) ;  //_GUI 254,64
 Object ( Variant Out1) Inc:A( Variant In1) ;  //_GUI 246,53
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 240,108
 Object ( Variant Address, Variant Size, Variant LastDone
    , Bit Done) AddressSizeGen( MSB032 Address, MSB024 Nums, Bit Go) ;  //_GUI 181,86
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnBusy:A( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 133,141
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 129,142
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In3) ;  //_GUI 126,159

 //_ Behavior Topology
 Output.0 = ListIn:A.1;  
 Output:A.0 = ListIn:A.0;  
 Output:B.0 = Reg:A.0;  //_GUI 263,95, 263,111
 Output:C.0 = RegOnGo.3;  
 ListOut.0 = Sub.1;  //_GUI 327,47
 ListOut.1 = Add.1;  
 RegClr.0 = Mux.0;  //_GUI 122,65, 122,58
 RegClr.2 = OR.0;  
 ListOut:A.0 = Dec.0;  
 ListOut:A.1 = Input.0;  
 Dec.0 = Input:A.0;  
 Junction.0 = Input:C.0;  
 Reg.0 = Junction.1;  
 ListIn.0 = Junction:A.2;  //_GUI 157,89
 ListOut:B.0 = Junction:F.1;  
 ListOut:B.1 = AddressSizeGen.0;  
 RegOnGo.0 = ListOut:B.0;  
 RegOnGo.3 = Junction:E.1;  //_GUI 228,98, 228,97
 ListIn:A.0 = RegOnGo.0;  //_GUI 253,86, 253,89
 Junction:A.0 = RegClr.0;  
 ListIn:B.0 = Junction:A.0;  //_GUI 157,32
 Add.0 = ListIn:B.1;  
 Add.1 = CollectMSB.0;  //_GUI 285,34, 285,57
 Sub.0 = Junction:I.1;  
 Sub.1 = Junction:J.0;  //_GUI 289,47
 CollectMSB.0 = Inc:A.0;  
 CollectMSB.1 = Input:E.0;  
 CollectMSB:A.0 = Input:F.0;  
 CollectMSB:A.1 = Junction:B.1;  
 CollectMSB:B.0 = Input:G.0;  
 CollectMSB:B.1 = Junction:B.0;  //_GUI 216,58
 Junction:B.0 = Junction:F.0;  //_GUI 210,69
 Cast.0 = Junction:C.1;  //_GUI 93,42
 Cast.1 = ListOut.0;  //_GUI 81,45, 81,26, 338,26
 Junction:C.0 = ListOut:A.0;  //_GUI 93,86
 OR.0 = Junction:D.2;  
 OR.1 = Junction:E.2;  //_GUI 100,73, 100,118, 218,118
 Junction:D.0 = Junction.0;  
 Junction:E.0 = Junction:K.1;  
 OR:A.0 = RegOnBusy.3;  //_GUI 133,137, 133,133
 OR:A.1 = RegOnBusy:A.3;  //_GUI 155,140, 155,152
 Mux.0 = Cast.0;  
 Mux.1 = Junction:C.2;  
 Mux.2 = Junction:D.1;  //_GUI 105,63
 Junction:F.0 = AddressSizeGen.1;  
 Junction:G.0 = OR:B.0;  
 State.0 = Junction:G.2;  //_GUI 235,142
 State.1 = Junction.2;  //_GUI 231,145, 231,157, 105,157
 INVERT.0 = State.0;  //_GUI 65,132, 65,172, 260,172, 260,143
 AND.0 = INVERT.0;  
 AND.1 = Input:B.0;  
 Junction:H.0 = AND.0;  
 RegOnBusy.0 = Junction:H.0;  //_GUI 102,124
 RegOnBusy.3 = Junction:H.1;  
 RegOnBusy.4 = Junction:M.1;  //_GUI 127,136
 Compare.0 = Junction:I.2;  //_GUI 296,64
 Compare.1 = Junction:J.1;  
 Junction:I.0 = ListIn:B.0;  //_GUI 195,44, 195,34
 Junction:J.0 = Inc.0;  
 OR:B.0 = AddressSizeGen.2;  //_GUI 222,94
 OR:B.1 = AND:A.0;  
 Junction:K.0 = AddressSizeGen.3;  
 AND:A.0 = Junction:K.2;  
 AND:A.1 = Compare.0;  //_GUI 200,114, 200,136, 344,136, 344,64
 Inc.0 = CollectMSB:A.0;  
 Inc:A.0 = CollectMSB:B.0;  
 Reg:A.0 = Junction:G.1;  
 AddressSizeGen.0 = ListIn.1;  
 AddressSizeGen.1 = ListIn.0;  
 AddressSizeGen.2 = OR:A.0;  //_GUI 175,97, 175,138
 RegOnBusy:A.0 = Junction:L.1;  
 RegOnBusy:A.3 = Junction:L.2;  //_GUI 130,152
 RegOnBusy:A.4 = Junction:M.2;  //_GUI 151,155, 151,160
 Junction:L.0 = Reg.0;  
 Junction:M.0 = Input:D.0;  //_GUI 127,197
}

Object ( Floating Out1) CollectFloating( Bit Sign, Variant BExp
    , Variant Mant) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the Sign, the Biased Exponent and the Mantissa (high bit implied) portions of a value into a Floating dataset.
 //
 // Inputs:
 //
 // Bit Sign: The sign bit.
 //
 // Variant SBExp: The biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded Floating value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Sign) Input;  //_GUI 21,17
 Object ( Variant BExp) Input:A;  //_GUI 21,20
 Object ( Variant Mant) Input:B;  //_GUI 21,26
 Object Output( Floating Out1) ;  //_GUI 71,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 44,20
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 27,16
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 57,20
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 28,24

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 ListOut.0 = MSB.0;  //_GUI 43,25, 43,27
 ListOut.1 = CollectMSB.0;  //_GUI 43,22, 43,19
 CollectMSB.0 = Input.0;  
 CollectMSB.1 = Input:A.0;  
 FloatingOut.0 = ListOut.0;  
 MSB.0 = Input:B.0;  
}

Object ( Variant Out1) MakeBias( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Determines the bias constant value for the size of exponent input.
 //
 // Inputs:
 //
 // Variant input: The exponent dataset for which a bias constant value will be generated..
 //
 // Outputs:
 //
 // Variant output: The bias constant value for the input exponent dataset.  The constant value is a most significant bit of zero and all other bits one.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 34,29
 Object Output( Variant Out1) ;  //_GUI 82,29
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 67,27
 Object Text;  //_GUI 67,24,Build our bias.
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 52,27
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 40,27

 //_ Behavior Topology
 Output.0 = ReverseBits.0;  
 ReverseBits.0 = INVERT.0;  
 INVERT.0 = One.0;  
 One.0 = Input.0;  
}

Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the whole and fractional portions of a value from a Fixed dataset.  SWhole and Fract combined are a two's complement number.  Care must be taken when using these portions of the Fixed dataset.  It is not recommended that you work with them as separate numbers, but if really want to, you can think of them like this: SWhole is a two's complement truncated whole number (rounded towards negative infinity) and Fract is the positive portion that is added to get the resulting fixed value.
 //
 // Example:
 //
 // Decimal	Binary	Interpretation
 // 2.25	010.01	2 + .25
 // -2.25	101.11	-3 + .75 = -2.25
 //
 // Note that two's complement of 9 (01001) is -9 (10111)
 //
 // Inputs:
 //
 // Variant input: The Fixed value to be exposed.
 //
 // Outputs:
 //
 // Variant SWhole: The signed whole portion of the Fixed dataset as a two's complement interpretation of the MSBxxx dataset.  Note that this is not a dataset of the name Signed.
 //
 // Variant Fract: The fractional portion of the Fixed dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 20,26
 Object Output( Variant SWhole) ;  //_GUI 52,25
 Object Output:A( Variant Fract) ;  //_GUI 52,28
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 26,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,24

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 FixedIn.0 = Input.0;  
 ListIn.0 = FixedIn.0;  
}

Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the whole and fractional portions of a value into a Fixed dataset.  SWhole and Fract combined are a two's complement number.  Care must be taken when using these portions of the Fixed dataset.  It is not recommended that you work with them as separate numbers, but if really want to, you can think of them like this: SWhole is a two's complement truncated whole number (rounded towards negative infinity) and Fract is the positive portion that is added to get the resulting fixed value.
 //
 // Example:
 //
 // Decimal	Binary	Interpretation
 // 2.25	010.01	2 + .25
 // -2.25	101.11	-3 + .75 = -2.25
 //
 // Note that two's complement of 9 (01001) is -9 (10111)
 //
 // Inputs:
 //
 // Variant SWhole: The signed whole portion of the Fixed dataset as a two's complement interpretation of the MSBxxx dataset.  Note that this is not a dataset of the name Signed.
 //
 // Variant Fract: The fractional portion of the Fixed dataset.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded complex value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant SWhole) Input;  //_GUI 20,38
 Object ( Variant Fract) Input:A;  //_GUI 20,41
 Object Output( Fixed Out1) ;  //_GUI 64,39
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 51,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 26,36
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 26,39

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 FixedOut.0 = ListOut.0;  
 ListOut.0 = MSB:A.0;  
 ListOut.1 = MSB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
}

Object ( Fixed Out1) CollectFixed( Variant SWhole, NULL Fract) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant SWhole) Input;  //_GUI 32,38
 Object ( NULL Fract) Input:A;  //_GUI 32,41
 Object Output( Fixed Out1) ;  //_GUI 64,39
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 51,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 FixedOut.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( Bit Out1) IsBit( Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is Bit.  Returns false in all other cases including contextual datasets of a single bit.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a Bit dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Bit, 0 otherwise.
 //
 // Date:
 // January 16, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 48,20
 Object Output( Bit Out1) ;  //_GUI 87,30
 Object ( Bit In) Input:A;  //_GUI 48,30
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 40,38,Everything besides a Bit matches this overload, so output a 0.  Note that single bit contextual datasets will match this overload and return a 0.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsBit( Bit Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 // Returns true if the input dataset is Bit.  Returns false in all other cases including contextual datasets of a single bit.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a Bit dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Bit, 0 otherwise.
 //
 // Date:
 // January 16, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 48,20
 Object Output( Bit Out1) ;  //_GUI 87,30
 Object ( Bit In) Input:A;  //_GUI 48,30
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 40,38,Everything besides a Bit matches the other overload, so output a 1.  Note that single bit contextual datasets will not match this overload and get a 0.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the real and imaginary portions of a complex value from a Complex dataset.  The real and imaginary datasets will both be either Fixed, Floating, or Signed.
 //
 // Inputs:
 //
 // Variant input: The complex value to expose.
 //
 // Outputs:
 //
 // Variant Real: The real portion of a complex dataset.
 //
 // Variant Imag: The imaginary portion of a complex dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 16,26
 Object Output( Variant Real) ;  //_GUI 52,25
 Object Output:A( Variant Imag) ;  //_GUI 52,28
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,24
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 25,24

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 ListIn.0 = ComplexIn.0;  
 ComplexIn.0 = Input.0;  
}

Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the real and imaginary portions of a complex value into a Complex dataset.  The real and imaginary datasets must both be Fixed, Floating, or Signed.
 //
 // Inputs:
 //
 // Variant Real: The real portion of a complex dataset.
 //
 // Variant Imag: The imaginary portion of a complex dataset.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded complex value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Real) Input;  //_GUI 32,38
 Object ( Variant Imag) Input:A;  //_GUI 32,41
 Object Output( Complex Out1) ;  //_GUI 68,39
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 51,37

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ComplexOut.0 = ListOut.0;  
}

Object ( Complex Out1) CollectComplex( Variant Real, NULL Imag) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Real) Input;  //_GUI 32,38
 Object ( NULL Imag) Input:A;  //_GUI 32,41
 Object Output( Complex Out1) ;  //_GUI 69,39
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 51,37

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ComplexOut.0 = ListOut.0;  
}

Object ( Variant Out1) Min_Rep( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Date:
 // 11/11/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,40
 Object Output( Variant Out1) ;  //_GUI 100,37
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 24,38
 //_ Attributes Documentation="bit"
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 86,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 20,40
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 69,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 47,42
 Object Text;  //_GUI 37,6,Remove all leading zeros then output as LSB.
 Object Text;  //_GUI 43,15,If MSB is a zero, remove it then recurse.
 Object Text;  //_GUI 46,103,If MSB is a one, LSB the original input and output it.
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 71,34
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 55,49
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 55,32

 //_ Behavior Topology
 Output.0 = $Select.0;  
 ExposeMSB.0 = Junction:A.1;  
 $Select.0 = Min_Rep.0;  
 $Select.1 = LSB.0;  //_GUI 82,40, 82,52
 $Select.2 = Junction:B.1;  
 Junction.0 = ExposeMSB.0;  
 Junction:A.0 = Input.0;  
 LSB.0 = $Select:A.0;  
 Junction:B.0 = Junction.2;  
 Min_Rep.0 = $Select:B.0;  //_GUI 71,35
 $Select:A.1 = Junction:A.2;  //_GUI 21,54
 $Select:A.2 = Junction:B.2;  //_GUI 48,57
 $Select:B.0 = ExposeMSB.1;  //_GUI 40,34, 40,43
 $Select:B.2 = Junction.1;  
}

Object ( NULL Out1) Min_Rep( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 16,24
 Object Output( NULL Out1) ;  //_GUI 29,24
 Object Text;  //_GUI 12,10,The minimum representation of NULL is NULL

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Signed Out1) Min_Rep( Signed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Signed"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 16,24
 Object Output( Signed Out1) ;  //_GUI 78,24
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 65,22
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 53,22
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 22,22
 Object ( Variant Out1) Min_Rep_Twos( Variant In1) ;  //_GUI 35,22

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedOut.0 = MSB.0;  
 MSB.0 = Min_Rep_Twos.0;  
 SignedIn.0 = Input.0;  
 Min_Rep_Twos.0 = SignedIn.0;  
}

Object ( Fixed Out1) Min_Rep( Fixed In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Fixed"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 16,30
 Object Output( Fixed Out1) ;  //_GUI 101,30
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 22,28
 Object ( Variant Out1) Min_Rep_Twos( Variant In1) ;  //_GUI 52,27
 Object Text;  //_GUI 45,19,Reduce whole part to smalles two's complement representation.
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 38,35
 //_ Attributes Documentation="Leaf"
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 53,35
 Object ( Variant Out1) ReverseBits:A( Variant In1) ;  //_GUI 65,35
 //_ Attributes Documentation="Leaf"
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 86,28
 Object Text;  //_GUI 43,44,Remove all trailing zeros of fraction

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 ExposeFixed.0 = Input.0;  
 Min_Rep_Twos.0 = ExposeFixed.0;  
 ReverseBits.0 = ExposeFixed.1;  //_GUI 36,38, 36,33
 Min_Rep.0 = ReverseBits.0;  
 ReverseBits:A.0 = Min_Rep.0;  
 CollectFixed.0 = Min_Rep_Twos.0;  
 CollectFixed.1 = ReverseBits:A.0;  //_GUI 82,33, 82,38
}

Object ( Bit Out1) Min_Rep( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 16,24
 Object Output( Bit Out1) ;  //_GUI 29,24
 Object Text;  //_GUI 12,10,A constant of 1 is represented by a single bit with a value of one.A constant of 0 is represented by a single bit with a value of zero.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Floating Out1) Min_Rep( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Floating"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 6,35
 Object Output( Floating Out1) ;  //_GUI 264,24
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 177,41
 //_ Attributes Documentation="Leaf"
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 192,41
 Object ( Variant Out1) ReverseBits:A( Variant In1) ;  //_GUI 204,41
 //_ Attributes Documentation="Leaf"
 Object Text;  //_GUI 181,38,Remove all trailing zeros of mant
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 22,33
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 246,22
 Object ( Variant Out1) Min_Rep_Twos( Variant In1) ;  //_GUI 137,29
 Object ( Bit OFL, Variant Out2) AddBias( Variant In1) ;  //_GUI 155,29
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 215,23
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 175,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 171,30
 Object Text;  //_GUI 177,13,Only overflows if trying to AddBias to MaxNeg, so in this case, sign extend one bit.
 Object Text;  //_GUI 62,25,two's complement bias
 Object ( Bit OFL, Variant Out1) RemoveBias( Variant In1) ;  //_GUI 60,35
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 84,29
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 125,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 77,36
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 107,29
 Object ( Bit In) Input:A;  //_GUI 101,30
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 197,23
 Object ( Bit In) Input:B;  //_GUI 191,24
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 87,18,Only overflows if trying to RemoveBias to MaxPos, so in this case, sign extend one bit.
 Object ( Variant Out1) EqualZero( Variant In1) ;  //_GUI 30,46
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:B
    ( Floating In0) ;  //_GUI 12,35
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 234,24
 Object ( MSB002 In) Input:C;  //_GUI 228,28
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant D
    , Bit S) ;  //_GUI 44,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 43,48
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 15,44
 //_ Attributes Documentation="bit"
 Object Text;  //_GUI 19,54,Detect negative zero also by removing the sign bit
 Object Text;  //_GUI 233,51,If zero, exp is 2 bits of zero

 //_ Behavior Topology
 Output.0 = CollectFloating.0;  
 ReverseBits.0 = ExposeFloating.2;  //_GUI 38,44
 Min_Rep.0 = ReverseBits.0;  
 ReverseBits:A.0 = Min_Rep.0;  
 ExposeFloating.0 = Junction:B.1;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 246,10, 38,10
 CollectFloating.1 = $Select:B.0;  
 CollectFloating.2 = ReverseBits:A.0;  //_GUI 246,44
 Min_Rep_Twos.0 = $Select:A.0;  
 AddBias.0 = Min_Rep_Twos.0;  
 $Select.0 = $SelectOut.0;  //_GUI 215,20, 187,20
 $Select.1 = CollectMSB:A.0;  //_GUI 212,28, 212,26
 $Select.2 = Junction.1;  
 $SelectOut.0 = AddBias.1;  //_GUI 168,25, 168,34
 $SelectOut.1 = Junction.0;  //_GUI 172,28
 Junction.0 = AddBias.0;  
 RemoveBias.0 = $SelectOut:B.0;  
 $SelectOut:A.0 = RemoveBias.1;  //_GUI 81,31, 81,40
 $SelectOut:A.1 = Junction:A.0;  //_GUI 78,34
 $Select:A.0 = $SelectOut:A.0;  //_GUI 125,27, 96,27
 $Select:A.1 = CollectMSB.0;  //_GUI 122,34, 122,32
 $Select:A.2 = Junction:A.1;  
 Junction:A.0 = RemoveBias.0;  
 CollectMSB.0 = Input:A.0;  
 CollectMSB.1 = $SelectOut:A.1;  
 CollectMSB:A.0 = Input:B.0;  
 CollectMSB:A.1 = $SelectOut.1;  
 EqualZero.0 = ExposeMSB.1;  
 Junction:B.0 = Input.0;  
 $Select:B.0 = $Select.0;  
 $Select:B.1 = Input:C.0;  
 $Select:B.2 = Junction:C.1;  //_GUI 234,49
 $SelectOut:B.0 = ExposeFloating.1;  
 $SelectOut:B.1 = Junction:C.0;  
 Junction:C.0 = EqualZero.0;  
 ExposeMSB.0 = Junction:B.2;  //_GUI 13,47
}

Object ( Variant Out1) $XOR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Variant"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 9,17
 Object ( Variant In2) Input:A;  //_GUI 9,25
 Object Output( Variant Out1) ;  //_GUI 99,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 19,15
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 19,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 63,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 15,17
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 81,14
 Object ( Variant Out1) $XOR( Variant In1, Variant In2) ;  //_GUI 46,15
 Object ( Variant Out1) $XOR:A( Variant In1, Variant In2) ;  //_GUI 46,23

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantIn:A.0 = Input:A.0;  
 VariantOut.0 = $XOR:A.0;  //_GUI 60,21, 60,26
 VariantOut.1 = $XOR.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 76,16, 76,11, 16,11
 Cast.1 = VariantOut.0;  
 $XOR.0 = VariantIn.1;  
 $XOR.1 = VariantIn:A.1;  //_GUI 42,20, 42,23, 35,23, 35,25
 $XOR:A.0 = VariantIn.0;  //_GUI 40,25, 40,20
 $XOR:A.1 = VariantIn:A.0;  
}

Object ( Bit Out1) $XOR( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit"
{
 // XOR - Variant Select Case
 //
 // Date:
 // 09 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 19,17
 Object ( Bit In2) Input:A;  //_GUI 19,28
 Object Output( Bit Out1) ;  //_GUI 86,19
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 37,16
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 74,17
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 37,24
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 49,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 28,17
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 31,28

 //_ Behavior Topology
 Output.0 = AND.0;  
 OR.0 = Junction.1;  
 OR.1 = Junction:A.0;  //_GUI 32,21
 AND.0 = OR.0;  
 AND.1 = INVERT.0;  //_GUI 65,22, 65,27
 AND:A.0 = Junction.2;  //_GUI 29,26
 AND:A.1 = Junction:A.1;  
 INVERT.0 = AND:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
}

Object ( List Out1) $XOR_SameLists( List In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List\\List"
{
 // Added Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 19,31
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $XOR_SameLists.0;  //_GUI 74,26, 74,23
 ListIn:A.0 = Input:A.0;  
 $XOR_SameLists.0 = ListIn.1;  
 $XOR_SameLists.1 = ListIn:A.1;  //_GUI 43,25, 43,33
 $XOR_SameLists:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $XOR_SameLists:A.1 = ListIn:A.0;  //_GUI 51,36
}

Object ( List Out1) $XOR_SameLists( List In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Bit In) Input:B;  //_GUI 22,39
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 28,39
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $XOR_SameLists.0;  //_GUI 74,26, 74,23
 Output:A.0 = Input:B.0;  
 $XOR_SameLists.0 = ListIn.1;  
 $XOR_SameLists.1 = Junction.0;  //_GUI 46,25
 $XOR_SameLists:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 $XOR_SameLists:A.1 = Junction.1;  
}

Object ( List Out1) $XOR_SameLists( Variant In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Var\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,17
 Object ( Bit In) Input:B;  //_GUI 30,34
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 36,34
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 48,16
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 48,24
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 71,22, 71,27
 ListOut.1 = $XOR_SameLists.0;  
 Output:A.0 = Input:B.0;  
 $XOR_SameLists.0 = Junction.1;  
 $XOR_SameLists.1 = ListIn.1;  //_GUI 41,21, 41,26
 $XOR_SameLists:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $XOR_SameLists:A.1 = ListIn.0;  
}

Object ( Variant Out1) $XOR_SameLists( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Var\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,20
 Object Output( Variant Out1) ;  //_GUI 30,18
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 18,16
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 XOR.0 = Input.0;  
 XOR.1 = Input:A.0;  
}

Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out"
{
 // Collects inputs into a BIN data set
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,16
 Object ( Variant In2) Input:A;  //_GUI 14,19
 Object Output( Variant Out1) ;  //_GUI 51,17
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 36,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 22,15

 //_ Behavior Topology
 Output.0 = BIN.0;  
 BIN.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( NULL mMSBOut) CollectBIN( NULL Hi, NULL Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out",Documentation="Null/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( NULL mMSBOut) ;  //_GUI 41,14

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 26,15, 26,14
}

Object ( Variant Out1) CollectBIN( NULL In3, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out",Documentation="null/var"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In3) Input;  //_GUI 22,22
 Object ( Variant In2) Input:A;  //_GUI 22,25
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 39,23

 //_ Behavior Topology
 Output.0 = BIN.0;  
 BIN.0 = Input:A.0;  
}

Object ( Variant Out1) CollectBIN( Variant In2, NULL In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out",Documentation="var/null"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,25
 Object ( NULL In3) Input:A;  //_GUI 22,27
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 41,23

 //_ Behavior Topology
 Output.0 = BIN.0;  
 BIN.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) RemoveBias( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Takes in a biased exponent and removes the bias from it and outputs a twos complement exponent. This object does not detect special IEEE floating-point cases for the exponent.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Variant input: A biased exponent
 //
 // Outputs:
 //
 // Bit OFL: The Overflow bit.  Goes high if the input is the maximum positive unsigned value (all bits high), which can't be represented in a twos complement manner.
 //
 // Variant output: The exponent with the bias offset removed and now in twos complement form.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 37,26
 Object Output( Bit OFL) ;  //_GUI 78,17
 Object Output:A( Variant Out1) ;  //_GUI 78,27
 Object ( Variant S) Sub( Variant A, Variant B) ;  //_GUI 64,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,26
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 47,31
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 64,15
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 47,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 59,26
 Object Text;  //_GUI 36,45,A Biased exponant of MaxUInt can't be represented as an unbiased 2's complement value of the same size.  For example a 3 bit biased exponent has a MaxUInt value of 7.  The Bias is 3.  7-3=4. 4 Can't be represented as a 2's complement value in 3 bits (100 is actually -4) and 4 must be represented in 4 bits (0100).Note that IEEE is not supported here.  A biased exponent of all zeros has the special meaning of denormalized mantissa.  A biased exponent of all ones has the special meaning of various NaNs.

 //_ Behavior Topology
 Output.0 = Equal.0;  
 Output:A.0 = Sub.0;  
 Sub.0 = Junction:A.1;  
 Sub.1 = MakeBias.0;  //_GUI 61,30, 61,34
 Junction.0 = Input.0;  
 MakeBias.0 = Junction.2;  //_GUI 44,34
 Equal.0 = AllOnes.0;  
 Equal.1 = Junction:A.0;  //_GUI 60,20
 AllOnes.0 = Junction.0;  //_GUI 44,17
 Junction:A.0 = Junction.1;  
}

Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\PackMSB",Icon="Exposer_Out"
{
 // Packs input elements into an MSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,15
 Object ( Variant In2) Input:A;  //_GUI 14,19
 Object ( Variant In3) Input:B;  //_GUI 14,22
 Object Output( List Out1) ;  //_GUI 52,16
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 20,18
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 36,14

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 ListOut.0 = Input:B.0;  
 ListOut.1 = Input:A.0;  
 ListOut:A.0 = ListOut.0;  //_GUI 33,19, 33,21
 ListOut:A.1 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3) UnPackMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\UnPackMSB",Icon="Exposer_In"
{
 // Unpacks an MSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 23,24
 Object Output( Variant Out1) ;  //_GUI 65,23
 Object Output:A( Variant Out2) ;  //_GUI 65,28
 Object Output:B( Variant Out3) ;  //_GUI 65,31
 Object ( Variant Out1, Variant Out2) UnPackMSB( Variant In1) ;  //_GUI 48,27
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2) UnPackMSB:A( Variant In1) ;  //_GUI 29,22
 //_ Attributes Documentation="Error"

 //_ Behavior Topology
 Output.0 = UnPackMSB:A.0;  
 Output:A.0 = UnPackMSB.0;  
 Output:B.0 = UnPackMSB.1;  
 UnPackMSB.0 = UnPackMSB:A.1;  //_GUI 46,30, 46,27
 UnPackMSB:A.0 = Input.0;  
}

Object ( Variant Iteration, Bit LastDone, Bit Active
    , Bit Done, Bit Busy) DoneForN_Down( Variant Iterations, Bit ClkG
    , Bit CLR, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced"
{
 // Produces N Dones for every one Go.  Outputs the Done iteration count decrementing from N-1 to 0. Uses the standard GDBW model.  Larger iterations at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Var/List Iterations: This value indicates the number of iterations or Dones to produce for every Go.  A Go with an Iterations value of 0 will produce no Done at all.  Iterations can be a list which yields nested loops, each loop with its own Iteration, LastDone, Active and Done.  The least significant element in Iterations is the inner loop.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit Go: Start producing N Dones.
 //
 // Bit Wait: Wait. Has a value of 0 if disconnected.  Holds off the Dones
 //
 // Outputs:
 //
 // Var/List Iteration The Done iteration value.  Same dataset as the Iterations input.  Values only valid while Done is high.  The first Done iteration value is N-1. the LastDone iteration value is 0.
 //
 // Bit/List LastDone Indicates when the last Done is occurring.
 //
 // Bit/List Active: Same behavior as the Done signal except it does not drop during Wait.
 //
 // Bit/List Done: N of these are produced for every Go.
 //
 // Bit Busy: Tells Go to hold off.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx, BINxxx and List
 //
 // Revision 1
 // Revision 2 - 7/19/06 improved speed, List overload documentation added
 //_ Object Prototypes
 Object ( Variant Iterations) Input;  //_GUI 13,36
 Object ( Bit ClkG) Input:A;  //_GUI 15,88
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:B;  //_GUI 15,91
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 15,95
 Object ( Bit Wait) Input:D;  //_GUI 158,101
 //_ Attributes Constant="0"
 Object Output( Variant Iteration) ;  //_GUI 180,24
 Object Output:A( Bit LastDone) ;  //_GUI 180,51
 Object Output:B( Bit Active) ;  //_GUI 181,74
 Object Output:C( Bit Done) ;  //_GUI 181,84
 Object Output:D( Bit Busy) ;  //_GUI 128,127
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 79,81
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 20,36
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 37,80
 Object Text;  //_GUI 59,95,When Busy we do not block Goes because if we are already in the Doning state and Go comes in we will stay in state.  This is OK for two reasons: 1) When we are on the last cycle (LastDone) Busy is dropped and we want to allow a new Go.  2) If not LastDone we will stay in state anyway, so it doesn't matter if we tell it to enter.
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 115,125
 Object Text;  //_GUI 67,77,Doning
 Object ( Variant Out1) Dec( Variant In1) ;  //_GUI 101,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In1) ;  //_GUI 55,85
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 176,51
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 102,124
 Object Text;  //_GUI 103,117,Only Busy when in Doning state and not LastDone
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 91,83
 Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 65,81
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 148,84
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 95,82
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 137,48
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 23,79
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 107,84
 Object ( Bit Out1) EqualOne( Variant In1) ;  //_GUI 100,31
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 165,99
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In2) ;  //_GUI 52,74
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 137,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In3) ;  //_GUI 149,11
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 74,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In2) ;  //_GUI 55,71
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 62,23
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 115,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 130,55
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 72,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 49,36
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 95,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 49,82
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 83,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In3) ;  //_GUI 52,56
 Object Text;  //_GUI 110,64,Also enable Dec when Done
 Object Text;  //_GUI 153,28,Register an EqualOne separately so we don't have to put an EqualZero after the Iterations register.  This trick allows us to run this circuit much faster.
 Object Text;  //_GUI 94,92,Done only when Doning and not Waiting
 Object Text;  //_GUI 27,70,Don't Go if Done iterations is 0
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 164,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 58,88
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In0) ;  //_GUI 61,91
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In3) ;  //_GUI 133,58
 Object Text;  //_GUI 83,46,Also enable Dec when!Doning & Entering Doning
 Object Text;  //_GUI 157,56,LastDone when Done and Iterations == 0
 Object Text;  //_GUI 148,47,Iterations == 0
 Object Text;  //_GUI 58,44,Select Iterations when not Doning or on LastDone
 Object Text;  //_GUI 185,28,Iteration is only valid while Done is high
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In3) ;  //_GUI 127,52
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 115,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In3) ;  //_GUI 91,74
 Object ( Variant Out1) Dec:A( Variant In1) ;  //_GUI 101,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In1) ;  //_GUI 90,20
 Object ( Bit Out1) EqualOne:A( Variant In1) ;  //_GUI 100,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:S
    ( Variant In0) ;  //_GUI 87,23
 Object ( Variant O) Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 115,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:T
    ( Bit In0) ;  //_GUI 95,26

 //_ Behavior Topology
 Output.0 = Junction:G.2;  //_GUI 165,25, 165,12
 Output:A.0 = Junction:B.1;  
 Output:B.0 = Junction:Q.2;  
 Output:C.0 = Junction:D.1;  
 Output:D.0 = AND:A.0;  
 VouchBit.0 = State.0;  
 Junction.0 = Input.0;  
 AND.0 = NotZero.0;  
 AND.1 = Input:C.0;  //_GUI 36,85, 36,96
 AND:A.0 = INVERT.0;  
 AND:A.1 = Junction:F.2;  //_GUI 53,130
 Dec.0 = Junction:R.1;  
 Junction:A.0 = Junction:H.2;  
 Junction:B.0 = AND:D.0;  
 INVERT.0 = Junction:A.2;  //_GUI 56,127
 Junction:C.0 = VouchBit.0;  
 State.0 = Junction:K.1;  
 State.1 = Junction:A.1;  
 State.2 = Junction:M.1;  
 State.3 = Junction:N.1;  
 Junction:D.0 = Junction:E.1;  
 AND:B.0 = Junction:C.1;  
 AND:B.1 = INVERT:A.0;  //_GUI 93,87, 93,90, 177,90, 177,102
 RegClr.0 = Mux:A.0;  //_GUI 137,35
 RegClr.1 = Junction:P.2;  
 RegClr.2 = Junction:I.1;  
 RegClr.3 = Junction:O.2;  
 NotZero.0 = Junction.2;  //_GUI 21,82
 Junction:E.0 = AND:B.0;  
 EqualOne.0 = Junction:R.2;  //_GUI 91,34
 INVERT:A.0 = Input:D.0;  
 Junction:F.0 = Junction:Q.0;  
 RegClr:A.0 = Mux.0;  
 RegClr:A.1 = Junction:P.1;  //_GUI 128,25
 RegClr:A.2 = Junction:I.0;  //_GUI 131,28
 RegClr:A.3 = Junction:O.1;  //_GUI 134,31
 Junction:G.0 = RegClr:A.0;  //_GUI 150,23
 OR.0 = INVERT:B.0;  
 OR.1 = Junction:H.1;  //_GUI 56,29
 Junction:H.0 = Junction:B.2;  //_GUI 177,72
 INVERT:B.0 = Junction:L.1;  //_GUI 53,26
 OR:A.0 = AND:C.0;  
 OR:A.1 = Junction:E.0;  //_GUI 108,58
 Junction:I.0 = OR:A.0;  
 Cast.0 = Junction:J.0;  //_GUI 50,17
 Cast.1 = Junction:G.0;  //_GUI 70,20, 70,12
 Junction:J.0 = Junction.1;  
 AND:C.0 = Junction:K.0;  //_GUI 50,54
 AND:C.1 = INVERT:C.0;  
 Junction:K.0 = AND.0;  
 INVERT:C.0 = Junction:L.2;  
 Junction:L.0 = Junction:F.1;  
 AND:D.0 = RegClr.0;  
 AND:D.1 = Junction:D.0;  //_GUI 149,54
 Junction:M.0 = Input:A.0;  
 Junction:N.0 = Input:B.0;  
 Junction:O.0 = Junction:N.0;  //_GUI 134,63, 62,63
 Junction:P.0 = Junction:M.0;  //_GUI 128,60, 59,60
 Mux.0 = Dec.0;  
 Mux.1 = Dec:A.0;  
 Mux.2 = Junction:T.1;  
 Junction:Q.0 = Junction:C.0;  
 Dec:A.0 = Junction:S.1;  
 Junction:R.0 = Cast.0;  //_GUI 91,18
 EqualOne:A.0 = Junction:S.2;  //_GUI 88,37
 Junction:S.0 = Junction:J.1;  //_GUI 68,24, 68,37
 Mux:A.0 = EqualOne.0;  
 Mux:A.1 = EqualOne:A.0;  
 Mux:A.2 = Junction:T.2;  //_GUI 96,40
 Junction:T.0 = OR.0;  
}

Object ( List Iteration, List LastDone, List Active
    , List Done, Bit Busy) DoneForN_Down( List Iterations, Bit ClkG
    , Bit CLR, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced",Documentation="List"
{
 // Revision 1
 //_ Object Prototypes
 Object ( List Iterations) Input;  //_GUI 14,16
 Object ( Bit ClkG) Input:A;  //_GUI 14,22
 Object ( Bit CLR) Input:B;  //_GUI 14,25
 Object ( Bit Go) Input:C;  //_GUI 14,28
 Object ( Bit Wait) Input:D;  //_GUI 90,99
 Object Output( List Iteration) ;  //_GUI 96,39
 Object Output:A( List LastDone) ;  //_GUI 96,47
 Object Output:B( List Active) ;  //_GUI 96,55
 Object Output:C( List Done) ;  //_GUI 96,63
 Object Output:D( Bit Busy) ;  //_GUI 19,91
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,14
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 83,37
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 83,45
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 83,53
 Object ( List Out) ListOut:C( Variant In1, Variant In2) ;  //_GUI 83,61
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 35,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 32,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 29,28
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 32,81
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In1) ;  //_GUI 16,85
 Object ( Variant Iteration, Variant LastDone, Variant Active
    , Variant Done, Bit Busy) DoneForN_Down( Variant Iterations, Bit ClkG
    , Bit CLR, Bit Go, Bit Wait) ;  //_GUI 47,18
 Object ( Variant Iteration, Variant LastDone, Variant Active
    , Variant Done, Bit Busy) DoneForN_Down:A( Variant Iterations, Bit ClkG
    , Bit CLR, Bit Go, Bit Wait) ;  //_GUI 47,73

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = ListOut:B.0;  
 Output:C.0 = ListOut:C.0;  
 Output:D.0 = Junction:C.2;  //_GUI 17,92
 ListIn.0 = Input.0;  
 ListOut.0 = DoneForN_Down:A.0;  //_GUI 80,42, 80,75
 ListOut.1 = DoneForN_Down.0;  //_GUI 80,39, 80,20
 ListOut:A.0 = DoneForN_Down:A.1;  //_GUI 78,50, 78,78
 ListOut:A.1 = DoneForN_Down.1;  //_GUI 78,47, 78,23
 ListOut:B.0 = DoneForN_Down:A.2;  //_GUI 76,58, 76,81
 ListOut:B.1 = DoneForN_Down.2;  //_GUI 76,55, 76,26
 ListOut:C.0 = DoneForN_Down:A.3;  //_GUI 74,66, 74,84
 ListOut:C.1 = DoneForN_Down.3;  //_GUI 74,63, 74,29
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:C.0;  
 OR.0 = Junction:B.2;  //_GUI 30,83
 OR.1 = Junction:C.1;  
 Junction:C.0 = DoneForN_Down.4;  //_GUI 17,32
 DoneForN_Down.0 = ListIn.1;  //_GUI 42,20, 42,16
 DoneForN_Down.1 = Junction.1;  
 DoneForN_Down.2 = Junction:A.1;  
 DoneForN_Down.3 = Junction:B.1;  
 DoneForN_Down.4 = DoneForN_Down:A.4;  //_GUI 72,32, 72,71, 44,71, 44,87
 DoneForN_Down:A.0 = ListIn.0;  //_GUI 39,75, 39,19
 DoneForN_Down:A.1 = Junction.2;  //_GUI 36,78
 DoneForN_Down:A.2 = Junction:A.2;  //_GUI 33,81
 DoneForN_Down:A.3 = OR.0;  
 DoneForN_Down:A.4 = Input:D.0;  //_GUI 97,87, 97,100
}

Object ( Variant Out1) "2^N_LSBList"( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 4,43
 Object Output( Variant Out1) ;  //_GUI 221,30
 Object ( Variant Size) ListSize( Variant List) ;  //_GUI 51,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,43
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 77,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 63,26
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 76,10
 //_ Attributes Documentation="list"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In3) ;  //_GUI 47,26
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 89,12
 //_ Attributes Documentation="NULL"
 Object Text;  //_GUI 51,33,Subtract (using Lo_N) our list size (in bits) from the power of 2 size.
 Object Text;  //_GUI 89,31,Make a list with one element per bit
 Object Text;  //_GUI 114,28,Replace each element with a zeroed one from the origonal list.
 Object Text;  //_GUI 75,4,Get an element and zero it.
 Object Text;  //_GUI 166,11,Add the zeroed elements to the top (Most sig) end.
 Object ( Variant Out1) Bit_List( Variant In1) ;  //_GUI 100,21
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 12,41
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 203,28
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 134,35
 //_ Attributes Documentation="NULL"
 Object Text;  //_GUI 142,50,we're performing a manual CAT operation here: the NULL list represents the empty list
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 176,20
 //_ Attributes Documentation="var/list"
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 151,20
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 151,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 133,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 147,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 147,32
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 90,21
 //_ Attributes Documentation="zterm"
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 115,19
 Object ( Variant Out1) "Pad2^N"( Variant In1) ;  //_GUI 65,19

 //_ Behavior Topology
 Output.0 = $Select.0;  
 ListSize.0 = Junction:B.2;  
 Junction.0 = LsbList.0;  
 Lo_N.0 = "Pad2^N".0;  //_GUI 76,24, 76,22
 Lo_N.1 = Junction:A.1;  
 Junction:A.0 = ListSize.0;  
 PopLsb.0 = Junction:B.1;  //_GUI 48,13
 Junction:B.0 = Junction.0;  
 Zero.0 = PopLsb.1;  
 Bit_List.0 = LSB.0;  
 LsbList.0 = Input.0;  
 $Select.0 = AppendLsbList.0;  //_GUI 203,23
 $Select.1 = $SelectOut:A.1;  
 $Select.2 = Junction:D.1;  //_GUI 173,36, 173,38
 IsNULL.0 = Junction:C.2;  
 AppendLsbList.0 = $SelectOut.0;  
 AppendLsbList.1 = $SelectOut:A.0;  //_GUI 176,30
 $SelectOut.0 = Junction:C.1;  
 $SelectOut.1 = Junction:E.1;  //_GUI 148,25
 $SelectOut:A.0 = Junction.1;  //_GUI 130,30, 130,44
 $SelectOut:A.1 = Junction:E.2;  
 Junction:C.0 = ListFill.0;  
 Junction:D.0 = IsNULL.0;  
 Junction:E.0 = Junction:D.0;  
 LSB.0 = Lo_N.0;  
 ListFill.0 = Zero.0;  //_GUI 112,21, 112,15
 ListFill.1 = Bit_List.0;  
 "Pad2^N".0 = Junction:A.0;  //_GUI 64,22
}

Object ( Variant Size) $ListSize( List List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 18,24
 Object Output( Variant Size) ;  //_GUI 89,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 62,22
 Object Text;  //_GUI 27,37,This object returns a data set with as many bits as the List has elements.
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 76,22
 Object ( Variant Size) $ListSize( Variant List) ;  //_GUI 46,16
 //_ Attributes Documentation="List"
 Object ( Variant Size) $ListSize:A( Variant List) ;  //_GUI 46,24
 //_ Attributes Documentation="List"

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $ListSize:A.0;  
 ListOut.1 = $ListSize.0;  //_GUI 59,24, 59,19
 LSB.0 = ListOut.0;  
 $ListSize.0 = ListIn.1;  //_GUI 44,19, 44,24
 $ListSize:A.0 = ListIn.0;  
}

Object ( Variant Size) $ListSize( NULL List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL List) Input;  //_GUI 13,21
 Object Output( Variant Size) ;  //_GUI 39,21
 Object Text;  //_GUI 16,27,This is an empty list element, which is still counted.
 Object ( Bit In) Input:A;  //_GUI 31,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Size) $ListSize( Variant List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 23,18
 Object Output( Variant Size) ;  //_GUI 47,18
 Object ( Bit In) Input:A;  //_GUI 39,18
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) $MaskToNum( Variant Data, Variant Lower) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="Variant"
{
 // Date Last Modifed:
 // 12 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 36,23
 Object ( Variant Lower) Input:A;  //_GUI 41,49
 Object Output( Variant Out1) ;  //_GUI 161,34
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 46,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,49
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 67,28
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 147,32
 Object Text;  //_GUI 66,73,At each step of the recursion we are setting the next bit (starting from the most-significant).  In this manner we build up an LSB data set containing the binary value.  The $Cast objects are here to enforce the type of our first collection of two Bits into an LSB002.
 Object ( Bit In) Input:B;  //_GUI 61,62
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 73,48
 Object ( Variant Out1) CollectLSB:A( Variant In2, Variant In3) ;  //_GUI 72,58
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 66,22
 Object ( Variant Out1) $MaskToNum( Variant Data, Variant Lower) ;  //_GUI 124,31
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $MaskToNum:A( Variant Data, Variant Lower) ;  //_GUI 123,56
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input.0;  
 Junction.0 = Input:A.0;  
 NotZero.0 = Junction:A.2;  
 OR.0 = $MaskToNum.0;  
 OR.1 = $MaskToNum:A.0;  //_GUI 144,37, 144,59
 CollectLSB.0 = Junction.1;  
 CollectLSB.1 = NotZero.0;  //_GUI 64,53, 64,39, 82,39, 82,31
 CollectLSB:A.0 = Junction.2;  //_GUI 61,60
 CollectLSB:A.1 = Input:B.0;  
 Junction:A.0 = VariantIn.1;  
 $MaskToNum.0 = Junction:A.1;  //_GUI 120,33, 120,23
 $MaskToNum.1 = CollectLSB.0;  //_GUI 106,36, 106,51
 $MaskToNum:A.0 = VariantIn.0;  //_GUI 117,58, 117,26
 $MaskToNum:A.1 = CollectLSB:A.0;  
}

Object ( Variant Out1) $MaskToNum( Bit Data, Variant Lower) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="leaf"
{
 // Date Last Modifed:
 // 12 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 36,31
 Object ( Variant Lower) Input:A;  //_GUI 37,42
 Object Output( Variant Out1) ;  //_GUI 94,42

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) "Pad2^N"( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Filters incoming data producing a BIN data set where the bitlength is a power of 2.  Leading 0s will be added if necessary.
 //
 // Inputs:
 //
 // Variant input: A value that may be zero extended to have a length equal to a power of two.
 //
 // Outputs:
 //
 // Variant output: The value that may have been zero extended to have a length equal to a power of two.
 //
 // Example:
 //
 // Input	Output
 // Bit (1)	Bit (1)
 // MSB002	BIN002
 // LSB003	BIN004
 // LSB004	BIN004
 // BIN005	BIN008
 // MSB008	BIN008
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 6,28
 Object Output( Variant Out1) ;  //_GUI 166,29
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 43,43
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 59,43
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 114,51
 Object Text;  //_GUI 44,54,We want the bitlength to be an even power of two.  If anything besides the most-signiicant bit is 1, we must increase the size of the input data set to an even power of 2.
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 138,27
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 151,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 22,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 55,45
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 77,33
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 60,35
 Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) ;  //_GUI 92,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 112,28
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 30,43
 Object ( Bit In) Input:A;  //_GUI 69,31
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 115,60,If the output of NotZero is asserted, we will alter the incoming data set.
 Object Text;  //_GUI 84,19,In this case, the output of Constant->N_Bits is a data set whose bitlength is an exact power of 2.
 Object Text;  //_GUI 175,23,We are guaranteed that the output is a BIN type whose bitlength is an exact power of 2.  This property may be very desirable in certain recursive situations.  See the Encode object as an example.
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 117,34

 //_ Behavior Topology
 Output.0 = BIN.0;  
 MSB.0 = BitLength.0;  
 VariantIn.0 = Junction:A.1;  
 NotZero.0 = VariantIn.0;  //_GUI 109,54, 109,48
 $Select.0 = Junction:B.1;  
 $Select.1 = UExtnd.1;  //_GUI 133,32, 133,39
 $Select.2 = NotZero.0;  //_GUI 135,35, 135,54
 BIN.0 = $Select.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = MSB.0;  
 VariantOut.0 = Zero.0;  
 VariantOut.1 = Input:A.0;  //_GUI 75,35, 75,32
 Zero.0 = Junction:A.0;  //_GUI 56,38
 "Constant->N_Bits".0 = VariantOut.0;  
 Junction:B.0 = Junction.1;  
 BitLength.0 = Junction.2;  //_GUI 23,46
 UExtnd.0 = "Constant->N_Bits".0;  
 UExtnd.1 = Junction:B.2;  //_GUI 113,39
}

Object ( Bit Out1) "Pad2^N"( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit"
{
 // Filters incoming data producing a BIN data set where the bitlength is a power of 2.  Leading 0s will be added if necessary.
 //
 // Inputs:
 //
 // Variant input: A value that may be zero extended to have a length equal to a power of two.
 //
 // Outputs:
 //
 // Variant output: The value that may have been zero extended to have a length equal to a power of two.
 //
 // Example:
 //
 // Input	Output
 // Bit (1)	Bit (1)
 // MSB002	BIN002
 // LSB003	BIN004
 // LSB004	BIN004
 // BIN005	BIN008
 // MSB008	BIN008
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 34,27
 Object Output( Bit Out1) ;  //_GUI 54,27
 Object Text;  //_GUI 40,35,If the input type is Bit, nothing needs to be done.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) Bisect( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,33
 Object Output( NULL Hi) ;  //_GUI 52,20
 Object Output:A( NULL Lo) ;  //_GUI 52,33
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 43,33

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 44,21
 Output:A.0 = Junction.1;  
 Junction.0 = Input.0;  
}

Object ( NULL Hi, Bit Lo) Bisect( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="bit"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 19,33
 Object Output( NULL Hi) ;  //_GUI 52,20
 Object Output:A( Bit Lo) ;  //_GUI 52,33
 Object ( NULL Out1) NULL;  //_GUI 34,18
 Object Text;  //_GUI 26,39,Odd elements go out Lo

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) Bisect( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,37
 Object Output( Variant Hi) ;  //_GUI 105,31
 Object Output:A( Variant Lo) ;  //_GUI 105,37
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 26,35
 //_ Attributes Documentation="list"
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 45,30
 //_ Attributes Documentation="list"
 Object ( Variant Hi, Variant Lo) Bisect( Variant In1) ;  //_GUI 59,32
 //_ Attributes Documentation="zterm"
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 75,29
 //_ Attributes Documentation="ztl/var"
 Object ( Variant Out1) PushLsb:A( Variant In1, Variant LSB) ;  //_GUI 88,35
 //_ Attributes Documentation="ztl/var"

 //_ Behavior Topology
 Output.0 = PushLsb.0;  
 Output:A.0 = PushLsb:A.0;  
 PopLsb.0 = Input.0;  
 PopMsb.0 = PopLsb.0;  //_GUI 40,33, 40,37
 Bisect.0 = PopMsb.1;  
 PushLsb.0 = PopMsb.0;  //_GUI 58,31, 58,32
 PushLsb.1 = Bisect.0;  
 PushLsb:A.0 = Bisect.1;  
 PushLsb:A.1 = PopLsb.1;  
}

Object ( Variant Hi, Variant Lo) Bisect( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,18
 Object Output( Variant Hi) ;  //_GUI 41,17
 Object Output:A( Variant Lo) ;  //_GUI 40,20
 Object ( Variant Hi, Variant Lo) BisectList( Variant In1) ;  //_GUI 23,16
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = BisectList.0;  
 Output:A.0 = BisectList.1;  
 BisectList.0 = Input.0;  
}

Object ( Variant MSB, Variant Remnant) ListPopMsb( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // This object removes the most significant element from a list.
 //
 // Inputs:
 //
 // Variant input:  The list data.
 //
 // Outputs:
 //
 // Variant MSB: The most significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant Remnant: The remnant of the list after the most significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the least significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 51,18
 Object Output:A( Variant Remnant) ;  //_GUI 51,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,17
 Object ( Variant MSB, Variant Out1) $ListPopMsb( Variant In2
    , Variant In1) ;  //_GUI 35,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $ListPopMsb.0;  
 Output:A.0 = $ListPopMsb.1;  
 ListIn.0 = Input.0;  
 $ListPopMsb.0 = ListIn.1;  
 $ListPopMsb.1 = ListIn.0;  
}

Object ( Variant MSB, NULL Remnant) ListPopMsb( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object removes the most significant element from a list.
 //
 // Inputs:
 //
 // Variant input:  The list data.
 //
 // Outputs:
 //
 // Variant MSB: The most significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant Remnant: The remnant of the list after the most significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the least significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 39,9
 Object Output:A( NULL Remnant) ;  //_GUI 39,17
 Object ( NULL Out1) NULL;  //_GUI 27,15

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 23,10, 23,20
 Output:A.0 = NULL.0;  
}

Object ( NULL MSB, NULL Remnant) ListPopMsb( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object removes the most significant element from a list.
 //
 // Inputs:
 //
 // Variant input:  The list data.
 //
 // Outputs:
 //
 // Variant MSB: The most significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant Remnant: The remnant of the list after the most significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the least significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,19
 Object Output( NULL MSB) ;  //_GUI 39,9
 Object Output:A( NULL Remnant) ;  //_GUI 39,17
 Object ( NULL Out1) NULL;  //_GUI 27,15

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 23,10, 23,20
 Output:A.0 = NULL.0;  
}

Object ( List MsbList) MsbList( List AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // This object converts a list of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant MsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element LSB ordered list converted to a four-element MSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (W, list (X, list (Y, Z)))
 // 2. LsbList(list (list (list (W, X), Y), Z))	= list (W, list (X, list (Y, Z)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList) Input;  //_GUI 20,33
 Object Output( List MsbList) ;  //_GUI 62,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,31
 Object ( List MsbList) MsbList( Variant AnyList_Hi, Variant AnyList_Lo) ;  //_GUI 41,31
 //_ Attributes Documentation="list/list"

 //_ Behavior Topology
 Output.0 = MsbList.0;  
 ListIn.0 = Input.0;  
 MsbList.0 = ListIn.1;  
 MsbList.1 = ListIn.0;  
}

Object ( Variant MsbList) MsbList( Variant AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts a list of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant MsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element LSB ordered list converted to a four-element MSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (W, list (X, list (Y, Z)))
 // 2. LsbList(list (list (list (W, X), Y), Z))	= list (W, list (X, list (Y, Z)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList) Input;  //_GUI 20,33
 Object Output( Variant MsbList) ;  //_GUI 31,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL MsbList) MsbList( NULL AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object converts a list of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant MsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element LSB ordered list converted to a four-element MSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (W, list (X, list (Y, Z)))
 // 2. LsbList(list (list (list (W, X), Y), Z))	= list (W, list (X, list (Y, Z)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList) Input;  //_GUI 20,33
 Object Output( NULL MsbList) ;  //_GUI 29,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit CO, Bit S) $$ADSU_logic( Bit A
    , Bit B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 14,20
 Object ( Bit B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 124,17
 Object Output:A( Bit S) ;  //_GUI 124,29
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 20,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 36,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 86,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 82,31
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 92,27
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:A( Bit In1, Bit In2) ;  //_GUI 64,20
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:B( Bit In1, Bit In2) ;  //_GUI 48,19
 //_ Attributes Documentation="Bit/Bit"
 Object Text;  //_GUI 27,48,This object will likely be overloaded with an optimized system specific implementation.
 Object ( Bit O) $Mux( Bit A, Bit B
    , Bit S) ;  //_GUI 94,15
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 Output:A.0 = XOR.0;  
 INVERT.0 = Input:B.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = XOR:A.0;  
 Junction:B.0 = Input:C.0;  //_GUI 83,41
 XOR.0 = Junction:A.2;  //_GUI 87,29
 XOR.1 = Junction:B.2;  
 XOR:A.0 = XOR:B.0;  
 XOR:A.1 = INVERT.0;  //_GUI 64,33
 XOR:B.0 = Junction.1;  
 XOR:B.1 = Input:A.0;  
 $Mux.0 = Junction.0;  //_GUI 37,17
 $Mux.1 = Junction:B.1;  //_GUI 83,20
 $Mux.2 = Junction:A.1;  
}

Object ( Bit CO, Variant S) $$ADSU_logic( Variant A
    , Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,32
 Object ( Variant B) Input:A;  //_GUI 23,40
 Object ( Bit ADD) Input:B;  //_GUI 26,46
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 27,52
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 145,24
 Object Output:A( Variant S) ;  //_GUI 150,42
 Object ( Variant Out1) $Cast( Variant Data, Variant Type) ;  //_GUI 136,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 33,30
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 115,42
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 33,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 71,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,32
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 133,22
 Object ( Variant CO, Variant S) $$ADSU_logic( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,42
 //_ Attributes Documentation="bit"
 Object ( Variant CO, Variant S) $$ADSU_logic:A( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,23
 //_ Attributes Documentation="bit"

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = $Cast.0;  
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction:A.0;  //_GUI 130,42, 130,19, 30,19
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $$ADSU_logic.1;  
 VariantOut.1 = $$ADSU_logic:A.1;  //_GUI 115,28
 VariantIn:A.0 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 VouchBit.0 = $$ADSU_logic:A.0;  
 $$ADSU_logic.0 = VariantIn.0;  //_GUI 79,44, 79,35
 $$ADSU_logic.1 = VariantIn:A.0;  //_GUI 76,47, 76,43
 $$ADSU_logic.2 = Junction.2;  //_GUI 72,50
 $$ADSU_logic.3 = Input:C.0;  
 $$ADSU_logic:A.0 = VariantIn.1;  //_GUI 66,25, 66,32
 $$ADSU_logic:A.1 = VariantIn:A.1;  //_GUI 69,28, 69,40
 $$ADSU_logic:A.2 = Junction.0;  //_GUI 72,31
 $$ADSU_logic:A.3 = $$ADSU_logic.0;  //_GUI 83,39, 98,39
}

Object ( NULL CO, NULL S) $$ADSU_logic( NULL A
    , NULL B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 14,17
 Object ( NULL B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( NULL CO) ;  //_GUI 40,17
 Object Output:A( NULL S) ;  //_GUI 40,23

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 25,44,( 0 >= 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), <, !)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 25,44,( ( ! 0 ) >= 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 25,44,( 0 >= ( ! 0 ) )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant LsbList) LsbList( Variant AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts a list of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant LsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element MSB ordered list converted to a four-element LSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (list (list (W, X), Y), Z)
 // 2. LsbList(list (W, list (X, list (Y, Z))))	= list (list (list (W, X), Y), Z)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList) Input;  //_GUI 20,33
 Object Output( Variant LsbList) ;  //_GUI 31,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List LsbList) LsbList( List AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // This object converts a list of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant LsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element MSB ordered list converted to a four-element LSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (list (list (W, X), Y), Z)
 // 2. LsbList(list (W, list (X, list (Y, Z))))	= list (list (list (W, X), Y), Z)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList) Input;  //_GUI 20,33
 Object Output( List LsbList) ;  //_GUI 62,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,31
 Object ( List LsbList) LsbList( Variant AnyList_Hi, Variant AnyList_Lo) ;  //_GUI 41,31

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 ListIn.0 = Input.0;  
 LsbList.0 = ListIn.1;  
 LsbList.1 = ListIn.0;  
}

Object ( NULL LsbList) LsbList( NULL AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object converts a list of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant LsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element MSB ordered list converted to a four-element LSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (list (list (W, X), Y), Z)
 // 2. LsbList(list (W, list (X, list (Y, Z))))	= list (list (list (W, X), Y), Z)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList) Input;  //_GUI 20,33
 Object Output( NULL LsbList) ;  //_GUI 29,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\Advanced\\Twos",Icon="Add"
{
 // Performs an add or a subtract function with Carry In, Carry Out and Overflow.
 //
 // This object has input and output behaviors that are dataset dependent.  It is not recommended that you use this object to implement dataset independent algorithms.  Use Add, Sub and AddSub to implement dataset independent algorithms.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Value A.
 //
 // Variant B: Value B.
 //
 // Bit Add: Add command.  1 for add, 0 for subtract.  If disconnected, defaults to 1.
 //
 // Bit CI: Carry In value.  Normally set this to low when adding and high when subtracting.  To Carry In, set to 1 (asserted high) when adding and set to 0 (asserted low) when subtracting.  If disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Bit CO: Carry Out value.  Indicates high bit rolled over.  Can be used in a carry chain or can be used to indicate an error condition when using unsigned numbers. When adding, Carry Out is signaled with a 1 (asserted high).  When subtracting, Carry Out is signaled with a 0 (asserted low).
 //
 // Bit OFL: Overflow value.  Indicates half rollover point crossed.  Can be used to indicate an error condition when using twos complement numbers.
 //
 // Variant S: The result of the operation.  The sum or the difference of A and B.
 //
 // Dataset Coverage:
 //
 // Unsigned (MSBxxx, LSBxxx and BINxxx use CO), Twos Complement (MSBxxx, LSBxxx and BINxxx use OFL), Signed (use OFL), Fixed (CI is LSB of fraction portion, use OFL), Floating (CI, CO ignored), Complex (the inputs Add and CI both get sent to the Real and Imaginary portions, CO and OFL are the OR of CO and OFL of both portions).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx, and BINxxx) and same size.  If different sizes then the inputs are symmetrized and a warning is produced.
 //
 // Examples: (widen dialog box to columate examples)
 //
 // A (Uns, 2's)	B (Uns, 2's)	Add	CI	CO	OFL	S (Uns, 2's)	Function
 // 000 (0,0)		000 (0,0)		1	0	0	0	000 (0,0)		A+B
 // 001 (1,1)		001 (1,1)		1	0	0	0	010 (2,2)		A+B
 // 001 (1,1)		010 (2,2)		1	0	0	0	011 (3,3)		A+B
 // 010 (2,2)		010 (2,2)		1	0	0	1	100 (4,-4)		A+B
 // 100 (4,-4)		100 (4,-4)		1	0	1	1	000 (0,0)		A+B
 // 110 (6,-2)		110 (6,-2)		1	0	1	0	100 (4,-4)		A+B
 // 111 (7,-1)		111 (7,-1)		1	0	1	0	110 (6,-2)		A+B
 // 000 (0,0)		000 (0,0)		1	1	0	0	001 (1,1)		A+B+1
 // 001 (1,1)		001 (1,1)		1	1	0	0	011 (3,3)		A+B+1
 // 001 (1,1)		010 (2,2)		1	1	0	1	100 (4,-4)		A+B+1
 // 010 (2,2)		010 (2,2)		1	1	0	1	101 (5,-3)		A+B+1
 // 100 (4,-4)		100 (4,-4)		1	1	1	1	001 (1,1)		A+B+1
 // 110 (6,-2)		110 (6,-2)		1	1	1	0	101 (5,-3)		A+B+1
 // 111 (7,-1)		111 (7,-1)		1	1	1	0	111 (7,-1)		A+B+1
 // 000 (0,0)		000 (0,0)		0	0	0	0	111 (7,-1)		A-B-1
 // 000 (0,0)		001 (1,1)		0	0	0	0	110 (6,-2)		A-B-1
 // 001 (1,1)		000 (0,0)		0	0	0	0	000 (0,0)		A-B-1
 // 100 (4,-4)		011 (3,3)		0	0	1	1	000 (0,0)		A-B-1
 // 100 (4,-4)		100 (4,-4)		0	0	0	0	111 (7,-1)		A-B-1
 // 110 (6,-2)		100 (4,-4)		0	0	1	0	001 (1,1)		A-B-1
 // 001 (1,1)		100 (4,-4)		0	0	0	1	100 (4,-4)		A-B-1
 // 000 (0,0)		000 (0,0)		0	1	0	0	000 (0,0)		A-B
 // 000 (0,0)		001 (1,1)		0	1	0	0	111 (7,-1)		A-B
 // 001 (1,1)		000 (0,0)		0	1	1	0	001 (1,1)		A-B
 // 100 (4,-4)		011 (3,3)		0	1	1	1	001 (1,1)		A-B
 // 100 (4,-4)		100 (4,-4)		0	1	1	0	000 (1,1)		A-B
 // 110 (6,-2)		100 (4,-4)		0	1	1	0	010 (2,2)		A-B
 // 001 (1,1)		100 (4,-4)		0	1	0	1	101 (5,-3)		A-B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 9,16
 Object ( Variant B) Input:A;  //_GUI 9,19
 Object ( Bit ADD) Input:B;  //_GUI 41,22
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 41,25
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 58,16
 Object Output:A( Bit OFL) ;  //_GUI 58,19
 Object Output:B( Variant S) ;  //_GUI 82,20
 Object ( Bit CO, Bit OFL, Variant S) $ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 46,15
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 15,15
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 32,14
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 32,17
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 70,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,16
 Object Text;  //_GUI 25,40,So the OFL is for the Twos compliment rollover on the last bit

 //_ Behavior Topology
 Output.0 = $ADSU.0;  
 Output:A.0 = $ADSU.1;  
 Output:B.0 = Context.0;  
 $ADSU.0 = MSB.0;  
 $ADSU.1 = MSB:A.0;  
 $ADSU.2 = Input:B.0;  
 $ADSU.3 = Input:C.0;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
 MSB.0 = Junction.1;  
 MSB:A.0 = Symmetrize.1;  
 Context.0 = Junction.0;  //_GUI 70,9, 29,9
 Context.1 = $ADSU.2;  
 Junction.0 = Symmetrize.0;  
}

Object ( Bit CO, Bit OFL, Floating S) ADSU
    ( Floating A, Floating B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal",Icon="Add",Documentation="Floating"
{
 // Instructions inside....
 //
 // Updated:
 // Oct 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating A) Input;  //_GUI 24,62
 Object ( Floating B) Input:A;  //_GUI 24,65
 Object ( Bit ADD) Input:B;  //_GUI 67,131
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 50,140
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 68,4
 Object Output:A( Bit OFL) ;  //_GUI 540,30
 Object Output:B( Floating S) ;  //_GUI 614,81
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 259,113
 Object ( LSB002 Twos) Input:D;  //_GUI 255,108
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 335,105
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 140,63
 Object ( Variant Out1) PushMsb:A( Variant MSB, Variant In2) ;  //_GUI 258,96
 Object ( LSB002 Twos) Input:E;  //_GUI 254,95
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 425,114
 Object Text;  //_GUI 425,108,Implicit toss
 Object Text;  //_GUI 272,43,this line changes depending on which one we chose
 Object Text;  //_GUI 264,140,we add two bits here: one for the co on the adsu and one to hold our sign bit
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 135,66
 Object Text;  //_GUI 366,125,if we're high in the top data bit, which is likely, we need to increment the exponent
 Object ( Variant MSB, Variant Out2) PopMsb:B( Variant In1) ;  //_GUI 380,112
 Object Text;  //_GUI 507,152,So if our top bit is high (this was the extra bit we added to catch the co on the mantissa add) then we need to add one to the exponent and use the rest of the bits without the lsb as the mantissa resultotherwise we toss the top bitand we shift the thing so that the top bit is setand we subtract from the exponent that number of shiftsand we toss the top bit for our result
 Object Text;  //_GUI 364,35,yikes: if the mantissa ADSU resulted in a zero we need to zero the exponent; one of our top two data bits (after shift) has to be high or we ended up with zero; we subtract off the whole exponent to make it that way if necessary
 Object Text;  //_GUI 134,132,This is a compare: we could do the FromTwos on the S (which would make more sense), but that would lengthen the already long logic path; instead we just Subtract the other direction in parallel.
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 423,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 422,37
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 30,61
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 200,53
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 479,140
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 390,135
 Object Text;  //_GUI 2,81,Special Operations (not all of these are implemented)Operations on special numbers are well-defined by IEEE. In the simplest case, any operation with a NaN yields a NaN result. Other operations are as follows:Operation	 	Resultn / Infinity 	0Infinity x Infinity 	Infinitynonzero / 0 	InfinityInfinity + Infinity 	Infinity0 / 0 		NaNInfinity - Infinity 	NaNInfinity / Infinity 	NaNInfinity x 0 	NaNfromhttp://stevehollasch.com/cgindex/coding/ieeefloat.html
 Object Text;  //_GUI 100,3,Infinity = all the exponent bits high and the significand bits lowNaN = QNaN or SNaNQNaN = all the exponent bits high and the MSB significand bit highSNaN = all the exponent bits high and the MSB significand bit low (other significand bits high)Zero = all bits low, not including the sign bit
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 486,68
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 203,26
 Object Text;  //_GUI 214,43,either being NaN triggers OFL
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 229,27
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 265,28
 Object Text;  //_GUI 260,25,subtraction of infinity triggers OFL
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 245,45
 Object Text;  //_GUI 559,22,Infinity + Infinity = Infinity, or so the IEEE saysThat means if we're adding and we CO then we fill the exp data high. If we're subtracting and we OFL then we fill the exponent high as well.
 Object Text;  //_GUI 228,7,possibilities (subraction handled by sign negation):adding and both negativeadding and both positiveadding and the top negative (OFL)adding and the bottom negative (OFL)
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 79,129
 Object Text;  //_GUI 59,121,if we're subtracting then we negate the sign on the lower input
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 219,32
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 127,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 115,76
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 200,111
 //_ Attributes Documentation="Bit"
 Object ( Variant O) $Mux:B( Variant A, Variant B
    , Bit S) ;  //_GUI 200,132
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 194,118
 Object ( Variant O) $Mux:C( Variant A, Variant B
    , Bit S) ;  //_GUI 200,100
 //_ Attributes Documentation="Bit"
 Object ( Variant O) $Mux:D( Variant A, Variant B
    , Bit S) ;  //_GUI 200,89
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In1) ;  //_GUI 194,107
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In1) ;  //_GUI 194,96
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 169,104
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 164,115
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 191,123
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 188,126
 Object Text;  //_GUI 185,146,We put these muxs in here to avoid having to have two Barrel Shifters and rounders
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In0) ;  //_GUI 194,63
 Object ( Bit Out1) EqualAllOnes( Variant In1) ;  //_GUI 474,87
 Object Text;  //_GUI 4,12,So the plan here is this:1. Figure out which one has the larger exponent2. Scale the smaller one to have the same exponent as the larger one3. Add a bit and convert the numbers to twos compliment depending upon the sign bit4. Perform the add'5. If there's a CO, dec/inc the exponent6. Scale the result to fit the implicit bit model
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 599,79
 Object ( Bit OFL, Bit ERNG_Data, Bit ERNG_FallOff
    , Bit Round, Variant FallOff, Variant Data) ShiftRightBy( Variant Data
    , Variant ShiftBy, Bit IsTwos) ;  //_GUI 222,112
 //_ Attributes Documentation="barrel with ranges"
 Object ( Variant O) $Mux:E( Variant A, Variant B
    , Bit S) ;  //_GUI 200,76
 //_ Attributes Documentation="Variant"
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 310,100
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 271,132
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 148,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In1) ;  //_GUI 194,83
 Object ( Bit SUB) Input:F;  //_GUI 142,69
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CI) Input:G;  //_GUI 142,72
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 297,121
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In3) ;  //_GUI 280,125
 Object Text;  //_GUI 393,4,If OFL triggers, that's technically a NaN. You should OR the OFL bit with the high bit of the mantissa and the exponent bits in the case where you care about NaNs.Arial,20,255,1
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In1) ;  //_GUI 389,120
 Object ( Bit CO, Bit OFL, Variant S) ADSU:B
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 148,78
 Object ( Bit SUB) Input:H;  //_GUI 142,85
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CI) Input:I;  //_GUI 142,88
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant O) $Mux:F( Variant A, Variant B
    , Bit S) ;  //_GUI 283,84
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT:C( Variant In1) ;  //_GUI 273,86
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:P
    ( Variant In3) ;  //_GUI 268,88
 Object ( Variant O) $Mux:G( Variant A, Variant B
    , Bit S) ;  //_GUI 368,93
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT:D( Variant In1) ;  //_GUI 355,95
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Q
    ( Variant In3) ;  //_GUI 367,103
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In3) ;  //_GUI 349,97
 Object Text;  //_GUI 316,116,So because we're doing an ADSU and because we have sufficient accuracy for the lone sign bit as well as the carry out, we can get away with One's complement instead of Twos.
 Object ( Variant O) $Mux:H( Variant A, Variant B
    , Bit S) ;  //_GUI 561,117
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 583,101
 Object Text;  //_GUI 504,38,!UFL
 Object Text;  //_GUI 488,63,!OFL
 Object Text;  //_GUI 445,57,!=0
 Object Text;  //_GUI 340,60,The OFL on the extend means that the encoded mantissa is larger than the exponent dataset. This is likely an error in the design of the dataset, but we will try to handle the case anyway. It is unlikely that BitLen(MaskToNum(mantissa)) - BitLen(Exponent) > BitsPerStageSG so we won't worry about the timing on the NotZero for it.
 Object ( Bit CO, Bit OFL, Variant S) ADSU:C
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 463,43
 Object ( Bit SUB) Input:J;  //_GUI 459,50
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:S
    ( Variant In0) ;  //_GUI 415,55
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In0) ;  //_GUI 408,136
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 409,137
 Object ( Variant O) $Mux:I( Variant A, Variant B
    , Bit S) ;  //_GUI 498,129
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant LSB) PopLsb:A( Variant In1) ;  //_GUI 458,128
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In0) ;  //_GUI 457,142
 Object ( Variant Out1) PushMsb:B( Variant MSB, Variant In2) ;  //_GUI 477,125
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:V
    ( Bit In0) ;  //_GUI 474,136
 Object ( Bit CI) Input:K;  //_GUI 459,53
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In0) ;  //_GUI 446,136
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 425,67
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:X
    ( Variant In1) ;  //_GUI 424,66
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Y
    ( Variant In0) ;  //_GUI 507,83
 Object ( Variant O) $Mux:J( Variant A, Variant B
    , Bit S) ;  //_GUI 560,49
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AND:C( Variant In1, Variant In2) ;  //_GUI 504,43
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 487,40
 Object ( Bit Out) INVERT:E( Bit In1) ;  //_GUI 472,39
 Object ( Variant O) $Mux:K( Variant A, Variant B
    , Bit S) ;  //_GUI 442,45
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Z
    ( Variant In0) ;  //_GUI 441,37
 Object ( Variant O) $Mux:L( Variant A, Variant B
    , Bit S) ;  //_GUI 561,100
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:a
    ( Variant In1) ;  //_GUI 507,107
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 481,101
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:b
    ( Variant In3) ;  //_GUI 418,103
 Object ( Bit Out) AND:E( Bit In1, Bit In2) ;  //_GUI 522,99
 Object ( Bit Out) INVERT:F( Bit In1) ;  //_GUI 573,100
 Object ( Variant Out1, Variant LSB) PopLsb:B( Variant In1) ;  //_GUI 450,95
 Object ( Variant Out1, Variant LSB) PopLsb:C( Variant In1) ;  //_GUI 460,88
 Object ( Bit Out) AND:F( Bit In1, Bit In2) ;  //_GUI 470,95
 Object ( Bit Out) AND:G( Bit In1, Bit In2) ;  //_GUI 512,88
 Object ( Variant Out1, Variant LSB) PopLsb:D( Variant In1) ;  //_GUI 515,68
 Object ( Variant Out1, Variant LSB) PopLsb:E( Variant In1) ;  //_GUI 525,61
 Object ( Bit Out) AND:H( Bit In1, Bit In2) ;  //_GUI 535,68
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:c
    ( Variant In0) ;  //_GUI 504,70
 Object ( Bit Out) AND:I( Bit In1, Bit In2) ;  //_GUI 545,91
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:d
    ( Bit In0) ;  //_GUI 502,89
 Object Text;  //_GUI 221,73,So A has the larger exponent; that means we shift B
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating
    ( Floating In1) ;  //_GUI 80,32
 //_ Attributes Documentation="with NaN"
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating:A
    ( Floating In1) ;  //_GUI 66,83
 //_ Attributes Documentation="with NaN"
 Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) LeftJustify( Variant Data) ;  //_GUI 398,118
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 285,121
 Object ( Variant Out1) XOR:B( Variant In1, Variant In2) ;  //_GUI 92,74
 Object Text;  //_GUI 90,68,(Negate or invert sign)
 Object Text;  //_GUI 284,115,(Negate or invert sign)
 Object ( Bit CO, Bit OFL, Variant S) ADSU:D
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 419,135
 Object ( Bit CO, Bit OFL, Variant S) ADSU:E
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 463,65

 //_ Behavior Topology
 Output.0 = Input:C.0;  //_GUI 58,5, 58,141
 Output:A.0 = OR:A.0;  
 Output:B.0 = CollectFloating.0;  
 PushMsb.0 = Input:D.0;  
 PushMsb.1 = ShiftRightBy.5;  //_GUI 259,129
 PopMsb.0 = ADSU.2;  
 Junction.0 = ExposeFloating.1;  //_GUI 131,64, 131,37
 PushMsb:A.0 = Input:E.0;  
 PushMsb:A.1 = $Mux:C.0;  //_GUI 245,101, 245,103
 PopMsb:A.0 = LeftJustify.0;  //_GUI 414,117
 Junction:A.0 = ExposeFloating:A.1;  //_GUI 131,67, 131,88
 PopMsb:B.0 = $Mux:G.0;  //_GUI 378,115
 UExtnd.0 = Junction:B.2;  
 UExtnd.1 = Junction:b.1;  //_GUI 419,50
 Junction:B.0 = Junction:S.0;  //_GUI 416,38
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
 $Mux.0 = Junction:A.0;  //_GUI 136,55
 $Mux.1 = Junction.0;  //_GUI 141,58
 $Mux.2 = Junction:L.0;  //_GUI 195,61
 MSB.0 = Junction:U.1;  
 PopLsb.0 = Junction:O.2;  
 OR.0 = ADSU:E.0;  //_GUI 486,67
 OR.1 = ADSU:E.2;  
 AND.0 = ExposeFloating.7;  //_GUI 110,28, 110,55
 AND.1 = ExposeFloating:A.7;  //_GUI 113,31, 113,106
 AND:A.0 = AND.0;  
 AND:A.1 = XOR.0;  
 OR:A.0 = AND:A.0;  
 OR:A.1 = OR:B.0;  //_GUI 255,33
 OR:B.0 = ExposeFloating.10;  //_GUI 120,47, 120,64
 OR:B.1 = ExposeFloating:A.10;  //_GUI 122,50, 122,115
 INVERT.0 = Input:B.0;  
 XOR.0 = Junction:C.1;  
 XOR.1 = Junction:D.0;  //_GUI 139,37, 139,43, 116,43
 Junction:C.0 = ExposeFloating.0;  
 Junction:D.0 = XOR:B.0;  
 $Mux:A.0 = Junction:H.2;  //_GUI 170,113
 $Mux:A.1 = Junction:I.1;  
 $Mux:A.2 = Junction:E.1;  
 $Mux:B.0 = Junction:J.1;  //_GUI 200,124
 $Mux:B.1 = Junction:K.1;  //_GUI 192,137, 192,127
 $Mux:B.2 = Junction:E.2;  //_GUI 195,140
 Junction:E.0 = Junction:F.2;  
 $Mux:C.0 = Junction:I.0;  //_GUI 165,102
 $Mux:C.1 = Junction:H.1;  
 $Mux:C.2 = Junction:F.1;  
 $Mux:D.0 = Junction:K.0;  //_GUI 189,91
 $Mux:D.1 = Junction:J.0;  //_GUI 192,94
 $Mux:D.2 = Junction:G.1;  
 Junction:F.0 = Junction:G.2;  
 Junction:G.0 = Junction:M.2;  
 Junction:H.0 = ExposeFloating.4;  //_GUI 106,105, 106,46
 Junction:I.0 = ExposeFloating:A.4;  //_GUI 143,116, 143,97
 Junction:J.0 = Junction:C.2;  //_GUI 128,124
 Junction:K.0 = Junction:D.2;  //_GUI 116,127
 Junction:L.0 = ADSU:A.0;  
 EqualAllOnes.0 = PopLsb:C.0;  
 CollectFloating.0 = Junction:Q.2;  //_GUI 385,81, 385,104
 CollectFloating.1 = $Mux:J.0;  //_GUI 570,84
 CollectFloating.2 = AND:B.0;  //_GUI 599,104
 ShiftRightBy.0 = $Mux:A.0;  
 ShiftRightBy.1 = $Mux:E.0;  //_GUI 216,117, 216,79
 $Mux:E.0 = ADSU:B.2;  //_GUI 179,78, 179,86
 $Mux:E.1 = ADSU:A.2;  //_GUI 172,81, 172,70
 $Mux:E.2 = Junction:M.1;  
 ADSU.0 = $Mux:F.0;  //_GUI 297,102, 297,87
 ADSU.1 = PushMsb.0;  //_GUI 270,105
 ADSU.2 = Junction:N.1;  //_GUI 281,108
 ADSU.3 = INVERT:B.0;  //_GUI 307,111
 INVERT:A.0 = $Mux:B.0;  
 ADSU:A.0 = Junction.1;  
 ADSU:A.1 = Junction:A.1;  
 ADSU:A.2 = Input:F.0;  
 ADSU:A.3 = Input:G.0;  
 Junction:M.0 = Junction:L.2;  
 INVERT:B.0 = XOR:A.0;  
 Junction:N.0 = INVERT:A.0;  
 Junction:O.0 = PopMsb:B.1;  
 ADSU:B.0 = Junction:A.2;  //_GUI 136,80
 ADSU:B.1 = Junction.2;  //_GUI 141,83
 ADSU:B.2 = Input:H.0;  
 ADSU:B.3 = Input:I.0;  
 $Mux:F.0 = Junction:P.1;  //_GUI 269,86
 $Mux:F.1 = INVERT:C.0;  
 $Mux:F.2 = $Mux:D.0;  
 INVERT:C.0 = Junction:P.2;  
 Junction:P.0 = PushMsb:A.0;  
 $Mux:G.0 = Junction:R.1;  //_GUI 350,95
 $Mux:G.1 = INVERT:D.0;  
 $Mux:G.2 = Junction:Q.1;  
 INVERT:D.0 = Junction:R.2;  
 Junction:Q.0 = PopMsb.0;  //_GUI 368,107
 Junction:R.0 = PopMsb.1;  //_GUI 350,110
 $Mux:H.0 = PopMsb:A.1;  
 $Mux:H.1 = $Mux:I.0;  //_GUI 512,122, 512,132
 $Mux:H.2 = Junction:a.2;  //_GUI 508,125
 AND:B.0 = INVERT:F.0;  
 AND:B.1 = $Mux:H.0;  //_GUI 579,106, 579,120
 ADSU:C.0 = Junction:Z.1;  //_GUI 463,38
 ADSU:C.1 = $Mux:K.0;  
 ADSU:C.2 = Input:J.0;  
 ADSU:C.3 = Input:K.0;  
 Junction:S.0 = $Mux.0;  
 Junction:T.0 = PopLsb.0;  
 Zero.0 = Junction:T.2;  
 $Mux:I.0 = MSB.0;  //_GUI 493,131, 493,143
 $Mux:I.1 = PushMsb:B.0;  //_GUI 488,134
 $Mux:I.2 = Junction:V.1;  
 PopLsb:A.0 = Junction:U.0;  
 Junction:U.0 = ADSU:D.2;  
 PushMsb:B.0 = Junction:V.0;  //_GUI 475,127
 PushMsb:B.1 = PopLsb:A.0;  
 Junction:V.0 = Junction:W.1;  
 Junction:W.0 = ADSU:D.0;  
 One.0 = Junction:X.2;  
 Junction:X.0 = Junction:S.1;  //_GUI 425,56
 Junction:Y.0 = PopMsb:B.0;  //_GUI 390,84
 $Mux:J.0 = AND:C.0;  //_GUI 560,46
 $Mux:J.1 = Junction:c.0;  //_GUI 505,54
 $Mux:J.2 = Junction:Y.0;  //_GUI 508,57
 AND:C.0 = AND:D.0;  //_GUI 500,45, 500,43
 AND:C.1 = ADSU:C.2;  //_GUI 490,48, 490,51
 AND:D.0 = INVERT:E.0;  
 AND:D.1 = ADSU:C.0;  
 INVERT:E.0 = UExtnd.0;  //_GUI 433,42
 $Mux:K.0 = Junction:Z.2;  
 $Mux:K.1 = UExtnd.1;  
 $Mux:K.2 = PopMsb:A.0;  //_GUI 442,116
 Junction:Z.0 = Junction:B.1;  
 $Mux:L.0 = AND:E.0;  
 $Mux:L.1 = AND:I.0;  //_GUI 555,105
 $Mux:L.2 = Junction:a.1;  
 Junction:a.0 = Junction:Y.2;  
 EqualZero.0 = Junction:b.2;  
 Junction:b.0 = LeftJustify.2;  //_GUI 419,126
 AND:E.0 = AND:G.0;  
 AND:E.1 = EqualZero.0;  
 INVERT:F.0 = $Mux:L.0;  
 PopLsb:B.0 = Junction:S.2;  //_GUI 416,98
 PopLsb:C.0 = PopLsb:B.0;  
 AND:F.0 = PopLsb:C.1;  
 AND:F.1 = PopLsb:B.1;  
 AND:G.0 = Junction:d.1;  
 AND:G.1 = AND:F.0;  //_GUI 512,98
 PopLsb:D.0 = Junction:c.1;  
 PopLsb:E.0 = PopLsb:D.0;  
 AND:H.0 = PopLsb:E.1;  
 AND:H.1 = PopLsb:D.1;  
 Junction:c.0 = OR.0;  
 AND:I.0 = AND:H.0;  
 AND:I.1 = Junction:d.2;  //_GUI 503,96
 Junction:d.0 = EqualAllOnes.0;  
 ExposeFloating.0 = Symmetrize.0;  //_GUI 42,35
 ExposeFloating:A.0 = Symmetrize.1;  //_GUI 66,78, 42,78
 LeftJustify.0 = Junction:O.1;  
 XOR:A.0 = ShiftRightBy.3;  
 XOR:A.1 = Junction:N.2;  
 XOR:B.0 = ExposeFloating:A.0;  //_GUI 82,76
 XOR:B.1 = INVERT.0;  //_GUI 92,132
 ADSU:D.0 = Junction:T.1;  
 ADSU:D.1 = Zero.0;  
 ADSU:D.3 = PopLsb.1;  //_GUI 400,146
 ADSU:E.0 = Junction:X.1;  
 ADSU:E.1 = One.0;  
 ADSU:E.3 = Junction:W.0;  //_GUI 447,76
}

Object ( Bit CO, Bit OFL, Complex S) ADSU
    ( Complex A, Complex B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal",Icon="Add",Documentation="Complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex A) Input;  //_GUI 9,12
 Object ( Complex B) Input:A;  //_GUI 10,27
 Object ( Bit ADD) Input:B;  //_GUI 10,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 10,35
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 97,12
 Object Output:A( Bit OFL) ;  //_GUI 97,21
 Object Output:B( Complex S) ;  //_GUI 97,30
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 50,10
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 50,25
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 79,28
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 16,25
 Object ( Variant Real, Variant Imag) ExposeComplex:A( Complex In1) ;  //_GUI 15,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 41,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 44,35
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 84,19
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 84,10
 Object Text;  //_GUI 34,41,For Complex, the CI is used by both the real and the comples.  Usually it will be the invers of ADD.The CO is used to see if either Real or Imag carried out, not to chain ADSUs together.The OFL is used to see if either Real or Imag overflowed, not to cain ADSUs together.

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 Output:A.0 = OR.0;  
 Output:B.0 = CollectComplex.0;  
 ADSU.0 = ExposeComplex:A.0;  
 ADSU.1 = ExposeComplex.0;  //_GUI 38,15, 38,21, 32,21
 ADSU.2 = Junction.0;  //_GUI 42,18
 ADSU.3 = Junction:A.0;  //_GUI 45,21
 ADSU:A.0 = ExposeComplex:A.1;  //_GUI 35,27, 35,15
 ADSU:A.1 = ExposeComplex.1;  
 ADSU:A.2 = Junction.1;  
 ADSU:A.3 = Junction:A.1;  
 CollectComplex.0 = ADSU.2;  //_GUI 79,18
 CollectComplex.1 = ADSU:A.2;  
 ExposeComplex.0 = Input:A.0;  
 ExposeComplex:A.0 = Input.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:C.0;  
 OR.0 = ADSU.1;  //_GUI 71,21, 71,15
 OR.1 = ADSU:A.1;  //_GUI 71,24, 71,30
 OR:A.0 = ADSU.0;  
 OR:A.1 = ADSU:A.0;  //_GUI 75,15, 75,27
}

Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Advanced"
{
 // Same behavior as Symmetrize except no warnings are produced.  Unsupported combinations of datasets still produce an error message.  See the Symmetrize object documentation for more information.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,21
 Object ( Variant In2) Input:A;  //_GUI 10,24
 Object Output( Variant Out1) ;  //_GUI 41,21
 Object Output:A( Variant Out2) ;  //_GUI 41,24
 Object Text;  //_GUI 25,41,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Bit In) Input:B;  //_GUI 20,27
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 26,20
 //_ Attributes Documentation="Variant"
 Object Text;  //_GUI 17,33,Don't warn.

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 $Symmetrize.0 = Input.0;  
 $Symmetrize.1 = Input:A.0;  
 $Symmetrize.2 = Input:B.0;  
}

Object ( List Out1, List Out2) $Symmetrize( List In1
    , List In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="List"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 13,15
 Object ( List In2) Input:A;  //_GUI 13,28
 Object ( Bit Warn) Input:B;  //_GUI 13,33
 Object Output( List Out1) ;  //_GUI 85,15
 Object Output:A( List Out2) ;  //_GUI 85,28
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,26
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 20,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,26
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 71,13
 Object Text;  //_GUI 25,39,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 46,13
 Object ( Variant Out1, Variant Out2) $Symmetrize:A( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 46,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,33

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 ListIn:A.0 = Input.0;  
 ListOut.0 = $Symmetrize:A.1;  
 ListOut.1 = $Symmetrize.1;  //_GUI 64,28, 64,18
 ListOut:A.0 = $Symmetrize:A.0;  //_GUI 67,18, 67,23, 61,23, 61,28
 ListOut:A.1 = $Symmetrize.0;  
 $Symmetrize.0 = ListIn:A.1;  
 $Symmetrize.1 = ListIn.1;  //_GUI 37,18, 37,28
 $Symmetrize.2 = Junction.0;  //_GUI 43,21
 $Symmetrize:A.0 = ListIn:A.0;  //_GUI 40,28, 40,23, 34,23, 34,18
 $Symmetrize:A.1 = ListIn.0;  
 $Symmetrize:A.2 = Junction.1;  
 Junction.0 = Input:B.0;  
}

Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Signed In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Signed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 16,21
 Object ( Signed In2) Input:A;  //_GUI 16,37
 Object ( Bit Warn) Input:B;  //_GUI 16,43
 Object Output( Signed Out1) ;  //_GUI 100,21
 Object Output:A( Signed Out2) ;  //_GUI 100,37
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 22,35
 Object ( Variant Out1) SignedIn:A( Signed In) ;  //_GUI 22,19
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 86,19
 Object Text;  //_GUI 63,83,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 72,33
 Object ( Variant OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 72,17
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 36,19
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 36,35
 Object ( Signed Out) SignedOut:A( Variant In1) ;  //_GUI 86,35
 Object ( Variant Max) $MaxSigned( Variant A, Variant B
    , Bit Warn) ;  //_GUI 53,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 49,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 68,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 49,37

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 Output:A.0 = SignedOut:A.0;  
 SignedIn.0 = Input:A.0;  
 SignedIn:A.0 = Input.0;  
 SignedOut.0 = TwosExtnd:A.1;  
 TwosExtnd.0 = Junction:A.2;  //_GUI 69,35
 TwosExtnd.1 = Junction:B.1;  
 TwosExtnd:A.0 = Junction:A.0;  //_GUI 69,19
 TwosExtnd:A.1 = Junction.1;  
 MSB.0 = SignedIn:A.0;  
 MSB:A.0 = SignedIn.0;  
 SignedOut:A.0 = TwosExtnd.1;  
 $MaxSigned.0 = Junction.2;  //_GUI 50,27
 $MaxSigned.1 = Junction:B.0;  //_GUI 50,30
 $MaxSigned.2 = Input:B.0;  //_GUI 53,44
 Junction.0 = MSB.0;  
 Junction:A.0 = $MaxSigned.0;  
 Junction:B.0 = MSB:A.0;  
}

Object ( Complex Out1, Complex Out2) $Symmetrize( Complex In1
    , Complex In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Complex"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 9,14
 Object ( Complex In2) Input:A;  //_GUI 9,27
 Object ( Bit Warn) Input:B;  //_GUI 9,32
 Object Output( Complex Out1) ;  //_GUI 90,14
 Object Output:A( Complex Out2) ;  //_GUI 90,27
 Object Text;  //_GUI 12,41,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 44,12
 Object ( Variant Out1, Variant Out2) $Symmetrize:A( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 44,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 40,32
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 16,12
 Object ( Variant Real, Variant Imag) ExposeComplex:A( Complex In1) ;  //_GUI 16,25
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 70,12
 Object ( Complex Out1) CollectComplex:A( Variant Real, Variant Imag) ;  //_GUI 70,25

 //_ Behavior Topology
 Output.0 = CollectComplex.0;  
 Output:A.0 = CollectComplex:A.0;  
 $Symmetrize.0 = ExposeComplex.0;  
 $Symmetrize.1 = ExposeComplex:A.0;  //_GUI 35,17, 35,27
 $Symmetrize.2 = Junction.0;  //_GUI 41,20
 $Symmetrize:A.0 = ExposeComplex.1;  //_GUI 38,27, 38,22, 32,22
 $Symmetrize:A.1 = ExposeComplex:A.1;  
 $Symmetrize:A.2 = Junction.1;  
 Junction.0 = Input:B.0;  
 ExposeComplex.0 = Input.0;  
 ExposeComplex:A.0 = Input:A.0;  
 CollectComplex.0 = $Symmetrize.0;  
 CollectComplex.1 = $Symmetrize:A.0;  //_GUI 66,17, 66,22, 60,22, 60,27
 CollectComplex:A.0 = $Symmetrize.1;  //_GUI 63,27, 63,17
 CollectComplex:A.1 = $Symmetrize:A.1;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Fixed In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Fixed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 10,25
 Object ( Fixed In2) Input:A;  //_GUI 10,40
 Object ( Bit Warn) Input:B;  //_GUI 10,52
 Object Output( Fixed Out1) ;  //_GUI 108,21
 Object Output:A( Fixed Out2) ;  //_GUI 108,35
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 87,19
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 18,23
 Object ( Variant SWhole, Variant Fract) ExposeFixed:A( Fixed In1) ;  //_GUI 18,38
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 65,45
 Object ( Variant OFL, Variant Out1) PadRight:A( Variant Type
    , Variant Data) ;  //_GUI 65,54
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 66,16
 Object ( Bit OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 66,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 36,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In1) ;  //_GUI 36,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 33,42
 Object ( Fixed Out1) CollectFixed:A( Variant SWhole, Variant Fract) ;  //_GUI 92,33
 Object Text;  //_GUI 15,64,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Max) $MaxFract( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 60,46
 Object ( Variant Max) $MaxSWhole( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 42,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 39,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 61,25

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 Output:A.0 = CollectFixed:A.0;  
 CollectFixed.0 = TwosExtnd.1;  
 CollectFixed.1 = PadRight.1;  //_GUI 87,50
 ExposeFixed.0 = Input.0;  
 ExposeFixed:A.0 = Input:A.0;  
 PadRight.0 = Junction:C.1;  
 PadRight.1 = Junction:A.2;  //_GUI 37,50
 PadRight:A.0 = Junction:C.2;  //_GUI 61,56
 PadRight:A.1 = Junction:B.2;  //_GUI 34,59
 TwosExtnd.0 = Junction:F.0;  //_GUI 62,18
 TwosExtnd.1 = Junction.0;  //_GUI 37,21
 TwosExtnd:A.0 = Junction:F.2;  //_GUI 62,32
 TwosExtnd:A.1 = Junction:D.1;  
 Junction.0 = ExposeFixed.0;  
 Junction:A.0 = ExposeFixed.1;  //_GUI 37,28
 Junction:B.0 = ExposeFixed:A.1;  
 CollectFixed:A.0 = TwosExtnd:A.1;  
 CollectFixed:A.1 = PadRight:A.1;  //_GUI 92,59
 $MaxFract.0 = Junction:A.1;  
 $MaxFract.1 = Junction:B.1;  
 $MaxFract.2 = Junction:E.2;  
 Junction:C.0 = $MaxFract.0;  //_GUI 61,41
 $MaxSWhole.0 = Junction.1;  
 $MaxSWhole.1 = Junction:D.0;  //_GUI 43,28
 $MaxSWhole.2 = Junction:E.1;  //_GUI 40,31
 Junction:D.0 = ExposeFixed:A.0;  //_GUI 31,35
 Junction:E.0 = Input:B.0;  //_GUI 40,53
 Junction:F.0 = $MaxSWhole.0;  
}

Object ( Floating Out1, Floating Out2) $Symmetrize( Floating In1
    , Floating In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Floating"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 6,33
 Object ( Floating In2) Input:A;  //_GUI 6,47
 Object ( Bit Warn) Input:B;  //_GUI 6,62
 Object Output( Floating Out1) ;  //_GUI 99,28
 Object Output:A( Floating Out2) ;  //_GUI 99,56
 Object ( Variant SBExp, Variant Mant) ExposeFloating( Floating In1) ;  //_GUI 20,31
 Object ( Variant SBExp, Variant Mant) ExposeFloating:A( Floating In1) ;  //_GUI 20,45
 Object ( Floating Out1) CollectFloating( Variant SBExp, Variant Mant) ;  //_GUI 64,32
 Object ( Bit OFL, Floating Out2) FloatExtnd( Floating Type
    , Floating Data) ;  //_GUI 85,24
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction
    ( Floating In0) ;  //_GUI 13,33
 Object ( Bit OFL, Floating Out2) FloatExtnd:A( Floating Type
    , Floating Data) ;  //_GUI 85,52
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:A
    ( Floating In0) ;  //_GUI 81,34
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:B
    ( Floating In0) ;  //_GUI 13,47
 Object Text;  //_GUI 34,16,Construct a Floating dataset with the larger of the two exponents and the larger of the two mantissas then convert both inputs to this dataset.
 Object Text;  //_GUI 20,65,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Max) $MaxMant( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,45
 Object ( Variant Max) $MaxSBExp( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 41,52

 //_ Behavior Topology
 Output.0 = FloatExtnd.1;  
 Output:A.0 = FloatExtnd:A.1;  
 ExposeFloating.0 = Junction.1;  
 ExposeFloating:A.0 = Junction:B.1;  
 CollectFloating.0 = $MaxSBExp.0;  
 CollectFloating.1 = $MaxMant.0;  //_GUI 62,37, 62,48
 FloatExtnd.0 = Junction:A.0;  //_GUI 82,26
 FloatExtnd.1 = Junction.0;  //_GUI 14,29
 Junction.0 = Input.0;  
 FloatExtnd:A.0 = Junction:A.2;  //_GUI 82,54
 FloatExtnd:A.1 = Junction:B.2;  //_GUI 14,57
 Junction:A.0 = CollectFloating.0;  
 Junction:B.0 = Input:A.0;  
 $MaxMant.0 = ExposeFloating.1;  //_GUI 45,43, 36,43
 $MaxMant.1 = ExposeFloating:A.1;  
 $MaxMant.2 = Junction:C.2;  
 $MaxSBExp.0 = ExposeFloating.0;  
 $MaxSBExp.1 = ExposeFloating:A.0;  //_GUI 39,36, 39,47
 $MaxSBExp.2 = Junction:C.1;  //_GUI 42,39
 Junction:C.0 = Input:B.0;  //_GUI 42,63
}

Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Variant In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Signed/var"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 10,11
 Object ( Variant In2) Input:A;  //_GUI 10,19
 Object ( Bit Warn) Input:B;  //_GUI 10,23
 Object Output( Signed Out1) ;  //_GUI 65,14
 Object Output:A( Signed Out2) ;  //_GUI 65,17
 Object Text;  //_GUI 20,57,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 22,15
 Object ( Bit In) Input:C;  //_GUI 16,16
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 23,25,Convert the unsigned dataset into a twos complement dataset by adding a zero MSB then wrap as Signed.
 Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Signed In2, Bit Warn) ;  //_GUI 50,13
 //_ Attributes Documentation="Signed"
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 37,15
 Object ( Bit Out1) $SymmInvalidDS( Variant In1) ;  //_GUI 20,42
 Object Output:B( Bit Error) ;  //_GUI 66,44
 //_ Attributes Trap="Error: Can not symmetrize these inputs.  Behavior is undefined."
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 16,19
 Object Output:C( Bit Warning) ;  //_GUI 66,38
 //_ Attributes Trap="Warning: Converting Unsigned input to Signed dataset by adding a zero most significant bit."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 19,23
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,36
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 42,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 39,44

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 CollectMSB.0 = Input:C.0;  
 CollectMSB.1 = Junction.1;  
 $Symmetrize.0 = Input.0;  //_GUI 49,15, 49,12
 $Symmetrize.1 = SignedOut.0;  
 $Symmetrize.2 = Junction:A.1;  //_GUI 50,24
 SignedOut.0 = CollectMSB.0;  
 $SymmInvalidDS.0 = Junction.2;  //_GUI 17,45
 Output:B.0 = Junction:B.1;  
 Junction.0 = Input:A.0;  
 Output:C.0 = AND.0;  
 Junction:A.0 = Input:B.0;  
 AND.0 = Junction:A.2;  //_GUI 20,38
 AND.1 = INVERT.0;  
 INVERT.0 = Junction:B.0;  //_GUI 40,41
 Junction:B.0 = $SymmInvalidDS.0;  
}

Object ( Signed Out1, Signed Out2) $Symmetrize( Variant In2
    , Signed In1, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/Signed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,10
 Object ( Signed In1) Input:A;  //_GUI 10,13
 Object ( Bit Warn) Input:B;  //_GUI 10,19
 Object Output( Signed Out1) ;  //_GUI 58,10
 Object Output:A( Signed Out2) ;  //_GUI 58,13
 Object Text;  //_GUI 6,27,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Variant In2, Bit Warn) ;  //_GUI 34,12
 //_ Attributes Documentation="Signed/var"

 //_ Behavior Topology
 Output.0 = $Symmetrize.1;  //_GUI 52,11, 52,17
 Output:A.0 = $Symmetrize.0;  
 $Symmetrize.0 = Input:A.0;  
 $Symmetrize.1 = Input.0;  //_GUI 23,17, 23,11
 $Symmetrize.2 = Input:B.0;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Signed In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Fixed/Signed"
{
 // Description:
 // Takes any two input data sets and outputs equivalent symmetrical data sets.  Symmetrical data sets are data sets that have not only the same context, but also the same bit patterns.  This object is capable of symmetrizing different integer types, ie Fixed, Signed and Nums (unsigned integers).  It can also symmetrize Floating values, but it cannot do integer type to Floating conversions.  A warning message will be produced if the object is used in this way.  (The Floating type will be treated as an integer.)
 //
 // Inputs:
 // In1:  input data set
 // In2:  input data set
 //
 // Outputs:
 // Out1:  symmetrized output data set from In1
 // Out2:  symmetrized output data set from In1
 //
 // Date:
 // Nov 16, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 11,12
 Object ( Signed In2) Input:A;  //_GUI 11,25
 Object ( Bit Warn) Input:B;  //_GUI 11,35
 Object Output( Fixed Out1) ;  //_GUI 80,25
 Object Output:A( Fixed Out2) ;  //_GUI 80,28
 Object Text;  //_GUI 14,54,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 21,23
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 50,26
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Fixed In2, Bit Warn) ;  //_GUI 65,24
 //_ Attributes Documentation="Fixed"
 Object Text;  //_GUI 14,44,Convert the signed value into a twos complement value then into a Fixed with zeroed fraction bits, then symmetrize it with the other Fixed input.
 Object Output:B( Bit Warning) ;  //_GUI 21,38
 //_ Attributes Trap="Warning: Converting Signed input to a fixed dataset by adding zeroed fraction bits."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 17,35
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 21,14
 Object ( Fixed Out1, Fixed Out2, Fixed Out3) Junction:A
    ( Fixed In0) ;  //_GUI 18,12
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 37,28
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 SignedIn.0 = Input:A.0;  
 CollectFixed.0 = SignedIn.0;  //_GUI 50,26
 CollectFixed.1 = Zero.0;  
 $Symmetrize.0 = Junction:A.1;  //_GUI 65,13
 $Symmetrize.1 = CollectFixed.0;  
 $Symmetrize.2 = Junction.1;  //_GUI 65,36
 Output:B.0 = Junction.2;  //_GUI 18,39
 Junction.0 = Input:B.0;  
 ExposeFixed.0 = Junction:A.2;  //_GUI 19,17
 Junction:A.0 = Input.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 35,31, 35,19
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Signed In2
    , Fixed In1, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Signed/Fixed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In2) Input;  //_GUI 10,14
 Object ( Fixed In1) Input:A;  //_GUI 10,17
 Object ( Bit Warn) Input:B;  //_GUI 10,23
 Object Output( Fixed Out1) ;  //_GUI 41,14
 Object Output:A( Fixed Out2) ;  //_GUI 41,17
 Object Text;  //_GUI 9,31,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Signed In2, Bit Warn) ;  //_GUI 21,16
 //_ Attributes Documentation="Fixed/Signed"

 //_ Behavior Topology
 Output.0 = $Symmetrize.1;  //_GUI 38,15, 38,21
 Output:A.0 = $Symmetrize.0;  
 $Symmetrize.0 = Input:A.0;  
 $Symmetrize.1 = Input.0;  //_GUI 18,21, 18,15
 $Symmetrize.2 = Input:B.0;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Variant In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="Fixed/var"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 10,5
 Object ( Variant In2) Input:A;  //_GUI 10,22
 Object ( Bit Warn) Input:B;  //_GUI 10,33
 Object Output( Fixed Out1) ;  //_GUI 81,18
 Object Output:A( Fixed Out2) ;  //_GUI 81,21
 Object Text;  //_GUI 16,68,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 22,18
 Object ( Bit In) Input:C;  //_GUI 16,19
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 23,36,Convert the unsigned dataset into a twos complement dataset by adding a zero MSB then collect into a Fixed with zeroed fraction bits.
 Object ( Bit Out1) $SymmInvalidDS( Variant In1) ;  //_GUI 25,55
 Object Output:B( Bit Error) ;  //_GUI 71,57
 //_ Attributes Trap="Error: Can not symmetrize these inputs.  Behavior is undefined."
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 16,22
 Object Output:C( Bit Warning) ;  //_GUI 71,51
 //_ Attributes Trap="Warning: Converting Unsigned input to Fixed dataset by adding a zero most significant bit to the signed whole and zeroed bits to the Fract portions."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 59,49
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 47,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 44,57
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 19,33
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 22,9
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 50,19
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 38,21
 //_ Attributes Documentation="Bit"
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Fixed In2, Bit Warn) ;  //_GUI 66,17
 //_ Attributes Documentation="Fixed"
 Object ( Fixed Out1, Fixed Out2, Fixed Out3) Junction:C
    ( Fixed In0) ;  //_GUI 17,5

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 CollectMSB.0 = Input:C.0;  
 CollectMSB.1 = Junction.1;  
 $SymmInvalidDS.0 = Junction.2;  //_GUI 17,58
 Output:B.0 = Junction:A.1;  
 Junction.0 = Input:A.0;  
 Output:C.0 = AND.0;  
 AND.0 = Junction:B.2;  //_GUI 20,51
 AND.1 = INVERT.0;  
 INVERT.0 = Junction:A.0;  //_GUI 45,54
 Junction:A.0 = $SymmInvalidDS.0;  
 Junction:B.0 = Input:B.0;  
 ExposeFixed.0 = Junction:C.2;  //_GUI 18,12
 CollectFixed.0 = CollectMSB.0;  
 CollectFixed.1 = Zero.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 37,24, 37,14
 $Symmetrize.0 = Junction:C.1;  //_GUI 66,6
 $Symmetrize.1 = CollectFixed.0;  
 $Symmetrize.2 = Junction:B.1;  //_GUI 66,34
 Junction:C.0 = Input.0;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Variant In2
    , Fixed In1, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/Fixed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,14
 Object ( Fixed In1) Input:A;  //_GUI 10,17
 Object ( Bit Warn) Input:B;  //_GUI 10,23
 Object Output( Fixed Out1) ;  //_GUI 40,14
 Object Output:A( Fixed Out2) ;  //_GUI 40,17
 Object Text;  //_GUI 10,31,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Variant In2, Bit Warn) ;  //_GUI 20,16
 //_ Attributes Documentation="Fixed/var"

 //_ Behavior Topology
 Output.0 = $Symmetrize.1;  //_GUI 37,15, 37,21
 Output:A.0 = $Symmetrize.0;  
 $Symmetrize.0 = Input:A.0;  
 $Symmetrize.1 = Input.0;  //_GUI 17,21, 17,15
 $Symmetrize.2 = Input:B.0;  
}

Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 9,120
 Object ( Variant In2) Input:A;  //_GUI 9,132
 Object ( Bit Warn) Input:B;  //_GUI 9,173
 Object Output( Variant Out1) ;  //_GUI 212,122
 Object Output:A( Variant Out2) ;  //_GUI 212,134
 Object ( Bit Out1) SameDataSets( Variant In1, Variant In2) ;  //_GUI 22,146
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 18,120
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 46,148
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 46,135
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 50,180
 Object Output:B( Variant Trap) ;  //_GUI 74,180
 //_ Attributes Trap="Warning: Converting smaller dataset size to larger size."
 Object Text;  //_GUI 21,80,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 15,132
 Object ( Bit Out1) BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 22,156
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In1) ;  //_GUI 18,147
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 15,150
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 187,139
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 168,141
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 96,158
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 72,138
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 114,99
 Object ( Variant Out1, Variant Out2) $Symmetrize:A( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 114,87
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 92,99
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 138,99
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 93,87
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 110,106
 Object ( Variant Out) VariantOut:A( Variant In1, Variant In2) ;  //_GUI 138,87
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 154,85
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 154,97
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In3) ;  //_GUI 88,89
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In1) ;  //_GUI 150,86
 Object ( Variant OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 135,29
 //_ Attributes Documentation="PadLeft"
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 91,34
 //_ Attributes Documentation="NULL/NULL"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In3) ;  //_GUI 108,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 128,22
 Object ( Variant OFL, Variant Out1) UExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 135,15
 //_ Attributes Documentation="PadLeft"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In0) ;  //_GUI 108,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In0) ;  //_GUI 150,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Q
    ( Variant In3) ;  //_GUI 125,26
 Object Text;  //_GUI 109,39,If different datasets and different lengths, unsign extend the smaller one to match the bigger one.
 Object Text;  //_GUI 113,110,If the same datasets but different sizes, do a variant split and recurse on $Symmetrize.  This could occur on contextual or user-defined datasets without a $Symmetrize overload.
 Object Text;  //_GUI 113,130,If the same datasets and same sizes, then already symmetrized so just pass through.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In0) ;  //_GUI 58,173
 Object Text;  //_GUI 41,198,If different datasets and different bitlengths and not invalid inputs and Warn and then signal a warning trapIf invalid inputs then signal an error trap.We are not warning in the case of different datasets but same lengths.  Usually this is a case of MSBxxx,  LSBxxx and BINxxx and not a concern so we silently convert the lower to the upper context.We are not warning here for same datasets but different lengths because the recursive calls to $Symmetrize will warn if necessary.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In3) ;  //_GUI 69,67
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 130,63
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In0) ;  //_GUI 126,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In3) ;  //_GUI 87,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:V
    ( Variant In3) ;  //_GUI 84,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In3) ;  //_GUI 168,68
 Object Text;  //_GUI 97,57,If different datasets and same lengths, apply the upper context to the lower.
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 50,183
 Object ( Bit Out1) $SymmInvalidDS( Variant In1, Variant In2) ;  //_GUI 22,165
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:X
    ( Variant In1) ;  //_GUI 18,157
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Y
    ( Variant In1) ;  //_GUI 15,160
 Object ( Variant Out1) AND( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 62,178
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 50,186
 Object Output:C( Bit Error) ;  //_GUI 74,191
 //_ Attributes Trap="Error: Can not symmetrize these inputs.  Behavior is undefined."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Z
    ( Bit In1) ;  //_GUI 40,188
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 51,119
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant In1
    , Bit S) ;  //_GUI 51,131
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant In1
    , Bit S) ;  //_GUI 73,50
 Object ( Variant "#0", Variant "#1") $SelectOut:C( Variant In1
    , Bit S) ;  //_GUI 73,63
 Object ( Variant "#0", Variant "#1") $SelectOut:D( Variant In1
    , Bit S) ;  //_GUI 76,122
 Object ( Variant "#0", Variant "#1") $SelectOut:E( Variant In1
    , Bit S) ;  //_GUI 76,134
 Object ( Variant "#0", Variant "#1") $SelectOut:F( Variant In1
    , Bit S) ;  //_GUI 112,18
 Object ( Variant "#0", Variant "#1") $SelectOut:G( Variant In1
    , Bit S) ;  //_GUI 112,29
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 154,18
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 154,29
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,50
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,61
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,122
 Object ( Variant Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,134
 Object ( Variant Out) $Select:F( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 196,120
 Object ( Variant Out) $Select:G( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 196,132
 Object ( Bit Out1) BitA_Eq_BitB:A( Variant A, Variant B) ;  //_GUI 70,156
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:a
    ( Variant In0) ;  //_GUI 65,135
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:b
    ( Variant In0) ;  //_GUI 69,123
 Object ( Bit Out1) BitA_Eq_BitB:B( Variant A, Variant B) ;  //_GUI 69,104
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:c
    ( Variant In3) ;  //_GUI 62,105
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:d
    ( Variant In3) ;  //_GUI 65,108
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:e
    ( Bit In3) ;  //_GUI 69,76

 //_ Behavior Topology
 Output.0 = $Select:F.0;  
 Output:A.0 = $Select:G.0;  
 SameDataSets.0 = Junction:D.1;  
 SameDataSets.1 = Junction:E.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = SameDataSets.0;  
 Junction:B.0 = Junction:A.0;  
 INVERT.0 = Junction:A.2;  //_GUI 47,183
 Output:B.0 = AND.0;  
 Junction:C.0 = Input:A.0;  
 BitA_Eq_BitB.0 = Junction:X.1;  
 BitA_Eq_BitB.1 = Junction:Y.1;  
 Junction:D.0 = Junction.2;  
 Junction:E.0 = Junction:C.2;  
 Junction:F.0 = Junction:A.1;  //_GUI 188,149
 Junction:G.0 = Junction:H.1;  //_GUI 169,159
 Junction:H.0 = BitA_Eq_BitB:A.0;  
 Junction:I.0 = Junction:H.0;  //_GUI 73,153, 97,153
 $Symmetrize.0 = VariantIn:A.0;  //_GUI 106,101, 106,92
 $Symmetrize.1 = VariantIn.0;  
 $Symmetrize.2 = Junction:J.2;  
 $Symmetrize:A.0 = VariantIn:A.1;  
 $Symmetrize:A.1 = VariantIn.1;  //_GUI 109,92, 109,97, 103,97
 $Symmetrize:A.2 = Junction:J.1;  //_GUI 111,95
 VariantIn.0 = $SelectOut:E.0;  //_GUI 92,136
 VariantOut.0 = $Symmetrize.1;  
 VariantOut.1 = $Symmetrize:A.1;  //_GUI 135,101, 135,92
 VariantIn:A.0 = Junction:K.2;  
 Junction:J.0 = Junction:R.1;  //_GUI 111,174
 VariantOut:A.0 = $Symmetrize.0;  //_GUI 138,98, 127,98
 VariantOut:A.1 = $Symmetrize:A.0;  
 $Cast.0 = VariantOut:A.0;  
 $Cast.1 = Junction:L.1;  
 $Cast:A.0 = VariantOut.0;  
 $Cast:A.1 = Junction:L.2;  //_GUI 151,99
 Junction:K.0 = $SelectOut:D.0;  //_GUI 89,124
 Junction:L.0 = Junction:K.1;  //_GUI 151,85, 89,85
 UExtnd.0 = Junction:N.2;  //_GUI 129,31
 UExtnd.1 = $SelectOut:G.1;  
 $BitA_Gt_BitB.0 = Junction:V.2;  
 $BitA_Gt_BitB.1 = Junction:U.2;  
 Junction:M.0 = Junction:O.0;  
 Junction:N.0 = $SelectOut:F.1;  
 UExtnd:A.0 = Junction:Q.1;  //_GUI 126,17
 UExtnd:A.1 = $SelectOut:F.0;  
 Junction:O.0 = $BitA_Gt_BitB.0;  
 Junction:P.0 = Junction:O.1;  
 Junction:Q.0 = $SelectOut:G.0;  //_GUI 126,31
 Junction:R.0 = Input:B.0;  
 Junction:S.0 = Junction:e.1;  
 Context.0 = Junction:T.2;  //_GUI 127,65
 Context.1 = $SelectOut:C.1;  
 Junction:T.0 = $SelectOut:B.1;  
 Junction:U.0 = $SelectOut:C.0;  //_GUI 88,65
 Junction:V.0 = $SelectOut:B.0;  
 Junction:W.0 = Junction:e.2;  //_GUI 169,77
 INVERT:A.0 = BitA_Eq_BitB.0;  //_GUI 44,186, 44,159
 $SymmInvalidDS.0 = Junction:X.2;  //_GUI 19,167
 $SymmInvalidDS.1 = Junction:Y.2;  //_GUI 16,170
 Junction:X.0 = Junction:D.2;  
 Junction:Y.0 = Junction:E.2;  
 AND.0 = Junction:R.2;  //_GUI 59,180
 AND.1 = INVERT.0;  
 AND.2 = INVERT:A.0;  
 AND.3 = INVERT:B.0;  
 INVERT:B.0 = Junction:Z.1;  
 Output:C.0 = Junction:Z.2;  //_GUI 41,192
 Junction:Z.0 = $SymmInvalidDS.0;  //_GUI 41,168
 $SelectOut.0 = Junction.1;  
 $SelectOut.1 = Junction:B.1;  //_GUI 47,124
 $SelectOut:A.0 = Junction:C.1;  
 $SelectOut:A.1 = Junction:B.2;  
 $SelectOut:B.0 = Junction:c.1;  //_GUI 63,52
 $SelectOut:B.1 = Junction:S.1;  //_GUI 70,55
 $SelectOut:C.0 = Junction:d.1;  //_GUI 66,65
 $SelectOut:C.1 = Junction:S.2;  
 $SelectOut:D.0 = Junction:b.1;  
 $SelectOut:D.1 = Junction:I.1;  //_GUI 73,127
 $SelectOut:E.0 = Junction:a.1;  
 $SelectOut:E.1 = Junction:I.2;  
 $SelectOut:F.0 = Junction:V.1;  //_GUI 85,20
 $SelectOut:F.1 = Junction:M.1;  //_GUI 109,23
 $SelectOut:G.0 = Junction:U.1;  //_GUI 88,31
 $SelectOut:G.1 = Junction:M.2;  
 $Select.0 = UExtnd:A.1;  
 $Select.1 = Junction:N.1;  
 $Select.2 = Junction:P.0;  //_GUI 151,26
 $Select:A.0 = Junction:Q.2;  //_GUI 148,31, 148,27
 $Select:A.1 = UExtnd.1;  
 $Select:A.2 = Junction:P.1;  
 $Select:B.0 = $Select.0;  //_GUI 175,21
 $Select:B.1 = Junction:T.1;  
 $Select:B.2 = Junction:W.1;  //_GUI 169,58
 $Select:C.0 = $Select:A.0;  //_GUI 172,63, 172,32
 $Select:C.1 = Context.0;  
 $Select:C.2 = Junction:W.2;  
 $Select:D.0 = $Cast.0;  //_GUI 175,88
 $Select:D.1 = $SelectOut:D.1;  
 $Select:D.2 = Junction:G.1;  //_GUI 169,130
 $Select:E.0 = $Cast:A.0;  //_GUI 172,136, 172,100
 $Select:E.1 = $SelectOut:E.1;  
 $Select:E.2 = Junction:G.2;  
 $Select:F.0 = $Select:B.0;  //_GUI 196,53
 $Select:F.1 = $Select:D.0;  
 $Select:F.2 = Junction:F.1;  //_GUI 188,128
 $Select:G.0 = $Select:C.0;  //_GUI 193,134, 193,64
 $Select:G.1 = $Select:E.0;  
 $Select:G.2 = Junction:F.2;  
 BitA_Eq_BitB:A.0 = Junction:b.2;  
 BitA_Eq_BitB:A.1 = Junction:a.2;  //_GUI 66,161
 Junction:a.0 = $SelectOut:A.1;  
 Junction:b.0 = $SelectOut.1;  
 BitA_Eq_BitB:B.0 = Junction:c.2;  
 BitA_Eq_BitB:B.1 = Junction:d.2;  
 Junction:c.0 = $SelectOut.0;  
 Junction:d.0 = $SelectOut:A.0;  //_GUI 66,133
 Junction:e.0 = BitA_Eq_BitB:B.0;  //_GUI 70,97, 83,97
}

Object ( Variant Out1) $OR-NInput( Variant In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="var/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,24
 Object ( Bit In2) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,22
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 43,22
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input.0;  
 OR.0 = $OR-NInput.0;  
 OR.1 = Input:A.0;  //_GUI 59,32
 $OR-NInput.0 = VariantIn.1;  
 $OR-NInput.1 = VariantIn.0;  
}

Object ( Bit Out1) $OR-NInput( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,24
 Object ( Bit In2) Input:A;  //_GUI 11,27
 Object Output( Bit Out1) ;  //_GUI 31,25
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 18,23

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
}

Object ( Variant Out1) $OR-NInput( Bit In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In2) Input;  //_GUI 10,24
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input:A.0;  
 OR.0 = Input.0;  
 OR.1 = $OR-NInput.0;  //_GUI 59,32
 $OR-NInput.0 = VariantIn.1;  
 $OR-NInput.1 = VariantIn.0;  
}

Object ( Variant Out1) $OR-NInput( Variant In1, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$OR",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,20
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 16,18
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 30,18
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1) $OR-NInput:A( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = Input.0;  
 OR.0 = $OR-NInput.0;  //_GUI 59,21
 OR.1 = $OR-NInput:A.0;  //_GUI 59,32
 $OR-NInput.0 = VariantIn:A.1;  
 $OR-NInput.1 = VariantIn:A.0;  
 $OR-NInput:A.0 = VariantIn.1;  
 $OR-NInput:A.1 = VariantIn.0;  
}

Object ( NULL Out1, Bit Out1) ExposeBIN( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\ExposeBIN",Icon="Exposer_In",Documentation="Bit"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 38,34
 Object Output( NULL Out1) ;  //_GUI 63,26
 Object Output:A( Bit Out1) ;  //_GUI 58,34
 Object ( NULL Out1) NULL;  //_GUI 50,24

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2) ExposeBIN( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\ExposeBIN",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 16,21
 Object Output( Variant Out1) ;  //_GUI 52,20
 Object Output:A( Variant Out2) ;  //_GUI 52,23
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 25,19
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 38,19

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  
 BIN.0 = Input.0;  
 VariantIn.0 = BIN.0;  
}

Object ( NULL Out1, NULL Out1) ExposeBIN( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\ExposeBIN",Icon="Exposer_In",Documentation="NULL"
{
 // Date:
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 36,32
 Object Output( NULL Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,39
 Junction.0 = Input.0;  
}

Object ( Bit OFL, Variant S) $ResolveError( Bit CO
    , Bit OFL, Variant S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Variant S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,21
 Object Output:A( Variant S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For unsigned datasets, CO is the error condition

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit OFL, Signed S) $ResolveError( Bit CO
    , Bit OFL, Signed S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="signed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Signed S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,24
 Object Output:A( Signed S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For signed datasets, OFL is the error condition

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit OFL, Fixed S) $ResolveError( Bit CO
    , Bit OFL, Fixed S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="fixed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Fixed S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,24
 Object Output:A( Fixed S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For fixed datasets, OFL is the error condition

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit OFL, Floating S) $ResolveError( Bit CO
    , Bit OFL, Floating S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Floating S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,24
 Object Output:A( Floating S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For fixed datasets, OFL is the error condition

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( List OFL, List S) $ResolveError( List CO
    , List OFL, List S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List CO) Input;  //_GUI 22,33
 Object ( List OFL) Input:A;  //_GUI 22,42
 Object ( List S) Input:B;  //_GUI 22,51
 Object Output( List OFL) ;  //_GUI 79,35
 Object Output:A( List S) ;  //_GUI 79,44
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,31
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 66,33
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,40
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 28,49
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 66,42
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 48,18
 Object ( Variant OFL, Variant S) $ResolveError:A( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 45,60

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $ResolveError:A.0;  //_GUI 60,38
 ListOut.1 = $ResolveError.0;  //_GUI 66,20
 ListIn:A.0 = Input:A.0;  
 ListIn:B.0 = Input:B.0;  
 ListOut:A.0 = $ResolveError:A.1;  //_GUI 66,65
 ListOut:A.1 = $ResolveError.1;  //_GUI 63,44
 $ResolveError.0 = ListIn.1;  //_GUI 39,20
 $ResolveError.1 = ListIn:A.1;  //_GUI 42,23, 42,42
 $ResolveError.2 = ListIn:B.1;  //_GUI 48,51
 $ResolveError:A.0 = ListIn.0;  //_GUI 45,36
 $ResolveError:A.1 = ListIn:A.0;  //_GUI 42,65, 42,45
 $ResolveError:A.2 = ListIn:B.0;  //_GUI 39,68
}

Object ( Variant OFL, Complex S) $ResolveError( Bit CO
    , Bit OFL, Complex S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 6,16
 Object ( Bit OFL) Input:A;  //_GUI 6,19
 Object ( Complex S) Input:B;  //_GUI 6,23
 Object Output( Variant OFL) ;  //_GUI 59,16
 Object Output:A( Complex S) ;  //_GUI 59,29
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 16,21
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 36,15
 Object ( Complex Out1, Complex Out2, Complex Out3) Junction
    ( Complex In0) ;  //_GUI 12,23
 Object Text;  //_GUI 18,33,Both the real and imaginary portions have the same dataset so just use one of them to resolve the error.

 //_ Behavior Topology
 Output.0 = $ResolveError.0;  
 Output:A.0 = Junction.2;  //_GUI 13,30
 ExposeComplex.0 = Junction.1;  
 $ResolveError.0 = Input.0;  
 $ResolveError.1 = Input:A.0;  
 $ResolveError.2 = ExposeComplex.0;  
 Junction.0 = Input:B.0;  
}

Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 35,35
 Object ( Bit S) Input:A;  //_GUI 36,54
 //_ Attributes Constant="0"
 Object Output( Variant "#0") ;  //_GUI 68,36
 Object Output:A( Variant "#1") ;  //_GUI 67,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,35
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 47,54
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,47

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Junction.0 = Input.0;  
 $Select.0 = Junction.1;  
 $Select.2 = Junction:A.0;  //_GUI 48,42
 Junction:A.0 = Input:A.0;  
 $Select:A.1 = Junction.2;  //_GUI 44,52
 $Select:A.2 = Junction:A.1;  
}

Object ( NULL "#0", NULL "#1") $SelectOut( NULL D
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 35,35
 Object ( Bit S) Input:A;  //_GUI 36,54
 Object Output( NULL "#0") ;  //_GUI 68,36
 Object Output:A( NULL "#1") ;  //_GUI 67,49
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 43,35
 Object ( NULL Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 47,54
 Object ( NULL Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,47

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Junction.0 = Input.0;  
 $Select.0 = Junction.1;  
 $Select.2 = Junction:A.0;  //_GUI 48,42
 Junction:A.0 = Input:A.0;  
 $Select:A.1 = Junction.2;  //_GUI 44,52
 $Select:A.2 = Junction:A.1;  
}

Object ( Bit OFL, Variant Out1) Convert( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 15,15
 Object ( Variant Data) Input:A;  //_GUI 15,18
 Object Output( Bit OFL) ;  //_GUI 66,15
 Object Output:A( Variant Out1) ;  //_GUI 66,18
 Object ( Bit OFL, Variant Out1) $Convert( Variant Type
    , Variant Data) ;  //_GUI 27,14
 //_ Attributes Documentation="Signed"

 //_ Behavior Topology
 Output.0 = $Convert.0;  
 Output:A.0 = $Convert.1;  
 $Convert.0 = Input.0;  
 $Convert.1 = Input:A.0;  
}

Object ( Bit OFL, Variant Out1) Convert( Variant Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="List"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 15,15
 Object ( List Data) Input:A;  //_GUI 15,18
 Object Output( Bit OFL) ;  //_GUI 55,15
 Object Output:A( Variant Out1) ;  //_GUI 55,20
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 41,13
 Object ( Variant OFL, Variant Out1) ConvertList( Variant Type
    , Variant Data) ;  //_GUI 27,14
 //_ Attributes Documentation="List/List"
 Object Text;  //_GUI 12,30,Takes either list/list or var/list

 //_ Behavior Topology
 Output.0 = OR-NInput.0;  
 Output:A.0 = ConvertList.1;  //_GUI 39,21
 OR-NInput.0 = ConvertList.0;  
 ConvertList.0 = Input.0;  
 ConvertList.1 = Input:A.0;  
}

Object ( Variant RdData, Variant WrRdyCnt, Bit WrBsy
    , Bit WrAlmBsy, Bit WrErr, Variant RdRdyCnt, Bit RdBsy
    , Bit RdAlmBsy, Bit RdErr) FIFO_Basic( Variant WrData, Variant AddrBits
    , Variant BsyBits, Bit WrClk, Bit WrEn, Bit RdClk
    , Bit RdEn, Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\Advanced"
{
 // First In First Out
 //
 // This FIFO allows the write side and the read side to be in different clock domains.
 //
 // Inputs:
 // WrData - Write data (ClkWr domain)
 // AddrBits - The bitwidth of the data type defines the size of the memory allocated (2^AddrBits - 1 elements)
 // BsyBits - Defines when the AlmBsy bits come on.
 // WrClk - Write clock
 // WrEn - Write Enable (ClkWr domain)
 // RdClk - Read clock
 // RdEn - Read Enable (ClkRd domain)
 // CLR - Clears the FIFO and any errors. If disconnected, defaults to 0.
 //
 // Outputs:
 // RdData - Read data. (ClkRd domain)
 // WrRdyCnt - the number of free elements ready to be written into (ClkWr domain)
 // WrBusy - The FIFO is full (ClkWr domain)
 // WrAlmBsy - The FIFO is almost full (2^BusyBits - 1 from full) (ClkWr domain)
 // WrErr - A write was performed while the FIFO was full - must CLR (ClkWr domain)
 // RdRdyCnt - the number of elements ready to be read out (ClkRd domain)
 // RdBsy - The FIFO is empty (ClkRd domain)
 // RdAlmBsy - The FIFO is almost empty (2^BusyBits - 1 from empty) (ClkRd domain)
 // RdErr - A read was performed while the FIFO was empty - must CLR (ClkRd domain)
 //
 // This object has been tested at 210 MHz on either side and 66 MHz on the other side with 8 AddrBits (255 elements), 64 data bits and 4 BsyBits with outputs of Rd/WrBsy and Rd/WrAlmBsy outputs.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant WrData) Input;  //_GUI 32,21
 Object ( Variant AddrBits) Input:A;  //_GUI 13,74
 Object ( Variant BsyBits) Input:B;  //_GUI 13,77
 Object ( Bit WrClk) Input:C;  //_GUI 13,80
 Object ( Bit WrEn) Input:D;  //_GUI 13,83
 Object ( Bit RdClk) Input:E;  //_GUI 25,110
 Object ( Bit RdEn) Input:F;  //_GUI 25,113
 Object ( Bit CLR) Input:G;  //_GUI 25,159
 //_ Attributes Constant="0"
 Object Output( Variant RdData) ;  //_GUI 317,24
 Object Output:A( Variant WrRdyCnt) ;  //_GUI 317,57
 Object Output:B( Bit WrBsy) ;  //_GUI 317,60
 Object Output:C( Bit WrAlmBsy) ;  //_GUI 317,63
 Object Output:D( Bit WrErr) ;  //_GUI 317,87
 Object Output:E( Variant RdRdyCnt) ;  //_GUI 320,118
 Object Output:F( Bit RdBsy) ;  //_GUI 320,121
 Object Output:G( Bit RdAlmBsy) ;  //_GUI 320,124
 Object Output:H( Bit RdErr) ;  //_GUI 320,147
 Object Text;  //_GUI 60,103,Read Pointer
 Object Text;  //_GUI 212,47,#avail for write equals RA-WA-1
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 50,80
 Object ( Bit In) Input:H;  //_GUI 207,60
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit In) Input:I;  //_GUI 207,63
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 158,42,Get Gray code of RA into WA's clock domain then convert back to an integer
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 243,57
 Object Text;  //_GUI 253,46,If WriteRdyCnt is zero, we are full and therefore busy.
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 41,73
 Object Text;  //_GUI 215,97,the number avail for read equals WA-RA
 Object ( Bit In) Input:J;  //_GUI 210,121
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit In) Input:K;  //_GUI 210,118
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 56,76
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 243,118
 Object Text;  //_GUI 234,95,If ReadRdyCnt is zero (equal), we are empty and therefore busy.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 51,110
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 120,111
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 136,110
 //_ Attributes ChildAttribute="FPGATNM=timing_group_FifoRead"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 48,113
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 54,152
 Object ( Variant Out1) Int2Gray( Variant In1) ;  //_GUI 124,109
 Object Text;  //_GUI 123,97,The incremented value and its Gray code value are latched simultaneously.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 129,146
 Object ( Variant Q) RegClr:B( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 152,51
 //_ Attributes ChildAttribute="FPGATNM=timing_group_FifoWrite"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 52,83
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 54,89
 Object ( Variant Out1) Gray2Int( Variant In1) ;  //_GUI 163,51
 Object ( Variant Out1) Int2Gray:A( Variant In1) ;  //_GUI 122,69
 Object ( Variant Q) RegClr:C( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 134,70
 //_ Attributes ChildAttribute="FPGATNM=timing_group_FifoWrite"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In3) ;  //_GUI 118,71
 Object Text;  //_GUI 158,97,Get Gray code of WA into RA's clock domain then convert back to an integer
 Object ( Variant Q) RegClr:D( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 157,109
 //_ Attributes ChildAttribute="FPGATNM=timing_group_FifoRead"
 Object ( Variant Out1) Gray2Int:A( Variant In1) ;  //_GUI 173,109
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 133,152
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In0) ;  //_GUI 131,149
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 133,89
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In0) ;  //_GUI 131,91
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In0) ;  //_GUI 128,93
 Object Text;  //_GUI 124,28,The incremented value and its Gray code value are latched simultaneously.
 Object ( Variant Q) RegClr:E( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 251,142
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In0) ;  //_GUI 273,121
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In0) ;  //_GUI 156,152
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In0) ;  //_GUI 154,146
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 41,103
 Object ( Variant Q) RegClr:F( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 234,79
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In0) ;  //_GUI 259,60
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:T
    ( Bit In0) ;  //_GUI 148,93
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:U
    ( Bit In0) ;  //_GUI 151,89
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:V
    ( Variant In0) ;  //_GUI 67,78
 Object ( Variant Q) RegClr:G( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 57,106
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 279,140
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 265,77
 Object Text;  //_GUI 164,157,Using ClrErr to drive an asynchronous clear.  This is OK because ClrErr is driven by a OneShot which is triggered on a PCI write so it doesn't need to be synchronized with any other event (other than maybe halting the FPGA side of the fifo).
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In0) ;  //_GUI 275,144
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:X
    ( Bit In0) ;  //_GUI 258,81
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Y
    ( Bit In0) ;  //_GUI 32,110
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Z
    ( Bit In0) ;  //_GUI 34,113
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 72,106
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:a
    ( Variant In3) ;  //_GUI 69,105
 Object ( Variant Out1) One:A( Variant In1) ;  //_GUI 69,73
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:b
    ( Variant In3) ;  //_GUI 67,75
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:c
    ( Variant In0) ;  //_GUI 69,108
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:d
    ( Bit In3) ;  //_GUI 54,116
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 291,123
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 307,122
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 291,62
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 303,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:e
    ( Variant In0) ;  //_GUI 19,74
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:f
    ( Bit In0) ;  //_GUI 28,80
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:AA
    ( Variant In0) ;  //_GUI 284,66
 Object Text;  //_GUI 97,158,Note the different timing groups in the registers. This is so we can set a timing constraint.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:BA
    ( Variant In0) ;  //_GUI 202,112
 Object Text;  //_GUI 76,64,store WA+1
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:CA
    ( Variant In0) ;  //_GUI 188,54
 Object Text;  //_GUI 190,26,if RA == WA+1 then we are full and therefore busy.
 Object ( Variant Out1) One:B( Variant In1) ;  //_GUI 93,47
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:DA
    ( Variant In0) ;  //_GUI 89,49
 Object ( Variant Out) $Cast:B( Variant Data, Variant Type) ;  //_GUI 44,47
 Object ( Variant Out1) One:C( Variant In1) ;  //_GUI 63,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:EA
    ( Variant In0) ;  //_GUI 58,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:FA
    ( Bit In3) ;  //_GUI 28,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:GA
    ( Bit In3) ;  //_GUI 30,57
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:HA
    ( Bit In0) ;  //_GUI 36,159
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:IA
    ( Bit In0) ;  //_GUI 175,89
 Object Text;  //_GUI 57,73,Write Pointer
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:JA
    ( Bit In0) ;  //_GUI 187,152
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:KA
    ( Bit In0) ;  //_GUI 184,146
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:LA
    ( Bit In0) ;  //_GUI 30,83
 Object ( Variant Q) RegInitPre( Variant D, Variant InitVal
    , Bit ClkG, Bit EN, Bit Preset) ;  //_GUI 76,47
 Object ( Variant OutA, Variant OutB) RAMDP( Variant InA
    , Variant AddrA, Variant AddrB, Bit ClkG, Bit ClkG
    , Bit WE, Bit REB) ;  //_GUI 95,20
 //_ Attributes Documentation="two clocks",read enable
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 263,142
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 246,79
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 109,48
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 99,74
 Object ( Bit CO, Bit OFL, Variant S) ADSU:B
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 100,104
 Object ( Bit CO, Bit OFL, Variant S) ADSU:C
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 211,53
 Object ( Bit CO, Bit OFL, Variant S) ADSU:D
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 214,111
 Object ( Variant Out1) OR:B( Variant In1, Variant In2) ;  //_GUI 142,17
 Object Text;  //_GUI 159,7,This circuit does nothing but get rid of a warning when the Xilinx tools get to the DRC (Design Rule Check) and RAMDP instantiates to the Slice RAM (RAM32X1D).  This circuit should get ripped out.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:MA
    ( Variant In0) ;  //_GUI 126,21
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 128,13
 Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) ;  //_GUI 82,74
 Object ( Variant Out1, Variant Out2) SymmetrizeNW:A( Variant In1
    , Variant In2) ;  //_GUI 83,104
 Object ( Variant Q) RegClr:H( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 188,110
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:NA
    ( Variant In3) ;  //_GUI 206,115
 Object ( Variant Q) RegClr:I( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 176,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:OA
    ( Bit In0) ;  //_GUI 172,93
 Object Text;  //_GUI 178,69,For timing.  Delays throughput latency by one
 Object Text;  //_GUI 190,127,For timing.  Delays throughput latency by one
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 198,35
 Object ( Bit Out1) Equal:A( Variant In1, Variant In2) ;  //_GUI 239,104
 Object ( Bit EN) Input:L;  //_GUI 151,116
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit EN) Input:M;  //_GUI 146,58
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 161,127,external enable to avoid an ngdbuild warning

 //_ Behavior Topology
 Output.0 = RAMDP.1;  
 Output:A.0 = Junction:A.1;  
 Output:B.0 = Junction:S.1;  
 Output:C.0 = EqualZero:A.0;  
 Output:D.0 = Junction:X.2;  //_GUI 259,88
 Output:E.0 = Junction:B.1;  
 Output:F.0 = Junction:P.1;  
 Output:G.0 = EqualZero.0;  
 Output:H.0 = Junction:W.2;  //_GUI 276,148
 Junction.0 = Junction:f.1;  
 Junction:A.0 = ADSU:C.2;  //_GUI 236,58, 236,61
 $Cast.0 = Junction:J.0;  //_GUI 39,78, 39,72
 $Cast.1 = Junction:e.1;  
 RegClr.0 = $Cast.0;  //_GUI 54,78, 54,76
 RegClr.1 = Junction.1;  
 RegClr.2 = Junction:H.1;  
 RegClr.3 = Junction:I.1;  //_GUI 55,87
 Junction:B.0 = ADSU:D.2;  
 Junction:C.0 = Junction:Y.1;  
 Junction:D.0 = ADSU:B.2;  
 RegClr:A.0 = Int2Gray.0;  
 RegClr:A.1 = Junction:G.0;  //_GUI 130,115
 RegClr:A.2 = Junction:L.0;  //_GUI 132,118
 RegClr:A.3 = Junction:K.0;  //_GUI 134,121
 Junction:E.0 = Junction:Z.1;  
 Junction:F.0 = Junction:HA.1;  //_GUI 55,160
 Int2Gray.0 = Junction:D.1;  
 Junction:G.0 = Junction:C.2;  //_GUI 52,147
 RegClr:B.0 = RegClr:A.0;  //_GUI 146,53
 RegClr:B.1 = Junction:T.0;  //_GUI 149,56
 RegClr:B.2 = Input:M.0;  
 RegClr:B.3 = Junction:U.0;  
 Junction:H.0 = Junction:LA.1;  
 Junction:I.0 = Junction:d.1;  
 Gray2Int.0 = RegClr:B.0;  
 Int2Gray:A.0 = Junction:J.2;  
 RegClr:C.0 = Int2Gray:A.0;  
 RegClr:C.1 = Junction:O.0;  //_GUI 129,75
 RegClr:C.2 = Junction:N.0;  //_GUI 132,78
 RegClr:C.3 = Junction:M.0;  
 Junction:J.0 = ADSU:A.2;  //_GUI 119,82
 RegClr:D.0 = RegClr:C.0;  //_GUI 155,111, 155,73
 RegClr:D.1 = Junction:R.0;  //_GUI 155,114
 RegClr:D.2 = Input:L.0;  
 RegClr:D.3 = Junction:Q.0;  
 Gray2Int:A.0 = RegClr:D.0;  
 Junction:K.0 = Junction:F.2;  
 Junction:L.0 = Junction:E.2;  //_GUI 49,150
 Junction:M.0 = Junction:I.2;  
 Junction:N.0 = Junction:H.2;  //_GUI 53,92
 Junction:O.0 = Junction.2;  //_GUI 51,94
 RegClr:E.0 = OR.0;  //_GUI 249,144, 249,139, 293,139, 293,143
 RegClr:E.1 = Junction:KA.1;  
 RegClr:E.2 = Junction:L.1;  
 RegClr:E.3 = Junction:JA.1;  
 Junction:P.0 = Equal:A.0;  //_GUI 256,122, 256,107
 Junction:Q.0 = Junction:K.1;  
 Junction:R.0 = Junction:G.1;  
 $Cast:A.0 = Junction:D.0;  //_GUI 39,108, 39,102, 121,102
 $Cast:A.1 = Junction:e.2;  //_GUI 20,105
 RegClr:F.0 = OR:A.0;  //_GUI 234,76, 278,76, 278,80
 RegClr:F.1 = Junction:OA.1;  //_GUI 226,84, 226,94
 RegClr:F.2 = Junction:N.1;  //_GUI 224,87, 224,92
 RegClr:F.3 = Junction:IA.1;  
 Junction:S.0 = Equal.0;  //_GUI 247,61, 247,38
 Junction:T.0 = Junction:O.1;  
 Junction:U.0 = Junction:M.1;  
 Junction:V.0 = RegClr.0;  
 RegClr:G.0 = $Cast:A.0;  //_GUI 52,108, 52,106
 RegClr:G.1 = Junction:C.1;  
 RegClr:G.2 = Junction:E.1;  
 RegClr:G.3 = Junction:d.2;  
 OR.0 = Junction:P.2;  //_GUI 274,142
 OR.1 = Junction:W.1;  
 OR:A.0 = Junction:S.2;  //_GUI 260,79
 OR:A.1 = Junction:X.1;  
 Junction:W.0 = VouchBit.0;  
 Junction:X.0 = VouchBit:A.0;  
 Junction:Y.0 = Input:E.0;  
 Junction:Z.0 = Input:F.0;  
 One.0 = Junction:c.1;  
 Junction:a.0 = Junction:c.0;  
 One:A.0 = Junction:b.2;  
 Junction:b.0 = Junction:V.0;  
 Junction:c.0 = RegClr:G.0;  
 Junction:d.0 = Junction:F.1;  
 Lo_N.0 = Junction:B.2;  //_GUI 244,125
 Lo_N.1 = Junction:AA.2;  //_GUI 285,128
 EqualZero.0 = Lo_N.0;  
 Lo_N:A.0 = Junction:A.2;  //_GUI 244,64
 Lo_N:A.1 = Junction:AA.1;  
 EqualZero:A.0 = Lo_N:A.0;  
 Junction:e.0 = Input:A.0;  
 Junction:f.0 = Input:C.0;  
 Junction:AA.0 = Input:B.0;  //_GUI 24,67, 24,78
 Junction:BA.0 = RegClr:H.0;  
 Junction:CA.0 = RegClr:I.0;  
 One:B.0 = Junction:DA.1;  
 Junction:DA.0 = RegInitPre.0;  
 $Cast:B.0 = ADSU.2;  //_GUI 42,52, 42,46, 144,46, 144,56
 $Cast:B.1 = Junction:e.0;  //_GUI 20,49
 One:C.0 = Junction:EA.2;  //_GUI 59,52
 Junction:EA.0 = $Cast:B.0;  
 Junction:FA.0 = Junction:f.0;  
 Junction:GA.0 = Junction:LA.0;  
 Junction:HA.0 = Input:G.0;  
 Junction:IA.0 = Junction:U.1;  
 Junction:JA.0 = Junction:Q.1;  
 Junction:KA.0 = Junction:R.1;  
 Junction:LA.0 = Input:D.0;  
 RegInitPre.0 = Junction:EA.0;  //_GUI 74,49, 74,48, 59,48
 RegInitPre.1 = One:C.0;  
 RegInitPre.2 = Junction:FA.2;  
 RegInitPre.3 = Junction:GA.2;  
 RegInitPre.4 = Junction:HA.0;  //_GUI 37,61
 RAMDP.0 = Input.0;  
 RAMDP.1 = Junction:b.1;  //_GUI 68,25
 RAMDP.2 = Junction:a.1;  //_GUI 70,28
 RAMDP.3 = Junction:FA.1;  //_GUI 29,31
 RAMDP.4 = Junction:Y.0;  //_GUI 33,34
 RAMDP.5 = Junction:GA.1;  //_GUI 31,37
 RAMDP.6 = Junction:Z.0;  //_GUI 35,40
 VouchBit.0 = RegClr:E.0;  
 VouchBit:A.0 = RegClr:F.0;  
 ADSU.0 = One:B.0;  
 ADSU.1 = Junction:DA.2;  //_GUI 90,53
 ADSU:A.0 = SymmetrizeNW.0;  
 ADSU:A.1 = SymmetrizeNW.1;  
 ADSU:B.0 = SymmetrizeNW:A.0;  
 ADSU:B.1 = SymmetrizeNW:A.1;  
 ADSU:C.0 = Junction:CA.1;  
 ADSU:C.1 = Junction:V.2;  //_GUI 202,58, 202,88, 68,88
 ADSU:C.2 = Input:H.0;  
 ADSU:C.3 = Input:I.0;  
 ADSU:D.0 = Junction:BA.1;  
 ADSU:D.1 = Junction:NA.2;  
 ADSU:D.2 = Input:K.0;  
 ADSU:D.3 = Input:J.0;  
 OR:B.0 = Cast.0;  //_GUI 141,19, 141,16
 OR:B.1 = Junction:MA.1;  
 Junction:MA.0 = RAMDP.0;  
 Cast.0 = Junction:MA.0;  //_GUI 127,15
 Cast.1 = OR:B.0;  //_GUI 125,18, 125,11, 155,11, 155,20
 SymmetrizeNW.0 = One:A.0;  
 SymmetrizeNW.1 = Junction:V.1;  
 SymmetrizeNW:A.0 = Junction:a.2;  
 SymmetrizeNW:A.1 = One.0;  
 RegClr:H.0 = Gray2Int:A.0;  
 RegClr:H.1 = Junction:KA.0;  //_GUI 185,115
 RegClr:H.3 = Junction:JA.0;  
 Junction:NA.0 = Junction:c.2;  //_GUI 207,125, 70,125
 RegClr:I.0 = Gray2Int.0;  
 RegClr:I.1 = Junction:OA.0;  //_GUI 173,57
 RegClr:I.3 = Junction:IA.0;  
 Junction:OA.0 = Junction:T.1;  
 Equal.0 = Junction:DA.0;  //_GUI 146,37, 146,44, 90,44
 Equal.1 = Junction:CA.0;  //_GUI 189,40
 Equal:A.0 = Junction:BA.0;  //_GUI 203,106
 Equal:A.1 = Junction:NA.1;  //_GUI 207,109
}

Object ( Variant CO, Variant OFL, Variant S
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) ADSU
    ( Variant A, Variant B, Bit Add, Bit CI
    , Bit ClkG, Bit AClr, Variant Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Advanced\\Twos",Icon="Add"
{
 // Performs an add or a subtract function with Carry In (CI), Carry Out (CO) and Overflow (OFL).
 //
 // This object has input and output behaviors that are dataset dependent.  It is not recommended that you use this object to implement dataset independent algorithms.  Use Add, Sub and AddSub to implement dataset independent algorithms.
 //
 // Inputs:
 //
 // Variant A: Value A.
 //
 // Variant B: Value B.
 //
 // Bit/List Add: 1 to Add, 0 to Subtract.  Add is latched in with B's Go.  If B is a list and B's Go is a list, Add must be an equivalently shaped list or it must be a single bit constant.  If the ADSU overload that is placed has a Bit input for Add and is disconnected, Add defaults to a value of 1.
 //
 // Bit/List CI: Carry In.  Usually 0 when adding and 1 when subtracting. To Carry In, set to 1 (asserted high) when adding and set to 0 (asserted low) when subtracting.  CI is latched in with B's Go.  The dataset of CI must match the dataset of Add.  If the ADSU overload that is referenced on the sheet has a Bit input for CI and is disconnected, CI defaults to a value of 0.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected
 //
 // Bit/List Go: Go of GDBW.  Can be a Bit if A and B don't need to be synchronized.  Can be a pair of bits in a list if A needs to be synchronized with B.  Can be a pair of lists in a list if the elements of a list for A need to be individually synchronized against the elements of a list for B.
 //
 // Bit Wait: Wait of GDBW.  If disconnected, has value of 0.
 //
 // Outputs:
 //
 // Bit CO: Carry Out value.  Indicates high bit rolled over.  Can be used in a carry chain or can be used to indicate an error condition when using unsigned numbers.  When adding, Carry Out is signaled with a 1 (asserted high).  When subtracting, Carry Out is signaled with a 0 (asserted low).
 //
 // Bit OFL: Overflow value.  Indicates half rollover point crossed.  Can be used to indicate an error condition when not using unsigned numbers.
 // Variant S:	The result of the operation.  The sum or the difference of A and B.
 //
 // Bit ClkG: Clock input pass through
 //
 // Bit AClr: Clear input pass through
 //
 // Bit Done: Done of GDBW
 //
 // Bit/List Busy: Busy of GDBW.  Same dataset as Go.  One busy for each respective Go.
 //
 // Dataset Coverage:
 //
 // Unsigned (MSBxxx, LSBxxx and BINxxx use CO), Twos Complement (MSBxxx, LSBxxx and BINxxx use OFL), Signed (use OFL), Fixed (CI is LSB of fraction portion, use OFL), Floating (CI, CO ignored, use OFL), Complex (the inputs Add and CI both get sent to the Real and Imaginary portions, CO and OFL are the OR of CO and OFL of both portions) and Lists of these (CO, OFL and S become Lists).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx, and BINxxx) or undefinded behavior will occur.  If A and B have different sizes then the inputs are symmetrized and a warning is produced.  If one of A or B is a list and the other is not, the other is duplicated into a list matching the one then the respective list elements are added.
 //
 // Examples: (widen dialog box to columate examples)
 //
 // A (Uns, 2's)	B (Uns, 2's)	Add	CI	CO	OFL	S (Uns, 2's)	Function
 // 000 (0,0)		000 (0,0)		1	0	0	0	000 (0,0)		A+B
 // 001 (1,1)		001 (1,1)		1	0	0	0	010 (2,2)		A+B
 // 001 (1,1)		010 (2,2)		1	0	0	0	011 (3,3)		A+B
 // 010 (2,2)		010 (2,2)		1	0	0	1	100 (4,-4)		A+B
 // 100 (4,-4)		100 (4,-4)		1	0	1	1	000 (0,0)		A+B
 // 110 (6,-2)		110 (6,-2)		1	0	1	0	100 (4,-4)		A+B
 // 111 (7,-1)		111 (7,-1)		1	0	1	0	110 (6,-2)		A+B
 // 000 (0,0)		000 (0,0)		1	1	0	0	001 (1,1)		A+B+1
 // 001 (1,1)		001 (1,1)		1	1	0	0	011 (3,3)		A+B+1
 // 001 (1,1)		010 (2,2)		1	1	0	1	100 (4,-4)		A+B+1
 // 010 (2,2)		010 (2,2)		1	1	0	1	101 (5,-3)		A+B+1
 // 100 (4,-4)		100 (4,-4)		1	1	1	1	001 (1,1)		A+B+1
 // 110 (6,-2)		110 (6,-2)		1	1	1	0	101 (5,-3)		A+B+1
 // 111 (7,-1)		111 (7,-1)		1	1	1	0	111 (7,-1)		A+B+1
 // 000 (0,0)		000 (0,0)		0	0	0	0	111 (7,-1)		A-B-1
 // 000 (0,0)		001 (1,1)		0	0	0	0	110 (6,-2)		A-B-1
 // 001 (1,1)		000 (0,0)		0	0	0	0	000 (0,0)		A-B-1
 // 100 (4,-4)		011 (3,3)		0	0	1	1	000 (0,0)		A-B-1
 // 100 (4,-4)		100 (4,-4)		0	0	0	0	111 (7,-1)		A-B-1
 // 110 (6,-2)		100 (4,-4)		0	0	1	0	001 (1,1)		A-B-1
 // 001 (1,1)		100 (4,-4)		0	0	0	1	100 (4,-4)		A-B-1
 // 000 (0,0)		000 (0,0)		0	1	0	0	000 (0,0)		A-B
 // 000 (0,0)		001 (1,1)		0	1	0	0	111 (7,-1)		A-B
 // 001 (1,1)		000 (0,0)		0	1	1	0	001 (1,1)		A-B
 // 100 (4,-4)		011 (3,3)		0	1	1	1	001 (1,1)		A-B
 // 100 (4,-4)		100 (4,-4)		0	1	1	0	000 (1,1)		A-B
 // 110 (6,-2)		100 (4,-4)		0	1	1	0	010 (2,2)		A-B
 // 001 (1,1)		100 (4,-4)		0	1	0	1	101 (5,-3)		A-B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 9,28
 Object ( Variant B) Input:A;  //_GUI 9,31
 Object ( Bit Add) Input:B;  //_GUI 9,34
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 9,37
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 9,43
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 9,46
 //_ Attributes Constant="0"
 Object ( Variant Go) Input:F;  //_GUI 9,49
 Object ( Bit Wait) Input:G;  //_GUI 140,58
 //_ Attributes Constant="0"
 Object Output( Variant CO) ;  //_GUI 146,31
 Object Output:A( Variant OFL) ;  //_GUI 146,34
 Object Output:B( Variant S) ;  //_GUI 146,37
 Object Output:C( Bit ClkG) ;  //_GUI 146,43
 Object Output:D( Bit AClr) ;  //_GUI 146,46
 Object Output:E( Bit Done) ;  //_GUI 146,49
 Object Output:F( Variant Busy) ;  //_GUI 10,55
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 56,27
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 89,30
 Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, Variant Busy) SyncQueuePass( Variant Data, Bit ClkG
    , Bit AClr, Variant Go, Bit Wait) ;  //_GUI 71,33
 //_ Attributes Documentation="List/List"
 Object ( Variant B, Variant Add, Variant CI) $AddSubPrepBOut
    ( Variant In1, Variant Around) ;  //_GUI 106,33
 //_ Attributes Documentation="Passthrough"
 Object Text;  //_GUI 62,18,Don't need to register type information
 Object ( Variant Out1, Variant Around) $AddSubPrepBIn( Variant B
    , Variant Add, Variant CI, Variant GoIn) ;  //_GUI 33,30
 //_ Attributes Documentation="Passthrough"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 27,49
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 131,30

 //_ Behavior Topology
 Output.0 = ADSU_Pipe.0;  
 Output:A.0 = ADSU_Pipe.1;  
 Output:B.0 = ADSU_Pipe.2;  
 Output:C.0 = ADSU_Pipe.4;  
 Output:D.0 = ADSU_Pipe.5;  
 Output:E.0 = ADSU_Pipe.6;  
 Output:F.0 = SyncQueuePass.4;  //_GUI 10,53, 65,53, 65,47
 ListOut.0 = $AddSubPrepBIn.0;  
 ListOut.1 = Input.0;  
 ListIn.0 = SyncQueuePass.0;  //_GUI 88,33, 88,35
 SyncQueuePass.0 = ListOut.0;  //_GUI 69,35, 69,30
 SyncQueuePass.1 = Input:D.0;  //_GUI 56,38, 56,44
 SyncQueuePass.2 = Input:E.0;  //_GUI 59,41, 59,47
 SyncQueuePass.3 = Junction.1;  //_GUI 62,44, 62,50
 SyncQueuePass.4 = ADSU_Pipe.7;  //_GUI 89,47, 89,53
 $AddSubPrepBOut.0 = ListIn.0;  
 $AddSubPrepBOut.1 = $AddSubPrepBIn.1;  //_GUI 103,38, 103,22, 53,22, 53,35
 $AddSubPrepBIn.0 = Input:A.0;  
 $AddSubPrepBIn.1 = Input:B.0;  
 $AddSubPrepBIn.2 = Input:C.0;  
 $AddSubPrepBIn.3 = Junction.0;  //_GUI 28,41
 Junction.0 = Input:F.0;  
 ADSU_Pipe.0 = ListIn.1;  
 ADSU_Pipe.1 = $AddSubPrepBOut.0;  
 ADSU_Pipe.2 = $AddSubPrepBOut.1;  
 ADSU_Pipe.3 = $AddSubPrepBOut.2;  
 ADSU_Pipe.4 = SyncQueuePass.1;  //_GUI 98,44, 98,38
 ADSU_Pipe.5 = SyncQueuePass.2;  //_GUI 95,47, 95,41
 ADSU_Pipe.6 = SyncQueuePass.3;  //_GUI 92,50, 92,44
 ADSU_Pipe.7 = Input:G.0;  
}

Object ( Variant CO, Variant OFL, Variant S
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) ADSU
    ( Variant A, Variant B, Variant Add, Variant CI
    , Bit ClkG, Bit AClr, Variant Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Advanced\\Twos",Icon="Add",Documentation="Var Add and CI"
{
 // Performs an add or a subtract function with Carry In (CI), Carry Out (CO) and Overflow (OFL).
 //
 // This object has input and output behaviors that are dataset dependent.  It is not recommended that you use this object to implement dataset independent algorithms.  Use Add, Sub and AddSub to implement dataset independent algorithms.
 //
 // Inputs:
 //
 // Variant A: Value A.
 //
 // Variant B: Value B.
 //
 // Bit/List Add: 1 to Add, 0 to Subtract.  Add is latched in with B's Go.  If B is a list and B's Go is a list, Add must be an equivalently shaped list or it must be a single bit constant.  If the ADSU overload that is placed has a Bit input for Add and is disconnected, Add defaults to a value of 1.
 //
 // Bit/List CI: Carry In.  Usually 0 when adding and 1 when subtracting. To Carry In, set to 1 (asserted high) when adding and set to 0 (asserted low) when subtracting.  CI is latched in with B's Go.  The dataset of CI must match the dataset of Add.  If the ADSU overload that is referenced on the sheet has a Bit input for CI and is disconnected, CI defaults to a value of 0.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected
 //
 // Bit/List Go: Go of GDBW.  Can be a Bit if A and B don't need to be synchronized.  Can be a pair of bits in a list if A needs to be synchronized with B.  Can be a pair of lists in a list if the elements of a list for A need to be individually synchronized against the elements of a list for B.
 //
 // Bit Wait: Wait of GDBW.  If disconnected, has value of 0.
 //
 // Outputs:
 //
 // Bit CO: Carry Out value.  Indicates high bit rolled over.  Can be used in a carry chain or can be used to indicate an error condition when using unsigned numbers.  When adding, Carry Out is signaled with a 1 (asserted high).  When subtracting, Carry Out is signaled with a 0 (asserted low).
 //
 // Bit OFL: Overflow value.  Indicates half rollover point crossed.  Can be used to indicate an error condition when not using unsigned numbers.
 // Variant S:	The result of the operation.  The sum or the difference of A and B.
 //
 // Bit ClkG: Clock input pass through
 //
 // Bit AClr: Clear input pass through
 //
 // Bit Done: Done of GDBW
 //
 // Bit/List Busy: Busy of GDBW.  Same dataset as Go.  One busy for each respective Go.
 //
 // Dataset Coverage:
 //
 // Unsigned (MSBxxx, LSBxxx and BINxxx use CO), Twos Complement (MSBxxx, LSBxxx and BINxxx use OFL), Signed (use OFL), Fixed (CI is LSB of fraction portion, use OFL), Floating (CI, CO ignored, use OFL), Complex (the inputs Add and CI both get sent to the Real and Imaginary portions, CO and OFL are the OR of CO and OFL of both portions) and Lists of these (CO, OFL and S become Lists).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx, and BINxxx) or undefinded behavior will occur.  If A and B have different sizes then the inputs are symmetrized and a warning is produced.  If one of A or B is a list and the other is not, the other is duplicated into a list matching the one then the respective list elements are added.
 //
 // Examples: (widen dialog box to columate examples)
 //
 // A (Uns, 2's)	B (Uns, 2's)	Add	CI	CO	OFL	S (Uns, 2's)	Function
 // 000 (0,0)		000 (0,0)		1	0	0	0	000 (0,0)		A+B
 // 001 (1,1)		001 (1,1)		1	0	0	0	010 (2,2)		A+B
 // 001 (1,1)		010 (2,2)		1	0	0	0	011 (3,3)		A+B
 // 010 (2,2)		010 (2,2)		1	0	0	1	100 (4,-4)		A+B
 // 100 (4,-4)		100 (4,-4)		1	0	1	1	000 (0,0)		A+B
 // 110 (6,-2)		110 (6,-2)		1	0	1	0	100 (4,-4)		A+B
 // 111 (7,-1)		111 (7,-1)		1	0	1	0	110 (6,-2)		A+B
 // 000 (0,0)		000 (0,0)		1	1	0	0	001 (1,1)		A+B+1
 // 001 (1,1)		001 (1,1)		1	1	0	0	011 (3,3)		A+B+1
 // 001 (1,1)		010 (2,2)		1	1	0	1	100 (4,-4)		A+B+1
 // 010 (2,2)		010 (2,2)		1	1	0	1	101 (5,-3)		A+B+1
 // 100 (4,-4)		100 (4,-4)		1	1	1	1	001 (1,1)		A+B+1
 // 110 (6,-2)		110 (6,-2)		1	1	1	0	101 (5,-3)		A+B+1
 // 111 (7,-1)		111 (7,-1)		1	1	1	0	111 (7,-1)		A+B+1
 // 000 (0,0)		000 (0,0)		0	0	0	0	111 (7,-1)		A-B-1
 // 000 (0,0)		001 (1,1)		0	0	0	0	110 (6,-2)		A-B-1
 // 001 (1,1)		000 (0,0)		0	0	0	0	000 (0,0)		A-B-1
 // 100 (4,-4)		011 (3,3)		0	0	1	1	000 (0,0)		A-B-1
 // 100 (4,-4)		100 (4,-4)		0	0	0	0	111 (7,-1)		A-B-1
 // 110 (6,-2)		100 (4,-4)		0	0	1	0	001 (1,1)		A-B-1
 // 001 (1,1)		100 (4,-4)		0	0	0	1	100 (4,-4)		A-B-1
 // 000 (0,0)		000 (0,0)		0	1	0	0	000 (0,0)		A-B
 // 000 (0,0)		001 (1,1)		0	1	0	0	111 (7,-1)		A-B
 // 001 (1,1)		000 (0,0)		0	1	1	0	001 (1,1)		A-B
 // 100 (4,-4)		011 (3,3)		0	1	1	1	001 (1,1)		A-B
 // 100 (4,-4)		100 (4,-4)		0	1	1	0	000 (1,1)		A-B
 // 110 (6,-2)		100 (4,-4)		0	1	1	0	010 (2,2)		A-B
 // 001 (1,1)		100 (4,-4)		0	1	0	1	101 (5,-3)		A-B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 9,28
 Object ( Variant B) Input:A;  //_GUI 9,31
 Object ( Variant Add) Input:B;  //_GUI 9,34
 Object ( Variant CI) Input:C;  //_GUI 9,37
 Object ( Bit ClkG) Input:D;  //_GUI 9,43
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 9,46
 //_ Attributes Constant="0"
 Object ( Variant Go) Input:F;  //_GUI 9,49
 Object ( Bit Wait) Input:G;  //_GUI 140,58
 //_ Attributes Constant="0"
 Object Output( Variant CO) ;  //_GUI 146,31
 Object Output:A( Variant OFL) ;  //_GUI 146,34
 Object Output:B( Variant S) ;  //_GUI 146,37
 Object Output:C( Bit ClkG) ;  //_GUI 146,43
 Object Output:D( Bit AClr) ;  //_GUI 146,46
 Object Output:E( Bit Done) ;  //_GUI 146,49
 Object Output:F( Variant Busy) ;  //_GUI 10,55
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 56,27
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 89,30
 Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, Variant Busy) SyncQueuePass( Variant Data, Bit ClkG
    , Bit AClr, Variant Go, Bit Wait) ;  //_GUI 71,33
 //_ Attributes Documentation="List/List"
 Object ( Variant B, Variant Add, Variant CI) $AddSubPrepBOut
    ( Variant In1, Variant Around) ;  //_GUI 106,33
 //_ Attributes Documentation="Passthrough"
 Object Text;  //_GUI 62,18,Don't need to register type information
 Object ( Variant Out1, Variant Around) $AddSubPrepBIn( Variant B
    , Variant Add, Variant CI, Variant GoIn) ;  //_GUI 33,30
 //_ Attributes Documentation="Passthrough"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 27,49
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 131,30

 //_ Behavior Topology
 Output.0 = ADSU_Pipe.0;  
 Output:A.0 = ADSU_Pipe.1;  
 Output:B.0 = ADSU_Pipe.2;  
 Output:C.0 = ADSU_Pipe.4;  
 Output:D.0 = ADSU_Pipe.5;  
 Output:E.0 = ADSU_Pipe.6;  
 Output:F.0 = SyncQueuePass.4;  //_GUI 10,53, 65,53, 65,47
 ListOut.0 = $AddSubPrepBIn.0;  
 ListOut.1 = Input.0;  
 ListIn.0 = SyncQueuePass.0;  //_GUI 88,33, 88,35
 SyncQueuePass.0 = ListOut.0;  //_GUI 69,35, 69,30
 SyncQueuePass.1 = Input:D.0;  //_GUI 56,38, 56,44
 SyncQueuePass.2 = Input:E.0;  //_GUI 59,41, 59,47
 SyncQueuePass.3 = Junction.1;  //_GUI 62,44, 62,50
 SyncQueuePass.4 = ADSU_Pipe.7;  //_GUI 89,47, 89,53
 $AddSubPrepBOut.0 = ListIn.0;  
 $AddSubPrepBOut.1 = $AddSubPrepBIn.1;  //_GUI 103,38, 103,22, 53,22, 53,35
 $AddSubPrepBIn.0 = Input:A.0;  
 $AddSubPrepBIn.1 = Input:B.0;  
 $AddSubPrepBIn.2 = Input:C.0;  
 $AddSubPrepBIn.3 = Junction.0;  //_GUI 28,41
 Junction.0 = Input:F.0;  
 ADSU_Pipe.0 = ListIn.1;  
 ADSU_Pipe.1 = $AddSubPrepBOut.0;  
 ADSU_Pipe.2 = $AddSubPrepBOut.1;  
 ADSU_Pipe.3 = $AddSubPrepBOut.2;  
 ADSU_Pipe.4 = SyncQueuePass.1;  //_GUI 98,44, 98,38
 ADSU_Pipe.5 = SyncQueuePass.2;  //_GUI 95,47, 95,41
 ADSU_Pipe.6 = SyncQueuePass.3;  //_GUI 92,50, 92,44
 ADSU_Pipe.7 = Input:G.0;  
}

Object ( Bit OnDeckRdy, Bit FifoRdEn, Bit OnDeckErr) OnDeck
    ( Bit FifoRdRdy, Bit GetNextRd, Bit ClrErr, Bit Clk
    , Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\$Internal"
{
 // Used to make a FIFO work with the GDBW protocol.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit FifoRdRdy) Input;  //_GUI 13,26
 Object ( Bit GetNextRd) Input:A;  //_GUI 13,50
 Object ( Bit ClrErr) Input:B;  //_GUI 13,72
 Object ( Bit Clk) Input:C;  //_GUI 13,78
 Object ( Bit CLR) Input:D;  //_GUI 13,81
 Object Output( Bit OnDeckRdy) ;  //_GUI 114,25
 Object Output:A( Bit FifoRdEn) ;  //_GUI 114,46
 Object Output:B( Bit OnDeckErr) ;  //_GUI 114,68
 Object ( Bit Out) $Cast( Variant Data, Bit Type) ;  //_GUI 97,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 75,26
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 42,32
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 42,46
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 26,34
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 64,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 18,50
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 64,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 58,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 39,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 109,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 21,36
 Object ( Bit Q) StickyReg( Bit D, Bit ClkG
    , Bit CLR) ;  //_GUI 86,66
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 40,65
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 26,64
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 79,70
 Object Text;  //_GUI 88,78,Error when a GetNextRead comes in and we don't have data on deck
 Object Text;  //_GUI 87,49,Read from the fifo in two cases:1. When there is data ready in the fifo and there is no data on deck.2. When there is data ready in the fifo and GetNextRd comes in
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In1) ;  //_GUI 39,33
 Object Text;  //_GUI 97,31,The FifoRdRdy value will be latched into OnDeck in two cases:1. On GetNextRd2. When FifoRdRdy and nothing OnDeck
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 85,25
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 66,71
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 58,81
 Object Text;  //_GUI 23,3,The purpose of the OnDeck module is to prime the read data lines with data if there is (was) at least one item of data in the fifo.  This allows the data to be ready for a Go any clock cycle after.  The Fpgas need the data available on the clock cycle of the Go but the Fifos make the data available on the clock cycle after the RdEn.  So the OnDeck module does a pre-read.

 //_ Behavior Topology
 Output.0 = Junction:D.1;  
 Output:A.0 = OR:A.0;  
 Output:B.0 = StickyReg.0;  
 $Cast.0 = RegClr.0;  
 $Cast.1 = Junction.0;  //_GUI 97,23, 76,23
 Junction.0 = Junction:C.1;  
 AND.0 = Junction:G.1;  
 AND.1 = INVERT.0;  
 AND:A.0 = Junction:G.2;  //_GUI 40,48
 AND:A.1 = Junction:A.1;  
 INVERT.0 = Junction:E.1;  
 OR.0 = Junction:A.0;  //_GUI 19,32
 OR.1 = Junction:B.1;  
 Junction:A.0 = Input:A.0;  
 OR:A.0 = Junction:B.2;  //_GUI 59,46
 OR:A.1 = AND:A.0;  
 Junction:B.0 = AND.0;  
 Junction:C.0 = Input.0;  
 Junction:D.0 = $Cast.0;  
 Junction:E.0 = Junction:D.0;  //_GUI 22,21, 110,21
 StickyReg.0 = AND:B.0;  
 StickyReg.1 = Junction:F.2;  
 StickyReg.2 = OR:B.0;  
 AND:B.0 = INVERT:A.0;  
 AND:B.1 = Junction:A.2;  //_GUI 19,70
 INVERT:A.0 = Junction:E.2;  //_GUI 22,67
 Junction:F.0 = Input:C.0;  //_GUI 80,79
 Junction:G.0 = Junction:C.2;  
 RegClr.0 = Junction.1;  
 RegClr.1 = Junction:F.1;  //_GUI 80,30
 RegClr.2 = OR.0;  
 RegClr.3 = Junction:H.1;  //_GUI 83,36, 83,82
 OR:B.0 = Input:B.0;  
 OR:B.1 = Junction:H.0;  //_GUI 59,76
 Junction:H.0 = Input:D.0;  
}

Object ( Variant S) $AbsorbCO( Bit CO, Bit OFL
    , Variant S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Variant S) Input:B;  //_GUI 21,27
 Object Output( Variant S) ;  //_GUI 47,25
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 31,23

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Input.0;  //_GUI 31,22
 CollectMSB.1 = Input:B.0;  
}

Object ( Fixed S) $AbsorbCO( Bit CO, Bit OFL
    , Fixed S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="fixed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,20
 Object ( Bit OFL) Input:A;  //_GUI 21,23
 Object ( Fixed S) Input:B;  //_GUI 21,27
 Object Output( Fixed S) ;  //_GUI 103,27
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 88,25
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 27,25
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 42,24
 Object ( Variant S) $AbsorbCO( Bit CO, Bit OFL
    , Variant S) ;  //_GUI 57,19
 //_ Attributes Documentation="Floating"
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 73,19

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 CollectFixed.0 = SignedIn.0;  //_GUI 86,27, 86,22
 CollectFixed.1 = ExposeFixed.1;  
 ExposeFixed.0 = Input:B.0;  
 SignedOut.0 = ExposeFixed.0;  
 $AbsorbCO.0 = Input.0;  
 $AbsorbCO.1 = Input:A.0;  
 $AbsorbCO.2 = SignedOut.0;  
 SignedIn.0 = $AbsorbCO.0;  
}

Object ( Floating S) $AbsorbCO( Bit CO, Bit OFL
    , Floating S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,19
 Object ( Bit OFL) Input:A;  //_GUI 21,23
 Object ( Floating S) Input:B;  //_GUI 21,27
 Object Output( Floating S) ;  //_GUI 48,27
 Object Text;  //_GUI 21,13,Floating doesn't use CO of Add.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Signed S) $AbsorbCO( Bit CO, Bit OFL
    , Signed S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="signed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 8,16
 Object ( Bit OFL) Input:A;  //_GUI 8,22
 Object ( Signed S) Input:B;  //_GUI 8,29
 Object Output( Signed S) ;  //_GUI 112,24
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 14,27
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 97,22
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 53,21
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 36,27
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 27,29
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 81,22

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedIn.0 = Input:B.0;  
 SignedOut.0 = CollectMSB.0;  
 XOR.0 = Input:A.0;  
 XOR.1 = ExposeMSB.0;  //_GUI 53,29
 ExposeMSB.0 = Junction.1;  
 Junction.0 = SignedIn.0;  
 CollectMSB.0 = XOR.0;  
 CollectMSB.1 = Junction.2;  //_GUI 81,36, 28,36
}

Object ( Variant Q, Variant Value) RegClrDepthVal( Variant D
    , Bit ClkG, Bit EN, Bit CLR, Variant depth) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\Advanced"
{
 // RegDepth with a CLR and a parallel Value output.
 //
 // Data in the output shifts from the least significant to the most significant bits.
 //
 // Note that D doesn't have to be bit, but can be any dataset.
 //
 // Inputs:
 //
 // Variant D: The input data that will be registered.
 //
 // Bit ClkG: The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit EN: Enables the registering (shifting) of the register depth chain.  If disconnected, defaults to 1.
 //
 // Bit CLR: Asynchronously clears the register depth chain.  If disconnected, defaults to 0.
 //
 // Variant depth: The size of this dataset in bits determines the depth of the register chain.
 //
 // Outputs:
 //
 // Variant Q: The output of the last register in the register chain.
 //
 // Variant Value: The output of all of the registers in the register chain.  The outputs shift from the least significant end to the most significant end.
 //
 // 11/15/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 20,16
 Object ( Bit ClkG) Input:A;  //_GUI 20,33
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 20,36
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 20,40
 //_ Attributes Constant="0"
 Object ( Variant depth) Input:D;  //_GUI 20,45
 Object Output( Variant Q) ;  //_GUI 130,16
 Object Output:A( Variant Value) ;  //_GUI 130,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 40,40
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 27,43
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 115,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 37,36
 Object ( Variant Q, Variant Value) RegClrDepthVal( Variant D
    , Bit ClkG, Bit EN, Bit CLR, Variant depth) ;  //_GUI 51,15
 //_ Attributes Documentation="Variant"
 Object ( Variant Q, Variant Value) RegClrDepthVal:A( Variant D
    , Bit ClkG, Bit EN, Bit CLR, Variant depth) ;  //_GUI 88,15
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = RegClrDepthVal:A.0;  
 Output:A.0 = CollectMSB.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:C.0;  
 ExposeMSB.0 = Input:D.0;  
 CollectMSB.0 = RegClrDepthVal:A.1;  
 CollectMSB.1 = RegClrDepthVal.1;  //_GUI 110,23, 110,11, 71,11, 71,20
 Junction:B.0 = Input:B.0;  
 RegClrDepthVal.0 = Input.0;  
 RegClrDepthVal.1 = Junction.0;  //_GUI 35,20
 RegClrDepthVal.2 = Junction:B.0;  //_GUI 38,23
 RegClrDepthVal.3 = Junction:A.0;  //_GUI 41,26
 RegClrDepthVal.4 = ExposeMSB.0;  //_GUI 44,29, 44,45
 RegClrDepthVal:A.0 = RegClrDepthVal.0;  
 RegClrDepthVal:A.1 = Junction.1;  //_GUI 75,20, 75,34
 RegClrDepthVal:A.2 = Junction:B.1;  //_GUI 78,23, 78,37
 RegClrDepthVal:A.3 = Junction:A.1;  //_GUI 81,26, 81,41
 RegClrDepthVal:A.4 = ExposeMSB.1;  //_GUI 84,29, 84,48
}

Object ( Variant Q, Variant Value) RegClrDepthVal( Variant D
    , Bit ClkG, Bit EN, Bit CLR, Bit depth) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 10,14
 Object ( Bit ClkG) Input:A;  //_GUI 10,24
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 10,28
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 10,32
 //_ Attributes Constant="0"
 Object ( Bit depth) Input:D;  //_GUI 10,38
 Object Output( Variant Q) ;  //_GUI 81,15
 Object Output:A( Variant Value) ;  //_GUI 81,19
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 54,13
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 75,15

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 76,20
 RegClr.0 = Input.0;  
 RegClr.1 = Input:A.0;  //_GUI 39,18, 39,25
 RegClr.2 = Input:B.0;  //_GUI 47,21, 47,29
 RegClr.3 = Input:C.0;  //_GUI 53,24, 53,33
 Junction.0 = RegClr.0;  
}

Object ( Bit Out1) EqualOne( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async"
{
 // Returns 1 if input is equal to a value of 1.
 //
 // Inputs:
 //
 // Variant input: input
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating, Fixed, List (has list inputs and bit output) and Complex (compares against (1+0i), not a magnitude of 1.0).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 4,20
 Object Output( Bit Out1) ;  //_GUI 65,21
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 52,19
 Object Text;  //_GUI 75,20,Then just compare against zero.
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 25,18
 //_ Attributes Documentation="List"
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 13,26
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 10,20
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 25,26
 //_ Attributes Documentation="List"
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 40,19
 //_ Attributes Documentation="Bit/Bit"
 Object Text;  //_GUI 32,35,A variable XORed with a constant just turns into wires or inverters.

 //_ Behavior Topology
 Output.0 = EqualZero.0;  
 EqualZero.0 = XOR.0;  
 LSB.0 = Junction.1;  
 One.0 = Junction.2;  //_GUI 11,29
 Junction.0 = Input.0;  
 LSB:A.0 = One.0;  
 XOR.0 = LSB.0;  
 XOR.1 = LSB:A.0;  //_GUI 37,24, 37,29
}

Object ( Variant Out1) Dec( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronously decrements the input value.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant input: Number
 //
 // Outputs:
 //
 // output: Number - 1.  No indication of carry out or overflow is given.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed and List.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 18,20
 Object Output( Variant Out1) ;  //_GUI 82,26
 Object ( Variant S) Sub( Variant A, Variant B) ;  //_GUI 65,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,20
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 37,26

 //_ Behavior Topology
 Output.0 = Sub.0;  
 Sub.0 = Junction.1;  //_GUI 57,26, 57,21
 Sub.1 = One.0;  
 Junction.0 = Input.0;  
 One.0 = Junction.2;  //_GUI 29,29
}

Object ( Variant Out1) AND( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\AND"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,22
 Object ( Variant In2) Input:A;  //_GUI 21,25
 Object ( Variant In3) Input:B;  //_GUI 21,29
 Object ( Variant In4) Input:C;  //_GUI 21,32
 Object Output( Variant Out1) ;  //_GUI 64,26
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 27,21
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 27,28

 //_ Behavior Topology
 Output.0 = AND:A.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
 AND:A.0 = AND.0;  //_GUI 43,26, 43,24
 AND:A.1 = AND:B.0;  //_GUI 43,29, 43,31
 AND:B.0 = Input:B.0;  
 AND:B.1 = Input:C.0;  
}

Object ( Variant Out1) AND( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\AND"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,18
 Object ( Variant In2) Input:A;  //_GUI 22,21
 Object ( Variant In3) Input:B;  //_GUI 22,24
 Object Output( Variant Out1) ;  //_GUI 67,22
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 34,17
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 51,20

 //_ Behavior Topology
 Output.0 = AND:A.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
 AND:A.0 = AND.0;  //_GUI 47,22, 47,20
 AND:A.1 = Input:B.0;  
}

Object ( Bit OFL, Variant S) Sub( Variant A
    , Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async"
{
 // Same as Sub (2,1) except has an extra OFL output.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Value
 //
 // Variant B: Value
 //
 // Outputs:
 //
 // Variant OFL: Overflow is output as high if the operation overflowed.  The dataset is a List of bits if inputs were list, Bit otherwise.
 //
 // Variant S: The result of A minus B or a list of results
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned), Signed, Floating, Fixed, Complex and List. If one input is a list and the other is not, the other is duplicated into an equivalent list of the one.  A and B pairs must have the same dataset (with the exception of MSBxxx, LSBxxx and BINxxx) or undefined behavior will occur and if they don't have the same bit length, they are symmetrized and a warning is generated.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 5,17
 Object ( Variant B) Input:A;  //_GUI 5,20
 Object Output( Bit OFL) ;  //_GUI 77,17
 Object Output:A( Variant S) ;  //_GUI 77,20
 Object ( Bit CI) Input:B;  //_GUI 10,26
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 65,15
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 16,16
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 48,16
 Object ( Bit SUB) Input:C;  //_GUI 10,23
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 36,15
 Object Text;  //_GUI 31,7,Change CO into an error for unsigned values

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = $ResolveError.1;  
 VouchBit.0 = $ResolveError.0;  
 ADSU.0 = Input.0;  
 ADSU.1 = Input:A.0;  
 ADSU.2 = Input:C.0;  
 ADSU.3 = Input:B.0;  
 $ResolveError.0 = INVERT.0;  
 $ResolveError.1 = ADSU.1;  
 $ResolveError.2 = ADSU.2;  
 INVERT.0 = ADSU.0;  
}

Object ( List OFL, List S) Sub( List A
    , Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 4,16
 Object ( Variant B) Input:A;  //_GUI 4,27
 Object Output( List OFL) ;  //_GUI 65,16
 Object Output:A( List S) ;  //_GUI 65,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 23,27
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 27,14
 //_ Attributes Documentation="List/List"
 Object ( Variant OFL, Variant S) Sub:A( Variant A
    , Variant B) ;  //_GUI 27,23
 //_ Attributes Documentation="List/List"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 10,14
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,23

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListOut.0 = Sub:A.0;  //_GUI 48,19, 48,25
 ListOut.1 = Sub.0;  
 Junction.0 = Input:A.0;  
 Sub.0 = ListIn.1;  
 Sub.1 = Junction.0;  //_GUI 24,19
 Sub:A.0 = ListIn.0;  //_GUI 27,22, 21,22
 Sub:A.1 = Junction.1;  
 ListIn.0 = Input.0;  
 ListOut:A.0 = Sub:A.1;  
 ListOut:A.1 = Sub.1;  //_GUI 52,22, 44,22
}

Object ( List OFL, List S) Sub( Variant A
    , List B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="Variant/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 6,11
 Object ( List B) Input:A;  //_GUI 6,21
 Object Output( List OFL) ;  //_GUI 69,12
 Object Output:A( List S) ;  //_GUI 69,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 12,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,11
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 31,10
 //_ Attributes Documentation="List/List"
 Object ( Variant OFL, Variant S) Sub:A( Variant A
    , Variant B) ;  //_GUI 31,19
 //_ Attributes Documentation="List/List"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,10
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 54,19

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
 Sub.0 = Junction.1;  
 Sub.1 = ListIn.1;  //_GUI 26,15, 26,21
 Sub:A.0 = Junction.2;  //_GUI 29,21
 Sub:A.1 = ListIn.0;  
 ListOut.0 = Sub:A.0;  //_GUI 51,15, 51,21
 ListOut.1 = Sub.0;  
 ListOut:A.0 = Sub:A.1;  
 ListOut:A.1 = Sub.1;  //_GUI 54,18, 48,18
}

Object ( List OFL, List S) Sub( List A
    , List B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 6,9
 Object ( List B) Input:A;  //_GUI 6,17
 Object Output( List OFL) ;  //_GUI 65,9
 Object Output:A( List S) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 12,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,7
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 12,7
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,15
 Object ( Bit OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 29,7
 Object ( Bit OFL, Variant S) Sub:A( Variant A
    , Variant B) ;  //_GUI 29,15

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = Sub:A.0;  //_GUI 49,12, 49,17
 ListOut.1 = Sub.0;  
 ListIn:A.0 = Input.0;  
 ListOut:A.0 = Sub:A.1;  
 ListOut:A.1 = Sub.1;  //_GUI 52,14, 46,14
 Sub.0 = ListIn:A.1;  
 Sub.1 = ListIn.1;  //_GUI 26,12, 26,17
 Sub:A.0 = ListIn:A.0;  //_GUI 29,15, 23,15
 Sub:A.1 = ListIn.0;  
}

Object ( List Q, Bit ClkG, Bit AClr
    , List Done, List Busy) RegOnBusy( List D, Bit ClkG
    , Bit AClr, List Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="List/List/Bit"
{
 // RegOnBusy
 //
 // Behaves as a pass through until 'Wait' goes high, on the next 'Go' the data is registered.  'Busy' is registered and comes out the clock cycle after 'Wait' and 'Go'.
 //
 // The purpose of this object is to register the 'Busy' to break up long 'Busy' - 'Wait' chains to meet timing constraints.
 //
 // This object is also useful as a single element Queue with zero latency. If you need a two element Queue, put two of these back-to-back, etc.
 //
 // Inputs:
 //
 // Variant D:	The data to be registered or passed through.
 //
 // Bit ClkG:	The input clock.  If disconnected, defaults to the ClkG, the global user clock signal.
 //
 // Bit AClr:	An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go:	Go of the GDBW protocol.  D is registered when Go is high, Busy is low and Wait is low on a rising clock edge.  D is passed through when Go is high, Busy is low and Wait is low.
 //
 // Bit Wait:	Wait of the GDBW protocol.  Holds off Done.  If disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Variant Q:	The output data.
 //
 // Bit AClr: An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go: Go of the GDBW protocol.  D is registered when Go is high and Busy is low on a rising clock edge.
 //
 // Bit Done:	Done of the GDBW protocol.  Q is only valid while Done is high.
 //
 // Bit Busy:	Busy of the GDBW protocol.  Tells the Go to hold off. For this object, Busy rises one clock cycle after Wait.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 27,21
 Object ( Bit ClkG) Input:A;  //_GUI 27,28
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 27,31
 //_ Attributes Constant="0"
 Object ( List Go) Input:C;  //_GUI 27,35
 Object ( Bit Wait) Input:D;  //_GUI 110,100
 //_ Attributes Constant="0"
 Object Output( List Q) ;  //_GUI 149,20
 Object Output:A( Bit ClkG) ;  //_GUI 149,28
 Object Output:B( Bit AClr) ;  //_GUI 149,31
 Object Output:C( List Done) ;  //_GUI 149,35
 Object Output:D( List Busy) ;  //_GUI 92,97
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 133,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 79,95
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 95,28
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 133,33
 Object Text;  //_GUI 2,6,The purpose of this object is to register the 'Busy' to break up long 'Busy' - 'Wait' chains to meet timing constraints.
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 46,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 117,66
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Variant Done, Variant Busy) RegOnBusy( Variant D, Bit ClkG
    , Bit AClr, Variant Go, Variant Wait) ;  //_GUI 100,24
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Variant Done, Variant Busy) RegOnBusy:A( Variant D, Bit ClkG
    , Bit AClr, Variant Go, Variant Wait) ;  //_GUI 100,53

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = RegOnBusy.1;  
 Output:B.0 = RegOnBusy.2;  
 Output:C.0 = ListOut:B.0;  
 Output:D.0 = ListOut:A.0;  
 ListOut.0 = RegOnBusy:A.0;  //_GUI 123,23, 123,55
 ListOut.1 = RegOnBusy.0;  //_GUI 120,20, 120,26
 ListIn.0 = Input.0;  
 ListOut:A.0 = RegOnBusy:A.4;  //_GUI 74,100, 74,67
 ListOut:A.1 = RegOnBusy.4;  //_GUI 71,97, 71,38
 Junction.0 = Input:A.0;  
 ListOut:B.0 = RegOnBusy:A.3;  //_GUI 126,38, 126,64
 ListOut:B.1 = RegOnBusy.3;  
 ListIn:A.0 = Input:C.0;  
 Junction:A.0 = Input:D.0;  //_GUI 118,101
 RegOnBusy.0 = ListIn.1;  //_GUI 92,26, 92,21
 RegOnBusy.1 = Junction.1;  
 RegOnBusy.2 = Input:B.0;  
 RegOnBusy.3 = ListIn:A.1;  
 RegOnBusy.4 = Junction:A.1;  //_GUI 118,38
 RegOnBusy:A.0 = ListIn.0;  //_GUI 89,55, 89,24
 RegOnBusy:A.1 = Junction.2;  //_GUI 96,58
 RegOnBusy:A.3 = ListIn:A.0;  //_GUI 67,64, 67,38
 RegOnBusy:A.4 = Junction:A.0;  
}

Object ( List Q, Bit ClkG, Bit AClr
    , List Done, List Busy) RegOnBusy( List D, Bit ClkG
    , Bit AClr, List Go, List Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="List/List/List"
{
 // RegOnBusy
 //
 // Behaves as a pass through until 'Wait' goes high, on the next 'Go' the data is registered.  'Busy' is registered and comes out the clock cycle after 'Wait' and 'Go'.
 //
 // The purpose of this object is to register the 'Busy' to break up long 'Busy' - 'Wait' chains to meet timing constraints.
 //
 // This object is also useful as a single element Queue with zero latency. If you need a two element Queue, put two of these back-to-back, etc.
 //
 // Inputs:
 //
 // Variant D:	The data to be registered or passed through.
 //
 // Bit ClkG:	The input clock.  If disconnected, defaults to the ClkG, the global user clock signal.
 //
 // Bit AClr:	An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go:	Go of the GDBW protocol.  D is registered when Go is high, Busy is low and Wait is low on a rising clock edge.  D is passed through when Go is high, Busy is low and Wait is low.
 //
 // Bit Wait:	Wait of the GDBW protocol.  Holds off Done.  If disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Variant Q:	The output data.
 //
 // Bit AClr: An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go: Go of the GDBW protocol.  D is registered when Go is high and Busy is low on a rising clock edge.
 //
 // Bit Done:	Done of the GDBW protocol.  Q is only valid while Done is high.
 //
 // Bit Busy:	Busy of the GDBW protocol.  Tells the Go to hold off. For this object, Busy rises one clock cycle after Wait.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 27,21
 Object ( Bit ClkG) Input:A;  //_GUI 27,28
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 27,31
 //_ Attributes Constant="0"
 Object ( List Go) Input:C;  //_GUI 27,35
 Object ( List Wait) Input:D;  //_GUI 109,97
 Object Output( List Q) ;  //_GUI 191,20
 Object Output:A( Bit ClkG) ;  //_GUI 191,28
 Object Output:B( Bit AClr) ;  //_GUI 191,31
 Object Output:C( List Done) ;  //_GUI 191,35
 Object Output:D( List Busy) ;  //_GUI 92,97
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 175,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 79,95
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 95,28
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 175,33
 Object Text;  //_GUI 2,6,The purpose of this object is to register the 'Busy' to break up long 'Busy' - 'Wait' chains to meet timing constraints.
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 46,33
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 119,95
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Variant Done, Variant Busy) RegOnBusy( Variant D, Bit ClkG
    , Bit AClr, Variant Go, Variant Wait) ;  //_GUI 100,24
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Variant Done, Variant Busy) RegOnBusy:A( Variant D, Bit ClkG
    , Bit AClr, Variant Go, Variant Wait) ;  //_GUI 100,53

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = RegOnBusy.1;  
 Output:B.0 = RegOnBusy.2;  
 Output:C.0 = ListOut:B.0;  
 Output:D.0 = ListOut:A.0;  
 ListOut.0 = RegOnBusy:A.0;  //_GUI 165,23, 165,55
 ListOut.1 = RegOnBusy.0;  //_GUI 162,20, 162,26
 ListIn.0 = Input.0;  
 ListOut:A.0 = RegOnBusy:A.4;  //_GUI 74,100, 74,67
 ListOut:A.1 = RegOnBusy.4;  //_GUI 71,97, 71,38
 Junction.0 = Input:A.0;  
 ListOut:B.0 = RegOnBusy:A.3;  //_GUI 168,38, 168,64
 ListOut:B.1 = RegOnBusy.3;  
 ListIn:A.0 = Input:C.0;  
 ListIn:B.0 = Input:D.0;  
 RegOnBusy.0 = ListIn.1;  //_GUI 92,26, 92,21
 RegOnBusy.1 = Junction.1;  
 RegOnBusy.2 = Input:B.0;  
 RegOnBusy.3 = ListIn:A.1;  
 RegOnBusy.4 = ListIn:B.1;  //_GUI 149,38, 149,97
 RegOnBusy:A.0 = ListIn.0;  //_GUI 89,55, 89,24
 RegOnBusy:A.1 = Junction.2;  //_GUI 96,58
 RegOnBusy:A.3 = ListIn:A.0;  //_GUI 67,64, 67,38
 RegOnBusy:A.4 = ListIn:B.0;  //_GUI 140,67, 140,100
}

Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnBusy( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="Var/Bit/Bit"
{
 // RegOnBusy
 //
 // Behaves as a pass through until 'Wait' goes high, on the next 'Go' the data is registered.  'Busy' is registered and comes out the clock cycle after 'Wait' and 'Go'.
 //
 // The purpose of this object is to register the 'Busy' to break up long 'Busy' - 'Wait' chains to meet timing constraints.
 //
 // This object is also useful as a single element Queue with zero latency. If you need a two element Queue, put two of these back-to-back, etc.
 //
 // Inputs:
 //
 // Variant D:	The data to be registered or passed through.
 //
 // Bit ClkG:	The input clock.  If disconnected, defaults to the ClkG, the global user clock signal.
 //
 // Bit AClr:	An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go:	Go of the GDBW protocol.  D is registered when Go is high, Busy is low and Wait is low on a rising clock edge.  D is passed through when Go is high, Busy is low and Wait is low.
 //
 // Bit Wait:	Wait of the GDBW protocol.  Holds off Done.  If disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Variant Q:	The output data.
 //
 // Bit AClr: An asynchronous clear.  If disconnected, defaults to 0.
 //
 // Bit Go: Go of the GDBW protocol.  D is registered when Go is high and Busy is low on a rising clock edge.
 //
 // Bit Done:	Done of the GDBW protocol.  Q is only valid while Done is high.
 //
 // Bit Busy:	Busy of the GDBW protocol.  Tells the Go to hold off. For this object, Busy rises one clock cycle after Wait.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 27,26
 Object ( Bit ClkG) Input:A;  //_GUI 26,73
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 26,84
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 26,98
 Object ( Bit Wait) Input:D;  //_GUI 26,103
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 149,25
 Object Output:A( Bit ClkG) ;  //_GUI 150,81
 Object Output:B( Bit AClr) ;  //_GUI 150,84
 Object Output:C( Bit Done) ;  //_GUI 150,92
 Object Output:D( Bit Busy) ;  //_GUI 149,103
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 51,69
 Object Text;  //_GUI 76,62,Have Data
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 111,90
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 97,89
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 93,68
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 46,66
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Variant EN, Bit CLR) ;  //_GUI 104,25
 Object ( Variant Out1) AND:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 84,30
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 66,36
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 130,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In3) ;  //_GUI 93,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 95,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 35,73
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 61,65
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 72,84
 Object Text;  //_GUI 129,107,Busy when we 'Have Data'.
 Object Text;  //_GUI 129,11,Pass through when we don't 'Have Data' or send it out when we do 'Have Data'.
 Object Text;  //_GUI 92,13,Latch in the data when  'Wait'ing, and receive a 'Go', and we don't have any data yet.
 Object Text;  //_GUI 54,49,Enter - We have data when we are 'Wait'ing and receive a 'Go'.
 Object Text;  //_GUI 54,56,Leave - We no longer have data when we are no longer waiting.
 Object Text;  //_GUI 2,6,The purpose of this object is to register the 'Busy' to break up long 'Busy' - 'Wait' chains to meet timing constraints.
 Object Text;  //_GUI 132,64,Done - We never send out 'Done' while 'Wai'ting otherwise send it out in two cases.Case 1: If we have data.Case 2: We don't have data and we receive a 'Go'. (pass-thru)
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 136,90
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 137,101
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 102,84
 Object ( Variant State) State( Variant Enter, Variant Leave
    , Bit ClkG, Bit CLR) ;  //_GUI 75,66
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 55,73
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 56,95
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In1) ;  //_GUI 51,75

 //_ Behavior Topology
 Output.0 = Mux.0;  
 Output:A.0 = Junction:E.2;  //_GUI 36,82
 Output:B.0 = Junction:G.1;  
 Output:C.0 = VouchBit.0;  
 Output:D.0 = VouchBit:A.0;  
 Junction.0 = Input:D.0;  //_GUI 45,70, 45,104
 AND.0 = OR.0;  
 AND.1 = INVERT:B.0;  //_GUI 105,95, 105,98
 OR.0 = Junction:A.2;  //_GUI 94,91
 OR.1 = Junction:B.2;  //_GUI 47,94
 Junction:A.0 = State.0;  
 Junction:B.0 = Input:C.0;  //_GUI 42,67, 42,99
 RegClr.0 = Junction:D.1;  
 RegClr.1 = Junction:E.0;  //_GUI 100,30, 100,29, 36,29
 RegClr.2 = AND:A.0;  
 RegClr.3 = Junction:G.0;  //_GUI 103,36
 AND:A.0 = Junction:B.0;  //_GUI 47,32
 AND:A.1 = Junction.0;  //_GUI 52,35
 AND:A.2 = INVERT.0;  //_GUI 80,38, 80,39
 INVERT.0 = Junction:C.0;  //_GUI 66,47
 Mux.0 = Junction:D.0;  //_GUI 117,25, 117,23, 96,23
 Mux.1 = RegClr.0;  
 Mux.2 = Junction:C.2;  //_GUI 126,31, 126,47
 Junction:C.0 = Junction:A.0;  
 Junction:D.0 = Input.0;  
 Junction:E.0 = Input:A.0;  
 AND:B.0 = Junction:B.1;  
 AND:B.1 = Junction.1;  
 Junction:F.0 = Input:B.0;  
 VouchBit.0 = AND.0;  
 VouchBit:A.0 = Junction:A.1;  //_GUI 127,104, 127,69
 Junction:G.0 = Junction:F.1;  
 State.0 = AND:B.0;  
 State.1 = INVERT:A.0;  //_GUI 70,71, 70,76
 State.2 = Junction:E.1;  
 State.3 = Junction:F.0;  //_GUI 73,77
 INVERT:A.0 = Junction:H.1;  
 INVERT:B.0 = Junction:H.2;  //_GUI 52,98
 Junction:H.0 = Junction.2;  
}

Object ( Bit "A<B", Bit "A=B", Bit "A>B") Compare
    ( Floating A, Floating B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Documentation="Floating"
{
 // Compares two numbers, A and B, and returns whether A is less than B, equal to B, or greater than B.
 //
 // Inputs:
 // Variant A: A
 // Variant B: B
 //
 // Outputs:
 //
 // Bit A<B: Asserted if A<B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A=B: Asserted if A=B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A>B: Asserted if A>B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned.  For 2's complement compares use CompareTwos or use the Signed dataset), Signed, Floating, Fixed and List (has list outputs and inputs).  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating A) Input;  //_GUI 6,39
 Object ( Floating B) Input:A;  //_GUI 6,50
 Object Output( Bit "A<B") ;  //_GUI 144,31
 Object Output:A( Bit "A=B") ;  //_GUI 144,43
 Object Output:B( Bit "A>B") ;  //_GUI 144,54
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 12,48
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating:A
    ( Floating In1) ;  //_GUI 12,37
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 38,40
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 38,51
 Object ( Bit "A<B", Bit "A=B", Bit "A>B") Compare
    ( Variant A, Variant B) ;  //_GUI 58,41
 //_ Attributes Documentation="Floating"
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 98,38
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 98,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 94,42
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 98,54
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 98,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 94,48
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 76,30
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 76,56
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 72,58
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 72,32
 Object ( Variant Out1) OR( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 120,29
 Object ( Variant Out1) OR:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 120,52
 Object ( Variant Out1) AND:D( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 98,18
 Object ( Variant Out1) EqualZero( Variant In1) ;  //_GUI 58,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 55,42
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 75,17
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 91,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 32,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 94,32
 Object ( Variant Out1) AND:E( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 98,61
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 94,58
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 35,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 88,19
 Object ( Bit Out) AND:F( Bit In1, Bit In2) ;  //_GUI 120,41
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 76,9
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 58,8
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 71,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In3) ;  //_GUI 32,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In3) ;  //_GUI 35,32
 Object Text;  //_GUI 131,16,A<B = (Am!=0) & (Am == Bm) & As & !Bs | !Bs & (Am < Bm) |(Am > Bm) & As
 Object Text;  //_GUI 52,40,Am
 Object Text;  //_GUI 52,51,Bm
 Object Text;  //_GUI 29,36,As
 Object Text;  //_GUI 29,46,Bs
 Object Text;  //_GUI 129,59,A>B = Bs & (Am < Bm) |(Am > Bm) & !As |!As & Bs & (Am == Bm) & (Am!=0)
 Object Text;  //_GUI 156,40,A=B = ((As == Bs) | (Am == 0)) &(Am == Bm)
 Object Text;  //_GUI 32,68,The biased exponent combined with the mantissa can be used to compare the magnitudes of two floating point numbers rather than comparing the biased exponents and mantissi separately.
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 132,29
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 132,41
 Object ( Bit Out1) VouchBit:B( Variant In1) ;  //_GUI 132,52

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = VouchBit:A.0;  
 Output:B.0 = VouchBit:B.0;  
 ExposeFloating.0 = Input:A.0;  
 ExposeFloating:A.0 = Input.0;  
 CollectMSB.0 = ExposeFloating:A.1;  
 CollectMSB.1 = ExposeFloating:A.2;  
 CollectMSB:A.0 = ExposeFloating.1;  
 CollectMSB:A.1 = ExposeFloating.2;  
 Compare.0 = Junction:D.1;  
 Compare.1 = CollectMSB:A.0;  //_GUI 56,46, 56,54
 AND.0 = Junction:C.2;  //_GUI 73,40
 AND.1 = Junction.1;  
 AND:A.0 = Junction:G.1;  
 AND:A.1 = Junction.0;  //_GUI 95,36
 Junction.0 = Compare.0;  
 AND:B.0 = Junction:A.2;  //_GUI 95,56
 AND:B.1 = Junction:H.1;  
 AND:C.0 = Junction:A.1;  
 AND:C.1 = Junction:B.0;  //_GUI 73,52
 Junction:A.0 = Compare.2;  
 INVERT.0 = Junction:C.1;  
 INVERT:A.0 = Junction:B.1;  
 Junction:B.0 = Junction:F.2;  //_GUI 33,59
 Junction:C.0 = Junction:M.2;  
 OR.0 = AND:D.0;  //_GUI 113,31, 113,21
 OR.1 = AND:A.0;  
 OR.2 = AND:C.0;  //_GUI 114,37, 114,50
 OR:A.0 = AND.0;  //_GUI 111,54, 111,41
 OR:A.1 = AND:B.0;  
 OR:A.2 = AND:E.0;  //_GUI 116,60, 116,64
 AND:D.0 = Junction:J.1;  
 AND:D.1 = Junction:E.0;  //_GUI 92,23
 AND:D.2 = Junction:L.2;  
 AND:D.3 = Junction:G.0;  //_GUI 95,29
 EqualZero.0 = Junction:D.0;  //_GUI 56,20
 Junction:D.0 = CollectMSB.0;  
 INVERT:B.0 = Junction:K.1;  
 Junction:E.0 = Compare.1;  
 Junction:F.0 = ExposeFloating:A.0;  
 Junction:G.0 = INVERT.0;  
 AND:E.0 = Junction:H.2;  //_GUI 95,63
 AND:E.1 = Junction:I.2;  //_GUI 36,66
 AND:E.2 = Junction:E.2;  //_GUI 92,69
 AND:E.3 = Junction:J.2;  //_GUI 89,72
 Junction:H.0 = INVERT:A.0;  
 Junction:I.0 = ExposeFloating.0;  
 Junction:J.0 = INVERT:B.0;  
 AND:F.0 = OR:B.0;  //_GUI 117,43, 117,12
 AND:F.1 = Junction:E.1;  
 OR:B.0 = Equal.0;  
 OR:B.1 = Junction:K.0;  //_GUI 72,14
 Equal.0 = Junction:L.1;  //_GUI 33,10
 Equal.1 = Junction:M.1;  //_GUI 36,13
 Junction:K.0 = EqualZero.0;  
 Junction:L.0 = Junction:F.0;  
 Junction:M.0 = Junction:I.0;  
 VouchBit.0 = OR.0;  
 VouchBit:A.0 = AND:F.0;  
 VouchBit:B.0 = OR:A.0;  
}

Object ( Bit "A<B", Bit "A=B", Bit "A>B") Compare
    ( Signed A, Signed B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Documentation="Signed"
{
 // Compares two numbers, A and B, and returns whether A is less than B, equal to B, or greater than B.
 //
 // Inputs:
 // Variant A: A
 // Variant B: B
 //
 // Outputs:
 //
 // Bit A<B: Asserted if A<B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A=B: Asserted if A=B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A>B: Asserted if A>B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned.  For 2's complement compares use CompareTwos or use the Signed dataset), Signed, Floating, Fixed and List (has list outputs and inputs).  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed A) Input;  //_GUI 17,10
 Object ( Signed B) Input:A;  //_GUI 18,19
 Object Output( Bit "A<B") ;  //_GUI 77,16
 Object Output:A( Bit "A=B") ;  //_GUI 77,19
 Object Output:B( Bit "A>B") ;  //_GUI 77,22
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 27,8
 Object ( Variant Out1) SignedIn:A( Signed In) ;  //_GUI 27,17
 Object ( Bit "A<B", Bit "A=B", Bit "A>B") CompareTwos
    ( Variant A, Variant B) ;  //_GUI 55,15

 //_ Behavior Topology
 Output.0 = CompareTwos.0;  
 Output:A.0 = CompareTwos.1;  
 Output:B.0 = CompareTwos.2;  
 SignedIn.0 = Input.0;  
 SignedIn:A.0 = Input:A.0;  
 CompareTwos.0 = SignedIn.0;  //_GUI 47,17, 47,11
 CompareTwos.1 = SignedIn:A.0;  
}

Object ( Bit "A<B", Bit "A=B", Bit "A>B") Compare
    ( Fixed A, Fixed B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Documentation="Fixed"
{
 // Compares two numbers, A and B, and returns whether A is less than B, equal to B, or greater than B.
 //
 // Inputs:
 // Variant A: A
 // Variant B: B
 //
 // Outputs:
 //
 // Bit A<B: Asserted if A<B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A=B: Asserted if A=B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A>B: Asserted if A>B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned.  For 2's complement compares use CompareTwos or use the Signed dataset), Signed, Floating, Fixed and List (has list outputs and inputs).  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed A) Input;  //_GUI 17,15
 Object ( Fixed B) Input:A;  //_GUI 17,24
 Object Output( Bit "A<B") ;  //_GUI 83,21
 Object Output:A( Bit "A=B") ;  //_GUI 83,24
 Object Output:B( Bit "A>B") ;  //_GUI 83,27
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 30,13
 Object ( List Out1) FixedIn:A( Fixed In) ;  //_GUI 30,22
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 48,13
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 48,22
 Object ( Bit "A<B", Bit "A=B", Bit "A>B") CompareTwos
    ( Variant A, Variant B) ;  //_GUI 64,20

 //_ Behavior Topology
 Output.0 = CompareTwos.0;  
 Output:A.0 = CompareTwos.1;  
 Output:B.0 = CompareTwos.2;  
 FixedIn.0 = Input.0;  
 FixedIn:A.0 = Input:A.0;  
 LSB.0 = FixedIn.0;  
 LSB:A.0 = FixedIn:A.0;  
 CompareTwos.0 = LSB.0;  //_GUI 60,22, 60,16
 CompareTwos.1 = LSB:A.0;  
}

Object ( Bit "A<B", Bit "A=B", Bit "A>B") Compare
    ( Bit A, Bit B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Documentation="Bit"
{
 // Compares two numbers, A and B, and returns whether A is less than B, equal to B, or greater than B.
 //
 // Inputs:
 // Variant A: A
 // Variant B: B
 //
 // Outputs:
 //
 // Bit A<B: Asserted if A<B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A=B: Asserted if A=B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A>B: Asserted if A>B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned.  For 2's complement compares use CompareTwos or use the Signed dataset), Signed, Floating, Fixed and List (has list outputs and inputs).  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 34,30
 Object ( Bit B) Input:A;  //_GUI 34,33
 Object Output( Bit "A<B") ;  //_GUI 110,31
 Object Output:A( Bit "A=B") ;  //_GUI 110,41
 Object Output:B( Bit "A>B") ;  //_GUI 110,51
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 80,39
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 95,29
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 80,28
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 95,49
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 80,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 68,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 72,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In1) ;  //_GUI 72,43
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In1) ;  //_GUI 68,40
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 95,39

 //_ Behavior Topology
 Output.0 = AND.0;  
 Output:A.0 = INVERT:B.0;  
 Output:B.0 = AND:A.0;  
 XOR.0 = Junction:C.1;  
 XOR.1 = Junction:B.1;  
 AND.0 = INVERT.0;  
 AND.1 = Junction.1;  
 INVERT.0 = Junction:A.1;  
 AND:A.0 = Junction:B.2;  //_GUI 73,51
 AND:A.1 = INVERT:A.0;  
 INVERT:A.0 = Junction:C.2;  //_GUI 69,54
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Junction:B.0 = Junction:A.2;  
 Junction:C.0 = Junction.2;  
 INVERT:B.0 = XOR.0;  
}

Object ( List "A<B", List "A=B", List "A>B") Compare
    ( List A, List B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Documentation="list"
{
 // Compares two numbers, A and B, and returns whether A is less than B, equal to B, or greater than B.
 //
 // Inputs:
 // Variant A: A
 // Variant B: B
 //
 // Outputs:
 //
 // Bit A<B: Asserted if A<B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A=B: Asserted if A=B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A>B: Asserted if A>B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned.  For 2's complement compares use CompareTwos or use the Signed dataset), Signed, Floating, Fixed and List (has list outputs and inputs).  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 34,31
 Object ( List B) Input:A;  //_GUI 34,40
 Object Output( List "A<B") ;  //_GUI 111,31
 Object Output:A( List "A=B") ;  //_GUI 111,40
 Object Output:B( List "A>B") ;  //_GUI 111,49
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 98,29
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 40,38
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 98,38
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 98,47
 Object ( Variant "A<B", Variant "A=B", Variant "A>B") Compare
    ( Variant A, Variant B) ;  //_GUI 68,29
 //_ Attributes Documentation="Floating"
 Object ( Variant "A<B", Variant "A=B", Variant "A>B") Compare:A
    ( Variant A, Variant B) ;  //_GUI 68,44
 //_ Attributes Documentation="Floating"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = ListOut:B.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Compare:A.0;  //_GUI 89,34, 89,46
 ListOut.1 = Compare.0;  
 ListIn:A.0 = Input:A.0;  
 ListOut:A.0 = Compare:A.1;  //_GUI 92,43, 92,49
 ListOut:A.1 = Compare.1;  //_GUI 86,40, 86,34
 ListOut:B.0 = Compare:A.2;  
 ListOut:B.1 = Compare.2;  //_GUI 95,49, 95,37
 Compare.0 = ListIn.1;  
 Compare.1 = ListIn:A.1;  //_GUI 63,34, 63,40
 Compare:A.0 = ListIn.0;  //_GUI 59,46, 59,34
 Compare:A.1 = ListIn:A.0;  //_GUI 51,49
}

Object ( Bit "A<B", Bit "A=B", Bit "A>B") Compare
    ( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async"
{
 // Compares two numbers, A and B, and returns whether A is less than B, equal to B, or greater than B.
 //
 // Inputs:
 // Variant A: A
 // Variant B: B
 //
 // Outputs:
 //
 // Bit A<B: Asserted if A<B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A=B: Asserted if A=B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Bit A>B: Asserted if A>B (Bit if A and B are Variant, List if A and B are Lists)
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned.  For 2's complement compares use CompareTwos or use the Signed dataset), Signed, Floating, Fixed and List (has list outputs and inputs).  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 2: modified to use more hardware but execute faster
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 21,31
 Object ( Variant B) Input:A;  //_GUI 21,34
 Object Output( Bit "A<B") ;  //_GUI 110,31
 Object Output:A( Bit "A=B") ;  //_GUI 110,38
 Object Output:B( Bit "A>B") ;  //_GUI 110,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 72,31
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 96,29
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 96,36
 Object ( Bit CI) Input:B;  //_GUI 21,40
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit ADD) Input:C;  //_GUI 21,37
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 41,30
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 41,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 36,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 33,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 30,37
 Object Text;  //_GUI 30,15,Remember the CO comes out high be default in the case of subtraction, which we're doing.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 72,47
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 96,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 27,40

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 Output:A.0 = AND.0;  
 Output:B.0 = INVERT:A.0;  
 Junction.0 = ADSU.0;  
 INVERT.0 = Junction.1;  
 AND.0 = Junction.2;  //_GUI 73,38
 AND.1 = Junction:D.0;  //_GUI 73,41
 ADSU.0 = Junction:A.1;  
 ADSU.1 = Junction:B.1;  
 ADSU.2 = Junction:C.1;  
 ADSU.3 = Junction:E.1;  
 ADSU:A.0 = Junction:B.2;  //_GUI 34,48
 ADSU:A.1 = Junction:A.2;  //_GUI 37,51
 ADSU:A.2 = Junction:C.2;  //_GUI 31,54
 ADSU:A.3 = Junction:E.2;  //_GUI 28,57
 Junction:A.0 = Input.0;  
 Junction:B.0 = Input:A.0;  
 Junction:C.0 = Input:C.0;  
 Junction:D.0 = ADSU:A.0;  
 INVERT:A.0 = Junction:D.1;  
 Junction:E.0 = Input:B.0;  
}

Object ( Variant Address, Variant Size, Variant LastDone
    , Bit Done) AddressSizeGen( MSB032 Address, MSB024 Nums, Bit Go) 
{
 //_ Object Prototypes
 Object ( MSB032 Address) Input;  //_GUI 58,44
 Object ( MSB024 Nums) Input:A;  //_GUI 58,56
 //_ Attributes WidgetLeft="20",WidgetTop="270",WidgetWidth="204",WidgetHeight="50",Widget="TextBox"
 Object ( Bit Go) Input:B;  //_GUI 56,109
 Object Output( Variant Address) ;  //_GUI 306,46
 Object Output:A( Variant Size) ;  //_GUI 306,49
 Object Output:B( Variant LastDone) ;  //_GUI 312,85
 Object Output:C( Bit Done) ;  //_GUI 312,101
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 109,54
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 129,35
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 92,28
 Object ( MSB012 MSB012) Input:C;  //_GUI 82,32
 //_ Attributes PromoteToParentObject="False"
 Object ( MSB032 Out1, MSB032 Out2, MSB032 Out3) Junction
    ( MSB032 In0) ;  //_GUI 76,44
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 108,30
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 142,31
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 202,43
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 293,45
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 139,11
 Object ( MSB032 Out1, MSB032 Out2, MSB032 Out3) Junction:A
    ( MSB032 In3) ;  //_GUI 76,29
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 120,13
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 238,41
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 93,55
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 169,99
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In1) ;  //_GUI 157,100
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 159,110
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 173,111
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 134,109
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 258,69
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 231,53
 Object ( MSB008 MSB008) Input:D;  //_GUI 80,59
 //_ Attributes PromoteToParentObject="False"
 Object ( MSB008 Out1, MSB008 Out2, MSB008 Out3) Junction:E
    ( MSB008 In0) ;  //_GUI 88,59
 Object ( MSB024 Out1, MSB024 Out2, MSB024 Out3) Junction:F
    ( MSB024 In0) ;  //_GUI 73,56
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 282,61
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 282,83
 Object ( Variant Address, Variant BlockSize, Bit LastDone
    , Bit Done) Anti4K_OneGo( MSB032 Address, MSB024 Nums, Bit Go) ;  //_GUI 151,43

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 Output:B.0 = Reg.0;  
 Output:C.0 = RegOnGo.3;  //_GUI 296,102, 296,72
 EqualZero.0 = Lo_N:A.0;  
 INVERT.0 = EqualZero.0;  //_GUI 123,38, 123,57
 Lo_N.0 = Junction:A.2;  
 Lo_N.1 = Input:C.0;  
 Junction.0 = Input.0;  
 EqualZero:A.0 = Lo_N.1;  
 AND.0 = EqualZero:A.0;  
 AND.1 = INVERT.0;  //_GUI 140,36, 140,38
 ListOut.0 = Anti4K_OneGo.1;  
 ListOut.1 = Anti4K_OneGo.0;  
 ListIn.0 = RegOnGo.0;  
 ListOut:A.0 = AllOnes.0;  
 ListOut:A.1 = Junction:A.1;  //_GUI 77,13
 Junction:A.0 = Junction.0;  
 AllOnes.0 = Junction:E.0;  //_GUI 89,16
 Mux.0 = ListOut:A.0;  //_GUI 226,43, 226,14
 Mux.1 = ListOut.0;  
 Mux.2 = Junction:D.0;  //_GUI 232,49
 Lo_N:A.0 = Junction:F.1;  
 Lo_N:A.1 = Junction:E.1;  
 AND:A.0 = Junction:B.1;  
 AND:A.1 = Junction:C.0;  //_GUI 135,104
 Junction:B.0 = AND.0;  //_GUI 158,34
 INVERT:A.0 = Junction:B.2;  //_GUI 158,113
 AND:B.0 = INVERT:A.0;  
 AND:B.1 = Junction:C.2;  //_GUI 135,116
 Junction:C.0 = Input:B.0;  
 OR.0 = Junction:D.2;  //_GUI 232,71
 OR.1 = AND:A.0;  //_GUI 240,74, 240,102
 Junction:D.0 = Anti4K_OneGo.3;  
 Junction:E.0 = Input:D.0;  
 Junction:F.0 = Input:A.0;  
 RegOnGo.0 = Mux.0;  //_GUI 279,63, 279,44
 RegOnGo.3 = OR.0;  
 Reg.0 = Anti4K_OneGo.2;  //_GUI 214,85, 214,51
 Anti4K_OneGo.0 = Junction.1;  
 Anti4K_OneGo.1 = Junction:F.2;  //_GUI 134,48, 134,72, 74,72
 Anti4K_OneGo.2 = AND:B.0;  //_GUI 145,54, 145,87, 198,87, 198,114
}

Object ( Bit Out1) ReverseBits( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Icon="Swap",Documentation="Leaf"
{
 // Date:
 // 10 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 27,20
 Object Output( Bit Out1) ;  //_GUI 40,20

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) ReverseBits( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps",Icon="Swap"
{
 // Swaps all the bits in a data set, so the most-significant bit becomes the least-significant and so on.  This object essentially changes the endian representatin of the input data set.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,20
 Object Output( Variant Out1) ;  //_GUI 98,18
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 49,18
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 37,18
 Object ( Variant Out1) $ReverseBits( Variant Build, Variant Orig) ;  //_GUI 66,18
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,20
 Object Text;  //_GUI 46,4,I guess we should make some attempt to convert this back to its original dataset.
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 84,16

 //_ Behavior Topology
 Output.0 = Context.0;  
 VariantIn.0 = MSB.0;  
 MSB.0 = Junction.1;  
 $ReverseBits.0 = VariantIn.1;  
 $ReverseBits.1 = VariantIn.0;  
 Junction.0 = Input.0;  
 Context.0 = Junction.0;  //_GUI 84,11, 31,11
 Context.1 = $ReverseBits.0;  
}

Object ( Variant Out1) Min_Rep_Twos( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // This takes in a constant, interpreting it as a twos complement number, and converts it to the smallest dataset capable of representing the constant.  (Removes duplicate leading bits.)  Supports datasets of MSBxxx, LSBxxx, and BINxxx.  A zero value input returns two bits with a value of zero.
 //
 // Inputs:
 //
 // Variant input:	Constant value interpreted as twos complement data.
 //
 // Outputs:
 //
 // Variant output:	A minimal dataset that can still represent the constant twos complement input.
 //
 // Date:
 // 11/11/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 18,18
 Object Output( Variant Out1) ;  //_GUI 58,18
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 24,16
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Variant In1) ;  //_GUI 39,16
 //_ Attributes Documentation="bit/var"

 //_ Behavior Topology
 Output.0 = $Min_Rep_Twos.0;  
 ExposeMSB.0 = Input.0;  
 $Min_Rep_Twos.0 = ExposeMSB.0;  
 $Min_Rep_Twos.1 = ExposeMSB.1;  
}

Object ( NULL Out1) Min_Rep_Twos( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // This takes in a constant, interpreting it as a twos complement number, and converts it to the smallest dataset capable of representing the constant.  (Removes duplicate leading bits.)  Supports datasets of MSBxxx, LSBxxx, and BINxxx.  A zero value input returns two bits with a value of zero.
 //
 // Inputs:
 //
 // Variant input:	Constant value interpreted as twos complement data.
 //
 // Outputs:
 //
 // Variant output:	A minimal dataset that can still represent the constant twos complement input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 18,18
 Object Output( NULL Out1) ;  //_GUI 42,18
 Object ( NULL Out1) NULL;  //_GUI 30,16
 Object ( Bit In) Input:A;  //_GUI 31,25
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 37,25
 //_ Attributes Trap="A two's complement number can't be represented with a single bit."

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit OFL, Variant Out2) AddBias( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Takes in a twos complement exponent and adds the bias onto it and outputs a biased exponent.
 //
 // Inputs:
 //
 // Variant input: A twos complement unbiased exponent
 //
 // Outputs:
 //
 // Bit OFL: The Overflow bit.  Goes high if the input is the maximum negative value (only the high bit set), which can't be represented in a biased manner.
 //
 // Variant output: The exponent with the bias offset added.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 27,37
 Object Output( Bit OFL) ;  //_GUI 80,29
 Object Output:A( Variant Out2) ;  //_GUI 83,38
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 40,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,37
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 40,26
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 52,26
 //_ Attributes Documentation="Leaf"
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 68,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 65,37
 Object Text;  //_GUI 33,16,Can't represent a biased exponent of MaxNeg
 Object ( Variant S) Add_CI( Variant A, Variant B
    , Bit CI) ;  //_GUI 70,36
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = Equal.0;  
 Output:A.0 = Add_CI.0;  
 MakeBias.0 = Junction.2;  //_GUI 35,47
 Junction.0 = Input.0;  
 One.0 = Junction.0;  //_GUI 35,29
 ReverseBits.0 = One.0;  
 Equal.0 = ReverseBits.0;  
 Equal.1 = Junction:A.0;  //_GUI 66,32
 Junction:A.0 = Junction.1;  
 Add_CI.0 = Junction:A.1;  
 Add_CI.1 = MakeBias.0;  //_GUI 66,41, 66,47
}

Object ( NULL Out1) BIN( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="NULL"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,25
 Object Output( NULL Out1) ;  //_GUI 31,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) BIN( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="Bit"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 13,25
 Object Output( Bit Out1) ;  //_GUI 31,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN002 Out1) BIN( BIN002 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN002"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN002 In1) Input;  //_GUI 42,38
 Object Output( BIN002 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN004 Out1) BIN( BIN004 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN004"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN004 In1) Input;  //_GUI 42,38
 Object Output( BIN004 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN008 Out1) BIN( BIN008 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN008"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN008 In1) Input;  //_GUI 42,38
 Object Output( BIN008 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN016 Out1) BIN( BIN016 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN016"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN016 In1) Input;  //_GUI 42,38
 Object Output( BIN016 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN032 Out1) BIN( BIN032 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN032"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN032 In1) Input;  //_GUI 42,38
 Object Output( BIN032 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN064 Out1) BIN( BIN064 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN064"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN064 In1) Input;  //_GUI 42,38
 Object Output( BIN064 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN128 Out1) BIN( BIN128 In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN128"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN128 In1) Input;  //_GUI 42,38
 Object Output( BIN128 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) BIN( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a BIN pattern, producing a BINxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 132,33
 Object ( Variant Out1) $Cast( Variant Data, BIN Type) ;  //_GUI 105,23
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 122,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,38
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 72,40
 Object ( Variant Out1) BIN:A( Variant In1) ;  //_GUI 72,32
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,9
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 21,32
 Object ( Bit In2) Input:A;  //_GUI 27,60
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), 65535, >)"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 45,60
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 91,38
 Object ( Variant Out1) $Cast:A( Variant Data, BIN Type) ;  //_GUI 105,36

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Cast.0 = $Select:A.0;  //_GUI 93,28, 93,12
 $Select.0 = $Cast.0;  //_GUI 115,33
 $Select.1 = $Cast:A.0;  //_GUI 115,36
 $Select.2 = Junction:B.1;  //_GUI 122,61
 VariantIn.0 = $Select:B.0;  //_GUI 49,41
 BIN.0 = VariantIn.0;  
 BIN:A.0 = VariantIn.1;  //_GUI 68,35, 68,40
 $Select:A.0 = Junction.1;  
 $Select:A.2 = Junction:A.1;  //_GUI 22,17
 $Select:B.1 = Junction.2;  //_GUI 31,30
 $Select:B.2 = Junction:A.2;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,50, 46,50
 Junction:B.0 = Input:A.0;  
 VariantOut.0 = BIN.0;  
 VariantOut.1 = BIN:A.0;  //_GUI 87,40, 87,35
 $Cast:A.0 = VariantOut.0;  
}

Object ( Variant Out1) BIN( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="list"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a BIN pattern, producing a BINxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 84,8
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 39,10
 Object ( Variant Out1) BIN:A( Variant In1) ;  //_GUI 39,2
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 58,8
 Object ( Variant Out1) $Cast( Variant Data, BIN Type) ;  //_GUI 72,6
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,8

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 BIN.0 = ListIn.0;  
 BIN:A.0 = ListIn.1;  //_GUI 35,5, 35,10
 VariantOut.0 = BIN.0;  
 VariantOut.1 = BIN:A.0;  //_GUI 54,10, 54,5
 $Cast.0 = VariantOut.0;  
 ListIn.0 = Input.0;  
}

Object ( Variant S) Sub( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronous subtraction
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Number
 //
 // Variant B: Number
 //
 // Outputs:
 //
 // S: The result of A minus B.  If the dataset of A and B are the same, then the dataset of S will also be the same.  If the dataset of A and B are different, the dataset of S will be the result of a Symmetrize of the two inputs.  In this case a compile-time warning is generated indicating the input datasets were different.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed, Complex and List. If one input is a list and the other is not, the other is duplicated into an equivalent list of the one.  A and B can not have mixed datasets except with respect to size or for the cases of MSB, LSB and BIN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 16,14
 Object ( Variant B) Input:A;  //_GUI 16,17
 Object Output( Variant S) ;  //_GUI 42,17
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 23,13
 //_ Attributes Documentation="List/List"

 //_ Behavior Topology
 Output.0 = Sub.1;  
 Sub.0 = Input.0;  
 Sub.1 = Input:A.0;  
}

Object ( Variant Out1) AllOnes( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 106,23
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,25
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 90,21
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 52,22
 Object ( Variant Out1) AllOnes:A( Variant In1) ;  //_GUI 52,32

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = AllOnes:A.0;  //_GUI 68,28, 68,35
 VariantOut.1 = AllOnes.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 89,23, 89,21, 27,21
 Cast.1 = VariantOut.0;  
 AllOnes.0 = VariantIn.1;  
 AllOnes:A.0 = VariantIn.0;  //_GUI 47,35, 47,28
}

Object ( Bit Out1) AllOnes( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Bit"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 37,30
 Object Output( Bit Out1) ;  //_GUI 57,41
 Object ( Bit In) Input:A;  //_GUI 38,41
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( NULL Out1) AllOnes( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 37,30
 Object Output( NULL Out1) ;  //_GUI 48,30

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Floating Out1) AllOnes( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Floating"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 37,30
 Object Output( Floating Out1) ;  //_GUI 111,30
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 48,28
 Object ( Floating Out1) CollectFloating( Bit Sign, Variant BExp
    , Variant Mant) ;  //_GUI 96,28
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 72,39
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 71,30
 Object Text;  //_GUI 47,16,we'll tie it to Infinity and leave the sign bit at whatever it came in as

 //_ Behavior Topology
 Output.0 = CollectFloating.0;  
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 96,26, 64,26
 CollectFloating.1 = AllOnes.0;  
 CollectFloating.2 = Zero.0;  //_GUI 87,36, 87,42
 Zero.0 = ExposeFloating.2;  //_GUI 66,42, 66,36
 AllOnes.0 = ExposeFloating.1;  
}

Object ( Variant Out1, Variant LSB) PopLsb( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="list"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant Out1) ;  //_GUI 35,18
 Object Output:A( Variant LSB) ;  //_GUI 35,21
 Object ( Variant Remnant, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 21,17
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListPopLsb.0;  
 Output:A.0 = ListPopLsb.1;  
 ListPopLsb.0 = Input.0;  
}

Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant Out1) ;  //_GUI 46,18
 Object Output:A( Variant LSB) ;  //_GUI 46,21
 Object ( Variant Out1, Variant Out11) ExposeLSB( Variant In1) ;  //_GUI 26,17
 //_ Attributes Documentation="Error"

 //_ Behavior Topology
 Output.0 = ExposeLSB.0;  
 Output:A.0 = ExposeLSB.1;  
 ExposeLSB.0 = Input.0;  
}

Object ( NULL Out1, Bit LSB) PopLsb( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="bit"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 14,27
 Object Output( NULL Out1) ;  //_GUI 39,17
 Object Output:A( Bit LSB) ;  //_GUI 39,27
 Object ( NULL Out1) NULL;  //_GUI 19,38
 Object Text;  //_GUI 22,50,Putting this on the bottom is a workaround for a bug to be fixed very soon.

 //_ Behavior Topology
 Output.0 = NULL.0;  //_GUI 35,18, 35,41
 Output:A.0 = Input.0;  
}

Object ( NULL Out1, NULL LSB) PopLsb( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,17
 Object Output( NULL Out1) ;  //_GUI 45,17
 Object Output:A( NULL LSB) ;  //_GUI 45,21
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 39,17
 Object Text;  //_GUI 17,30,Generally you should arrange your ZTList recursion such that this function is not called with the ZTerm dataset.  (It can be ambiguous with the case of null data in a list.)  But if you do, here are some NULLs that will get ripped out eventually.

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 40,22
 Junction.0 = Input.0;  
}

Object ( List LsbList) AppendLsbList( Variant LsbList, List AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 // Works for the var/list and the list/list case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant LsbList) Input;  //_GUI 20,38
 Object ( List AnyList) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 76,42
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 42,37
 Object ( List LsbList) AppendLsbList:A( Variant LsbList, Variant AnyList) ;  //_GUI 59,40

 //_ Behavior Topology
 Output.0 = AppendLsbList:A.0;  
 ListIn.0 = Input:A.0;  
 AppendLsbList.0 = Input.0;  
 AppendLsbList.1 = ListIn.1;  
 AppendLsbList:A.0 = AppendLsbList.0;  //_GUI 58,42, 58,40
 AppendLsbList:A.1 = ListIn.0;  
}

Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal"
{
 // Works for the var/var and the list/var case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant LsbList) Input;  //_GUI 20,33
 Object ( Variant AnyList) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 69,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 39,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( Variant DataList) ListFill( Variant Data, Variant List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // Replaces each element of the input List with the input Data.
 //
 // Inputs:
 //
 // Variant Data: The value that will be copied N times, where N is the size of the List on the List input
 //
 // Variant List: This is an instantiation of a List.  It is only here to provide the pattern of the output List.  The data sets internal to this List do not matter, as they will be replaced with instances of the Data input.
 //
 // Ouputs:
 //
 // Variant DataList: A List in the Shape of the List input where every element is a copy of the Data input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 23,9
 Object ( Variant List) Input:A;  //_GUI 23,14
 Object Output( Variant DataList) ;  //_GUI 48,9
 Object Text;  //_GUI 14,22,When the input List is a variant, this means that the list was a single element list.  In this case we output a single elemet list (a variant) that is the Data passed in.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List DataList) ListFill( Variant Data, List List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="List"
{
 // Replaces each element of the input List with the input Data.
 //
 // Inputs:
 //
 // Variant Data: The value that will be copied N times, where N is the size of the List on the List input
 //
 // Variant List: This is an instantiation of a List.  It is only here to provide the pattern of the output List.  The data sets internal to this List do not matter, as they will be replaced with instances of the Data input.
 //
 // Ouputs:
 //
 // Variant DataList: A List in the Shape of the List input where every element is a copy of the Data input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 33,33
 Object ( List List) Input:A;  //_GUI 33,44
 Object Output( List DataList) ;  //_GUI 108,42
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 58,33
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 91,40
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 65,32
 Object ( Variant DataList) ListFill:A( Variant Data, Variant List) ;  //_GUI 66,42

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
 ListOut.0 = ListFill:A.0;  
 ListOut.1 = ListFill.0;  //_GUI 86,42, 86,35
 ListFill.0 = Junction.1;  
 ListFill.1 = ListIn.1;  //_GUI 54,37, 54,44
 ListFill:A.0 = Junction.2;  //_GUI 59,44
 ListFill:A.1 = ListIn.0;  
}

Object ( NULL DataList) ListFill( Variant Data, NULL List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Replaces each element of the input List with the input Data.
 //
 // Inputs:
 //
 // Variant Data: The value that will be copied N times, where N is the size of the List on the List input
 //
 // Variant List: This is an instantiation of a List.  It is only here to provide the pattern of the output List.  The data sets internal to this List do not matter, as they will be replaced with instances of the Data input.
 //
 // Ouputs:
 //
 // Variant DataList: A List in the Shape of the List input where every element is a copy of the Data input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 21,12
 Object ( NULL List) Input:A;  //_GUI 21,17
 Object Output( NULL DataList) ;  //_GUI 47,17
 Object Text;  //_GUI 14,27,A NULL list is an empty list.  So replacing all list nodes (none) with Data produces an empty list (NULL).

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Takes in a constant value and returns an MSB data set whose bitlength is equal to the numeric value of the constant.  The MSB data set will contain all 0s.
 //
 // Date:
 // 12 Nov 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Constant) Input;  //_GUI 10,37
 Object Output( Variant N_Bits) ;  //_GUI 50,35
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 16,35
 Object ( Bit In) Input:A;  //_GUI 21,29
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 34,2,This object produces an N-bit data set (MSB) where N is defined by a constant unsigned integer on the input Constant.  The output data set will contain all 0s.Arial,8,0,1
 Object Text;  //_GUI 7,15,First the constant is filtered through a Min_Rep object.  This object removes all leading 0s, giving us our constant represented in the smallest data set possiblet.
 Object Text;  //_GUI 10,44,We then start our recursion which doubles the size of Append and strips an LSB from Constant for every recurse.
 Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Variant Constant) ;  //_GUI 28,33
 //_ Attributes Documentation="var"

 //_ Behavior Topology
 Output.0 = "$Constant->N_Bits".0;  
 Min_Rep.0 = Input.0;  
 "$Constant->N_Bits".0 = Input:A.0;  //_GUI 28,30
 "$Constant->N_Bits".1 = Min_Rep.0;  
}

Object ( NULL N_Bits) "Constant->N_Bits"( NULL Constant) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Constant) Input;  //_GUI 12,19
 Object Output( NULL N_Bits) ;  //_GUI 25,19

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) BisectList( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 19,37
 Object Output( Variant Hi) ;  //_GUI 107,36
 Object Output:A( Variant Lo) ;  //_GUI 72,39
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( Variant Hi, Variant Lo) $BisectList_Low( Variant List
    , Variant LSB) ;  //_GUI 49,35
 //_ Attributes Documentation="list"
 Object ( Variant Out1, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 28,35
 //_ Attributes Documentation="ztlist"
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 86,34

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 Output:A.0 = $BisectList_Low.1;  
 $BisectList_Low.0 = ListPopLsb.0;  
 $BisectList_Low.1 = ListPopLsb.1;  
 ListPopLsb.0 = Input.0;  
 LsbList.0 = $BisectList_Low.0;  
}

Object ( NULL Hi, Variant Lo) BisectList( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,37
 Object Output( NULL Hi) ;  //_GUI 105,31
 Object Output:A( Variant Lo) ;  //_GUI 105,37
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( NULL Out1) NULL;  //_GUI 75,29

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) BisectList( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,37
 Object Output( NULL Hi) ;  //_GUI 105,31
 Object Output:A( NULL Lo) ;  //_GUI 105,37
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( NULL Out1) NULL;  //_GUI 75,29

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant MSB, Variant Out1) $ListPopMsb( Variant In2
    , Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 15,12
 Object ( Variant In1) Input:A;  //_GUI 15,18
 Object Output( Variant MSB) ;  //_GUI 51,12
 Object Output:A( Variant Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant MSB, List Out1) $ListPopMsb( List In2
    , Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 15,31
 Object ( Variant In1) Input:A;  //_GUI 15,36
 Object Output( Variant MSB) ;  //_GUI 68,30
 Object Output:A( List Out1) ;  //_GUI 68,34
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,32
 Object ( Variant MSB, Variant Out1) $ListPopMsb( Variant In2
    , Variant In1) ;  //_GUI 37,29
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $ListPopMsb.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = $ListPopMsb.1;  
 $ListPopMsb.0 = ListIn.1;  
 $ListPopMsb.1 = ListIn.0;  
}

Object ( Variant MSB, NULL Out1) $ListPopMsb( Variant In2
    , NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 15,12
 Object ( NULL In1) Input:A;  //_GUI 15,18
 Object Output( Variant MSB) ;  //_GUI 51,12
 Object Output:A( NULL Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL MSB, NULL Out1) $ListPopMsb( NULL In2
    , NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 15,12
 Object ( NULL In1) Input:A;  //_GUI 15,18
 Object Output( NULL MSB) ;  //_GUI 51,12
 Object Output:A( NULL Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL MSB, Variant Out1) $ListPopMsb( NULL In2
    , Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 15,12
 Object ( Variant In1) Input:A;  //_GUI 15,18
 Object Output( NULL MSB) ;  //_GUI 51,12
 Object Output:A( Variant Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List MsbList) MsbList( List AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/list"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 97,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 34,31
 Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) ;  //_GUI 57,38
 Object ( List MsbList) MsbList( List AnyList) ;  //_GUI 27,40
 //_ Attributes Documentation="list"
 Object ( List MsbList) AppendMsbList:A( Variant AnyList, Variant MsbList) ;  //_GUI 79,31

 //_ Behavior Topology
 Output.0 = AppendMsbList:A.0;  
 ListIn.0 = Input.0;  
 AppendMsbList.0 = ListIn.0;  //_GUI 51,40, 51,36
 AppendMsbList.1 = MsbList.0;  
 MsbList.0 = Input:A.0;  
 AppendMsbList:A.0 = ListIn.1;  
 AppendMsbList:A.1 = AppendMsbList.0;  //_GUI 76,36, 76,41
}

Object ( List MsbList) MsbList( Variant AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 80,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 67,32
 Object ( List MsbList) MsbList( List AnyList) ;  //_GUI 26,40
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = MsbList.0;  //_GUI 54,37, 54,43
 ListOut.1 = Input.0;  
 MsbList.0 = Input:A.0;  
}

Object ( List MsbList) MsbList( List AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 103,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 32,31
 Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) ;  //_GUI 81,31
 Object ( List MsbList) AppendMsbList:A( Variant AnyList, Variant MsbList) ;  //_GUI 52,38

 //_ Behavior Topology
 Output.0 = AppendMsbList.0;  
 ListIn.0 = Input.0;  
 AppendMsbList.0 = ListIn.1;  
 AppendMsbList.1 = AppendMsbList:A.0;  //_GUI 76,36, 76,41
 AppendMsbList:A.0 = ListIn.0;  //_GUI 47,40, 47,36
 AppendMsbList:A.1 = Input:A.0;  
}

Object ( List MsbList) MsbList( Variant AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 54,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 33,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( NULL MsbList) MsbList( NULL AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( NULL MsbList) ;  //_GUI 34,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant MsbList) MsbList( Variant AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant MsbList) ;  //_GUI 81,33
 Object ( Variant MsbList) MsbList( Variant AnyList) ;  //_GUI 33,31

 //_ Behavior Topology
 Output.0 = MsbList.0;  
 MsbList.0 = Input.0;  
}

Object ( Variant MsbList) MsbList( NULL AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant MsbList) ;  //_GUI 74,42
 Object ( Variant MsbList) MsbList( Variant AnyList) ;  //_GUI 32,40

 //_ Behavior Topology
 Output.0 = MsbList.0;  
 MsbList.0 = Input:A.0;  
}

Object ( List LsbList) LsbList( Variant AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 54,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 33,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( List LsbList) LsbList( List AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/list"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 94,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 60,32
 Object ( List LsbList) AppendLsbList:A( Variant LsbList, Variant AnyList) ;  //_GUI 77,33
 Object ( List LsbList) LsbList( List AnyList) ;  //_GUI 34,31
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = AppendLsbList:A.0;  
 ListIn.0 = Input:A.0;  
 AppendLsbList.0 = LsbList.0;  
 AppendLsbList.1 = ListIn.1;  //_GUI 60,42
 AppendLsbList:A.0 = AppendLsbList.0;  
 AppendLsbList:A.1 = ListIn.0;  //_GUI 77,45
 LsbList.0 = Input.0;  
}

Object ( List LsbList) LsbList( List AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 94,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 60,32
 Object ( List LsbList) LsbList( List AnyList) ;  //_GUI 33,31
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 60,43
 ListOut.1 = LsbList.0;  
 LsbList.0 = Input.0;  
}

Object ( List LsbList) LsbList( Variant AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 94,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 60,32
 Object ( List LsbList) AppendLsbList:A( Variant LsbList, Variant AnyList) ;  //_GUI 77,33

 //_ Behavior Topology
 Output.0 = AppendLsbList:A.0;  
 ListIn.0 = Input:A.0;  
 AppendLsbList.0 = Input.0;  
 AppendLsbList.1 = ListIn.1;  //_GUI 60,42
 AppendLsbList:A.0 = AppendLsbList.0;  
 AppendLsbList:A.1 = ListIn.0;  //_GUI 77,45
}

Object ( Variant LsbList) LsbList( Variant AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant LsbList) ;  //_GUI 81,33
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 33,31

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 LsbList.0 = Input.0;  
}

Object ( Variant LsbList) LsbList( NULL AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant LsbList) ;  //_GUI 74,42
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 26,40

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 LsbList.0 = Input:A.0;  
}

Object ( NULL LsbList) LsbList( NULL AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( NULL LsbList) ;  //_GUI 34,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) EqualAllOnes( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced"
{
 // Takes in a value of any dataset and returns a high value if all bits of the dataset are high.
 //
 // Inputs:
 //
 // Variant input: The input value
 //
 // Outputs:
 //
 // Bit output: Asserted if all bits of the input are high.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 4,20
 Object Output( Bit Out1) ;  //_GUI 50,20
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 25,18
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 37,18
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 12,18
 Object Text;  //_GUI 11,26,remove any contexts

 //_ Behavior Topology
 Output.0 = EqualZero.0;  
 INVERT.0 = LSB.0;  
 EqualZero.0 = INVERT.0;  
 LSB.0 = Input.0;  
}

Object ( Bit OFL, Bit ERNG_Data, Bit ERNG_FallOff
    , Bit Round, Variant FallOff, Variant Data) ShiftRightBy( Variant Data
    , Variant ShiftBy, Bit IsTwos) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\Async\\Advanced",Documentation="barrel with ranges"
{
 // ShiftLeftBy instantiates a barrelshifter.  Data is shifted right (towards the least significant end) by ShiftBy amount.  This object is the same as a simpler object of the same name except that this object has some additional outputs and a Two's complement selector input.
 //
 // Since barrel shifters use large amounts of physical resources, the ShiftBy input is preprocessed, converting it into the smallest data set possible of representing the bit length of Data.  This ensures that an optimal structure is created.
 // If the ShiftBy input is constant, this object simply becomes a series of SHRs, which are free.
 //
 // Inputs:
 //
 // Variant Data: The input data that will be shifted at runtime (as apposed to SHR which shifts at compile time).
 //
 // Variant ShiftBy: The amount to shift data by.
 //
 // Bit IsTwos: If this input is a 1 the number to be right shifted should be interpreted as a two's complement number.  The most significant bit will be duplicated for the bit shifted in on the left.
 //
 // Outputs:
 //
 // Bit OFL: Overflow (OFL) goes high when any bits shifted off the end have a high value or ERNG_Data.
 //
 // Bit ERNG_Data: This indicates an error in the ShiftBy range.  This bit goes high if the ShiftBy value exceeds (Data size rounded up to the nearest power of two).
 //
 // Bit ERNG_FallOff: This indicates an error in the ShiftBy range.  This bit goes high if the ShiftBy value exceeds ( 2 * (Data size rounded up to the nearest power of two)).
 //
 // Bit Round: A bit used for rounding in some applications.  This is the MSB of FallOff.
 //
 // Variant FallOff: Data is shifted right out of Data into FallOff.  The dataset is the same as Data.
 //
 // Variant Data: The result of Data shifted right by ShiftBy.
 //
 // Date:
 // 07/30/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 7,35
 Object ( Variant ShiftBy) Input:A;  //_GUI 8,48
 Object ( Bit IsTwos) Input:B;  //_GUI 13,61
 //_ Attributes Constant="0"
 Object Output( Bit OFL) ;  //_GUI 217,6
 Object Output:A( Bit ERNG_Data) ;  //_GUI 215,15
 Object Output:B( Bit ERNG_FallOff) ;  //_GUI 215,23
 Object Output:C( Bit Round) ;  //_GUI 216,30
 Object Output:D( Variant FallOff) ;  //_GUI 214,37
 Object Output:E( Variant Data) ;  //_GUI 214,52
 Object ( Variant Data) List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 90,34
 //_ Attributes Documentation="var/ztlist"
 Object ( Variant Data) List_Mux_Sel:A( Variant ListData, Variant Sel) ;  //_GUI 86,22
 //_ Attributes Documentation="var/ztlist"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In3) ;  //_GUI 85,38
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 166,6
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 20,33
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 182,6
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 159,23
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 177,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 15,35
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 145,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In3) ;  //_GUI 139,34
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 123,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 112,36
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 126,35
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Variant Out1, Variant ZeroTheResult) ShiftByFilter( Variant Data
    , Variant ShiftBy) ;  //_GUI 36,44
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 111,59
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 109,41
 //_ Attributes Documentation="ztlist"
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 202,4
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 125,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 105,48
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 169,40
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 202,35
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 193,39
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 201,28
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 133,59
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 32,35
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 205,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 193,32
 Object Text;  //_GUI 143,74,So ERNG_FallOff triggers as soon as the Round and FallOff outputs are no longer validOFL triggers when data has fallen off of Data or the shift goes out of range for the Data input.
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 145,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 196,15
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 163,14
 Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Bit IsTwos) ;  //_GUI 60,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 107,24

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = Junction:J.2;  
 Output:B.0 = INVERT:A.0;  
 Output:C.0 = AND:B.0;  
 Output:D.0 = AND:A.0;  
 Output:E.0 = Context:A.0;  //_GUI 158,53, 158,36
 List_Mux_Sel.0 = PossibleRightShifts.0;  //_GUI 90,31
 List_Mux_Sel.1 = Junction.2;  
 List_Mux_Sel:A.0 = PossibleRightShifts.1;  //_GUI 83,24, 83,34
 List_Mux_Sel:A.1 = Junction.1;  
 Junction.0 = ShiftByFilter.0;  //_GUI 86,46
 OR-NInput.0 = Junction:K.0;  //_GUI 108,9
 MSB.0 = Junction:B.1;  
 VouchBit.0 = OR-NInput.0;  
 Junction:A.0 = Context.0;  
 VouchBit:A.0 = PopMsb.0;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:C.1;  //_GUI 140,23
 Context.1 = Mux.0;  
 Junction:C.0 = Junction:B.2;  //_GUI 140,54, 16,54
 Mux.0 = Junction:K.1;  
 Mux.1 = Junction:D.0;  //_GUI 113,28
 Mux.2 = PopLsb.1;  //_GUI 123,46
 Junction:D.0 = List_Mux_Sel.0;  
 AND.0 = Junction:D.1;  
 AND.1 = Junction:E.0;  
 ShiftByFilter.0 = Junction:H.2;  //_GUI 33,46
 ShiftByFilter.1 = Input:A.0;  
 EqualZero.0 = Junction:F.2;  //_GUI 106,62
 PopLsb.0 = Junction:F.0;  //_GUI 106,44
 OR.0 = Junction:J.1;  //_GUI 197,6
 OR.1 = VouchBit.0;  
 Junction:E.0 = EqualZero.0;  
 Junction:F.0 = ShiftByFilter.1;  
 EqualZero:A.0 = PopLsb.0;  
 AND:A.0 = Junction:A.1;  //_GUI 166,37, 166,24
 AND:A.1 = Junction:G.2;  
 Junction:G.0 = EqualZero:A.0;  //_GUI 194,43
 AND:B.0 = VouchBit:A.0;  //_GUI 190,30, 190,16
 AND:B.1 = Junction:I.2;  
 INVERT.0 = Junction:E.1;  
 Junction:H.0 = MSB.0;  
 INVERT:A.0 = Junction:I.1;  //_GUI 194,24
 Junction:I.0 = Junction:G.1;  
 Context:A.0 = Junction:C.2;  
 Context:A.1 = AND.0;  
 Junction:J.0 = INVERT.0;  //_GUI 197,62
 PopMsb.0 = Junction:A.0;  //_GUI 160,17
 PossibleRightShifts.0 = Junction:H.1;  //_GUI 52,31, 52,36
 PossibleRightShifts.1 = Input:B.0;  //_GUI 60,62
 Junction:K.0 = List_Mux_Sel:A.0;  
}

Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) LeftJustify( Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\Async\\Advanced"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 37,29
 Object Output( Variant ShiftedData) ;  //_GUI 176,27
 Object Output:A( Variant ShiftMask) ;  //_GUI 176,39
 Object Output:B( Variant ShiftNum) ;  //_GUI 176,47
 Object Output:C( Bit Zero) ;  //_GUI 176,52
 Object Text;  //_GUI 49,6,round up to the nearest power of two.
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 93,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 89,18
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 148,28
 Object ( Variant Out1) "2^N_Bits"( Variant In1) ;  //_GUI 75,16
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 93,16
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,16
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 148,37
 Object ( Variant Val) Encoder( Variant Mask) ;  //_GUI 63,16
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 154,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 134,52
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 139,47
 Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, Variant ShBy) ;  //_GUI 111,28
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 164,25
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 164,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 160,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In3) ;  //_GUI 47,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 144,11
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In1) ;  //_GUI 144,32

 //_ Behavior Topology
 Output.0 = Context.0;  
 Output:A.0 = Context:A.0;  
 Output:B.0 = AND.0;  
 Output:C.0 = Junction:B.1;  
 PadRight.0 = Junction:A.2;  //_GUI 90,27
 PadRight.1 = Junction.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = "2^N_Bits".0;  
 Hi_N.0 = $LeftJustify.0;  
 Hi_N.1 = Junction:F.1;  
 "2^N_Bits".0 = Encoder.0;  
 ExposeBIN.0 = Junction:A.1;  
 Zero.0 = Junction:D.2;  
 Lo_N.0 = $LeftJustify.1;  //_GUI 141,39, 141,33
 Lo_N.1 = Junction:F.2;  //_GUI 145,42
 Encoder.0 = Zero.0;  
 AND.0 = $LeftJustify.2;  //_GUI 135,47, 135,36
 AND.1 = INVERT.0;  
 Junction:B.0 = $LeftJustify.3;  //_GUI 131,53, 131,39
 INVERT.0 = Junction:B.0;  //_GUI 135,50
 $LeftJustify.0 = PadRight.1;  
 $LeftJustify.1 = ExposeBIN.1;  //_GUI 107,33, 107,21
 Context.0 = Junction:C.1;  
 Context.1 = Hi_N.0;  
 Context:A.0 = Junction:C.2;  //_GUI 161,39
 Context:A.1 = Lo_N.1;  
 Junction:C.0 = Junction:E.1;  //_GUI 161,12
 Junction:D.0 = Junction.0;  
 Junction:E.0 = Junction:D.1;  //_GUI 48,12
 Junction:F.0 = Junction:E.2;  
}

Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 // See inside and the other overload for documentation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 18,42
 Object ( Variant Data) Input:A;  //_GUI 18,55
 Object Output( Bit OFL) ;  //_GUI 241,34
 Object Output:A( Variant Out1) ;  //_GUI 241,48
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 104,54
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 205,48
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 33,67
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 118,53
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 88,58
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 29,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 33,71
 Object Text;  //_GUI 207,63,So if the data is shorter then the type, we need to tack on some zero fill on the top. Otherwise we just truncate it.
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 205,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 104,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 199,55
 Object Text;  //_GUI 144,13,If we lose non-zero data on the high end and we weren't signed, that's an overflow. If we lose non-high data on the upper end and we were signed, that's an overflow.
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 170,30
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 91,61
 //_ Attributes Documentation="Error"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 174,55
 Object Text;  //_GUI 29,9,The #0 is for data truncation and the #1 case is for data extension.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 88,63
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 145,54
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 135,56
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 134,55
 Object Text;  //_GUI 108,65,So if signed, we prepend all high bits else prepend all low bits.
 Object ( Variant Out1, Variant Out11) ExposeMSB:A( Variant In1) ;  //_GUI 86,29
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In3) ;  //_GUI 80,39
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 155,30
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT:A( Variant In1) ;  //_GUI 145,32
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 144,31
 Object ( Bit "#1") Input:B;  //_GUI 199,36
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 172,41
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out11) ExposeMSB:B( Variant In1) ;  //_GUI 130,40
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 124,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 150,37
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 184,31
 //_ Attributes Documentation="ztlist/ztlist"
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 223,46
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 229,32
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 10,69
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 26,55
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 48,50
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 52,67
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,60
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 48,28
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,27
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In0) ;  //_GUI 52,45
 Object ( Variant Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,38

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 Lo_N.0 = $Select:E.0;  //_GUI 87,56, 87,46, 71,46
 Lo_N.1 = Junction:A.1;  
 $Select.0 = Junction:I.2;  //_GUI 125,50
 $Select.1 = CollectMSB.0;  //_GUI 194,53, 194,58
 $Select.2 = Junction:D.2;  
 Junction.0 = Junction:C.0;  
 Zero.0 = Lo_N.0;  
 Junction:A.0 = $Select:C.0;  //_GUI 79,59, 79,63
 Junction:B.0 = Input.0;  
 Junction:C.0 = BitA_Gt_BitB.0;  
 $Select:A.0 = OR.0;  
 $Select:A.1 = Input:B.0;  
 $Select:A.2 = Junction:D.1;  //_GUI 200,40
 Lo_N:A.0 = Junction:G.2;  
 Lo_N:A.1 = $Select:D.0;  //_GUI 75,43, 75,30
 Junction:D.0 = Junction:C.1;  //_GUI 200,72
 NotZero.0 = $Mux:A.0;  
 ExposeMSB.0 = Junction:E.1;  
 CollectMSB.0 = $Mux.0;  
 CollectMSB.1 = Junction:E.2;  //_GUI 174,70, 89,70
 Junction:E.0 = Junction:A.2;  
 $Mux.0 = Junction:F.1;  
 $Mux.1 = INVERT.0;  
 $Mux.2 = ExposeMSB.0;  //_GUI 118,62, 118,63
 INVERT.0 = Junction:F.2;  
 Junction:F.0 = Zero.0;  
 ExposeMSB:A.0 = Junction:G.1;  //_GUI 81,32
 Junction:G.0 = $Select:B.0;  //_GUI 81,52
 $Mux:A.0 = Junction:H.1;  
 $Mux:A.1 = INVERT:A.0;  
 $Mux:A.2 = Junction:J.1;  
 INVERT:A.0 = Junction:H.2;  
 Junction:H.0 = Lo_N:A.0;  //_GUI 128,32, 128,40
 XOR.0 = Junction:J.2;  //_GUI 151,43
 XOR.1 = ExposeMSB:B.0;  //_GUI 147,46, 147,42
 ExposeMSB:B.0 = Junction:I.1;  
 Junction:I.0 = Lo_N:A.1;  
 Junction:J.0 = ExposeMSB:A.0;  //_GUI 122,38, 122,31
 OR.0 = NotZero.0;  
 OR.1 = XOR.0;  //_GUI 184,44
 Context.0 = Junction:B.0;  //_GUI 223,26, 30,26
 Context.1 = $Select.0;  
 VouchBit.0 = $Select:A.0;  
 BitA_Gt_BitB.0 = Junction:B.2;  //_GUI 10,48, 30,48
 BitA_Gt_BitB.1 = Junction:K.2;  //_GUI 6,74, 6,62, 27,62
 Junction:K.0 = Input:A.0;  
 Junction:L.0 = Junction:K.1;  //_GUI 38,51, 38,56
 $Select:B.0 = Junction:L.1;  
 $Select:B.2 = Junction:M.0;  //_GUI 53,57
 Junction:M.0 = Junction.2;  
 $Select:C.1 = Junction:L.2;  //_GUI 49,65
 $Select:C.2 = Junction:M.1;  
 Junction:N.0 = Junction:B.1;  //_GUI 39,29, 39,43
 $Select:D.0 = Junction:N.1;  
 $Select:D.2 = Junction:O.0;  //_GUI 53,35
 Junction:O.0 = Junction.1;  //_GUI 34,46
 $Select:E.1 = Junction:N.2;  //_GUI 49,43
 $Select:E.2 = Junction:O.1;  
}

Object ( List OFL, List Out1) TwosExtnd( Variant Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/List"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 15,17
 Object ( List Data) Input:A;  //_GUI 15,21
 Object Output( List OFL) ;  //_GUI 89,11
 Object Output:A( List Out1) ;  //_GUI 84,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 36,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 69,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 72,9
 Object ( Variant OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 40,31
 Object ( Variant OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 40,16

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = TwosExtnd.1;  //_GUI 63,24, 63,36
 ListOut.1 = TwosExtnd:A.1;  
 ListOut:A.0 = TwosExtnd.0;  //_GUI 56,14, 56,33
 ListOut:A.1 = TwosExtnd:A.0;  //_GUI 52,11
 TwosExtnd.0 = Junction.2;  //_GUI 37,33
 TwosExtnd.1 = ListIn.0;  //_GUI 32,36
 TwosExtnd:A.0 = Junction.1;  
 TwosExtnd:A.1 = ListIn.1;  
}

Object ( List OFL, List Out1) TwosExtnd( List Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="list"
{
 // See inside and the other overload for documentation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 14,37
 Object ( List Data) Input:A;  //_GUI 14,48
 Object Output( List OFL) ;  //_GUI 65,42
 Object Output:A( List Out1) ;  //_GUI 65,53
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 37,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,40
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 20,46
 Object ( Bit OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 34,51
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,51

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 TwosExtnd.0 = ListIn.1;  
 TwosExtnd.1 = ListIn:A.1;  //_GUI 37,48
 ListIn.0 = Input.0;  
 ListOut.0 = TwosExtnd:A.0;  //_GUI 46,45
 ListOut.1 = TwosExtnd.0;  //_GUI 52,37
 ListIn:A.0 = Input:A.0;  
 TwosExtnd:A.0 = ListIn.0;  //_GUI 34,40
 TwosExtnd:A.1 = ListIn:A.0;  //_GUI 31,56
 ListOut:A.0 = TwosExtnd:A.1;  
 ListOut:A.1 = TwosExtnd.1;  //_GUI 49,53
}

Object ( Variant Max) $MaxSigned( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller Signed size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Bit OFL, NULL Out1) PadRight( NULL Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL/var"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( Variant Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,12
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 23,21

 //_ Behavior Topology
 Output.0 = NotZero.0;  //_GUI 35,13
 Output:A.0 = Input.0;  
 NotZero.0 = Input:A.0;  
}

Object ( Bit OFL, NULL Out1) PadRight( NULL Type
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) PadRight( Variant Type
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( Variant Out1) ;  //_GUI 53,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,15

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced"
{
 // Similar to UExtnd except adds or removes bits from the least significant end rather than from the most significant end of the number.  If Type is a Variant and Data is a List, PadRight is called on each element of the list with the specified Type.  If both Type and Data are lists, then PadRight is called on each respective input pair.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to right pad
 //
 // Outputs:
 //
 // Bit/List OFL 1 if any non-zero bits were removed.  This output is asynchronous and may have difficulty meeting timing specifications with large reductions in dataset sizes and/or faster frequencies.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,38
 Object ( Variant Data) Input:A;  //_GUI 7,51
 Object Output( Bit OFL) ;  //_GUI 190,29
 Object Output:A( Variant Out1) ;  //_GUI 179,37
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 44,37
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 79,50
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 38,54
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 95,49
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 69,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 34,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 38,67
 Object Text;  //_GUI 52,73,So if the data is shorter then the type, we need to tack on some zero fill on the bottom.
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,27
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 44,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 138,51
 Object Text;  //_GUI 42,26,If we lose non-zero data on the low end, that's an overflow.
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 102,33
 //_ Attributes Documentation="Bit"
 Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) ;  //_GUI 121,34
 //_ Attributes Documentation="Variant"
 Object ( Bit In) Input:B;  //_GUI 117,38
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 97,10,If inputs Type and Data are the same sizes, the Lo output of Hi_N will be NULL.  In this case there is no overflow, so change it to a bit of value zero with ZeroNulls.
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 178,27
 Object ( Bit In) Input:C;  //_GUI 138,31
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 19,65
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 18,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 14,51
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 122,50
 //_ Attributes Documentation="ztl/var"
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 162,35
 Object Text;  //_GUI 11,30,so the #0 case is shrinking the data
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 79,34

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 $SelectOut.0 = Junction:B.1;  
 $SelectOut.1 = Junction.1;  //_GUI 39,42
 Lo_N.0 = $SelectOut.1;  //_GUI 68,52, 68,42
 Lo_N.1 = Junction:A.1;  
 $Select.0 = Hi_N.0;  //_GUI 95,46, 95,36
 $Select.1 = PushLsb.0;  //_GUI 132,49
 $Select.2 = Junction:D.2;  
 Junction.0 = Junction:C.0;  
 Zero.0 = Lo_N.0;  
 Junction:A.0 = $SelectOut:A.1;  
 Junction:B.0 = Junction:E.1;  
 Junction:C.0 = BitA_Ge_BitB.0;  
 $Select:A.0 = ZeroNulls.0;  //_GUI 134,29, 134,37
 $Select:A.1 = Input:C.0;  
 $Select:A.2 = Junction:D.1;  //_GUI 139,35
 $SelectOut:A.0 = Junction:F.1;  
 $SelectOut:A.1 = Junction.2;  
 Junction:D.0 = Junction:C.1;  //_GUI 139,68
 NotZero.0 = Hi_N.1;  //_GUI 98,36, 98,39
 ZeroNulls.0 = NotZero.0;  
 ZeroNulls.1 = Input:B.0;  
 VouchBit.0 = $Select:A.0;  
 BitA_Ge_BitB.0 = Junction:E.2;  
 BitA_Ge_BitB.1 = Junction:F.2;  //_GUI 15,70
 Junction:E.0 = Input.0;  
 Junction:F.0 = Input:A.0;  
 PushLsb.0 = Junction:A.2;  //_GUI 113,52, 113,64, 70,64
 PushLsb.1 = Zero.0;  //_GUI 105,55
 Context.0 = Junction:B.0;  //_GUI 162,8, 35,8
 Context.1 = $Select.0;  //_GUI 158,40, 158,47
 Hi_N.0 = $SelectOut:A.0;  //_GUI 62,36, 62,52
 Hi_N.1 = $SelectOut.0;  
}

Object ( List OFL, List Out1) PadRight( Variant Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="Var/List"
{
 // Similar to UExtnd except adds or removes bits from the least significant end rather than from the most significant end of the number.  If Type is a Variant and Data is a List, PadRight is called on each element of the list with the specified Type.  If both Type and Data are lists, then PadRight is called on each respective input pair.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to right pad
 //
 // Outputs:
 //
 // Bit/List OFL 1 if any non-zero bits were removed.  This output is asynchronous and may have difficulty meeting timing specifications with large reductions in dataset sizes and/or faster frequencies.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,17
 Object ( List Data) Input:A;  //_GUI 7,21
 Object Output( List OFL) ;  //_GUI 65,12
 Object Output:A( List Out1) ;  //_GUI 65,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 13,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,10
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,17
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 33,16
 //_ Attributes Documentation="var/List"
 Object ( Variant OFL, Variant Out1) PadRight:A( Variant Type
    , Variant Data) ;  //_GUI 33,31
 //_ Attributes Documentation="var/List"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = PadRight:A.1;  //_GUI 49,24, 49,36
 ListOut.1 = PadRight.1;  
 ListOut:A.0 = PadRight:A.0;  //_GUI 46,15, 46,33
 ListOut:A.1 = PadRight.0;  //_GUI 43,12
 Junction.0 = Input.0;  
 PadRight.0 = Junction.1;  
 PadRight.1 = ListIn.1;  
 PadRight:A.0 = Junction.2;  //_GUI 29,33
 PadRight:A.1 = ListIn.0;  //_GUI 24,36
}

Object ( List OFL, List Out1) PadRight( List Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="List\\List"
{
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 17,21
 Object ( List Data) Input:A;  //_GUI 17,30
 Object Output( List OFL) ;  //_GUI 75,15
 Object Output:A( List Out1) ;  //_GUI 75,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 23,28
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 62,22
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 62,13
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 43,19
 //_ Attributes Documentation="var/List"
 Object ( Variant OFL, Variant Out1) PadRight:A( Variant Type
    , Variant Data) ;  //_GUI 43,34
 //_ Attributes Documentation="var/List"
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 23,19

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = PadRight:A.1;  //_GUI 59,27, 59,39
 ListOut.1 = PadRight.1;  
 ListOut:A.0 = PadRight:A.0;  //_GUI 56,18, 56,36
 ListOut:A.1 = PadRight.0;  //_GUI 53,15
 PadRight.0 = ListIn:A.1;  
 PadRight.1 = ListIn.1;  //_GUI 43,30
 PadRight:A.0 = ListIn:A.0;  //_GUI 39,36, 39,24
 PadRight:A.1 = ListIn.0;  //_GUI 34,39
 ListIn:A.0 = Input.0;  
}

Object ( Variant Max) $MaxFract( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller fixed-point fraction size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Variant Max) $MaxSWhole( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller fixed-point sign and whole size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Variant SBExp, Variant Mant) ExposeFloating( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the Sign and Biased Exponent portion along with the Mantissa (high bit implied) portion of a value from a Floating dataset.
 //
 // Inputs:
 //
 // Variant input: The Floating value to expose.
 //
 // Outputs:
 //
 // Variant SBExp: The sign bit (as MSB) along with the biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 11,20
 Object Output( Variant SBExp) ;  //_GUI 43,19
 Object Output:A( Variant Mant) ;  //_GUI 43,22
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 17,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,18
 Object Text;  //_GUI 48,14,Sign and Biased exponent

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 FloatingIn.0 = Input.0;  
 ListIn.0 = FloatingIn.0;  
}

Object ( Floating Out1) CollectFloating( Variant SBExp, Variant Mant) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the Sign and Biased Exponent with the Mantissa (high bit implied) portions of a value into a Floating dataset.
 //
 // Inputs:
 //
 // Variant SBExp: The sign bit (as MSB) along with the biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded Floating value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant SBExp) Input;  //_GUI 24,20
 Object ( Variant Mant) Input:A;  //_GUI 24,23
 Object Output( Floating Out1) ;  //_GUI 71,21
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 57,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 44,19
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 31,18
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 31,21

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 FloatingOut.0 = ListOut.0;  
 ListOut.0 = MSB:A.0;  
 ListOut.1 = MSB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
}

Object ( Bit OFL, Floating Out2) FloatExtnd( Floating Type
    , Floating Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Changes the size of a floating-point number by either extending or shrinking the exponent and/or the mantissa.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Floating Type: The destination dataset for the floating-point conversion.
 //
 // Floating Data: The floating-point value to be converted.
 //
 // Outputs:
 //
 // Bit OFL: Indicates that there was an overflow in the conversion (shrinking) of the exponent.
 //
 // Variant output: The floating-point value represented in the destination Floating dataset specified with the Type input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 11,13
 Object ( Floating Data) Input:A;  //_GUI 10,28
 Object Output( Bit OFL) ;  //_GUI 343,47
 Object Output:A( Floating Out2) ;  //_GUI 353,62
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 265,63
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 51,11
 Object ( Bit Add1Exp, Variant Out2) ConvMant( Variant Type
    , Variant Data) ;  //_GUI 149,82
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 293,66
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 278,73
 Object Text;  //_GUI 144,99,Convert mantissa.If shrinking mantissa, round.If expanding, zero extend LSBs.
 Object Text;  //_GUI 268,80,Zero the Data when SetTo0, or EqualZero
 Object Text;  //_GUI 289,51,Pass OFL through when not zero
 Object Text;  //_GUI 292,74,Pass data through when not zeroing
 Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) ConvBExp
    ( Variant Type, Variant Data) ;  //_GUI 149,70
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 185,78
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 181,77
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 266,73
 Object Text;  //_GUI 198,57,OFL when SetToMaxPos or CO
 Object Text;  //_GUI 196,98,If the entire mantissa rounds up, then we add 1 to the BExp (which could carry over). It's not an overflow because we have the OFL triggering on a 255 exponent. This allows us to roll the exponent up to 255 for an even infinity.
 Object ( Floating Out) $Cast( Variant Data, Floating Type) ;  //_GUI 341,60
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 195,76
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 236,65
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 250,77
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 222,76
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating:A
    ( Floating In1) ;  //_GUI 108,53
 //_ Attributes Documentation="with NaN"
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 193,67
 Object ( Bit Out) OR:C( Bit In1, Bit In2) ;  //_GUI 200,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 185,71
 Object ( Variant Out1) OR:D( Variant In1, Variant In2) ;  //_GUI 213,64
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 227,66
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 92,51
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating:B
    ( Floating In1) ;  //_GUI 50,26
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 327,62
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 331,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 72,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 69,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 321,52
 Object ( Bit Out) OR:E( Bit In1, Bit In2) ;  //_GUI 109,27
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 77,26
 Object ( Bit Out1) BitA_Ne_BitB:A( Variant A, Variant B) ;  //_GUI 77,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 127,29
 Object ( Bit "#0") Input:B;  //_GUI 309,46
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:G
    ( Floating In0) ;  //_GUI 35,28
 Object Text;  //_GUI 24,55,turn this thing into a passthrough in the case where the datasets are equal
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:H
    ( Floating In0) ;  //_GUI 285,65

 //_ Behavior Topology
 Output.0 = $Select:A.0;  
 Output:A.0 = $Cast.0;  
 CollectFloating.0 = ExposeFloating:A.0;  //_GUI 260,65, 260,55
 CollectFloating.1 = OR:A.0;  
 CollectFloating.2 = AND:A.0;  //_GUI 260,71
 ExposeFloating.0 = Input.0;  
 ConvMant.0 = Junction:D.1;  //_GUI 146,84, 146,19
 ConvMant.1 = ExposeFloating:A.3;  //_GUI 138,87, 138,64
 AND.0 = Junction:H.2;  //_GUI 286,68
 AND.1 = INVERT.0;  //_GUI 290,71, 290,76
 INVERT.0 = OR.0;  
 ConvBExp.0 = Junction:C.1;  //_GUI 149,16
 ConvBExp.1 = ExposeFloating:A.1;  //_GUI 141,75, 141,58
 Zero.0 = Junction.2;  //_GUI 182,81
 Junction.0 = ConvBExp.2;  
 OR.0 = ConvBExp.1;  
 OR.1 = ExposeFloating:A.6;  //_GUI 266,96, 131,96, 131,73
 $Cast.0 = $Select.0;  
 $Cast.1 = Junction:H.0;  //_GUI 286,62
 ADSU.0 = Junction.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = ConvMant.0;  //_GUI 169,87, 169,84
 OR:A.0 = Junction:B.1;  
 OR:A.1 = ADSU.2;  //_GUI 236,84
 AND:A.0 = INVERT:A.0;  
 AND:A.1 = ConvMant.1;  //_GUI 250,92, 165,92, 165,87
 INVERT:A.0 = Junction:B.2;  //_GUI 222,72, 228,72
 ExposeFloating:A.0 = $SelectOut.1;  
 OR:B.0 = ExposeFloating:A.7;  //_GUI 135,69, 135,76
 OR:B.1 = Junction:A.1;  
 OR:C.0 = ExposeFloating:A.10;  //_GUI 128,49, 128,85
 OR:C.1 = Junction:A.0;  //_GUI 186,52
 Junction:A.0 = ConvBExp.0;  
 OR:D.0 = OR:B.0;  //_GUI 203,66
 OR:D.1 = ADSU.0;  
 Junction:B.0 = OR:D.0;  
 $SelectOut.0 = Junction:G.2;  //_GUI 36,53
 $SelectOut.1 = Junction:F.2;  //_GUI 78,56, 78,46, 128,46
 ExposeFloating:B.0 = Junction:G.1;  
 $Select.0 = $SelectOut.0;  //_GUI 327,24, 104,24
 $Select.1 = AND.0;  //_GUI 310,67, 310,69
 $Select.2 = Junction:E.2;  //_GUI 322,70
 $Select:A.0 = Input:B.0;  
 $Select:A.1 = OR:C.0;  
 $Select:A.2 = Junction:E.1;  
 Junction:C.0 = ExposeFloating.1;  
 Junction:D.0 = ExposeFloating.2;  
 Junction:E.0 = Junction:F.1;  //_GUI 322,30
 OR:E.0 = BitA_Ne_BitB.0;  
 OR:E.1 = BitA_Ne_BitB:A.0;  //_GUI 98,32, 98,39
 BitA_Ne_BitB.0 = Junction:C.2;  //_GUI 73,28
 BitA_Ne_BitB.1 = ExposeFloating:B.1;  
 BitA_Ne_BitB:A.0 = Junction:D.2;  //_GUI 70,38
 BitA_Ne_BitB:A.1 = ExposeFloating:B.2;  //_GUI 66,41
 Junction:F.0 = OR:E.0;  
 Junction:G.0 = Input:A.0;  
 Junction:H.0 = CollectFloating.0;  
}

Object ( Variant Max) $MaxMant( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller floating-point mantissa size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Variant Max) $MaxSBExp( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller floating-point sign and biased exponent size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Bit Out1) $SymmInvalidDS( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,19
 Object Output( Bit Out1) ;  //_GUI 72,21
 Object ( Bit Out1) IsFloating( Variant In1) ;  //_GUI 24,17
 //_ Attributes Documentation="Floating"
 Object ( Bit Out1) IsList( Variant In1) ;  //_GUI 24,25
 //_ Attributes Documentation="list"
 Object ( Bit Out1) IsComplex( Variant In1) ;  //_GUI 24,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 19,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In1) ;  //_GUI 19,27
 Object Text;  //_GUI 17,48,The datasets Floating, List and Complex only support symmetrize with themselves, not with anything else.
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 43,18
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 59,19

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 IsFloating.0 = Junction.1;  
 IsList.0 = Junction:A.1;  
 IsComplex.0 = Junction:A.2;  //_GUI 20,36
 Junction.0 = Input.0;  
 Junction:A.0 = Junction.2;  
 OR.0 = IsFloating.0;  
 OR.1 = IsList.0;  //_GUI 38,23, 38,28
 OR:A.0 = OR.0;  
 OR:A.1 = IsComplex.0;  //_GUI 59,28, 42,28, 42,36
}

Object ( Bit Out1) SameDataSets( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 // Returns 1 if the two input datasets have the same outermost dataset.
 //
 // Will return 1 even if the contents of both outermost datasets are different, as long as the outermost datasets themselves are the same.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be contextual dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Contextual, 0 otherwise.
 //
 // Examples:
 //
 // SameDataSets ( MSB003, MSB003 ) = 1
 // SameDataSets ( MSB003, LSB003 ) = 0
 // SameDataSets ( MSB003, MSB004 ) = 0
 // SameDataSets ( Fixed ( 5.3 ), Fixed ( 20.20 ) ) = 1
 // SameDataSets ( List ( MSB003, BIN008 ), List ( Bit, Bit ) ) = 1
 // SameDataSets ( Signed ( MSB003 ), Signed ( MSB004 ) ) = 1
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 43,22
 Object ( Bit In2) Input:A;  //_GUI 43,25
 Object Output( Bit Out1) ;  //_GUI 69,22
 Object ( Bit In) Input:B;  //_GUI 59,22
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameDataSets( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns 1 if the two input datasets have the same outermost dataset.
 //
 // Will return 1 even if the contents of both outermost datasets are different, as long as the outermost datasets themselves are the same.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be contextual dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Contextual, 0 otherwise.
 //
 // Examples:
 //
 // SameDataSets ( MSB003, MSB003 ) = 1
 // SameDataSets ( MSB003, LSB003 ) = 0
 // SameDataSets ( MSB003, MSB004 ) = 0
 // SameDataSets ( Fixed ( 5.3 ), Fixed ( 20.20 ) ) = 1
 // SameDataSets ( List ( MSB003, BIN008 ), List ( Bit, Bit ) ) = 1
 // SameDataSets ( Signed ( MSB003 ), Signed ( MSB004 ) ) = 1
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 43,22
 Object ( Variant In2) Input:A;  //_GUI 43,25
 Object Output( Bit Out1) ;  //_GUI 91,31
 Object ( Bit In) Input:B;  //_GUI 60,31
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:DSNum), $(NodeInfo:1:DSNum), =)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Eq_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Eq_BitB.0 = MSB.0;  
 $BitA_Eq_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 == 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Eq_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Eq_BitB.0 = Input.0;  
 $BitA_Eq_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"
 Object Text;  //_GUI 8,29,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Eq_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Eq_BitB.0 = MSB.0;  
 $BitA_Eq_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 28,44,(0 > 0)

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), >)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 28,44,( ( ! 0) > 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 28,44,( 0 > ( ! 0) )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SymmInvalidDS( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 25,26
 Object ( Variant In2) Input:A;  //_GUI 25,29
 Object Output( Bit Out1) ;  //_GUI 62,27
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 50,25
 Object ( Bit Out1) $SymmInvalidDS( Variant In1) ;  //_GUI 31,24
 Object ( Bit Out1) $SymmInvalidDS:A( Variant In1) ;  //_GUI 31,27

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = $SymmInvalidDS.0;  
 OR.1 = $SymmInvalidDS:A.0;  
 $SymmInvalidDS.0 = Input.0;  
 $SymmInvalidDS:A.0 = Input:A.0;  
}

Object ( Bit OFL, Signed Out1) $Convert( Signed Type
    , Signed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Signed"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 02 Jan 2003
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Type) Input;  //_GUI 34,37
 Object ( Signed Data) Input:A;  //_GUI 34,45
 Object Output( Bit OFL) ;  //_GUI 95,39
 Object Output:A( Signed Out1) ;  //_GUI 123,45
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 52,43
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 94,43
 Object ( Variant Out1) SignedIn:A( Signed In) ;  //_GUI 52,35
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 77,41

 //_ Behavior Topology
 Output.0 = TwosExtnd.0;  //_GUI 89,40
 Output:A.0 = SignedOut.0;  
 SignedIn.0 = Input:A.0;  
 SignedOut.0 = TwosExtnd.1;  
 SignedIn:A.0 = Input.0;  
 TwosExtnd.0 = SignedIn:A.0;  //_GUI 71,43, 71,38
 TwosExtnd.1 = SignedIn.0;  
}

Object ( Bit OFL, Fixed Out2) $Convert( Fixed Type
    , Fixed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Fixed"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Type) Input;  //_GUI 7,14
 Object ( Fixed Data) Input:A;  //_GUI 7,23
 Object Output( Bit OFL) ;  //_GUI 137,14
 Object Output:A( Fixed Out2) ;  //_GUI 138,30
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 16,12
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 121,28
 Object ( Variant SWhole, Variant Fract) ExposeFixed:A( Fixed In1) ;  //_GUI 16,21
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 40,12
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 42,21
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 42,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 36,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 32,19
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 68,31
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 57,21
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 76,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 72,23
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 125,12
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 109,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 32,33
 Object Text;  //_GUI 32,45,Would be done after PadRight if we didn't have to round.  But we need to, so get the next lower bit in the original Fract (if there is one, otherwise it's a NULL) and add it to the entire fixed value then separate it into SWhole and Fract.
 Object Text;  //_GUI 84,45,-      With Type as       4 bit whole       1 bit fractFix16  OFL output 0.0    0    0.0 1.0    0    1.0 1.24   0    1.0 1.25   0    1.5 1.26   0    1.5 7.5    0    7.5 7.74   0    7.5 7.75   1   -8.0 7.76   1   -8.0 8.00   1   -8.0 8.10   1   -8.0-1.0    0   -1.0-1.24   0   -1.0-1.25   0   -1.0-1.26   0   -1.5-7.5    0   -7.5-7.74   0   -7.5-7.75   0   -7.5-7.76   0   -8.0-8.00   0   -8.0-8.10   1   -8.0Courier New,8,0,0
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 87,22
 Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) ;  //_GUI 57,32
 Object ( Bit Type) Input:B;  //_GUI 51,36
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = CollectFixed.0;  
 ExposeFixed.0 = Input.0;  
 CollectFixed.0 = Lo_N.0;  
 CollectFixed.1 = Lo_N.1;  
 ExposeFixed:A.0 = Input:A.0;  
 TwosExtnd.0 = ExposeFixed.0;  
 TwosExtnd.1 = ExposeFixed:A.0;  //_GUI 37,17, 37,23
 PadRight.0 = Junction:A.1;  //_GUI 42,20
 PadRight.1 = Junction.1;  
 Hi_N.0 = Junction.2;  //_GUI 37,31
 Hi_N.1 = Junction:C.1;  
 Junction.0 = ExposeFixed:A.1;  
 Junction:A.0 = ExposeFixed.1;  //_GUI 29,20
 ExposeMSB.0 = ZeroNulls.0;  
 CollectMSB.0 = TwosExtnd.1;  //_GUI 55,23, 55,17
 CollectMSB.1 = PadRight.1;  
 Zero.0 = Junction:B.2;  //_GUI 73,27
 Junction:B.0 = CollectMSB.0;  
 OR.0 = TwosExtnd.0;  
 OR.1 = ADSU.1;  //_GUI 110,17, 110,27
 Lo_N.0 = ADSU.2;  
 Lo_N.1 = Junction:C.2;  //_GUI 107,33, 107,41, 33,41
 Junction:C.0 = Junction:A.2;  
 ADSU.0 = Junction:B.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = ExposeMSB.0;  
 ZeroNulls.0 = Hi_N.1;  
 ZeroNulls.1 = Input:B.0;  
}

Object ( Bit OFL, NULL Out1) $Convert( NULL Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="NULL"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 43,45
 Object ( Variant Data) Input:A;  //_GUI 43,54
 Object Output( Bit OFL) ;  //_GUI 108,36
 Object Output:A( NULL Out1) ;  //_GUI 109,45
 Object ( Bit In) Input:B;  //_GUI 79,36
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( NULL Out1) NULL;  //_GUI 92,43

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = NULL.0;  
}

Object ( Bit OFL, Floating Out1) $Convert( Floating Type
    , Floating Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Floating"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 34,37
 Object ( Floating Data) Input:A;  //_GUI 34,40
 Object Output( Bit OFL) ;  //_GUI 79,37
 Object Output:A( Floating Out1) ;  //_GUI 79,40
 Object ( Bit OFL, Floating Out2) FloatExtnd( Floating Type
    , Floating Data) ;  //_GUI 51,36
 //_ Attributes Documentation="FloatIng"

 //_ Behavior Topology
 Output.0 = FloatExtnd.0;  
 Output:A.0 = FloatExtnd.1;  
 FloatExtnd.0 = Input.0;  
 FloatExtnd.1 = Input:A.0;  
}

Object ( Bit OFL, Signed Out1) $Convert( Signed Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Unsigned->Signed"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Type) Input;  //_GUI 12,28
 Object ( Variant Data) Input:A;  //_GUI 12,31
 Object Output( Bit OFL) ;  //_GUI 77,27
 Object Output:A( Signed Out1) ;  //_GUI 77,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,31
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 65,25
 Object ( Bit Out1) Sign( Variant In1) ;  //_GUI 52,29
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 35,27
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 20,26
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 51,37
 Object Text;  //_GUI 32,9,If the size of the data was reduced or stayed the same, if the most significant bit or any removed bits were asserted, data is lost and this is an overflow condition.

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = SignedOut.0;  
 Junction.0 = UExtnd.1;  
 OR.0 = UExtnd.0;  //_GUI 48,27, 48,29
 OR.1 = Sign.0;  //_GUI 63,30, 63,32
 Sign.0 = Junction.1;  
 UExtnd.0 = SignedIn.0;  
 UExtnd.1 = Input:A.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = Junction.2;  //_GUI 48,40
}

Object ( Bit OFL, Fixed Out1) $Convert( Fixed Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Unsigned->Fixed"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Type) Input;  //_GUI 11,24
 Object ( Variant Data) Input:A;  //_GUI 11,30
 Object Output( Bit OFL) ;  //_GUI 83,18
 Object Output:A( Fixed Out1) ;  //_GUI 83,30
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 41,30
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 41,22
 Object ( Bit Out1) Sign( Variant In1) ;  //_GUI 57,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,26
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 70,16
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 18,22
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 57,28
 Object Text;  //_GUI 44,2,If the size of Data was reduced or stayed the same, if the most significant bit or any removed bits were asserted, data is lost and this is an overflow condition.

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = CollectFixed.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 35,33, 35,27
 UExtnd.0 = ExposeFixed.0;  
 UExtnd.1 = Input:A.0;  //_GUI 38,27, 38,31
 Sign.0 = Junction.0;  //_GUI 54,21
 Junction.0 = UExtnd.1;  
 OR.0 = UExtnd.0;  //_GUI 70,16, 51,16
 OR.1 = Sign.0;  
 ExposeFixed.0 = Input.0;  
 CollectFixed.0 = Junction.2;  //_GUI 54,30
 CollectFixed.1 = Zero.0;  
}

Object ( Bit OFL, Variant Out1) $Convert( Variant Type
    , Signed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Signed->Unsigned"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 12,48
 Object ( Signed Data) Input:A;  //_GUI 12,56
 Object Output( Bit OFL) ;  //_GUI 100,36
 Object Output:A( Variant Out1) ;  //_GUI 100,51
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 18,54
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 63,52
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,56
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 51,57
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,51
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 44,56
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 47,59
 Object ( Bit Out1) Sign( Variant In1) ;  //_GUI 34,57
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 88,47
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 62,34
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 37,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 34,48
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 49,30
 Object Text;  //_GUI 43,68,Take the absolute value of the data
 Object Text;  //_GUI 90,56,Shrink or expand the data the data
 Object Text;  //_GUI 30,21,If shrinking, overflow if any of the high bits are asserted, whether value is posative or negative.
 Object Text;  //_GUI 57,41,If growing, OFL if value was negative.
 Object Text;  //_GUI 24,73,Type of     Type of           2 bits      5 bits Data    OFL output  OFL output 0 0000   0  0 00     0  0 00000 1 0001   0  1 01     0  1 00001 2 0010   0  2 10     0  2 00010 3 0011   0  3 11     0  3 00011 4 0100   1  0 00     0  4 00100 5 0101   1  1 01     0  5 00101 6 0110   1  2 10     0  6 00110 7 0111   1  3 11     0  7 00111-8 1000   1  0 00     1  8 01000-7 1001   1  3 11     1  7 00111-6 1010   1  2 10     1  6 00110-5 1011   1  1 01     1  5 00101-4 1100   1  0 00     1  4 00100-3 1101   1  3 11     1  3 00011-2 1110   1  2 10     1  2 00010-1 1111   1  1 01     1  1 00001Courier New,8,0,0

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = UExtnd.1;  
 SignedIn.0 = Input:A.0;  
 ADSU.0 = Zero.0;  
 ADSU.1 = Junction:A.1;  
 ADSU.2 = INVERT.0;  
 ADSU.3 = Junction:B.2;  //_GUI 48,63
 Junction.0 = SignedIn.0;  
 INVERT.0 = Junction:B.1;  
 Zero.0 = Junction:A.0;  //_GUI 45,54
 Junction:A.0 = Junction.1;  
 Junction:B.0 = Sign.0;  
 Sign.0 = Junction.2;  //_GUI 32,60
 UExtnd.0 = Junction:C.1;  
 UExtnd.1 = ADSU.2;  //_GUI 88,60
 OR.0 = OR-NInput.0;  //_GUI 61,36, 61,33
 OR.1 = Junction:B.0;  //_GUI 48,39
 Lo_N.0 = Junction.0;  //_GUI 32,33
 Lo_N.1 = Junction:C.0;  //_GUI 35,36
 Junction:C.0 = Input.0;  
 OR-NInput.0 = Lo_N.0;  
}

Object ( Bit OFL, Fixed Out1) $Convert( Fixed Type
    , Signed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Signed->Fixed"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Type) Input;  //_GUI 5,12
 Object ( Signed Data) Input:A;  //_GUI 5,21
 Object Output( Bit OFL) ;  //_GUI 69,11
 Object Output:A( Fixed Out1) ;  //_GUI 69,15
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 41,15
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 11,19
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 27,10
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 11,10
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 54,13

 //_ Behavior Topology
 Output.0 = TwosExtnd.0;  
 Output:A.0 = CollectFixed.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 24,18
 SignedIn.0 = Input:A.0;  
 TwosExtnd.0 = ExposeFixed.0;  
 TwosExtnd.1 = SignedIn.0;  //_GUI 27,22
 ExposeFixed.0 = Input.0;  
 CollectFixed.0 = TwosExtnd.1;  
 CollectFixed.1 = Zero.0;  
}

Object ( Bit OFL, Variant Out2) $Convert( Variant Type
    , Fixed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Fixed->Unsigned"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 08 Feb 2003
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 9,26
 Object ( Fixed Data) Input:A;  //_GUI 9,43
 Object Output( Bit OFL) ;  //_GUI 135,27
 Object Output:A( Variant Out2) ;  //_GUI 135,34
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 64,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,42
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 52,43
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 35,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 48,45
 Object ( Bit Out1) Sign( Variant In1) ;  //_GUI 35,43
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 63,20
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 38,17
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 50,16
 Object Text;  //_GUI 53,57,Round to positive infinity at .5 then take the absolute value.
 Object Text;  //_GUI 90,39,Shrink or expand the data the data (Lo_N uextends if Lo_N > Data)  (UExtnd's OFL is slower)
 Object Text;  //_GUI 32,6,If shrinking, overflow if any of the high bits are asserted, independent of whether value is posative or negative.
 Object Text;  //_GUI 58,27,If growing, OFL if value was negative.
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 16,41
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 33,52
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 35,26
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 54,49
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 93,30
 Object ( Variant Out1, Variant Out1) ExposeLSB( Variant In1) ;  //_GUI 105,25
 //_ Attributes Documentation="bit"
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 123,25
 Object Text;  //_GUI 102,15,Catch overflow when rounding (only need the next bit to do this)
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In3) ;  //_GUI 31,39
 Object Text;  //_GUI 48,66,With TypeFix16  as 2 bitsData   OFL output 0.0    0    0 1.0    0    1 1.4    0    1 1.5    0    2 1.6    0    2 3.0    0    3 3.4    0    3 3.5    1    0 3.6    1    0-1.0    1    1-1.4    1    1-1.5    1    1-1.6    1    2-3.0    1    3-3.4    1    3-3.5    1    3-3.6    1    0Courier New,8,0,0

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 Output:A.0 = Lo_N:A.1;  
 ADSU.0 = Zero.0;  
 ADSU.1 = Junction.1;  
 ADSU.2 = INVERT.0;  
 ADSU.3 = XOR.0;  
 Junction.0 = ExposeFixed.0;  
 INVERT.0 = Junction:A.1;  
 Zero.0 = Junction:C.2;  
 Junction:A.0 = Sign.0;  
 Sign.0 = Junction.2;  //_GUI 32,46
 OR.0 = OR-NInput.0;  //_GUI 62,22, 62,19
 OR.1 = Junction:A.0;  //_GUI 49,25
 Lo_N.0 = Junction:C.1;  //_GUI 32,19
 Lo_N.1 = Junction:B.0;  //_GUI 36,22
 OR-NInput.0 = Lo_N.0;  
 ExposeFixed.0 = Input:A.0;  
 ExposeMSB.0 = ExposeFixed.1;  //_GUI 30,55, 30,46
 Junction:B.0 = Input.0;  
 XOR.0 = Junction:A.2;  //_GUI 49,51
 XOR.1 = ExposeMSB.0;  
 Lo_N:A.0 = ADSU.2;  //_GUI 85,32, 85,46
 Lo_N:A.1 = Junction:B.2;  //_GUI 36,35
 ExposeLSB.0 = Lo_N:A.0;  //_GUI 104,28, 104,32
 OR:A.0 = OR.0;  //_GUI 123,23
 OR:A.1 = ExposeLSB.1;  
 Junction:C.0 = Junction.0;  
}

Object ( Bit OFL, Signed Out2) $Convert( Signed Type
    , Fixed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Fixed->Signed"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Type) Input;  //_GUI 13,16
 Object ( Fixed Data) Input:A;  //_GUI 13,27
 Object Output( Bit OFL) ;  //_GUI 136,17
 Object Output:A( Signed Out2) ;  //_GUI 136,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,19
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 63,20
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 122,15
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 25,14
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 121,23
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 44,15
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 25,25
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 43,27
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 110,17
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit IsNeg) Sign( Variant In1) ;  //_GUI 98,19
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 95,25
 Object ( Bit IsNeg) Sign:A( Variant In1) ;  //_GUI 44,7
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In3) ;  //_GUI 39,19
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 75,18

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = SignedOut.0;  
 Junction.0 = TwosExtnd.1;  
 Zero.0 = Junction.2;  //_GUI 61,23
 OR.0 = TwosExtnd.0;  
 OR.1 = XOR.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = Junction:A.1;  
 TwosExtnd.0 = SignedIn.0;  
 TwosExtnd.1 = Junction:B.2;  
 ExposeFixed.0 = Input:A.0;  
 ExposeMSB.0 = ExposeFixed.1;  
 XOR.0 = Sign:A.0;  //_GUI 110,10
 XOR.1 = Sign.0;  
 Sign.0 = Junction:A.0;  //_GUI 96,22
 Junction:A.0 = ADSU.2;  
 Sign:A.0 = Junction:B.1;  //_GUI 40,10
 Junction:B.0 = ExposeFixed.0;  //_GUI 40,27
 ADSU.0 = Junction.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = ExposeMSB.0;  
}

Object ( Bit OFL, Floating Out1) $Convert( Floating Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Unsigned->Floating"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 34,37
 Object ( Variant Data) Input:A;  //_GUI 34,40
 Object Output( Bit OFL) ;  //_GUI 79,37
 Object Output:A( Floating Out1) ;  //_GUI 79,40
 Object ( Bit OFL, Floating Out1) UnsignedToFloating( Floating Floating
    , Variant Unsigned) ;  //_GUI 46,36

 //_ Behavior Topology
 Output.0 = UnsignedToFloating.0;  
 Output:A.0 = UnsignedToFloating.1;  
 UnsignedToFloating.0 = Input.0;  
 UnsignedToFloating.1 = Input:A.0;  
}

Object ( Bit OFL, Floating O) $Convert( Floating Type
    , Signed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Signed->Floating"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 47,25
 Object ( Signed Data) Input:A;  //_GUI 25,46
 Object Output( Bit OFL) ;  //_GUI 129,18
 Object Output:A( Floating O) ;  //_GUI 166,28
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 31,44
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 117,16
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 114,26
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 145,26
 Object ( Bit OFL, Floating Out1) UnsignedToFloating( Floating Floating
    , Variant Unsigned) ;  //_GUI 84,24
 Object ( Variant OFL, Variant Sign, Variant Unsigned) FromTwos
    ( Variant TwosComp) ;  //_GUI 48,44

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = CollectFloating.0;  
 SignedIn.0 = Input:A.0;  
 OR.0 = FromTwos.0;  //_GUI 68,18
 OR.1 = UnsignedToFloating.0;  //_GUI 117,26
 ExposeFloating.0 = UnsignedToFloating.1;  
 CollectFloating.0 = FromTwos.1;  //_GUI 139,28, 139,49
 CollectFloating.1 = ExposeFloating.1;  
 CollectFloating.2 = ExposeFloating.2;  
 UnsignedToFloating.0 = Input.0;  
 UnsignedToFloating.1 = FromTwos.2;  //_GUI 80,29, 80,52
 FromTwos.0 = SignedIn.0;  
}

Object ( Bit OFL, Floating O) $Convert( Floating Type
    , Fixed Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Fixed->Floating"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 56,26
 Object ( Fixed Data) Input:A;  //_GUI 18,46
 Object Output( Bit OFL) ;  //_GUI 222,17
 Object Output:A( Floating O) ;  //_GUI 213,29
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 112,11
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 33,44
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 49,44
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 26,34
 Object ( Fixed Out1, Fixed Out2, Fixed Out3) Junction
    ( Fixed In0) ;  //_GUI 25,46
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 191,27
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 117,27
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 65,36
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 201,15
 Object ( Bit Sub) Input:B;  //_GUI 162,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CI) Input:C;  //_GUI 162,28
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 188,17
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 166,18
 Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) ;  //_GUI 144,18
 Object ( Bit OFL, Floating Out1) UnsignedToFloating( Floating Floating
    , Variant Unsigned) ;  //_GUI 89,25
 Object ( Variant OFL, Variant Sign, Variant Unsigned) FromTwos
    ( Variant TwosComp) ;  //_GUI 62,44

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 Output:A.0 = CollectFloating.0;  
 OR.0 = FromTwos.0;  //_GUI 84,13, 84,46
 OR.1 = UnsignedToFloating.0;  //_GUI 112,27
 FixedIn.0 = Junction.1;  
 LSB.0 = FixedIn.0;  
 ExposeFixed.0 = Junction.0;  
 Junction.0 = Input:A.0;  
 CollectFloating.0 = FromTwos.1;  //_GUI 187,29, 187,49
 CollectFloating.1 = ADSU.2;  //_GUI 184,32
 CollectFloating.2 = ExposeFloating.2;  
 ExposeFloating.0 = UnsignedToFloating.1;  
 BitLength.0 = ExposeFixed.1;  
 OR:A.0 = OR.0;  //_GUI 201,14
 OR:A.1 = INVERT.0;  
 INVERT.0 = ADSU.0;  
 ADSU.0 = SymmetrizeNW.0;  
 ADSU.1 = SymmetrizeNW.1;  
 ADSU.2 = Input:B.0;  
 ADSU.3 = Input:C.0;  
 SymmetrizeNW.0 = ExposeFloating.1;  //_GUI 141,20, 141,32
 SymmetrizeNW.1 = BitLength.0;  //_GUI 76,23
 UnsignedToFloating.0 = Input.0;  
 UnsignedToFloating.1 = FromTwos.2;  //_GUI 89,52
 FromTwos.0 = LSB.0;  
}

Object ( Bit OFL, Variant Out1) $Convert( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="var"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 47,45
 Object ( Variant Data) Input:A;  //_GUI 47,48
 Object Output( Bit OFL) ;  //_GUI 110,45
 Object Output:A( Variant Out1) ;  //_GUI 110,48
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 72,44
 Object ( Bit Error) StaticError( Variant Type) ;  //_GUI 61,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,48
 Object Output:B( Bit Trap) ;  //_GUI 80,59
 //_ Attributes Trap="Convert operators are only overloaded for dynamic datasets."
 Object ( Bit Error) StaticError:A( Variant Type) ;  //_GUI 59,36
 Object Output:C( Bit Trap) ;  //_GUI 78,38
 //_ Attributes Trap="Convert operators are only overloaded for dynamic datasets."
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 58,45

 //_ Behavior Topology
 Output.0 = UExtnd.0;  
 Output:A.0 = UExtnd.1;  
 UExtnd.0 = Junction:A.1;  
 UExtnd.1 = Junction.1;  
 StaticError.0 = Junction.2;  
 Junction.0 = Input:A.0;  
 Output:B.0 = StaticError.0;  
 StaticError:A.0 = Junction:A.0;  
 Output:C.0 = StaticError:A.0;  
 Junction:A.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) $Convert( Variant Type
    , Floating Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Floating->x"
{
 // added Dec 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 34,37
 Object ( Floating Data) Input:A;  //_GUI 34,40
 Object Output( Bit OFL) ;  //_GUI 79,30
 Object Output:A( Variant Out1) ;  //_GUI 78,38
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 48,36
 Object ( Bit In) Input:B;  //_GUI 59,30
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 71,30
 Object Output:B( Bit Trap) ;  //_GUI 82,23
 //_ Attributes Trap="Error: From-Floating conversions are implemented synchronously only."

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Context.0;  
 Context.0 = Input.0;  
 Context.1 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Output:B.0 = Junction.0;  //_GUI 72,24
}

Object ( Bit OFL, Complex Out1) $Convert( Complex Type
    , Complex Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal\\Converters",Documentation="Complex"
{
 // Convert - Variant Select Case
 //
 // Date:
 // 10 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex Type) Input;  //_GUI 13,24
 Object ( Complex Data) Input:A;  //_GUI 13,34
 Object Output( Bit OFL) ;  //_GUI 72,24
 Object Output:A( Complex Out1) ;  //_GUI 72,38
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 19,22
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 54,36
 Object ( Variant Real, Variant Imag) ExposeComplex:A( Complex In1) ;  //_GUI 19,32
 Object ( Bit OFL, Variant Out1) $Convert( Variant Type
    , Variant Data) ;  //_GUI 41,22
 //_ Attributes Documentation="Signed"
 Object ( Bit OFL, Variant Out1) $Convert:A( Variant Type
    , Variant Data) ;  //_GUI 38,36
 //_ Attributes Documentation="Signed"
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 60,22

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = CollectComplex.0;  
 ExposeComplex.0 = Input.0;  
 CollectComplex.0 = $Convert.1;  //_GUI 54,27
 CollectComplex.1 = $Convert:A.1;  
 ExposeComplex:A.0 = Input:A.0;  
 $Convert.0 = ExposeComplex.0;  
 $Convert.1 = ExposeComplex:A.0;  //_GUI 41,34
 $Convert:A.0 = ExposeComplex.1;  //_GUI 38,27
 $Convert:A.1 = ExposeComplex:A.1;  //_GUI 35,41
 OR.0 = $Convert.0;  
 OR.1 = $Convert:A.0;  //_GUI 60,33, 49,33
}

Object ( List OFL, List Out1) ConvertList( List Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="List/List"
{
 // Converts elements in a List to the Type input.  If The Data input is a List and the Type is some known type other than List, every element in the Data List will be converted to the known type.  If the type input is also a List, however, this object will decompose the Type and Data Lists in parallel until a non-List type is reached on the Type input.  The remaining elements in the Data List will then each be converted to this Type.  The number of elements in the Data List must be >= number of elements in the Type List and must be shape-compatible or undefined behavior will result.  The only significant difference between ConvertList and Convert is ConvertList has a list of bits for OFL that match the list shape of the input Data.  Convert always has a bit OFL even with List datasets for Data.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Var/List Type: The destination dataset(s) for the conversion.
 //
 // Var/List Data: The value(s) to be converted.
 //
 // Outputs:
 //
 // Bit/List OFL: Indicates that there was an overflow in the conversion (shrinking) of the dataset.  One OFL bit per Data list element.
 //
 // Var/List output: The results of Data being converted to Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 31,13
 Object ( List Data) Input:A;  //_GUI 31,26
 Object Output( List OFL) ;  //_GUI 109,9
 Object Output:A( List Out1) ;  //_GUI 109,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 92,16
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 43,11
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 43,24
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 92,7
 Object ( Variant OFL, Variant Out1) ConvertList( Variant Type
    , Variant Data) ;  //_GUI 71,13
 //_ Attributes Documentation="List/List"
 Object ( Variant OFL, Variant Out1) ConvertList:A( Variant Type
    , Variant Data) ;  //_GUI 73,24
 //_ Attributes Documentation="List/List"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListOut.0 = ConvertList:A.1;  //_GUI 92,29
 ListOut.1 = ConvertList.1;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 ListOut:A.0 = ConvertList:A.0;  //_GUI 90,12, 90,26
 ListOut:A.1 = ConvertList.0;  //_GUI 83,9
 ConvertList.0 = ListIn.1;  //_GUI 69,15, 69,13
 ConvertList.1 = ListIn:A.1;  //_GUI 62,18, 62,26
 ConvertList:A.0 = ListIn.0;  //_GUI 65,26, 65,16
 ConvertList:A.1 = ListIn:A.0;  
}

Object ( List OFL, List Out1) ConvertList( Variant Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="var/List"
{
 // Converts elements in a List to the Type input.  If The Data input is a List and the Type is some known type other than List, every element in the Data List will be converted to the known type.  If the type input is also a List, however, this object will decompose the Type and Data Lists in parallel until a non-List type is reached on the Type input.  The remaining elements in the Data List will then each be converted to this Type.  The number of elements in the Data List must be >= number of elements in the Type List and must be shape-compatible or undefined behavior will result.  The only significant difference between ConvertList and Convert is ConvertList has a list of bits for OFL that match the list shape of the input Data.  Convert always has a bit OFL even with List datasets for Data.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Var/List Type: The destination dataset(s) for the conversion.
 //
 // Var/List Data: The value(s) to be converted.
 //
 // Outputs:
 //
 // Bit/List OFL: Indicates that there was an overflow in the conversion (shrinking) of the dataset.  One OFL bit per Data list element.
 //
 // Var/List output: The results of Data being converted to Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 16,19
 Object ( List Data) Input:A;  //_GUI 16,23
 Object Output( List OFL) ;  //_GUI 90,13
 Object Output:A( List Out1) ;  //_GUI 85,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 37,19
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 22,21
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 70,21
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 73,11
 Object ( Variant OFL, Variant Out1) ConvertList( Variant Type
    , Variant Data) ;  //_GUI 42,18
 //_ Attributes Documentation="List/List"
 Object ( Variant OFL, Variant Out1) ConvertList:A( Variant Type
    , Variant Data) ;  //_GUI 41,33
 //_ Attributes Documentation="List/List"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = ConvertList:A.1;  //_GUI 64,26, 64,38
 ListOut.1 = ConvertList.1;  
 ListOut:A.0 = ConvertList:A.0;  //_GUI 57,16, 57,35
 ListOut:A.1 = ConvertList.0;  //_GUI 54,13
 ConvertList.0 = Junction.1;  
 ConvertList.1 = ListIn.1;  
 ConvertList:A.0 = Junction.2;  //_GUI 38,35
 ConvertList:A.1 = ListIn.0;  //_GUI 33,38
}

Object ( Bit OFL, Variant Out1) ConvertList( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced"
{
 // Converts elements in a List to the Type input.  If The Data input is a List and the Type is some known type other than List, every element in the Data List will be converted to the known type.  If the type input is also a List, however, this object will decompose the Type and Data Lists in parallel until a non-List type is reached on the Type input.  The remaining elements in the Data List will then each be converted to this Type.  The number of elements in the Data List must be >= number of elements in the Type List and must be shape-compatible or undefined behavior will result.  The only significant difference between ConvertList and Convert is ConvertList has a list of bits for OFL that match the list shape of the input Data.  Convert always has a bit OFL even with List datasets for Data.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Var/List Type: The destination dataset(s) for the conversion.
 //
 // Var/List Data: The value(s) to be converted.
 //
 // Outputs:
 //
 // Bit/List OFL: Indicates that there was an overflow in the conversion (shrinking) of the dataset.  One OFL bit per Data list element.
 //
 // Var/List output: The results of Data being converted to Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 17,11
 Object ( Variant Data) Input:A;  //_GUI 17,14
 Object Output( Bit OFL) ;  //_GUI 69,11
 Object Output:A( Variant Out1) ;  //_GUI 76,14
 Object ( Bit OFL, Variant Out1) $Convert( Variant Type
    , Variant Data) ;  //_GUI 36,10
 //_ Attributes Documentation="Signed"

 //_ Behavior Topology
 Output.0 = $Convert.0;  
 Output:A.0 = $Convert.1;  
 $Convert.0 = Input.0;  
 $Convert.1 = Input:A.0;  
}

Object ( Variant Out1) Int2Gray( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\Async\\Advanced"
{
 // Converts from an integer to Gray code.  Gray codes are useful when transferring an incrementing or decrementing value from one time domain to another because only a single bit changes at a time.  There are multiple Gray code sequences.  This implements the most common sequence.
 //
 // Inputs:
 //
 // Variant input: The integer value to be converted.
 //
 // Outputs:
 //
 // Variant output: The resulting Gray code value.
 //
 // Example:
 //
 // Integer	Gray
 // 0000	0000
 // 0001	0001
 // 0010	0011
 // 0011	0010
 // 0100	0110
 // 0101	0111
 // 0110	0101
 // 0111	0100
 // 1000	1100
 // 1001	1101
 // 1010	1111
 // 1011	1110
 // 1100	1010
 // 1101	1011
 // 1110	1001
 // 1111	1000
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 7,16
 Object Output( Variant Out1) ;  //_GUI 89,12
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 31,14
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 63,12
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 15,14
 Object ( Variant Out1) $Int2Gray( Bit In1, Variant In2) ;  //_GUI 49,14
 //_ Attributes Documentation="bit/bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,15
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 77,10
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 27,16

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $Int2Gray.0;  
 VariantOut.1 = Junction.0;  //_GUI 63,12, 46,12
 MSB.0 = Input.0;  
 $Int2Gray.0 = Junction.1;  
 $Int2Gray.1 = VariantIn.0;  
 Junction.0 = VariantIn.1;  
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction:A.0;  //_GUI 77,9, 28,9
 Junction:A.0 = MSB.0;  
}

Object ( Bit Out1) Int2Gray( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="Bit"
{
 // Description:
 // Use Gray2Int and Int2Gray for going between registers in different time domains.
 //
 // Inputs:
 // In1:  data
 //
 // Out1:  gray data
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 9,25
 Object Output( Bit Out1) ;  //_GUI 96,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) Gray2Int( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 17,23
 Object Output( Bit Out1) ;  //_GUI 28,23

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) Gray2Int( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\Async\\Advanced"
{
 // Converts from Gray code to an integer.  Gray codes are useful when transferring an incrementing or decrementing value from one time domain to another because only a single bit changes at a time.  There are multiple Gray code sequences.  This implements the most common sequence.
 //
 // Inputs:
 //
 // Variant input: The Gray code value to be converted.
 //
 // Outputs:
 //
 // Variant output: The resulting integer value.
 //
 // Example:
 //
 // Integer	Gray
 // 0000	0000
 // 0001	0001
 // 0010	0011
 // 0011	0010
 // 0100	0110
 // 0101	0111
 // 0110	0101
 // 0111	0100
 // 1000	1100
 // 1001	1101
 // 1010	1111
 // 1011	1110
 // 1100	1010
 // 1101	1011
 // 1110	1001
 // 1111	1000
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 6,41
 Object Output( Variant Out1) ;  //_GUI 73,42
 Object Text;  //_GUI 4,8,Here is the algorithm for Gray code to Integer:n=Gray;sh=1;while(n>>sh){      n^=(n>>sh);      sh<<=1;}return (n);
 Object Text;  //_GUI 10,55,Find the smallest power-of-two number of bits that could hold the incoming data.  The data type is BIN.
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 30,43
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 44,43
 Object Text;  //_GUI 40,55,Now split it in half and this will be our shift amount.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 12,41
 Object ( Variant Nout) $Gray2Int( Variant Nin, Variant Shift) ;  //_GUI 58,40
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) "Pad2^N"( Variant In1) ;  //_GUI 17,43

 //_ Behavior Topology
 Output.0 = $Gray2Int.0;  
 Zero.0 = "Pad2^N".0;  
 VariantIn.0 = Zero.0;  
 Junction.0 = Input.0;  
 $Gray2Int.0 = Junction.1;  
 $Gray2Int.1 = VariantIn.1;  
 "Pad2^N".0 = Junction.2;  //_GUI 13,46
}

Object ( Variant Q) RegInitPre( Variant D, Variant InitVal
    , Bit ClkG, Bit EN, Bit Preset) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers"
{
 // Register with option to preload/preset initial value.
 //
 // Inputs:
 // D - Data - loaded on positive clock edge when En is high (and Preset is low)
 //
 // InitVal (Var)- Initial Value (pre-loaded) - loaded asynchronously when Preset is high, regardless of state of En.  Dataset must be the same as D.
 //
 // En - If Preset not high, cause D to be loaded into register on positive clock edge.  If disconnected, defaults to 1.
 //
 // Preset (Bit) - will cause InitVal to be loaded into register on positive clock edge.  If disconnected, defaults to 0.
 //
 // Outputs:
 // Q - current contents of register
 //
 // Date:
 // 11/09/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 41,17
 Object ( Variant InitVal) Input:A;  //_GUI 41,20
 Object ( Bit ClkG) Input:B;  //_GUI 41,24
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:C;  //_GUI 41,27
 //_ Attributes Constant="1"
 Object ( Bit Preset) Input:D;  //_GUI 41,30
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 105,23
 Object Text;  //_GUI 39,46,Upon initialization or Preset the Q output goes to InitVal.  When init val is a constant, the XOR turns into passthrough or inverts which don't take any resources.
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 72,20
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 50,16
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 92,21
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 46,20

 //_ Behavior Topology
 Output.0 = XOR:A.0;  
 RegClr.0 = XOR.0;  //_GUI 63,22, 63,19
 RegClr.1 = Input:B.0;  
 RegClr.2 = Input:C.0;  
 RegClr.3 = Input:D.0;  
 XOR.0 = Input.0;  
 XOR.1 = Junction.1;  
 XOR:A.0 = RegClr.0;  
 XOR:A.1 = Junction.2;  //_GUI 89,26, 89,39, 47,39
 Junction.0 = Input:A.0;  
}

Object ( Variant OutA, Variant OutB) RAMDP( Variant InA
    , Variant AddrA, Variant AddrB, Bit ClkG, Bit ClkG
    , Bit WE, Bit REB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\$Internal",Icon="RAMDP2",Documentation="2 clk",REB
{
 // RAMDP is a dual-port RAM object. It is capable of reading from memory and writing to memory during the same clock cycle.
 //
 // Inputs:
 // InA - The data to be written into memory.
 // AddrA - The memory address to read or write.
 // AddrB - The memory address to read from.
 // ClkG(top) - Port A clock  Defaulted to the system clock.
 // ClkG(bottom) - Port B clock.  Defaulted to the system clock.
 // WE - Write Enable tells the memory to write the data InA to the address specified by AddA. When WE is deasserted, the object will read from the address specified and output data to OutA.
 // REB - Read Enable Port B.  This allows port B read data to be strobed.
 //
 // Outputs:
 // OutA: Outputs the data at address AddrA.
 // OutB: Outputs the data at address AddrB.
 //
 // Modified:
 // 12/07/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant InA) Input;  //_GUI 11,12
 Object ( Variant AddrA) Input:A;  //_GUI 11,20
 Object ( Variant AddrB) Input:B;  //_GUI 11,28
 Object ( Bit ClkG) Input:C;  //_GUI 11,32
 //_ Attributes Resource="Global"
 Object ( Bit ClkG) Input:D;  //_GUI 11,35
 //_ Attributes Resource="Global"
 Object ( Bit WE) Input:E;  //_GUI 11,38
 Object ( Bit REB) Input:F;  //_GUI 11,47
 Object Output( Variant OutA) ;  //_GUI 90,12
 Object Output:A( Variant OutB) ;  //_GUI 90,21
 Object Text;  //_GUI 12,64,Top ClkG is for PortA clock and bottom ClkG is for PortB clock, either of which can be overloaded with different clocks.
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 21,18
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 21,10
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 77,19
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 17,12
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 77,10
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 43,21
 Object Text;  //_GUI 50,51,In the DP BRAM case the second port is not written to in order to avoid data collision (simulataneous write to port A and B of the same address).  Therefore, zero signal WEB.
 Object Text;  //_GUI 40,10,Manual says to set all unused bits to one.  We only write to Port A.
 Object ( Bit In) Input:G;  //_GUI 50,41
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant Out1) MSB:B( Variant In1) ;  //_GUI 21,26
 Object Text;  //_GUI 12,51,Read Enable port B for enable reading at a specified address time.  Used in FIFO_Basic
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In1) ;  //_GUI 37,18
 Object ( Variant OutA, Variant OutB) $RAMBDP( Variant InA
    , Variant InB, Variant AddrA, Variant AddrB, Bit ClkG
    , Bit ClkG, Bit WEA, Bit ENA, Bit WEB
    , Bit ENB) ;  //_GUI 56,19
 //_ Attributes Documentation="Var/MSB009"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 73,11
 Object ( Bit In) Input:H;  //_GUI 50,44
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Context:A.0;  
 Output:A.0 = Context.0;  
 MSB.0 = Input:A.0;  
 MSB:A.0 = Junction.1;  
 Context.0 = Junction:B.2;  //_GUI 74,21
 Context.1 = $RAMBDP.1;  
 Junction.0 = Input.0;  
 Context:A.0 = Junction:B.1;  
 Context:A.1 = $RAMBDP.0;  //_GUI 71,15, 71,21
 AllOnes.0 = Junction:A.2;  //_GUI 38,24
 MSB:B.0 = Input:B.0;  
 Junction:A.0 = MSB:A.0;  //_GUI 38,13
 $RAMBDP.0 = Junction:A.1;  //_GUI 54,21, 54,19
 $RAMBDP.1 = AllOnes.0;  
 $RAMBDP.2 = MSB.0;  //_GUI 35,27, 35,21
 $RAMBDP.3 = MSB:B.0;  //_GUI 33,30, 33,29
 $RAMBDP.4 = Input:C.0;  
 $RAMBDP.5 = Input:D.0;  
 $RAMBDP.6 = Input:E.0;  
 $RAMBDP.7 = Input:G.0;  
 $RAMBDP.8 = Input:H.0;  
 $RAMBDP.9 = Input:F.0;  
 Junction:B.0 = Junction.0;  //_GUI 74,8, 18,8
}

Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, List Busy) SyncQueuePass( List Data, Bit ClkG
    , Bit AClr, List Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Synchronizers\\Advanced",Documentation="List/List"
{
 // This object is the same as SyncQueue except in the case where there is a single Go.  In this case no queue is built and the object becomes a pass through.
 //
 // A data synchronizer for joining two or more data flow paths.  The object creates queues for each synchronized data path input.
 //
 // Inputs:
 //
 // Variant Data: Single data path or list of data paths to synchronize.
 //
 // Bit ClkG: The global user clock if disconnected or a specific clock if connected.
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected.
 //
 // Variant Go: Go of GDBW.  Bit if single unsynchronized data path or a list of Gos, one for each data path to synchronize.
 //
 // Bit Wait: Wait of GDBW.  Defaults to 0 if disconnected.  Tells Done to hold off.
 //
 // Outputs:
 //
 // Variant Data: The single queued data or a list of the synchronized queued data.
 //
 // Bit ClkG: Clock input pass through
 //
 // Bit AClr: Clear input pass through
 //
 // Bit Done: Done of GDBW.  Data valid while high.
 //
 // Variant Busy: Busy of GDBW.  Tells Go (or each individual Go, if a List) to hold off.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Data) Input;  //_GUI 13,36
 Object ( Bit ClkG) Input:A;  //_GUI 13,39
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 13,42
 //_ Attributes Constant="0"
 Object ( List Go) Input:C;  //_GUI 13,45
 Object ( Bit Wait) Input:D;  //_GUI 58,52
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 59,36
 Object Output:A( Bit ClkG) ;  //_GUI 59,39
 Object Output:B( Bit AClr) ;  //_GUI 59,42
 Object Output:C( Bit Done) ;  //_GUI 59,45
 Object Output:D( List Busy) ;  //_GUI 54,58
 Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, Variant Busy) SyncQueue( Variant Data, Bit ClkG
    , Bit AClr, Variant Go, Bit Wait) ;  //_GUI 29,35
 //_ Attributes Documentation="Var/Bit"
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 22,45
 Object ( List Out) $Cast( Variant Data, List Type) ;  //_GUI 40,56
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 28,58
 Object ( List Out1, List Out2, List Out3) Junction:A
    ( List In1) ;  //_GUI 22,54

 //_ Behavior Topology
 Output.0 = SyncQueue.0;  
 Output:A.0 = SyncQueue.1;  
 Output:B.0 = SyncQueue.2;  
 Output:C.0 = SyncQueue.3;  
 Output:D.0 = $Cast.0;  
 SyncQueue.0 = Input.0;  
 SyncQueue.1 = Input:A.0;  
 SyncQueue.2 = Input:B.0;  
 SyncQueue.3 = Junction.1;  
 SyncQueue.4 = Input:D.0;  //_GUI 64,49, 64,53
 Junction.0 = Input:C.0;  
 $Cast.0 = Cast.0;  
 $Cast.1 = Junction:A.1;  //_GUI 40,55
 Cast.0 = Junction:A.2;  //_GUI 23,60
 Cast.1 = SyncQueue.4;  //_GUI 20,63, 20,49
 Junction:A.0 = Junction.2;  
}

Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) SyncQueuePass( Variant Data, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Synchronizers\\Advanced",Documentation="Var/Bit"
{
 // This object is the same as SyncQueue except in the case where there is a single Go.  In this case no queue is built and the object becomes a pass through.
 //
 // A data synchronizer for joining two or more data flow paths.  The object creates queues for each synchronized data path input. If there is a single Go, a queue will still be built.  To not build a queue in that case, use SyncQueuePass.
 //
 // Inputs:
 //
 // Variant Data: Single data path or list of data paths to synchronize.
 //
 // Bit ClkG: The global user clock if disconnected or a specific clock if connected.
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected.
 //
 // Variant Go: Go of GDBW.  Bit if single unsynchronized data path or a list of Gos, one for each data path to synchronize.
 //
 // Bit Wait: Wait of GDBW.  Defaults to 0 if disconnected.  Tells Done to hold off.
 //
 // Outputs:
 //
 // Variant Data: The single queued data or a list of the synchronized queued data.
 //
 // Bit ClkG: Clock input pass through
 //
 // Bit AClr: Clear input pass through
 //
 // Bit Done: Done of GDBW.  Data valid while high.
 //
 // Variant Busy: Busy of GDBW.  Tells Go (or each individual Go, if a List) to hold off.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 9,18
 Object ( Bit ClkG) Input:A;  //_GUI 9,23
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 9,27
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 9,32
 Object ( Bit Wait) Input:D;  //_GUI 31,40
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 32,18
 Object Output:A( Bit ClkG) ;  //_GUI 32,23
 Object Output:B( Bit AClr) ;  //_GUI 32,27
 Object Output:C( Bit Done) ;  //_GUI 32,32
 Object Output:D( Bit Busy) ;  //_GUI 10,40
 Object Text;  //_GUI 10,8,In the single Go case we are just a pass through.

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Input:B.0;  
 Output:C.0 = Input:C.0;  
 Output:D.0 = Input:D.0;  //_GUI 5,41, 5,37, 40,37, 40,41
}

Object ( Variant B, Variant Add, Variant CI) $AddSubPrepBOut
    ( Variant In1, NULL Around) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="Passthrough"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 35,22
 Object ( NULL Around) Input:A;  //_GUI 35,33
 Object Output( Variant B) ;  //_GUI 56,21
 Object Output:A( Variant Add) ;  //_GUI 56,24
 Object Output:B( Variant CI) ;  //_GUI 56,27
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 41,20

 //_ Behavior Topology
 Output.0 = UnPackLSB.0;  
 Output:A.0 = UnPackLSB.1;  
 Output:B.0 = UnPackLSB.2;  
 UnPackLSB.0 = Input.0;  
}

Object ( Variant B, Variant Add, Variant CI) $AddSubPrepBOut
    ( Variant In1, Variant Around) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="Transpose"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 16,22
 Object ( Variant Around) Input:A;  //_GUI 16,25
 Object Output( Variant B) ;  //_GUI 54,21
 Object Output:A( Variant Add) ;  //_GUI 54,24
 Object Output:B( Variant CI) ;  //_GUI 54,27
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 39,20
 Object ( Variant Out1, Variant Around) Transpose( Variant In1
    , Variant Around) ;  //_GUI 22,21

 //_ Behavior Topology
 Output.0 = UnPackLSB.0;  
 Output:A.0 = UnPackLSB.1;  
 Output:B.0 = UnPackLSB.2;  
 UnPackLSB.0 = Transpose.0;  
 Transpose.0 = Input.0;  
 Transpose.1 = Input:A.0;  
}

Object ( List Out1, NULL Around) $AddSubPrepBIn( Variant B
    , Bit Add, Bit CI, Bit GoIn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="var/bit/bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant B) Input;  //_GUI 26,27
 Object ( Bit Add) Input:A;  //_GUI 26,30
 Object ( Bit CI) Input:B;  //_GUI 26,33
 Object ( Bit GoIn) Input:C;  //_GUI 26,38
 Object Output( List Out1) ;  //_GUI 75,28
 Object Output:A( NULL Around) ;  //_GUI 75,34
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 45,26
 Object ( NULL Out1) NULL;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = PackLSB.0;  
 Output:A.0 = NULL.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
}

Object ( Variant Out1, Variant Around) $AddSubPrepBIn( List B
    , List Add, List CI, List GoIn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="list/list/list/list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List B) Input;  //_GUI 26,27
 Object ( List Add) Input:A;  //_GUI 26,30
 Object ( List CI) Input:B;  //_GUI 26,33
 Object ( List GoIn) Input:C;  //_GUI 26,55
 Object Output( Variant Out1) ;  //_GUI 81,28
 Object Output:A( Variant Around) ;  //_GUI 81,31
 Object ( Bit Out1) SameListStruct( Variant In1, Variant In2) ;  //_GUI 51,43
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 32,33
 Object ( List Out1, List Out2, List Out3) Junction:A
    ( List In0) ;  //_GUI 35,30
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 68,43
 Object ( Variant Out1, Variant Around) Transpose( Variant In1
    , Variant Around) ;  //_GUI 63,27
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 45,26
 Object ( List Out1, List Out2, List Out3) Junction:B
    ( List In1) ;  //_GUI 35,37
 Object Text;  //_GUI 27,14,We must transpose this 2D list so that a single Go will associate with a single B, Add and CI.
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 32,53
 Object ( Bit Out1) SameListStruct:A( Variant In1, Variant In2) ;  //_GUI 51,53
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 68,53
 Object Output:B( Bit Trap) ;  //_GUI 83,45
 //_ Attributes Trap="ERROR: Inputs Add and CI must have the same list structures.  Behavior is undefined."
 Object ( List Out1, List Out2, List Out3) Junction:C
    ( List In0) ;  //_GUI 46,47
 Object Text;  //_GUI 29,64,Get B's Go.
 Object ( Bit Out1) IsList( Variant In1) ;  //_GUI 51,62
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 46,57
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 82,54
 Object Output:C( Bit Trap) ;  //_GUI 94,56
 //_ Attributes Trap="ERROR: Since B's Go is a list structure",inputs Add and CI must have the same list structure as B's Go.  Behavior is undefined.
 Object Text;  //_GUI 50,72,If B's Go is a list then Add and CI's list must be the same structure.

 //_ Behavior Topology
 Output.0 = Transpose.0;  
 Output:A.0 = Transpose.1;  
 SameListStruct.0 = Junction:B.2;  //_GUI 36,45
 SameListStruct.1 = Junction:C.1;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:A.0;  
 INVERT.0 = SameListStruct.0;  
 Transpose.0 = PackLSB.0;  
 Transpose.1 = Junction:B.1;  //_GUI 63,38
 PackLSB.0 = Input.0;  
 PackLSB.1 = Junction:A.1;  
 PackLSB.2 = Junction.1;  
 Junction:B.0 = Junction:A.2;  
 ListIn.0 = Input:C.0;  
 SameListStruct:A.0 = Junction:C.2;  //_GUI 47,55
 SameListStruct:A.1 = Junction:D.1;  
 INVERT:A.0 = SameListStruct:A.0;  
 Output:B.0 = INVERT.0;  
 Junction:C.0 = Junction.2;  //_GUI 33,48
 IsList.0 = Junction:D.2;  //_GUI 47,65
 Junction:D.0 = ListIn.0;  
 AND.0 = INVERT:A.0;  
 AND.1 = IsList.0;  //_GUI 82,65
 Output:C.0 = AND.0;  
}

Object ( Variant Out1, Variant Around) $AddSubPrepBIn( Variant B
    , Bit Add, Bit CI, List GoIn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="var/bit/bit/list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant B) Input;  //_GUI 23,15
 Object ( Bit Add) Input:A;  //_GUI 23,25
 Object ( Bit CI) Input:B;  //_GUI 23,38
 Object ( List GoIn) Input:C;  //_GUI 23,64
 Object Output( Variant Out1) ;  //_GUI 201,17
 Object Output:A( Variant Around) ;  //_GUI 201,39
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 165,14
 Object ( NULL Out1) NULL;  //_GUI 168,28
 Object ( Variant Out1, Variant Around) $AddSubPrepBIn( Variant B
    , Variant Add, Variant CI, Variant GoIn) ;  //_GUI 161,37
 //_ Attributes Documentation="Passthrough"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 29,62
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 62,37
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant In1
    , Bit S) ;  //_GUI 62,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 58,41
 Object ( Bit Out1) IsList( Variant In1) ;  //_GUI 46,64
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 58,66
 Object ( Bit Out1) IsBit( Variant Type) ;  //_GUI 46,73
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 42,66
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 62,71
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 74,71
 Object Output:B( Bit Trap) ;  //_GUI 86,73
 //_ Attributes Trap="ERROR: Go must be a List or  Bit"
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 115,40
 Object ( Variant DataList) ListFill:A( Variant Data, Variant List) ;  //_GUI 115,27
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 189,15
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant In1
    , Bit S) ;  //_GUI 62,14
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 58,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In3) ;  //_GUI 110,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 110,49
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 189,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 184,44
 Object ( Bit Out1) MustBeConst( Bit In1) ;  //_GUI 89,39
 Object ( Bit Out1) MustBeConst:A( Bit In1) ;  //_GUI 89,26
 Object Text;  //_GUI 81,52,If B's Go is a list then Add and CI must be a list unless Add and CI are bit constants.
 Object Text;  //_GUI 113,51,If B's Go is a list and Add and CI are bit constants then create an equivelent list struct of const bits for Add and CI.
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 148,45
 Object ( Bit In) Input:D;  //_GUI 142,46
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 141,54,Reconstruct the Go.  GoA is unused, so can be anything.
 Object Text;  //_GUI 162,52,Recurse so can transpose the 2D array.
 Object Text;  //_GUI 147,7,B's Go is a bit so don't need to do anything, just collect and pass through.

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 PackLSB.0 = $SelectOut:B.0;  
 PackLSB.1 = $SelectOut:A.0;  //_GUI 78,19, 78,26
 PackLSB.2 = $SelectOut.0;  //_GUI 81,22, 81,39
 $AddSubPrepBIn.0 = $SelectOut:B.1;  //_GUI 161,24, 74,24
 $AddSubPrepBIn.1 = ListFill:A.0;  //_GUI 133,42, 133,30
 $AddSubPrepBIn.2 = ListFill.0;  //_GUI 130,45, 130,43
 $AddSubPrepBIn.3 = ListOut.0;  
 ListIn.0 = Input:C.0;  
 $SelectOut.0 = Input:B.0;  
 $SelectOut.1 = Junction.2;  
 $SelectOut:A.0 = Input:A.0;  
 $SelectOut:A.1 = Junction:C.2;  
 Junction.0 = Junction:A.0;  
 IsList.0 = Junction:B.1;  
 Junction:A.0 = IsList.0;  
 IsBit.0 = Junction:B.2;  //_GUI 43,76
 Junction:B.0 = ListIn.0;  
 OR.0 = Junction:A.2;  //_GUI 59,73
 OR.1 = IsBit.0;  
 INVERT.0 = OR.0;  
 Output:B.0 = INVERT.0;  
 ListFill.0 = MustBeConst.0;  
 ListFill.1 = Junction:D.2;  
 ListFill:A.0 = MustBeConst:A.0;  
 ListFill:A.1 = Junction:D.1;  //_GUI 111,32
 $Select.0 = PackLSB.0;  
 $Select.1 = $AddSubPrepBIn.0;  //_GUI 181,20, 181,39
 $Select.2 = Junction:F.1;  //_GUI 185,23
 $SelectOut:B.0 = Input.0;  
 $SelectOut:B.1 = Junction:C.1;  //_GUI 59,19
 Junction:C.0 = Junction.1;  
 Junction:D.0 = Junction:E.0;  
 Junction:E.0 = Junction:B.0;  //_GUI 43,50
 $Select:A.0 = NULL.0;  //_GUI 189,31
 $Select:A.1 = $AddSubPrepBIn.1;  
 $Select:A.2 = Junction:F.2;  
 Junction:F.0 = Junction:A.1;  //_GUI 185,67
 MustBeConst.0 = $SelectOut.1;  
 MustBeConst:A.0 = $SelectOut:A.1;  
 ListOut.0 = Junction:E.1;  
 ListOut.1 = Input:D.0;  
}

Object ( List Out1, NULL Around) $AddSubPrepBIn( List B
    , List Add, List CI, Bit GoIn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal",Documentation="list/list/list/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List B) Input;  //_GUI 26,27
 Object ( List Add) Input:A;  //_GUI 26,30
 Object ( List CI) Input:B;  //_GUI 26,33
 Object ( Bit GoIn) Input:C;  //_GUI 26,38
 Object Output( List Out1) ;  //_GUI 75,28
 Object Output:A( NULL Around) ;  //_GUI 75,34
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 45,26
 Object ( NULL Out1) NULL;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = PackLSB.0;  
 Output:A.0 = NULL.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
}

Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 // Same as Add with data chopping according to the BitsPerStageSG system global and an output saying what the latency is.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,13
 Object ( Variant B) Input:A;  //_GUI 22,32
 Object ( Bit Add) Input:B;  //_GUI 30,51
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 45,54
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 95,57
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 95,60
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 95,63
 Object ( Bit Wait) Input:G;  //_GUI 119,81
 Object Output( Variant CO) ;  //_GUI 181,22
 Object Output:A( Variant OFL) ;  //_GUI 185,25
 Object Output:B( Variant R) ;  //_GUI 175,49
 Object Output:C( Variant PipeLen) ;  //_GUI 130,54
 Object Output:D( Bit ClkG) ;  //_GUI 125,57
 Object Output:E( Bit AClr) ;  //_GUI 125,60
 Object Output:F( Bit Done) ;  //_GUI 125,63
 Object Output:G( Bit Busy) ;  //_GUI 109,76
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 33,21
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 66,35
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 163,47
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 51,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In3) ;  //_GUI 44,13
 Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 72,28
 //_ Attributes Documentation="Variant"
 Object ( NULL Out1) NULL;  //_GUI 53,19
 Object ( Variant Data) $NMin_Bit_LSB_List:A( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 76,9
 //_ Attributes Documentation="Variant"
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:B
    ( NULL In0) ;  //_GUI 71,21
 Object Text;  //_GUI 5,43,The Symmetrize will line up the decimal point on the fixed dataset.
 Object ( Variant BitsPerStageSG) Input:H;  //_GUI 59,40
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 51,11
 Object ( Bit CO, Bit OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $ADSU_Pipe( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 109,44
 //_ Attributes Documentation="lsb list"

 //_ Behavior Topology
 Output.0 = $ADSU_Pipe.0;  //_GUI 132,23, 132,46
 Output:A.0 = $ADSU_Pipe.1;  //_GUI 134,26, 134,49
 Output:B.0 = Context.0;  
 Output:C.0 = $ADSU_Pipe.3;  
 Output:D.0 = $ADSU_Pipe.4;  
 Output:E.0 = $ADSU_Pipe.5;  
 Output:F.0 = $ADSU_Pipe.6;  
 Output:G.0 = $ADSU_Pipe.7;  
 Symmetrize.0 = Input.0;  //_GUI 29,23, 29,14
 Symmetrize.1 = Input:A.0;  //_GUI 29,26, 29,33
 Junction.0 = Input:H.0;  //_GUI 65,36, 65,41
 Context.0 = Junction:A.1;  //_GUI 144,49, 144,7, 45,7
 Context.1 = $ADSU_Pipe.2;  
 MSB.0 = Symmetrize.1;  //_GUI 45,33
 Junction:A.0 = Symmetrize.0;  
 $NMin_Bit_LSB_List.0 = Junction:B.2;  
 $NMin_Bit_LSB_List.1 = MSB.0;  
 $NMin_Bit_LSB_List.2 = Junction.1;  
 $NMin_Bit_LSB_List:A.0 = Junction:B.0;  //_GUI 72,11
 $NMin_Bit_LSB_List:A.1 = MSB:A.0;  
 $NMin_Bit_LSB_List:A.2 = Junction.0;  //_GUI 67,17
 Junction:B.0 = NULL.0;  
 MSB:A.0 = Junction:A.2;  
 $ADSU_Pipe.0 = $NMin_Bit_LSB_List:A.0;  //_GUI 102,46, 102,12
 $ADSU_Pipe.1 = $NMin_Bit_LSB_List.0;  //_GUI 97,49, 97,31
 $ADSU_Pipe.2 = Input:B.0;  
 $ADSU_Pipe.3 = Input:C.0;  
 $ADSU_Pipe.4 = Input:D.0;  
 $ADSU_Pipe.5 = Input:E.0;  
 $ADSU_Pipe.6 = Input:F.0;  
 $ADSU_Pipe.7 = Input:G.0;  
}

Object ( Bit CO, Bit OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Floating A, Floating B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating A) Input;  //_GUI 22,22
 Object ( Floating B) Input:A;  //_GUI 22,25
 Object ( Bit Add) Input:B;  //_GUI 22,28
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 22,31
 Object ( Bit ClkG) Input:D;  //_GUI 22,34
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 22,37
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 22,40
 Object ( Bit Wait) Input:G;  //_GUI 45,48
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 60,22
 Object Output:A( Bit OFL) ;  //_GUI 60,25
 Object Output:B( Variant R) ;  //_GUI 60,28
 Object Output:C( Variant PipeLen) ;  //_GUI 60,31
 Object Output:D( Bit ClkG) ;  //_GUI 60,34
 Object Output:E( Bit AClr) ;  //_GUI 60,37
 Object Output:F( Bit Done) ;  //_GUI 60,40
 Object Output:G( Bit Busy) ;  //_GUI 36,52
 Object ( Bit In) Input:H;  //_GUI 54,22
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 36,24
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = Input:H.0;  
 Output:A.0 = Add_Pipe.0;  
 Output:B.0 = Add_Pipe.1;  
 Output:C.0 = Add_Pipe.2;  
 Output:D.0 = Add_Pipe.3;  
 Output:E.0 = Add_Pipe.4;  
 Output:F.0 = Add_Pipe.5;  
 Output:G.0 = Add_Pipe.6;  
 Add_Pipe.0 = Input.0;  //_GUI 33,26, 33,23
 Add_Pipe.1 = Input:A.0;  //_GUI 31,29, 31,26
 Add_Pipe.2 = Input:B.0;  //_GUI 29,32, 29,29
 Add_Pipe.3 = Input:D.0;  
 Add_Pipe.4 = Input:E.0;  
 Add_Pipe.5 = Input:F.0;  
 Add_Pipe.6 = Input:G.0;  
}

Object ( Bit CO, Bit OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Complex A, Complex B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex A) Input;  //_GUI 22,22
 Object ( Complex B) Input:A;  //_GUI 22,25
 Object ( Bit Add) Input:B;  //_GUI 22,28
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 22,31
 Object ( Bit ClkG) Input:D;  //_GUI 22,34
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 22,37
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 22,40
 Object ( Bit Wait) Input:G;  //_GUI 45,48
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 60,22
 Object Output:A( Bit OFL) ;  //_GUI 60,25
 Object Output:B( Variant R) ;  //_GUI 60,28
 Object Output:C( Variant PipeLen) ;  //_GUI 60,31
 Object Output:D( Bit ClkG) ;  //_GUI 60,34
 Object Output:E( Bit AClr) ;  //_GUI 60,37
 Object Output:F( Bit Done) ;  //_GUI 60,40
 Object Output:G( Bit Busy) ;  //_GUI 36,52
 Object ( Bit In) Input:H;  //_GUI 54,22
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 36,24
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = Input:H.0;  
 Output:A.0 = Add_Pipe.0;  
 Output:B.0 = Add_Pipe.1;  
 Output:C.0 = Add_Pipe.2;  
 Output:D.0 = Add_Pipe.3;  
 Output:E.0 = Add_Pipe.4;  
 Output:F.0 = Add_Pipe.5;  
 Output:G.0 = Add_Pipe.6;  
 Add_Pipe.0 = Input.0;  //_GUI 33,26, 33,23
 Add_Pipe.1 = Input:A.0;  //_GUI 31,29, 31,26
 Add_Pipe.2 = Input:B.0;  //_GUI 29,32, 29,29
 Add_Pipe.3 = Input:D.0;  
 Add_Pipe.4 = Input:E.0;  
 Add_Pipe.5 = Input:F.0;  
 Add_Pipe.6 = Input:G.0;  
}

Object ( List CO, List OFL, List R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( List A, List B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/List/Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 8,28
 Object ( List B) Input:A;  //_GUI 8,37
 Object ( Bit Add) Input:B;  //_GUI 8,44
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 8,47
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 8,50
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 8,53
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 8,56
 Object ( Bit Wait) Input:G;  //_GUI 176,68
 //_ Attributes Constant="0"
 Object Output( List CO) ;  //_GUI 177,18
 Object Output:A( List OFL) ;  //_GUI 177,28
 Object Output:B( List R) ;  //_GUI 177,37
 Object Output:C( Variant PipeLen) ;  //_GUI 177,43
 Object Output:D( Bit ClkG) ;  //_GUI 177,46
 Object Output:E( Bit AClr) ;  //_GUI 177,49
 Object Output:F( Bit Done) ;  //_GUI 177,61
 Object Output:G( Bit Busy) ;  //_GUI 9,65
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,56
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 161,26
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 103,30
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 14,35
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 14,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 39,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 42,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 36,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 33,44
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 70,5
 Object ( List Out1) PackLSB:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 70,61
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 161,16
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 161,35
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 132,16
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB:A
    ( Variant In1) ;  //_GUI 132,32
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 55,5
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe:A( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 55,61

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Output:B.0 = ListOut:B.0;  
 Output:C.0 = SyncRegPair_Pipe.4;  
 Output:D.0 = SyncRegPair_Pipe.5;  
 Output:E.0 = SyncRegPair_Pipe.6;  
 Output:F.0 = SyncRegPair_Pipe.9;  
 Output:G.0 = ADSU_Pipe:A.7;  //_GUI 9,60, 49,60, 49,84
 Junction.0 = Input:F.0;  
 ListOut.0 = UnPackLSB:A.1;  //_GUI 148,31, 148,37
 ListOut.1 = UnPackLSB.1;  //_GUI 161,25, 154,25, 154,21
 SyncRegPair_Pipe.0 = PackLSB.0;  //_GUI 84,32, 84,8
 SyncRegPair_Pipe.1 = PackLSB:A.0;  //_GUI 84,35, 84,64
 SyncRegPair_Pipe.2 = ADSU_Pipe.3;  //_GUI 87,38, 87,16
 SyncRegPair_Pipe.3 = ADSU_Pipe:A.3;  //_GUI 87,41, 87,72
 SyncRegPair_Pipe.4 = ADSU_Pipe:A.4;  //_GUI 90,44, 90,75
 SyncRegPair_Pipe.5 = ADSU_Pipe:A.5;  //_GUI 93,47, 93,78
 SyncRegPair_Pipe.6 = ADSU_Pipe.6;  //_GUI 96,50, 96,25
 SyncRegPair_Pipe.7 = ADSU_Pipe:A.6;  //_GUI 96,53, 96,81
 SyncRegPair_Pipe.8 = Input:G.0;  //_GUI 180,65
 ListIn.0 = Input:A.0;  
 ListIn:A.0 = Input.0;  
 Junction:A.0 = Input:D.0;  
 Junction:B.0 = Input:E.0;  
 Junction:C.0 = Input:C.0;  
 Junction:D.0 = Input:B.0;  
 PackLSB.0 = ADSU_Pipe.0;  
 PackLSB.1 = ADSU_Pipe.1;  
 PackLSB.2 = ADSU_Pipe.2;  
 PackLSB:A.0 = ADSU_Pipe:A.0;  
 PackLSB:A.1 = ADSU_Pipe:A.1;  
 PackLSB:A.2 = ADSU_Pipe:A.2;  
 ListOut:A.0 = UnPackLSB:A.0;  //_GUI 158,21, 158,28, 145,28
 ListOut:A.1 = UnPackLSB.0;  
 ListOut:B.0 = UnPackLSB:A.2;  
 ListOut:B.1 = UnPackLSB.2;  //_GUI 151,37, 151,24
 UnPackLSB.0 = SyncRegPair_Pipe.0;  //_GUI 124,19, 124,32
 UnPackLSB:A.0 = SyncRegPair_Pipe.1;  
 ADSU_Pipe.0 = ListIn:A.1;  //_GUI 28,7, 28,28
 ADSU_Pipe.1 = ListIn.1;  //_GUI 31,10, 31,37
 ADSU_Pipe.2 = Junction:D.0;  //_GUI 34,13
 ADSU_Pipe.3 = Junction:C.0;  //_GUI 37,16
 ADSU_Pipe.4 = Junction:A.0;  //_GUI 40,19
 ADSU_Pipe.5 = Junction:B.0;  //_GUI 43,22
 ADSU_Pipe.6 = Junction.0;  //_GUI 46,25
 ADSU_Pipe.7 = SyncRegPair_Pipe.7;  //_GUI 127,28, 127,53
 ADSU_Pipe:A.0 = ListIn:A.0;  //_GUI 28,63, 28,31
 ADSU_Pipe:A.1 = ListIn.0;  //_GUI 31,66, 31,40
 ADSU_Pipe:A.2 = Junction:D.2;  //_GUI 34,69
 ADSU_Pipe:A.3 = Junction:C.2;  //_GUI 37,72
 ADSU_Pipe:A.4 = Junction:A.2;  //_GUI 40,75
 ADSU_Pipe:A.5 = Junction:B.2;  //_GUI 43,78
 ADSU_Pipe:A.6 = Junction.2;  //_GUI 46,81
 ADSU_Pipe:A.7 = SyncRegPair_Pipe.8;  //_GUI 137,84, 137,56
}

Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, List B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Var/List/Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,18
 Object ( List B) Input:A;  //_GUI 23,25
 Object ( Bit Add) Input:B;  //_GUI 23,28
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 23,31
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 23,34
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 23,37
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 23,40
 Object ( Bit Wait) Input:G;  //_GUI 74,46
 //_ Attributes Constant="0"
 Object Output( Variant CO) ;  //_GUI 75,22
 Object Output:A( Variant OFL) ;  //_GUI 75,25
 Object Output:B( Variant R) ;  //_GUI 75,28
 Object Output:C( Variant PipeLen) ;  //_GUI 75,31
 Object Output:D( Bit ClkG) ;  //_GUI 75,34
 Object Output:E( Bit AClr) ;  //_GUI 75,37
 Object Output:F( Bit Done) ;  //_GUI 75,40
 Object Output:G( Bit Busy) ;  //_GUI 24,46
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,17
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 31,25
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 49,21

 //_ Behavior Topology
 Output.0 = ADSU_Pipe.0;  
 Output:A.0 = ADSU_Pipe.1;  
 Output:B.0 = ADSU_Pipe.2;  
 Output:C.0 = ADSU_Pipe.3;  
 Output:D.0 = ADSU_Pipe.4;  
 Output:E.0 = ADSU_Pipe.5;  
 Output:F.0 = ADSU_Pipe.6;  
 Output:G.0 = ADSU_Pipe.7;  //_GUI 24,44
 ListFill.0 = Input.0;  
 ListFill.1 = Junction.0;  
 Junction.0 = Input:A.0;  
 ADSU_Pipe.0 = ListFill.0;  //_GUI 47,23, 47,20
 ADSU_Pipe.1 = Junction.1;  
 ADSU_Pipe.2 = Input:B.0;  
 ADSU_Pipe.3 = Input:C.0;  
 ADSU_Pipe.4 = Input:D.0;  
 ADSU_Pipe.5 = Input:E.0;  
 ADSU_Pipe.6 = Input:F.0;  
 ADSU_Pipe.7 = Input:G.0;  //_GUI 78,44
}

Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( List A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/Var/Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 22,18
 Object ( Variant B) Input:A;  //_GUI 22,21
 Object ( Bit Add) Input:B;  //_GUI 22,28
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 22,31
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 22,34
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 22,37
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 22,40
 Object ( Bit Wait) Input:G;  //_GUI 74,46
 //_ Attributes Constant="0"
 Object Output( Variant CO) ;  //_GUI 75,22
 Object Output:A( Variant OFL) ;  //_GUI 75,25
 Object Output:B( Variant R) ;  //_GUI 75,28
 Object Output:C( Variant PipeLen) ;  //_GUI 75,31
 Object Output:D( Bit ClkG) ;  //_GUI 75,34
 Object Output:E( Bit AClr) ;  //_GUI 75,37
 Object Output:F( Bit Done) ;  //_GUI 75,40
 Object Output:G( Bit Busy) ;  //_GUI 23,46
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,20
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 28,18
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 49,21

 //_ Behavior Topology
 Output.0 = ADSU_Pipe.0;  
 Output:A.0 = ADSU_Pipe.1;  
 Output:B.0 = ADSU_Pipe.2;  
 Output:C.0 = ADSU_Pipe.3;  
 Output:D.0 = ADSU_Pipe.4;  
 Output:E.0 = ADSU_Pipe.5;  
 Output:F.0 = ADSU_Pipe.6;  
 Output:G.0 = ADSU_Pipe.7;  //_GUI 23,44
 ListFill.0 = Input:A.0;  
 ListFill.1 = Junction.2;  //_GUI 29,25
 Junction.0 = Input.0;  
 ADSU_Pipe.0 = Junction.1;  //_GUI 49,19
 ADSU_Pipe.1 = ListFill.0;  //_GUI 45,26
 ADSU_Pipe.2 = Input:B.0;  
 ADSU_Pipe.3 = Input:C.0;  
 ADSU_Pipe.4 = Input:D.0;  
 ADSU_Pipe.5 = Input:E.0;  
 ADSU_Pipe.6 = Input:F.0;  
 ADSU_Pipe.7 = Input:G.0;  //_GUI 78,44
}

Object ( List CO, List OFL, List R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( List A, List B, List Add
    , List CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/List/List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 8,20
 Object ( List B) Input:A;  //_GUI 8,28
 Object ( List Add) Input:B;  //_GUI 8,36
 Object ( List CI) Input:C;  //_GUI 8,44
 Object ( Bit ClkG) Input:D;  //_GUI 8,50
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 8,53
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 8,56
 Object ( Bit Wait) Input:G;  //_GUI 176,68
 //_ Attributes Constant="0"
 Object Output( List CO) ;  //_GUI 177,18
 Object Output:A( List OFL) ;  //_GUI 177,28
 Object Output:B( List R) ;  //_GUI 177,37
 Object Output:C( Variant PipeLen) ;  //_GUI 177,43
 Object Output:D( Bit ClkG) ;  //_GUI 177,46
 Object Output:E( Bit AClr) ;  //_GUI 177,49
 Object Output:F( Bit Done) ;  //_GUI 177,61
 Object Output:G( Bit Busy) ;  //_GUI 9,65
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,56
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 161,26
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 103,30
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 14,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 39,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 42,53
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 70,5
 Object ( List Out1) PackLSB:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 70,61
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 161,16
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 161,35
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 132,16
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB:A
    ( Variant In1) ;  //_GUI 132,32
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 14,34
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 14,42
 Object ( Variant Out1, Variant Out2) ListIn:C( List In) ;  //_GUI 14,18
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 55,5
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe:A( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 55,61

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Output:B.0 = ListOut:B.0;  
 Output:C.0 = SyncRegPair_Pipe.4;  
 Output:D.0 = SyncRegPair_Pipe.5;  
 Output:E.0 = SyncRegPair_Pipe.6;  
 Output:F.0 = SyncRegPair_Pipe.9;  
 Output:G.0 = ADSU_Pipe:A.7;  //_GUI 9,60, 49,60, 49,84
 Junction.0 = Input:F.0;  
 ListOut.0 = UnPackLSB:A.1;  //_GUI 148,31, 148,37
 ListOut.1 = UnPackLSB.1;  //_GUI 161,25, 154,25, 154,21
 SyncRegPair_Pipe.0 = PackLSB.0;  //_GUI 84,32, 84,8
 SyncRegPair_Pipe.1 = PackLSB:A.0;  //_GUI 84,35, 84,64
 SyncRegPair_Pipe.2 = ADSU_Pipe.3;  //_GUI 87,38, 87,16
 SyncRegPair_Pipe.3 = ADSU_Pipe:A.3;  //_GUI 87,41, 87,72
 SyncRegPair_Pipe.4 = ADSU_Pipe:A.4;  //_GUI 90,44, 90,75
 SyncRegPair_Pipe.5 = ADSU_Pipe:A.5;  //_GUI 93,47, 93,78
 SyncRegPair_Pipe.6 = ADSU_Pipe.6;  //_GUI 96,50, 96,25
 SyncRegPair_Pipe.7 = ADSU_Pipe:A.6;  //_GUI 96,53, 96,81
 SyncRegPair_Pipe.8 = Input:G.0;  //_GUI 180,65
 ListIn.0 = Input:A.0;  
 Junction:A.0 = Input:D.0;  
 Junction:B.0 = Input:E.0;  
 PackLSB.0 = ADSU_Pipe.0;  
 PackLSB.1 = ADSU_Pipe.1;  
 PackLSB.2 = ADSU_Pipe.2;  
 PackLSB:A.0 = ADSU_Pipe:A.0;  
 PackLSB:A.1 = ADSU_Pipe:A.1;  
 PackLSB:A.2 = ADSU_Pipe:A.2;  
 ListOut:A.0 = UnPackLSB:A.0;  //_GUI 158,21, 158,28, 145,28
 ListOut:A.1 = UnPackLSB.0;  
 ListOut:B.0 = UnPackLSB:A.2;  
 ListOut:B.1 = UnPackLSB.2;  //_GUI 151,37, 151,24
 UnPackLSB.0 = SyncRegPair_Pipe.0;  //_GUI 124,19, 124,32
 UnPackLSB:A.0 = SyncRegPair_Pipe.1;  
 ListIn:A.0 = Input:B.0;  
 ListIn:B.0 = Input:C.0;  
 ListIn:C.0 = Input.0;  
 ADSU_Pipe.0 = ListIn:C.1;  //_GUI 28,7, 28,20
 ADSU_Pipe.1 = ListIn.1;  //_GUI 31,10, 31,28
 ADSU_Pipe.2 = ListIn:A.1;  //_GUI 34,13, 34,36
 ADSU_Pipe.3 = ListIn:B.1;  //_GUI 37,16, 37,44
 ADSU_Pipe.4 = Junction:A.0;  //_GUI 40,19
 ADSU_Pipe.5 = Junction:B.0;  //_GUI 43,22
 ADSU_Pipe.6 = Junction.0;  //_GUI 46,25
 ADSU_Pipe.7 = SyncRegPair_Pipe.7;  //_GUI 127,28, 127,53
 ADSU_Pipe:A.0 = ListIn:C.0;  //_GUI 28,63, 28,23
 ADSU_Pipe:A.1 = ListIn.0;  //_GUI 31,66, 31,31
 ADSU_Pipe:A.2 = ListIn:A.0;  //_GUI 34,69, 34,39
 ADSU_Pipe:A.3 = ListIn:B.0;  //_GUI 37,72, 37,47
 ADSU_Pipe:A.4 = Junction:A.2;  //_GUI 40,75
 ADSU_Pipe:A.5 = Junction:B.2;  //_GUI 43,78
 ADSU_Pipe:A.6 = Junction.2;  //_GUI 46,81
 ADSU_Pipe:A.7 = SyncRegPair_Pipe.8;  //_GUI 137,84, 137,56
}

Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, List B, List Add
    , List CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Var/List/List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,18
 Object ( List B) Input:A;  //_GUI 23,25
 Object ( List Add) Input:B;  //_GUI 23,28
 Object ( List CI) Input:C;  //_GUI 23,31
 Object ( Bit ClkG) Input:D;  //_GUI 23,34
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 23,37
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 23,40
 Object ( Bit Wait) Input:G;  //_GUI 74,46
 //_ Attributes Constant="0"
 Object Output( Variant CO) ;  //_GUI 75,22
 Object Output:A( Variant OFL) ;  //_GUI 75,25
 Object Output:B( Variant R) ;  //_GUI 75,28
 Object Output:C( Variant PipeLen) ;  //_GUI 75,31
 Object Output:D( Bit ClkG) ;  //_GUI 75,34
 Object Output:E( Bit AClr) ;  //_GUI 75,37
 Object Output:F( Bit Done) ;  //_GUI 75,40
 Object Output:G( Bit Busy) ;  //_GUI 24,46
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,17
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 31,25
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 49,21

 //_ Behavior Topology
 Output.0 = ADSU_Pipe.0;  
 Output:A.0 = ADSU_Pipe.1;  
 Output:B.0 = ADSU_Pipe.2;  
 Output:C.0 = ADSU_Pipe.3;  
 Output:D.0 = ADSU_Pipe.4;  
 Output:E.0 = ADSU_Pipe.5;  
 Output:F.0 = ADSU_Pipe.6;  
 Output:G.0 = ADSU_Pipe.7;  //_GUI 24,44
 ListFill.0 = Input.0;  
 ListFill.1 = Junction.0;  
 Junction.0 = Input:A.0;  
 ADSU_Pipe.0 = ListFill.0;  //_GUI 47,23, 47,20
 ADSU_Pipe.1 = Junction.1;  
 ADSU_Pipe.2 = Input:B.0;  
 ADSU_Pipe.3 = Input:C.0;  
 ADSU_Pipe.4 = Input:D.0;  
 ADSU_Pipe.5 = Input:E.0;  
 ADSU_Pipe.6 = Input:F.0;  
 ADSU_Pipe.7 = Input:G.0;  //_GUI 78,44
}

Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( List A, Variant B, List Add
    , List CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/Var/List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 22,18
 Object ( Variant B) Input:A;  //_GUI 22,21
 Object ( List Add) Input:B;  //_GUI 22,28
 Object ( List CI) Input:C;  //_GUI 22,31
 Object ( Bit ClkG) Input:D;  //_GUI 22,34
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 22,37
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 22,40
 Object ( Bit Wait) Input:G;  //_GUI 74,46
 //_ Attributes Constant="0"
 Object Output( Variant CO) ;  //_GUI 75,22
 Object Output:A( Variant OFL) ;  //_GUI 75,25
 Object Output:B( Variant R) ;  //_GUI 75,28
 Object Output:C( Variant PipeLen) ;  //_GUI 75,31
 Object Output:D( Bit ClkG) ;  //_GUI 75,34
 Object Output:E( Bit AClr) ;  //_GUI 75,37
 Object Output:F( Bit Done) ;  //_GUI 75,40
 Object Output:G( Bit Busy) ;  //_GUI 23,46
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,20
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 28,18
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 49,21

 //_ Behavior Topology
 Output.0 = ADSU_Pipe.0;  
 Output:A.0 = ADSU_Pipe.1;  
 Output:B.0 = ADSU_Pipe.2;  
 Output:C.0 = ADSU_Pipe.3;  
 Output:D.0 = ADSU_Pipe.4;  
 Output:E.0 = ADSU_Pipe.5;  
 Output:F.0 = ADSU_Pipe.6;  
 Output:G.0 = ADSU_Pipe.7;  //_GUI 23,44
 ListFill.0 = Input:A.0;  
 ListFill.1 = Junction.2;  //_GUI 29,25
 Junction.0 = Input.0;  
 ADSU_Pipe.0 = Junction.1;  //_GUI 49,19
 ADSU_Pipe.1 = ListFill.0;  //_GUI 45,26
 ADSU_Pipe.2 = Input:B.0;  
 ADSU_Pipe.3 = Input:C.0;  
 ADSU_Pipe.4 = Input:D.0;  
 ADSU_Pipe.5 = Input:E.0;  
 ADSU_Pipe.6 = Input:F.0;  
 ADSU_Pipe.7 = Input:G.0;  //_GUI 78,44
}

Object ( Bit Q) StickyReg( Bit D, Bit ClkG
    , Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers"
{
 // The StickyReg starts out in a 0 state.  When the D input goes high, the StickyReg will enter a 1 state (on the positive clock edge).  It will remain in this state until a CLR (asynchronous) is received.
 //
 // Inputs:
 // D (Bit) - values of 1 will 'stick'
 // CLR - asynchronous clear
 //
 // Outputs:
 // Q - current state
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit D) Input;  //_GUI 52,46
 Object ( Bit ClkG) Input:A;  //_GUI 52,49
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:B;  //_GUI 53,55
 Object Output( Bit Q) ;  //_GUI 97,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 64,46
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 71,45
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 84,45

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Junction.0 = Input.0;  
 RegClr.0 = Junction.1;  
 RegClr.1 = Input:A.0;  
 RegClr.2 = Junction.2;  //_GUI 65,53
 RegClr.3 = Input:B.0;  
 VouchBit.0 = RegClr.0;  
}

Object ( Variant Q) StickyReg( Variant D, Bit ClkG
    , Variant CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\Advanced",Documentation="var/var"
{
 // Same as StickyReg except with a synchronous clear instead of an asynchronous clear. Also supports a multi-bit overload where D, CLR, and Q are variants of the same dataset in which each bit is stickied and cleared independent of one another.
 //
 // The StickyReg starts out in a 0 state.  When the D input goes high, the StickyReg will enter a 1 state (on the positive clock edge).  It will remain in this state until a CLR (asynchronous) is received. Also supports a multi-bit overload where D, CLR, and Q are variants of the same dataset in which each bit is stickied and cleared independent of one another. Also supports a multi-bit overload where D, and Q are variants of the same dataset in which each bit is stickied independent of one another but cleared together.
 //
 // Inputs:
 // D (Var/Bit) - values of 1 will 'stick'
 // CLR (Var/Bit) - asynchronous clear
 //
 // Outputs:
 // Q (Var/Bit)- current state
 //
 // Revision 1 - 11/08/05 new Var/Var overload
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 34,17
 Object ( Bit ClkG) Input:A;  //_GUI 33,26
 //_ Attributes Resource="Global"
 Object ( Variant CLR) Input:B;  //_GUI 32,31
 Object Output( Variant Q) ;  //_GUI 133,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,15
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 105,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 48,17
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 58,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 75,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 120,14
 Object ( Variant Q) StickyReg( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,15
 Object ( Variant Q) StickyReg:A( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,28

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = StickyReg:A.0;  //_GUI 99,21, 99,31
 VariantOut.1 = StickyReg.0;  
 Junction.0 = Input.0;  
 VariantIn:A.0 = Input:B.0;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction.0;  //_GUI 118,16, 118,9, 49,9
 Cast.1 = VariantOut.0;  
 StickyReg.0 = VariantIn.1;  
 StickyReg.1 = Junction:A.0;  //_GUI 76,20
 StickyReg.2 = VariantIn:A.1;  //_GUI 71,23, 71,31
 StickyReg:A.0 = VariantIn.0;  //_GUI 73,30, 73,20
 StickyReg:A.1 = Junction:A.2;  //_GUI 76,33
 StickyReg:A.2 = VariantIn:A.0;  //_GUI 73,36, 73,34
}

Object ( Variant Q) StickyReg( Variant D, Bit ClkG
    , Bit CLR) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Registers\\$Internal",Documentation="var/bit"
{
 // Same as StickyReg except with a synchronous clear instead of an asynchronous clear. Also supports a multi-bit overload where D, CLR, and Q are variants of the same dataset in which each bit is stickied and cleared independent of one another.
 //
 // The StickyReg starts out in a 0 state.  When the D input goes high, the StickyReg will enter a 1 state (on the positive clock edge).  It will remain in this state until a CLR (asynchronous) is received. Also supports a multi-bit overload where D, CLR, and Q are variants of the same dataset in which each bit is stickied and cleared independent of one another. Also supports a multi-bit overload where D, and Q are variants of the same dataset in which each bit is stickied independent of one another but cleared together.
 //
 // Inputs:
 // D (Var/Bit) - values of 1 will 'stick'
 // CLR (Var/Bit) - asynchronous clear
 //
 // Outputs:
 // Q (Var/Bit)- current state
 //
 // Revision 1 - 11/08/05 new Var/Bit overload
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 34,17
 Object ( Bit ClkG) Input:A;  //_GUI 33,26
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:B;  //_GUI 33,35
 Object Output( Variant Q) ;  //_GUI 133,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,15
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 105,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 48,17
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 75,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 120,14
 Object ( Variant Q) StickyReg( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,15
 Object ( Variant Q) StickyReg:A( Variant D, Bit ClkG
    , Variant CLR) ;  //_GUI 79,28
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 70,35

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = StickyReg:A.0;  //_GUI 99,21, 99,31
 VariantOut.1 = StickyReg.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction.0;  //_GUI 118,16, 118,9, 49,9
 Cast.1 = VariantOut.0;  
 StickyReg.0 = VariantIn.1;  
 StickyReg.1 = Junction:A.0;  //_GUI 76,20
 StickyReg.2 = Junction:B.0;  //_GUI 71,23
 StickyReg:A.0 = VariantIn.0;  //_GUI 73,30, 73,20
 StickyReg:A.1 = Junction:A.2;  //_GUI 76,33
 StickyReg:A.2 = Junction:B.1;  
 Junction:B.0 = Input:B.0;  
}

Object ( Variant Out1) OR( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\OR"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,18
 Object ( Variant In2) Input:A;  //_GUI 22,21
 Object ( Variant In3) Input:B;  //_GUI 22,24
 Object Output( Variant Out1) ;  //_GUI 67,22
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 50,20
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 34,17

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = OR:A.0;  //_GUI 47,22, 47,20
 OR.1 = Input:B.0;  
 OR:A.0 = Input.0;  
 OR:A.1 = Input:A.0;  
}

Object ( Bit "A<B", Bit "A=B", Bit "A>B") CompareTwos
    ( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Icon="Compare"
{
 // Same as Compare in the non-Advanced tree except the inputs are interpreted as twos complement numbers.
 //
 // Inputs:
 //
 // Variant A:	A
 //
 // Variant B:	B
 //
 // Outputs:
 //
 // Bit A<B:	Asserted if A<B
 //
 // Bit A=B:	Asserted if A=B
 //
 // Bit A>B:	Asserted if A>B
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (twos complement)
 //
 // Revision 2: modified to use more hardware but execute faster
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 15,23
 Object ( Variant B) Input:A;  //_GUI 15,26
 Object Output( Bit "A<B") ;  //_GUI 99,24
 Object Output:A( Bit "A=B") ;  //_GUI 99,30
 Object Output:B( Bit "A>B") ;  //_GUI 98,43
 Object Text;  //_GUI 113,44,A>B if resulting sign bit and OFL are same and result is not 0
 Object Text;  //_GUI 116,21,A<B if resulting sign bit and OFL are different
 Object Text;  //_GUI 118,35,A=B if result is 0
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 85,28
 Object ( Bit CI) Input:B;  //_GUI 15,32
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit ADD) Input:C;  //_GUI 15,29
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 35,22
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 35,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 27,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 24,29
 Object Text;  //_GUI 24,10,Remember the CO comes out high be default in the case of subtraction, which we're doing.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 21,32
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 85,22
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit IsNeg) Sign( Variant In1) ;  //_GUI 70,21
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1) XOR:A( Bit In1, Bit In2) ;  //_GUI 79,41
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit IsNeg) Sign:A( Variant In1) ;  //_GUI 67,43
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 Output:A.0 = AND.0;  
 Output:B.0 = XOR:A.0;  
 AND.0 = ADSU.0;  //_GUI 62,30, 62,24
 AND.1 = ADSU:A.0;  //_GUI 62,33, 62,40
 ADSU.0 = Junction.1;  
 ADSU.1 = Junction:A.1;  
 ADSU.2 = Junction:B.1;  
 ADSU.3 = Junction:C.1;  
 ADSU:A.0 = Junction:A.2;  //_GUI 28,40
 ADSU:A.1 = Junction.2;  //_GUI 31,43
 ADSU:A.2 = Junction:B.2;  //_GUI 25,46
 ADSU:A.3 = Junction:C.2;  //_GUI 22,49
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = Input:C.0;  
 Junction:C.0 = Input:B.0;  
 XOR.0 = Sign.0;  
 XOR.1 = ADSU.1;  
 Sign.0 = ADSU.2;  //_GUI 70,20, 58,20, 58,30
 XOR:A.0 = ADSU:A.1;  
 XOR:A.1 = Sign:A.0;  
 Sign:A.0 = ADSU:A.2;  
}

Object ( Variant Address, Variant BlockSize, Bit LastDone
    , Bit Done) Anti4K_OneGo( MSB032 Address, MSB024 Nums, Bit Go) 
{
 //_ Object Prototypes
 Object ( MSB032 Address) Input;  //_GUI 41,43
 Object ( MSB024 Nums) Input:A;  //_GUI 13,67
 Object ( Bit Go) Input:B;  //_GUI 42,94
 Object Output( Variant Address) ;  //_GUI 364,42
 Object Output:A( Variant BlockSize) ;  //_GUI 364,45
 Object Output:B( Bit LastDone) ;  //_GUI 377,73
 Object Output:C( Bit Done) ;  //_GUI 364,114
 Object ( MSB004 MSB004) Input:C;  //_GUI 97,62
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 118,45
 Object ( MSB032 Out1, MSB032 Out2, MSB032 Out3) Junction
    ( MSB032 In0) ;  //_GUI 52,43
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 314,41
 Object ( List Out1) PackMSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 103,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 58,70
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 67,94
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackMSB
    ( Variant In1) ;  //_GUI 325,41
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 176,46
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 151,47
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 156,58
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 171,60
 Object ( List Out1) PackMSB:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 300,104
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 259,88
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 151,107
 Object ( MSB032 Out1, MSB032 Out2, MSB032 Out3) Junction:F
    ( MSB032 In0) ;  //_GUI 71,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In0) ;  //_GUI 74,70
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 147,94
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 163,107
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 244,104
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 224,119
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 207,117
 Object ( MSB008 MSB008) Input:D;  //_GUI 203,121
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 118,106
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 284,104
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 152,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 103,42
 Object ( Variant Hi, Variant Lo) Lo_N:B( Variant Data
    , Variant Lo_N) ;  //_GUI 193,100
 Object ( MSB004 MSB004) Input:E;  //_GUI 189,104
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 176,101
 Object ( Bit Out1) VouchBit( Bit In1) ;  //_GUI 339,112
 Object ( Bit Q) Reg:A( Bit D, Bit ClkG) ;  //_GUI 208,86
 Object ( Bit Q) Reg:B( Bit D, Bit ClkG) ;  //_GUI 159,67
 Object ( MSB012 MSB012) Input:F;  //_GUI 95,46
 //_ Attributes PromoteToParentObject="False"
 Object ( Variant Hi, Variant Lo) Lo_N:C( Variant Data
    , Variant Lo_N) ;  //_GUI 33,66
 Object ( MSB008 MSB008) Input:G;  //_GUI 22,70
 //_ Attributes PromoteToParentObject="False"
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 134,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 292,48
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 350,70
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In1) ;  //_GUI 338,75
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 365,71
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 101,58
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 49,81
 Object Text;  //_GUI 74,15,4kAddress+ Blocksize4k

 //_ Behavior Topology
 Output.0 = UnPackMSB.0;  
 Output:A.0 = UnPackMSB.1;  
 Output:B.0 = AND:A.0;  
 Output:C.0 = VouchBit.0;  
 Add.0 = Lo_N:A.1;  
 Add.1 = CollectMSB.0;  //_GUI 118,61
 Junction.0 = Input.0;  
 Mux.0 = Reg.0;  //_GUI 311,43, 311,35
 Mux.1 = PackMSB:A.0;  //_GUI 311,46
 Mux.2 = Junction:J.1;  
 PackMSB.0 = Junction.0;  //_GUI 53,33
 PackMSB.1 = Junction:A.0;  //_GUI 59,36
 PackMSB.2 = Junction:B.0;  //_GUI 68,39
 Junction:A.0 = Lo_N:C.1;  
 Junction:B.0 = Input:B.0;  
 UnPackMSB.0 = Mux.0;  
 RegClr.0 = Junction:C.1;  
 RegClr.2 = Junction:D.0;  //_GUI 172,54
 RegClr.3 = Reg:B.0;  //_GUI 176,70
 Junction:C.0 = OR.0;  
 AND.0 = Junction:C.2;  //_GUI 152,60
 AND.1 = Junction:H.0;  //_GUI 148,63
 Junction:D.0 = AND.0;  
 PackMSB:A.0 = ListIn:A.1;  
 PackMSB:A.1 = ListIn:A.0;  
 PackMSB:A.2 = Junction:E.1;  //_GUI 278,112, 278,89
 Junction:E.0 = Reg:A.0;  
 RegClr:A.0 = ListOut:A.0;  
 RegClr:A.2 = Junction:H.2;  //_GUI 148,115
 Junction:F.0 = Junction.1;  
 Junction:G.0 = Junction:A.1;  
 Junction:H.0 = Junction:B.1;  
 ListIn.0 = RegClr:A.0;  
 ListOut.0 = INVERT.0;  //_GUI 244,122
 ListOut.1 = Junction:I.0;  //_GUI 231,106, 231,97, 177,97
 INVERT.0 = Lo_N.1;  
 Lo_N.0 = Lo_N:B.0;  //_GUI 207,102
 Lo_N.1 = Input:D.0;  
 ListOut:A.0 = Junction:G.2;  //_GUI 75,111
 ListOut:A.1 = Junction:F.2;  //_GUI 72,108
 ListIn:A.0 = ListOut.0;  
 Reg.0 = PackMSB.0;  
 Lo_N:A.0 = Junction:F.1;  
 Lo_N:A.1 = Input:F.0;  
 Lo_N:B.0 = Junction:I.1;  
 Lo_N:B.1 = Input:E.0;  
 Junction:I.0 = ListIn.1;  //_GUI 174,102
 VouchBit.0 = Junction:K.2;  
 Reg:A.0 = Junction:D.2;  //_GUI 172,88
 Reg:B.0 = Junction:E.2;  //_GUI 141,69, 141,140, 260,140
 Lo_N:C.0 = Input:A.0;  
 Lo_N:C.1 = Input:G.0;  
 OR.0 = Add.0;  
 OR.1 = NotZero.0;  //_GUI 134,84
 Junction:J.0 = RegClr.0;  
 INVERT:A.0 = Junction:J.2;  //_GUI 293,73
 Junction:K.0 = UnPackMSB.2;  
 AND:A.0 = INVERT:A.0;  
 AND:A.1 = Junction:K.1;  
 CollectMSB.0 = Junction:G.1;  //_GUI 87,60, 87,71
 CollectMSB.1 = Input:C.0;  
 NotZero.0 = Lo_N:C.0;  //_GUI 46,84, 46,68
}

Object ( Variant Out1) $ReverseBits( Variant Build, Variant Orig) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Variant"
{
 // Date:
 // 10 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Build) Input;  //_GUI 18,21
 Object ( Variant Orig) Input:A;  //_GUI 18,26
 Object Output( Variant Out1) ;  //_GUI 91,26
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 25,24
 Object ( Variant Out1) $ReverseBits( Variant Build, Variant Orig) ;  //_GUI 73,24
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 42,17

 //_ Behavior Topology
 Output.0 = $ReverseBits.0;  
 VariantIn.0 = Input:A.0;  
 $ReverseBits.0 = CollectMSB.0;  //_GUI 58,26, 58,20
 $ReverseBits.1 = VariantIn.0;  
 CollectMSB.0 = VariantIn.1;  //_GUI 39,19, 39,26
 CollectMSB.1 = Input.0;  
}

Object ( Variant Out1) $ReverseBits( Variant Build, Bit Orig) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Leaf"
{
 // Date:
 // 10 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Build) Input;  //_GUI 18,21
 Object ( Bit Orig) Input:A;  //_GUI 18,25
 Object Output( Variant Out1) ;  //_GUI 63,19
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 43,17

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Input:A.0;  //_GUI 37,19, 37,26
 CollectMSB.1 = Input.0;  
}

Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,30
 Object ( Variant In1) Input:A;  //_GUI 12,34
 Object Output( Variant Out1) ;  //_GUI 137,21
 Object Text;  //_GUI 41,2,Remove all MSBs that are the same, except one.
 Object Text;  //_GUI 89,49,If the two MSBs are the same, remove the MSB then recurse.
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 47,29
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 26,32
 //_ Attributes Documentation="bit"
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 67,27
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 67,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 62,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 18,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 21,34
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant D
    , Bit S) ;  //_GUI 67,36
 Object ( Variant "#0", Variant "#1") $SelectOut:C( Variant D
    , Bit S) ;  //_GUI 67,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 42,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In1) ;  //_GUI 62,40
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 96,18
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 123,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 62,50
 Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Variant In1) ;  //_GUI 92,39
 //_ Attributes Documentation="bit/var"
 Object Text;  //_GUI 88,7,If the two MSBs are different, put the MSB back on and we are done.

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Equal.0 = Junction:A.1;  
 Equal.1 = Junction:C.1;  
 ExposeMSB.0 = Junction:B.1;  
 $SelectOut.0 = Junction:B.0;  //_GUI 67,27, 22,27
 $SelectOut.1 = Junction.1;  
 $SelectOut:A.0 = Junction:A.0;  //_GUI 19,20
 $SelectOut:A.1 = Junction.0;  //_GUI 63,23
 Junction.0 = Equal.0;  
 Junction:A.0 = Input.0;  
 Junction:B.0 = Input:A.0;  
 $SelectOut:B.0 = Junction:C.2;  //_GUI 43,38
 $SelectOut:B.1 = Junction:D.1;  
 $SelectOut:C.0 = ExposeMSB.1;  //_GUI 39,48
 $SelectOut:C.1 = Junction:E.1;  
 Junction:C.0 = ExposeMSB.0;  
 Junction:D.0 = Junction.2;  
 CollectLSB.0 = $SelectOut:A.0;  
 CollectLSB.1 = $SelectOut.0;  //_GUI 87,23, 87,29
 $Select.0 = CollectLSB.0;  
 $Select.1 = $Min_Rep_Twos.0;  //_GUI 116,24, 116,42
 $Select.2 = Junction:E.2;  //_GUI 123,58, 63,58
 Junction:E.0 = Junction:D.2;  
 $Min_Rep_Twos.0 = $SelectOut:B.1;  
 $Min_Rep_Twos.1 = $SelectOut:C.1;  //_GUI 85,44, 85,51
}

Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,30
 Object ( Bit In1) Input:A;  //_GUI 12,33
 Object Output( Variant Out1) ;  //_GUI 50,31
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 19,29
 Object Text;  //_GUI 31,43,Min_Rep_Twos(1)=01Min_Rep_Twos(0)=00Min_Rep_Twos(-1)=11Min_Rep_Twos(-2)=10

 //_ Behavior Topology
 Output.0 = CollectLSB.0;  
 CollectLSB.0 = Input.0;  
 CollectLSB.1 = Input:A.0;  
}

Object ( NULL Out1) $Min_Rep_Twos( Bit In1, NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,13
 Object ( NULL In1) Input:A;  //_GUI 10,16
 Object Output( NULL Out1) ;  //_GUI 29,16
 Object ( Bit In) Input:B;  //_GUI 17,21
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 25,21
 //_ Attributes Trap="A two's complement number can't be represented with a single bit."
 Object Text;  //_GUI 18,32,This overload will only get called in the unusual case where the call to Min_Rep_Twos had an input dataset of a contextual dataset that wrapped a single bit.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Variant S) Add_CI( Variant A, Variant B
    , Bit CI) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 15,15
 Object ( Variant B) Input:A;  //_GUI 15,18
 Object ( Bit CI) Input:B;  //_GUI 15,24
 //_ Attributes Constant="0"
 Object Output( Variant S) ;  //_GUI 48,21
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 26,14

 //_ Behavior Topology
 Output.0 = ADSU.2;  
 ADSU.0 = Input.0;  
 ADSU.1 = Input:A.0;  
 ADSU.3 = Input:B.0;  
}

Object ( Variant Remnant, Variant LSB) ListPopLsb( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="list"
{
 // This object removes the least significant element from a list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: The remnant of the list after the least significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the most significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant Remnant) ;  //_GUI 50,18
 Object Output:A( Variant LSB) ;  //_GUI 50,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,17
 Object ( Variant Out1, Variant LSB) $ListPopLsb( Variant In1
    , Variant In2) ;  //_GUI 35,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $ListPopLsb.0;  
 Output:A.0 = $ListPopLsb.1;  
 ListIn.0 = Input.0;  
 $ListPopLsb.0 = ListIn.1;  
 $ListPopLsb.1 = ListIn.0;  
}

Object ( NULL Remnant, Variant LSB) ListPopLsb( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="var"
{
 // This object removes the least significant element from a list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: The remnant of the list after the least significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the most significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,27
 Object Output( NULL Remnant) ;  //_GUI 39,18
 Object Output:A( Variant LSB) ;  //_GUI 39,27
 Object ( NULL Out1) NULL;  //_GUI 16,37

 //_ Behavior Topology
 Output.0 = NULL.0;  //_GUI 26,19
 Output:A.0 = Input.0;  
}

Object ( NULL Remnant, NULL LSB) ListPopLsb( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="NULL"
{
 // This object removes the least significant element from a list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: The remnant of the list after the least significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the most significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,19
 Object Output( NULL Remnant) ;  //_GUI 39,19
 Object Output:A( NULL LSB) ;  //_GUI 39,27
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 22,19

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 23,28
 Junction.0 = Input.0;  
}

Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Variant Constant) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Append) Input;  //_GUI 12,38
 Object ( Variant Constant) Input:A;  //_GUI 12,47
 Object Output( Variant N_Bits) ;  //_GUI 105,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 20,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In3) ;  //_GUI 20,29
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 37,34
 Object Text;  //_GUI 30,9,At each recursive step, the size of the Append data set is doubled and passed on.The LSB of Constant is removed and used in this stage.  The remaining bits are passed on.
 Object Text;  //_GUI 21,56,Remove the LSB.  If it is 1, we concatenate Append with the N_Bits from the inner recursions.
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 35,25
 Object ( Variant Out1, Variant Out1) ExposeLSB( Variant In1) ;  //_GUI 18,45
 //_ Attributes Documentation="Error"
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 75,27
 Object ( NULL Out1) NULL;  //_GUI 23,31
 Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Variant Constant) ;  //_GUI 52,26
 //_ Attributes Documentation="var"

 //_ Behavior Topology
 Output.0 = CollectMSB:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction.0;  
 $Select.0 = NULL.0;  //_GUI 36,36, 36,34
 $Select.1 = Junction.1;  
 $Select.2 = ExposeLSB.1;  //_GUI 33,42, 33,50
 CollectMSB.0 = Junction:A.1;  //_GUI 21,27
 CollectMSB.1 = Junction:A.2;  
 ExposeLSB.0 = Input:A.0;  
 CollectMSB:A.0 = "$Constant->N_Bits".0;  
 CollectMSB:A.1 = $Select.0;  //_GUI 75,37
 "$Constant->N_Bits".0 = CollectMSB.0;  
 "$Constant->N_Bits".1 = ExposeLSB.0;  //_GUI 50,31, 50,47
}

Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Bit Constant) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Append) Input;  //_GUI 11,41
 Object ( Bit Constant) Input:A;  //_GUI 11,44
 Object Output( Variant N_Bits) ;  //_GUI 44,39
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 31,37
 Object Text;  //_GUI 18,11,Here we have the most significant bit of the original Constant.  Append is the number of bits that the MSB represents (if it is 1).Because of MinRep, this bit is guarnteed to be a 1 unless the conatant passed to the base object is zero, so we still need to do a check.
 Object ( NULL Out1) NULL;  //_GUI 17,34

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Select.0 = NULL.0;  //_GUI 30,39, 30,37
 $Select.1 = Input.0;  
 $Select.2 = Input:A.0;  
}

Object ( Variant Hi, List Lo) $BisectList_Low( List List
    , Variant LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 20,32
 Object ( Variant LSB) Input:A;  //_GUI 20,39
 Object Output( Variant Hi) ;  //_GUI 105,31
 Object Output:A( List Lo) ;  //_GUI 105,37
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( List Out1) PackLSB( Variant In1, Variant In2) ;  //_GUI 88,35
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object ( Variant MSB, Variant Out2) ListPopMsb( Variant In1) ;  //_GUI 34,30
 //_ Attributes Documentation="list"
 Object ( Variant Hi, Variant Lo) $BisectList_High( Variant MSB
    , Variant List) ;  //_GUI 53,30
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = $BisectList_High.0;  
 Output:A.0 = PackLSB.0;  
 PackLSB.0 = $BisectList_High.1;  //_GUI 78,37, 78,35
 PackLSB.1 = Input:A.0;  
 ListPopMsb.0 = Input.0;  
 $BisectList_High.0 = ListPopMsb.0;  
 $BisectList_High.1 = ListPopMsb.1;  
}

Object ( Variant Hi, Variant Lo) $BisectList_Low( Variant List
    , Variant LSB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 20,32
 Object ( Variant LSB) Input:A;  //_GUI 20,39
 Object Output( Variant Hi) ;  //_GUI 70,32
 Object Output:A( Variant Lo) ;  //_GUI 96,39
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List MsbList) AppendMsbList( List AnyList, Variant MsbList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 // Works for the var/list and the list/list case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList) Input;  //_GUI 20,42
 Object ( Variant MsbList) Input:A;  //_GUI 20,50
 Object Output( List MsbList) ;  //_GUI 101,42
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) ;  //_GUI 50,46
 Object ( List MsbList) AppendMsbList:A( Variant AnyList, Variant MsbList) ;  //_GUI 79,40

 //_ Behavior Topology
 Output.0 = AppendMsbList:A.0;  
 ListIn.0 = Input.0;  
 AppendMsbList.0 = ListIn.0;  //_GUI 43,48, 43,45
 AppendMsbList.1 = Input:A.0;  
 AppendMsbList:A.0 = ListIn.1;  
 AppendMsbList:A.1 = AppendMsbList.0;  //_GUI 75,45, 75,49
}

Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal"
{
 // Works for the var/var and the list/var case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList) Input;  //_GUI 20,33
 Object ( Variant MsbList) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 69,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 39,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( Variant Data) List_Mux_Sel( Variant ListData, NULL Sel) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,11
 Object ( NULL Sel) Input:A;  //_GUI 23,24
 Object Output( Variant Data) ;  //_GUI 82,11
 Object Text;  //_GUI 25,6,The leaf for a 1-dimention mux where the Sel was not a ZTList.
 Object Text;  //_GUI 18,33,We are not selecting, so pass the data through.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data) List_Mux_Sel( Variant ListData, Variant Sel) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Multiplexers\\Async"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 14,27
 Object ( Variant Sel) Input:A;  //_GUI 15,41
 Object Output( Variant Data) ;  //_GUI 150,36
 Object ( Variant Out1) "2^N_List"( Variant In1) ;  //_GUI 21,25
 Object Text;  //_GUI 18,14,Bring the number of elements up to a power of two.
 Object ( Variant Size) ListSize( Variant List) ;  //_GUI 54,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,27
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 66,32
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 85,33
 //_ Attributes Documentation="ztlist"
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 123,48
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 133,34
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 115,33
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 102,35
 Object ( Variant Out1) 2MinList( Variant In1) ;  //_GUI 39,25
 //_ Attributes Documentation="var"
 Object Text;  //_GUI 38,17,Make at least two elements

 //_ Behavior Topology
 Output.0 = AND.0;  
 "2^N_List".0 = Input.0;  
 ListSize.0 = Junction.2;  //_GUI 52,35
 Junction.0 = 2MinList.0;  
 MaskToNum.0 = ListSize.0;  
 UExtnd.0 = MaskToNum.0;  
 UExtnd.1 = Input:A.0;  //_GUI 85,42
 INVERT.0 = UExtnd.0;  //_GUI 99,51, 99,35
 AND.0 = $List_Mux_Sel.0;  
 AND.1 = INVERT.0;  
 $List_Mux_Sel.0 = Junction.1;  //_GUI 115,28
 $List_Mux_Sel.1 = MSB.0;  
 MSB.0 = UExtnd.1;  
 2MinList.0 = "2^N_List".0;  
}

Object ( Variant Out1, Variant ZeroTheResult) ShiftByFilter( Variant Data
    , Variant ShiftBy) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal"
{
 // Object Name:
 // ShiftByFilter
 //
 // Description:
 // This object shaves down the ShiftBy data set so that it is only large enough to encode the bitlength of the data set to be shifted.  The ShiftByFilter output will roll over if the shift by value exceeds the number of bits of the minimum bit representation needed for the maximum shift by value.  In this case, the ZeroTheResult output will go high and the result of the next stage should be ignored and be replaced with zero (an AND gate).
 //
 // Date:
 // made so won't roll-over
 // 02/04/04
 // added ZeroTheResult instead, faster
 // 07/27/04
 // Removed use of BitLength32, added BitA_Lt_BitB
 // 11/16/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 9,35
 Object ( Variant ShiftBy) Input:A;  //_GUI 11,45
 Object Output( Variant Out1) ;  //_GUI 121,17
 Object Output:A( Variant ZeroTheResult) ;  //_GUI 125,40
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 41,44
 Object Text;  //_GUI 17,6,Get the min rep for the bit length
 Object Text;  //_GUI 42,33,Strip off any high bits
 Object Text;  //_GUI 57,52,IsNull is true if there are no extra bits.
 Object Text;  //_GUI 64,12,If there are extra bits, if any of them are high, we know our shift amount will exceed the bit length of our data and the result is guaranteed to be zero.  Note that we used to have a MUX in here instead of the ZeroTheResult output, which was slower.
 Object Text;  //_GUI 116,50,If there are no extra bits we don't want to zero the result.  Note: Don't use an AND gate instead of $Select becasue no NULL overload available.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 35,48
 Object Text;  //_GUI 77,68,Lo_N will pad if Lo_N input is larger than Data.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 20,45
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 65,62
 Object Text;  //_GUI 40,84,In the case where bitlen(Data) is larger than the shift dataset, we don't wan the Lo_N to pad it.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 20,66
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 48,69
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 22,33
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 90,38
 Object ( Bit "#1") Input:B;  //_GUI 84,42
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 68,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 55,45

 //_ Behavior Topology
 Output.0 = $Select.0;  //_GUI 111,18, 111,65
 Output:A.0 = $Select:A.0;  
 Lo_N.0 = Junction:A.1;  
 Lo_N.1 = Junction.1;  
 Junction.0 = MaskToNum.0;  
 Junction:A.0 = Input:A.0;  
 $Select.0 = Lo_N.1;  //_GUI 51,64
 $Select.1 = Junction:B.1;  
 $Select.2 = BitA_Gt_BitB.0;  //_GUI 65,72
 Junction:B.0 = Junction:A.2;  
 BitA_Gt_BitB.0 = Junction.2;  //_GUI 36,71
 BitA_Gt_BitB.1 = Junction:B.2;  //_GUI 21,74
 MaskToNum.0 = Input.0;  
 $Select:A.0 = Junction:C.0;  //_GUI 56,40
 $Select:A.1 = Input:B.0;  
 $Select:A.2 = IsNULL.0;  
 IsNULL.0 = Junction:C.1;  
 Junction:C.0 = Lo_N.0;  
}

Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Bit IsTwos) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal"
{
 // This object produces an LSB list of all the possible shifts of the data. The Lower part is the carry-off (or falloff) of the data. All the output data elements will be LSB. So for example, the first element of Upper will be the unshifted data, the second element will be the data shifted to the right one bit, etc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 26,11
 Object ( Bit IsTwos) Input:A;  //_GUI 28,29
 //_ Attributes Constant="0"
 Object Output( Variant RightUpper) ;  //_GUI 152,23
 Object Output:A( Variant RightLower) ;  //_GUI 143,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 86,11
 Object ( Bit LSB) Input:B;  //_GUI 72,26
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 116,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 112,31
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 86,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 81,11
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 35,9
 Object ( Variant MSB, Variant Out2) ListPopMsb( Variant In1) ;  //_GUI 133,19
 //_ Attributes Documentation="list"
 Object ( Variant MSB, Variant Out2) ListPopMsb:A( Variant In1) ;  //_GUI 128,31
 //_ Attributes Documentation="list"
 Object Text;  //_GUI 124,12,We don't really need the values from the leaf node
 Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Variant Size, Bit IsTwos) ;  //_GUI 87,22

 //_ Behavior Topology
 Output.0 = ListPopMsb.1;  
 Output:A.0 = ListPopMsb:A.1;  
 Junction.0 = Junction:A.1;  
 ListOut.0 = Junction.1;  //_GUI 111,24, 111,12
 ListOut.1 = PossibleRightShifts.0;  //_GUI 106,21
 ListOut:A.0 = Zero.0;  
 ListOut:A.1 = PossibleRightShifts.1;  //_GUI 106,33
 Zero.0 = Junction:A.2;  //_GUI 82,36
 Junction:A.0 = LSB.0;  
 LSB.0 = Input.0;  
 ListPopMsb.0 = ListOut.0;  
 ListPopMsb:A.0 = ListOut:A.0;  
 PossibleRightShifts.0 = Junction.2;  
 PossibleRightShifts.1 = Input:B.0;  
 PossibleRightShifts.2 = Input:A.0;  
}

Object ( Variant Out1) "2^N_Bits"( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Description:
 // This object produces a data set whose bitlength is 2^N bits, where N is the bitlength of the incoming data set.  The numeric value carried by the data set will be 0.
 //
 // Inputs:
 // In1:
 //
 // Outputs:
 // Out1:
 //
 // Date:
 // 1/7/05
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,37
 Object Output( Variant Out1) ;  //_GUI 89,37
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 74,35
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 36,35
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 66,39
 Object ( Variant Out1) "2^N_Bits"( Variant In1) ;  //_GUI 54,37

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Junction.0;  //_GUI 67,37
 CollectMSB.1 = Junction.1;  
 ExposeMSB.0 = Input.0;  
 Junction.0 = "2^N_Bits".0;  
 "2^N_Bits".0 = ExposeMSB.1;  
}

Object ( Variant Out1) "2^N_Bits"( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // Description:
 // This object produces a data set whose bitlength is 2^N bits, where N is the bitlength of the incoming data set.  The numeric value carried by the data set will be 0.
 //
 // Inputs:
 // In1:
 //
 // Outputs:
 // Out1:
 //
 // Date:
 // 1/7/05
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 28,37
 Object Output( Variant Out1) ;  //_GUI 75,38
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 60,36
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 34,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,37

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Junction.1;  
 CollectMSB.1 = Junction.2;  //_GUI 54,41
 Zero.0 = Input.0;  
 Junction.0 = Zero.0;  
}

Object ( Bit Out1) "2^N_Bits"( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // Description:
 // This object produces a data set whose bitlength is 2^N bits, where N is the bitlength of the incoming data set.  The numeric value carried by the data set will be 0.
 //
 // Inputs:
 // In1:
 //
 // Outputs:
 // Out1:
 //
 // Date:
 // 8/7/05
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 12,15
 Object Output( Bit Out1) ;  //_GUI 34,15
 Object ( Bit In) Input:A;  //_GUI 28,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Val) Encoder( Variant Mask) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\Async"
{
 // A basic encoder.  A set of bits is passed in with one bit, the Xth bit (from LSB), asserted.  This set of bits is encoded into the output, which has the value of X.  If the Mask has anything other than one bit asserted, the output Val is undefined.
 //
 // Inputs:
 //
 // Variant Mask: The bits to be encoded (Only one asserted at a time)
 //
 // Outputs:
 //
 // Variant Val: The resulting encoded value
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Mask) Input;  //_GUI 31,28
 Object Output( Variant Val) ;  //_GUI 53,28
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 37,26

 //_ Behavior Topology
 Output.0 = MaskToNum.0;  
 MaskToNum.0 = Input.0;  
}

Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, Variant ShBy) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 37,32
 Object ( Variant ShBy) Input:A;  //_GUI 37,39
 Object Output( Variant Val) ;  //_GUI 156,31
 Object Output:A( Variant ShiftMask) ;  //_GUI 156,41
 Object Output:B( Variant ShiftNum) ;  //_GUI 156,57
 Object Output:C( Bit Zero) ;  //_GUI 156,78
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 48,45
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 141,55
 Object ( Variant C, Variant Out2) SHL( Variant In1
    , Variant C) ;  //_GUI 49,35
 //_ Attributes Documentation="Bit_Carry"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 44,39
 Object Text;  //_GUI 47,56,If ExposeBIN's input is bit, the top output is NULL
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 80,36
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 129,54
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 86,29
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 66,34
 Object ( Variant O) Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 143,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 120,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In1) ;  //_GUI 44,47
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) ;  //_GUI 128,33
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2) ;  //_GUI 128,41
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 130,75
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 143,76
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In3) ;  //_GUI 123,42
 Object Text;  //_GUI 29,22,Initially ShBy is half the size of Val
 Object Text;  //_GUI 61,17,If any of the most significant ShBy number of bits are high, we pass through the unshifted data.
 Object Text;  //_GUI 99,19,Reduce ShBy by half and recurse.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 126,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In1) ;  //_GUI 126,56
 Object Text;  //_GUI 124,17,If any of the most significant ShBy number of bits are high, we pass through the unshifted ShiftMask.
 Object Text;  //_GUI 139,64,Add a most significant bit to ShiftNum
 Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, Variant ShBy) ;  //_GUI 99,30

 //_ Behavior Topology
 Output.0 = $LeftJustify.0;  
 Output:A.0 = Mux:A.0;  
 Output:B.0 = CollectMSB.0;  
 Output:C.0 = AND.0;  
 ExposeBIN.0 = Junction:D.1;  
 CollectMSB.0 = INVERT.0;  
 CollectMSB.1 = $LeftJustify.2;  //_GUI 118,60, 118,38
 SHL.0 = Junction.2;  //_GUI 44,37
 SHL.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = OR-NInput.0;  
 INVERT.0 = Junction:G.1;  
 Mux.0 = SHL.1;  //_GUI 62,31, 62,40
 Mux.1 = Junction.1;  //_GUI 83,34, 83,33
 Mux.2 = Junction:B.1;  
 OR-NInput.0 = SHL.0;  
 Mux:A.0 = CollectBIN.0;  //_GUI 141,41, 141,36
 Mux:A.1 = CollectBIN:A.0;  
 Mux:A.2 = Junction:F.1;  //_GUI 143,50
 Junction:C.0 = $LeftJustify.1;  
 Junction:D.0 = Junction:A.2;  
 CollectBIN.0 = Junction:C.1;  
 CollectBIN.1 = Junction:E.1;  //_GUI 124,38
 CollectBIN:A.0 = Junction:E.2;  
 CollectBIN:A.1 = Junction:C.2;  //_GUI 121,46
 INVERT:A.0 = Junction:G.2;  //_GUI 127,78
 AND.0 = INVERT:A.0;  
 AND.1 = $LeftJustify.3;  //_GUI 115,81, 115,41
 Junction:E.0 = Junction:D.2;  //_GUI 124,54, 45,54
 Junction:F.0 = Junction:B.2;  //_GUI 81,50
 Junction:G.0 = Junction:F.2;  
 $LeftJustify.0 = Mux.0;  
 $LeftJustify.1 = ExposeBIN.0;  //_GUI 99,47
}

Object ( Variant Val, Variant ShiftMask, NULL ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, NULL ShiftIn) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 28,17
 Object ( NULL ShiftIn) Input:A;  //_GUI 28,32
 Object Output( Variant Val) ;  //_GUI 72,17
 Object Output:A( Variant ShiftMask) ;  //_GUI 72,22
 Object Output:B( NULL ShiftNum) ;  //_GUI 72,32
 Object Output:C( Bit Zero) ;  //_GUI 72,39
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 37,21
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 60,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 55,22

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction:A.1;  
 Output:B.0 = Input:A.0;  
 Output:C.0 = INVERT.0;  
 ExposeMSB.0 = Junction.2;  //_GUI 35,24
 Junction.0 = Input.0;  
 INVERT.0 = Junction:A.2;  //_GUI 56,40
 Junction:A.0 = ExposeMSB.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Gt_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Gt_BitB.0 = MSB.0;  
 $BitA_Gt_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Gt_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Gt_BitB.0 = Input.0;  
 $BitA_Gt_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 17,12
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Gt_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Gt_BitB.0 = MSB.0;  
 $BitA_Gt_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 14,27,( 0 > 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,13
 Object ( Variant In2) Input:A;  //_GUI 11,16
 Object Output( Variant Min) ;  //_GUI 68,14
 Object Output:A( Variant Max) ;  //_GUI 68,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 48,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 44,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 40,13
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,12
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,23
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 26,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 17,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 20,13

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Junction.0 = BitA_Gt_BitB.0;  
 Junction:A.0 = Junction:C.1;  
 Junction:B.0 = Junction:D.1;  
 $Select.0 = Junction:B.1;  
 $Select.1 = Junction:A.1;  
 $Select.2 = Junction.0;  //_GUI 49,20
 $Select:A.0 = Junction:A.2;  //_GUI 45,25
 $Select:A.1 = Junction:B.2;  //_GUI 41,28
 $Select:A.2 = Junction.1;  
 BitA_Gt_BitB.0 = Junction:D.2;  //_GUI 21,30
 BitA_Gt_BitB.1 = Junction:C.2;  //_GUI 18,33
 Junction:C.0 = Input:A.0;  
 Junction:D.0 = Input.0;  
}

Object ( NULL Min, Variant Max) OrderDatasets( NULL In1
    , Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/Var"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 11,13
 Object ( Variant In2) Input:A;  //_GUI 11,16
 Object Output( NULL Min) ;  //_GUI 68,13
 Object Output:A( Variant Max) ;  //_GUI 68,16

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL Min, NULL Max) OrderDatasets( NULL In1
    , NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/NULL"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 11,13
 Object ( NULL In2) Input:A;  //_GUI 11,16
 Object Output( NULL Min) ;  //_GUI 68,13
 Object Output:A( NULL Max) ;  //_GUI 68,16

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL Min, Variant Max) OrderDatasets( Variant In1
    , NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Var/NULL"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,13
 Object ( NULL In2) Input:A;  //_GUI 11,16
 Object Output( NULL Min) ;  //_GUI 68,16
 Object Output:A( Variant Max) ;  //_GUI 68,19

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input.0;  //_GUI 24,20, 24,14
}

Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Ne_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Ne_BitB.0 = MSB.0;  
 $BitA_Ne_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Ne_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,! (0 == 0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Ne_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Ne_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Ne_BitB.0 = Input.0;  
 $BitA_Ne_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Ne_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Var/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 8,24,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12

 //_ Behavior Topology
 Output.0 = $BitA_Ne_BitB.0;  
 $BitA_Ne_BitB.0 = MSB.0;  
 $BitA_Ne_BitB.1 = Input:A.0;  
 MSB.0 = Input.0;  
}

Object ( Bit Add1Exp, Variant Out2) ConvMant( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Changes the size of a floating-point mantissa.  If expanding, adds zeros to the LSB end.  If shrinking, rounds.  Rounding can roll over the mantissa in which case Add1Exp goes high.
 //
 // Inputs:
 //
 // Variant Type: The destination dataset for the mantissa conversion.  This dataset size is without the implied high bit.
 //
 // Variant Data: The floating-point mantissa to be converted.  This dataset does not hold the implied high bit.
 //
 // Outputs:
 //
 // Bit Add1Exp: Indicates that mantissa rolled over from a round after shrinking.
 //
 // Variant output: The mantissa represented in the new dataset.  Implied bit not represented.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 30,55
 Object ( Variant Data) Input:A;  //_GUI 30,59
 Object Output( Bit Add1Exp) ;  //_GUI 155,56
 Object Output:A( Variant Out2) ;  //_GUI 157,67
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 73,55
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 41,58
 Object Text;  //_GUI 75,26,Rounding can roll over mantissa (without explicit bit) [1.]11111111[1111]+[0.]00000001---------------------[10.]00000000 == [1.]00000000 * 2^1Courier New,10,0,0
 Object Text;  //_GUI 42,85,Grab bit for rounding
 Object Text;  //_GUI 32,37,If Type has more bits than Data, Hi_N will zero extend the LSBs of the Hi output to match the size of Type and the Lo output becomes NULL.
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 57,53
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 58,67
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 84,67
 Object ( Bit "#1") Input:B;  //_GUI 78,71
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 74,87
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 73,68
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 100,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 83,81
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 139,54
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 74,56
 //_ Attributes Documentation="Bit"
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 139,65
 Object ( Bit "#1") Input:C;  //_GUI 133,58
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 135,72

 //_ Behavior Topology
 Output.0 = $Select:A.0;  
 Output:A.0 = $Select:B.0;  
 Junction.0 = MSB.0;  
 Hi_N.0 = Input:A.0;  
 Hi_N.1 = Input.0;  //_GUI 39,63, 39,56
 MSB.0 = Hi_N.0;  //_GUI 54,56, 54,60
 PopMsb.0 = Hi_N.1;  //_GUI 54,70, 54,63
 $Select.0 = Junction:A.1;  
 $Select.1 = Input:B.0;  
 $Select.2 = Junction:B.1;  
 IsNULL.0 = Junction:A.2;  
 Junction:A.0 = PopMsb.0;  
 ADSU.0 = Junction.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = $Select.0;  //_GUI 97,65, 97,70
 Junction:B.0 = IsNULL.0;  
 $Select:A.0 = ADSU.0;  
 $Select:A.1 = Input:C.0;  
 $Select:A.2 = Junction:C.1;  //_GUI 136,62
 Zero.0 = Junction.2;  
 $Select:B.0 = ADSU.2;  //_GUI 118,67
 $Select:B.1 = Junction.0;  //_GUI 126,70, 126,52, 74,52
 $Select:B.2 = Junction:C.2;  
 Junction:C.0 = Junction:B.2;  //_GUI 136,82
}

Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) ConvBExp
    ( Variant Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Changes the size of a biased Exponent.  If shrinking, the exponent can overflow (SetToMaxPos) or underflow (SetTo0).
 //
 // Inputs:
 //
 // Variant Type: The destination dataset for the biased exponent conversion.
 //
 // Variant Data: The floating-point biased exponent to be converted.
 //
 // Outputs:
 //
 // Bit SetToMaxPos: Indicates that the incoming exponent value was too large to be represented in the destination dataset.
 //
 // Bit SetTo0: Indicates that the incoming exponent value was too small to be represented in the destination dataset, so just represent the floating-point number as a zero.
 //
 // Variant output: The converted biased exponent.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,39
 Object ( Variant Data) Input:A;  //_GUI 7,48
 Object Output( Bit SetToMaxPos) ;  //_GUI 168,5
 Object Output:A( Bit SetTo0) ;  //_GUI 168,17
 Object Output:B( Variant Out3) ;  //_GUI 168,29
 Object ( Variant "#0", Variant "#1") Deselect( Variant In1
    , Bit S) ;  //_GUI 40,47
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 13,48
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 16,39
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 36,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 36,56
 Object ( Bit Out1) BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 20,31
 Object ( Variant "#0", Variant "#1") Deselect:A( Variant In1
    , Bit S) ;  //_GUI 65,15
 Object ( Variant "#0", Variant "#1") Deselect:B( Variant In1
    , Bit S) ;  //_GUI 65,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 61,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 61,27
 Object ( Variant "#0", Variant "#1") Deselect:C( Variant In1
    , Bit S) ;  //_GUI 40,38
 Object ( Variant Out1) $ConvBExpGrow( Variant Type, Variant Data) ;  //_GUI 86,41
 Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) $ConvBExpShrink
    ( Variant Type, Variant Data) ;  //_GUI 85,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 118,21
 Object ( Bit In) Input:B;  //_GUI 114,3
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 120,3
 Object ( Bit In) Input:C;  //_GUI 134,7
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 140,7
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 138,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 138,22
 Object Text;  //_GUI 39,59,Type > Data
 Object Text;  //_GUI 122,38,Type < Data
 Object Text;  //_GUI 142,39,Type > Data
 Object Text;  //_GUI 64,36,Type < Data
 Object Text;  //_GUI 79,13,Type = Data (pass through)
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 118,33
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 20,54
 Object ( Bit Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,3
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,15
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 143,27
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 124,26
 Object ( Bit Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 124,14
 Object ( Bit Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 124,2

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Output:B.0 = $Select:B.0;  
 Deselect.0 = Junction.1;  
 Deselect.1 = Junction:B.2;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Junction:B.0 = Junction:C.0;  
 Junction:C.0 = BitA_Gt_BitB.0;  
 BitA_Lt_BitB.0 = Junction:A.0;  //_GUI 17,33
 BitA_Lt_BitB.1 = Junction.0;  //_GUI 14,36
 Deselect:A.0 = Deselect:C.0;  //_GUI 53,17, 53,40
 Deselect:A.1 = Junction:E.1;  //_GUI 62,20
 Deselect:B.0 = Deselect.0;  //_GUI 57,25, 57,49
 Deselect:B.1 = Junction:E.2;  
 Junction:D.0 = BitA_Lt_BitB.0;  
 Junction:E.0 = Junction:D.0;  
 Deselect:C.0 = Junction:A.1;  
 Deselect:C.1 = Junction:B.1;  //_GUI 37,43
 $ConvBExpGrow.0 = Deselect:C.1;  
 $ConvBExpGrow.1 = Deselect.1;  //_GUI 61,46, 61,52
 $ConvBExpShrink.0 = Deselect:A.1;  //_GUI 83,25, 83,20
 $ConvBExpShrink.1 = Deselect:B.1;  
 Junction:F.0 = Junction:K.0;  
 Junction:G.0 = Input:B.0;  
 Junction:H.0 = Input:C.0;  
 Junction:I.0 = Junction:C.1;  //_GUI 139,57
 Junction:J.0 = Junction:I.1;  
 Junction:K.0 = Junction:D.1;  
 BitA_Gt_BitB.0 = Junction:A.2;  //_GUI 17,56
 BitA_Gt_BitB.1 = Junction.2;  //_GUI 14,59
 $Select.0 = $Select:E.0;  
 $Select.1 = Junction:H.1;  
 $Select.2 = Junction:J.1;  //_GUI 139,11
 $Select:A.0 = $Select:D.0;  
 $Select:A.1 = Junction:H.2;  //_GUI 141,20
 $Select:A.2 = Junction:J.2;  
 $Select:B.0 = $Select:C.0;  
 $Select:B.1 = $ConvBExpGrow.0;  //_GUI 136,32, 136,44
 $Select:B.2 = Junction:I.2;  
 $Select:C.0 = Deselect:B.0;  //_GUI 116,28, 116,17, 79,17, 79,25
 $Select:C.1 = $ConvBExpShrink.2;  
 $Select:C.2 = Junction:K.1;  
 $Select:D.0 = Junction:G.2;  //_GUI 121,16
 $Select:D.1 = $ConvBExpShrink.1;  //_GUI 113,19, 113,28
 $Select:D.2 = Junction:F.2;  
 $Select:E.0 = Junction:G.1;  
 $Select:E.1 = $ConvBExpShrink.0;  //_GUI 110,7, 110,25
 $Select:E.2 = Junction:F.1;  //_GUI 119,10
}

Object ( Bit Out1) IsFloating( Floating In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Floating"
{
 // Returns true if the input dataset is a Floating dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be Floating.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Floating, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsFloating( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a Floating dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be Floating.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Floating, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsList( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="list"
{
 // Returns true if the input dataset is a List dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be List.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is List, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsList( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a List dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be List.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is List, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsComplex( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a complex dataset.  Returns false in all other cases.  A complex dataset is a contextual dataset of a list of two elements.  The most significant is the real portion and the least significant is the imaginary portion.  The datasets of both portions can be unsigned (MSBxxx, LSBxxx, BINxxx), Signed, Fixed or Floating.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a complex dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Conomplex, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsComplex( Complex In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Complex"
{
 // Returns true if the input dataset is a complex dataset.  Returns false in all other cases.  A complex dataset is a contextual dataset of a list of two elements.  The most significant is the real portion and the least significant is the imaginary portion.  The datasets of both portions can be unsigned (MSBxxx, LSBxxx, BINxxx), Signed, Fixed or Floating.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a complex dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Conomplex, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), =)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 == 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != (!0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != (!0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit IsNeg) Sign( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\$Internal",Documentation="Bit"
{
 // Description:
 // returns the sign of the incoming data.
 //
 // Inputs:
 // In1:  incoming data
 //
 // Outputs:
 // Out1:  sign of data
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 56,34
 Object Output( Bit IsNeg) ;  //_GUI 71,34

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit IsNeg) Sign( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the high bit of the dataset.  This object pulls the high bit off of unsigned datasets as well.
 //
 // Inputs:
 //
 // Variant input: The value to expose the sign bit of.
 //
 // Outputs:
 //
 // Bit IsNeg: The sign bit is high if the value was negative, low if positive.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object Output( Bit IsNeg) ;  //_GUI 52,16
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 18,15
 //_ Attributes Documentation="bit"
 Object Text;  //_GUI 27,33,In all supported datasets the sign bit is the high bit and it is high if the number is negative
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 38,14

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 ExposeMSB.0 = Input.0;  
 VouchBit.0 = ExposeMSB.0;  
}

Object ( Bit OFL, Floating Out1) UnsignedToFloating( Floating Floating
    , Variant Unsigned) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Converts an unsigned integer to the specified floating dataset.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Floating Floating: The destination floating-point dataset.
 //
 // Variant Unsigned: The unsigned integer to be converted into a floating-point value.  Usually this dataset is one of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Bit OFL: Indicates that there was an overflow either in the conversion of the exponent or the mantissa.
 //
 // Floating output: The Uint value converted to the specified Floating dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Floating) Input;  //_GUI 17,32
 Object ( Variant Unsigned) Input:A;  //_GUI 18,97
 Object Output( Bit OFL) ;  //_GUI 272,41
 Object Output:A( Floating Out1) ;  //_GUI 263,53
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 94,29
 //_ Attributes Documentation="Bit"
 Object Text;  //_GUI 4,75,Supports unsigned integers only....Final Exponent if bitlen(Mant) == bitlen(Num):Bias +Bitlen(Num) -NumberOfShifts to left align
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 49,38
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 29,30
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 235,51
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 72,68
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 211,101
 Object ( Bit Implicit) Input:B;  //_GUI 68,69
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Sub) Input:C;  //_GUI 150,46
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 107,39
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 66,45
 //_ Attributes Documentation="PadLeft"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 65,40
 Object Output:B( Bit Trap) ;  //_GUI 83,18
 //_ Attributes Trap="Bitlength of the mantissa exceeds exponent capacity."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 160,46
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 168,47
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 87,88
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 53,47
 Object ( Variant Out1) InvertEn( Variant In1, Bit En) ;  //_GUI 235,39
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 255,39
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 217,25
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 221,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 52,97
 Object Text;  //_GUI 91,70,this will pad right in the case that we are too small on the data input
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 53,87
 Object Text;  //_GUI 105,54,should be constant folding through this
 Object ( Variant MSB, Variant Out2) PopMsb:B( Variant In1) ;  //_GUI 101,92
 Object ( Variant O) RoundUp( Variant Round, Variant D) ;  //_GUI 117,85
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 187,39
 Object Text;  //_GUI 187,90,If the implied bit of the mantissa is 0 then the entire value is zero, so zero the exponent.
 Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) ;  //_GUI 169,39
 Object Text;  //_GUI 89,105,Round only if we don't carry out.
 Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) LeftJustify( Variant Data) ;  //_GUI 62,95

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = CollectFloating.0;  
 Zero.0 = ExposeFloating.0;  
 MakeBias.0 = ExposeFloating.1;  //_GUI 49,35
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = Zero.0;  //_GUI 225,53, 225,32
 CollectFloating.1 = AND.0;  
 CollectFloating.2 = PopMsb.1;  //_GUI 227,59, 227,106
 PushMsb.0 = Input:B.0;  
 PushMsb.1 = ExposeFloating.2;  //_GUI 45,73
 PopMsb.0 = RoundUp.0;  //_GUI 155,104, 155,88
 ADSU.0 = Junction.1;  
 ADSU.1 = UExtnd.1;  //_GUI 81,44, 81,50
 UExtnd.0 = Junction.2;  
 UExtnd.1 = BitLength.0;  
 Junction.0 = MakeBias.0;  
 Output:B.0 = UExtnd.0;  //_GUI 76,19
 Junction:A.0 = Input:C.0;  
 INVERT.0 = Junction:A.2;  //_GUI 161,50
 Hi_N.0 = LeftJustify.0;  //_GUI 78,90
 Hi_N.1 = PushMsb.0;  //_GUI 83,93
 BitLength.0 = PopMsb:A.1;  //_GUI 53,82, 68,82, 68,92
 InvertEn.0 = ADSU:A.0;  
 InvertEn.1 = INVERT:A.0;  //_GUI 230,44, 230,28
 VouchBit.0 = InvertEn.0;  
 INVERT:A.0 = ADSU.0;  //_GUI 136,28, 136,41
 AND.0 = ADSU:A.2;  //_GUI 221,47
 AND.1 = PopMsb.0;  
 Junction:B.0 = Input:A.0;  
 PopMsb:A.0 = Junction:B.0;  
 PopMsb:B.0 = Hi_N.1;  //_GUI 97,95
 RoundUp.0 = PopMsb:B.0;  //_GUI 114,87, 114,94
 RoundUp.1 = Hi_N.0;  
 ADSU:A.0 = SymmetrizeNW.0;  
 ADSU:A.1 = SymmetrizeNW.1;  
 ADSU:A.2 = Junction:A.1;  
 ADSU:A.3 = INVERT.0;  
 SymmetrizeNW.0 = ADSU.2;  //_GUI 142,41, 142,47
 SymmetrizeNW.1 = LeftJustify.2;  //_GUI 146,44, 146,103
 LeftJustify.0 = Junction:B.1;  
}

Object ( Bit OFL, Bit Sign, Variant Unsigned) FromTwos
    ( Variant TwosComp) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced"
{
 // Converts a twos complement value into a sign and magnitude.  The Unsigned output (its magnitude) is the same dataset as the TwosComp input.  A List input will produce List outputs. This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Var/List TwosComp: The input value to be interpreted as a twos complement number.
 //
 // Outputs:
 //
 // Bit/List OFL Goes high if the input was the maximum negative value.  This is the same bit as the high bit of the Unsigned (magnitude) output.  If you use the entire Unsigned output and don't throw away the high bit, this OFL output is unnecessary.
 //
 // Bit/List Sign High if the twos complement input was negative, low if positive.  This value is the same as the high bit of the twos complement input.
 //
 // Var/List Unsigned: The magnitude of the twos complement input.  If you want to consider converting from the maximum negative input value an overflow condition, then you can drop the high bit of this output and use the OFL output for detection.
 //
 // Dataset Coverage:
 //
 // The TwosComp input can be one of the following dataset: MSBxxx, LSBxxx, BINxxx, Signed, Fixed or List.  For the Signed and Fixed datasets, the output datasets are maintained but the Unsigned output is the absolute value of the TwosComp input.
 //
 // Examples:
 //
 // TwosComp	OFL	Sign	Unsigned
 // 000 (0)		0	0	000 (0)
 // 001 (1)		0	0	001 (1)
 // 010 (2)		0	0	010 (2)
 // 011 (3)		0	0	011 (3)
 // 100 (-4)		1	1	100 (4)
 // 101 (-3)		0	1	011 (3)
 // 110 (-2)		0	1	010 (2)
 // 111 (-1)		0	1	001 (1)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant TwosComp) Input;  //_GUI 16,53
 Object Output( Bit OFL) ;  //_GUI 168,13
 Object Output:A( Bit Sign) ;  //_GUI 204,21
 Object Output:B( Variant Unsigned) ;  //_GUI 205,28
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 43,51
 //_ Attributes Documentation="Error"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 119,15
 Object Text;  //_GUI 63,75,Convert from twos compliment, maintaining the same number of bits as the incoming data set.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 113,13
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 26,51
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 193,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 22,53
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 176,19
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 92,12
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 79,11
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In3) ;  //_GUI 61,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In3) ;  //_GUI 55,44
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 68,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In3) ;  //_GUI 55,22

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = VouchBit.0;  
 Output:B.0 = Context.0;  
 ExposeMSB.0 = MSB.0;  
 CollectMSB.0 = Junction.2;  //_GUI 114,17
 CollectMSB.1 = ADSU.2;  
 Junction.0 = ADSU.0;  
 MSB.0 = Junction:A.1;  
 Context.0 = Junction:A.0;  //_GUI 193,7, 23,7
 Context.1 = CollectMSB.0;  //_GUI 149,31, 149,18
 Junction:A.0 = Input.0;  
 VouchBit.0 = Junction:C.2;  //_GUI 169,22, 169,45
 ADSU.0 = Zero.0;  
 ADSU.1 = Junction:B.2;  
 ADSU.2 = INVERT.0;  
 ADSU.3 = Junction:D.2;  
 Zero.0 = Junction:B.1;  //_GUI 62,14
 Junction:B.0 = ExposeMSB.1;  //_GUI 62,56
 Junction:C.0 = ExposeMSB.0;  
 INVERT.0 = Junction:D.1;  //_GUI 56,20
 Junction:D.0 = Junction:C.1;  
}

Object ( List OFL, List Sign, List Unsigned) FromTwos
    ( List TwosComp) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\Async\\Advanced",Documentation="list"
{
 // Converts a twos complement value into a sign and magnitude.  The Unsigned output (its magnitude) is the same dataset as the TwosComp input.  A List input will produce List outputs. This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Var/List TwosComp: The input value to be interpreted as a twos complement number.
 //
 // Outputs:
 //
 // Bit/List OFL Goes high if the input was the maximum negative value.  This is the same bit as the high bit of the Unsigned (magnitude) output.  If you use the entire Unsigned output and don't throw away the high bit, this OFL output is unnecessary.
 //
 // Bit/List Sign High if the twos complement input was negative, low if positive.  This value is the same as the high bit of the twos complement input.
 //
 // Var/List Unsigned: The magnitude of the twos complement input.  If you want to consider converting from the maximum negative input value an overflow condition, then you can drop the high bit of this output and use the OFL output for detection.
 //
 // Dataset Coverage:
 //
 // The TwosComp input can be one of the following dataset: MSBxxx, LSBxxx, BINxxx, Signed, Fixed or List.  For the Signed and Fixed datasets, the output datasets are maintained but the Unsigned output is the absolute value of the TwosComp input.
 //
 // Examples:
 //
 // TwosComp	OFL	Sign	Unsigned
 // 000 (0)		0	0	000 (0)
 // 001 (1)		0	0	001 (1)
 // 010 (2)		0	0	010 (2)
 // 011 (3)		0	0	011 (3)
 // 100 (-4)		1	1	100 (4)
 // 101 (-3)		0	1	011 (3)
 // 110 (-2)		0	1	010 (2)
 // 111 (-1)		0	1	001 (1)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List TwosComp) Input;  //_GUI 19,25
 Object Output( List OFL) ;  //_GUI 90,11
 Object Output:A( List Sign) ;  //_GUI 90,21
 Object Output:B( List Unsigned) ;  //_GUI 90,30
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 77,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 77,28
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 77,9
 Object ( Variant OFL, Variant Sign, Variant Unsigned) FromTwos
    ( Variant TwosComp) ;  //_GUI 40,9
 Object ( Variant OFL, Variant Sign, Variant Unsigned) FromTwos:A
    ( Variant TwosComp) ;  //_GUI 41,25

 //_ Behavior Topology
 Output.0 = ListOut:B.0;  
 Output:A.0 = ListOut.0;  
 Output:B.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = FromTwos:A.1;  //_GUI 64,24, 64,30
 ListOut.1 = FromTwos.1;  //_GUI 70,21, 70,14
 ListOut:A.0 = FromTwos:A.2;  
 ListOut:A.1 = FromTwos.2;  //_GUI 67,30, 67,17
 ListOut:B.0 = FromTwos:A.0;  //_GUI 73,14, 73,27
 ListOut:B.1 = FromTwos.0;  
 FromTwos.0 = ListIn.1;  //_GUI 39,12, 39,25
 FromTwos:A.0 = ListIn.0;  
}

Object ( Bit Error) StaticError( Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\Advanced"
{
 // Description:
 // Reports the presence of a deprecated Static Type.  As Static Types are no longer used to provide context, the presence of any Static Type other than the default Unsigned signifies incorrect data set usage.
 //
 // Inputs:
 // Type: the data set that has been propogated to an operator.
 //
 // Outputs:
 // Error: asserted if the input type has anything other than the default Unsigned attribute.
 //
 // Date:
 // January 26, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 37,22
 Object Output( Bit Error) ;  //_GUI 80,25
 Object ( Variant Out1) OR( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 66,23
 Object ( Bit Unsigned, Bit Signed, Bit "Fixed Point"
    , Bit "Floating Point", Bit Complex) StaticType( Variant Type) ;  //_GUI 43,20
 Object Text;  //_GUI 36,40,Static Types are a deprecated concept in Viva.  Since Context is now exclusively handled via Contextual Data Sets, the Static Type attribute is no longer used.  All grammatical data sets should have the default value of Unsigned.  This object is used in context-sensitive operators to catch and report an error when a user uses old-style static data sets to provide context.  The library operators no longer support static data types, and  as such will treat them all as grammatical Nums (unsigned integers).  When a static type error is found, a library operator will generally issue a warning message and then build the operator the only way it knows how, which is in the context of an unsigned integer.Arial,9,0,0

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = StaticType.1;  
 OR.1 = StaticType.2;  
 OR.2 = StaticType.3;  
 OR.3 = StaticType.4;  
 StaticType.0 = Input.0;  
}

Object ( Variant Out1) $Int2Gray( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,21
 Object ( Bit In2) Input:A;  //_GUI 11,25
 Object Output( Variant Out1) ;  //_GUI 118,25
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 58,20

 //_ Behavior Topology
 Output.0 = XOR.0;  //_GUI 87,26, 87,23
 XOR.0 = Input.0;  
 XOR.1 = Input:A.0;  //_GUI 37,25, 37,26
}

Object ( Variant Out1) $Int2Gray( Bit In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,21
 Object ( Variant In2) Input:A;  //_GUI 11,30
 Object Output( Variant Out1) ;  //_GUI 115,26
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 89,26
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 34,28
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 58,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,29
 Object ( Variant Out1) $Int2Gray( Bit In1, Variant In2) ;  //_GUI 58,28
 //_ Attributes Documentation="bit/var"
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 103,24

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantOut.0 = $Int2Gray.0;  
 VariantOut.1 = XOR.0;  //_GUI 87,28, 87,23
 VariantIn.0 = Input:A.0;  
 XOR.0 = Input.0;  
 XOR.1 = Junction.0;  //_GUI 52,25
 Junction.0 = VariantIn.1;  
 $Int2Gray.0 = Junction.1;  
 $Int2Gray.1 = VariantIn.0;  
 $Cast.0 = VariantOut.0;  
}

Object ( Variant Nout) $Gray2Int( Variant Nin, Bit Shift) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Nin) Input;  //_GUI 6,14
 Object ( Bit Shift) Input:A;  //_GUI 6,17
 Object Output( Variant Nout) ;  //_GUI 47,15
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 33,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 13,14
 Object ( Variant C, Variant Out2) SHR( Variant In1
    , Variant C) ;  //_GUI 17,13
 //_ Attributes Documentation="Var_Carry"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 XOR.0 = Junction.0;  //_GUI 33,10, 14,10
 XOR.1 = SHR.1;  
 Junction.0 = Input.0;  
 SHR.0 = Junction.1;  
 SHR.1 = Input:A.0;  
}

Object ( Variant Nout) $Gray2Int( Variant Nin, Variant Shift) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Nin) Input;  //_GUI 6,13
 Object ( Variant Shift) Input:A;  //_GUI 6,17
 Object Output( Variant Nout) ;  //_GUI 78,15
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 64,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 44,14
 Object ( Variant C, Variant Out2) SHR( Variant In1
    , Variant C) ;  //_GUI 48,13
 //_ Attributes Documentation="Var_Carry"
 Object ( Variant Nout) $Gray2Int( Variant Nin, Variant Shift) ;  //_GUI 31,12
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 15,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 12,17
 Object Text;  //_GUI 5,48,Here is the algorithm for Gray code to Integer:n=Gray;sh=1;while(n>>sh){      n^=(n>>sh);      sh<<=1;}return (n);
 Object Text;  //_GUI 52,48,The while loop in the algorithm has the shift amount starting at 1 and going to when the bits are all shifted out.  Our resursion goes from half the power of 2 bit length down to 1 bit but we do the computation in the reverse order (the same order as the algorithm) since the computation is performed after the exit of each recursion.
 Object Text;  //_GUI 13,26,Split the number of bits in half for the next recursion's shift amount.
 Object Text;  //_GUI 44,28,Shift the previous recursion's result and XOR it with the non-shifted version.

 //_ Behavior Topology
 Output.0 = XOR.0;  
 XOR.0 = Junction.0;  //_GUI 64,10, 45,10
 XOR.1 = SHR.1;  
 Junction.0 = $Gray2Int.0;  
 SHR.0 = Junction.1;  
 SHR.1 = Junction:A.2;  //_GUI 48,24, 13,24
 $Gray2Int.0 = Input.0;  
 $Gray2Int.1 = VariantIn.1;  
 VariantIn.0 = Junction:A.1;  
 Junction:A.0 = Input:A.0;  
}

Object ( Variant OutA, Variant OutB) $RAMBDP( Variant InA
    , Variant InB, Variant AddrA, Variant AddrB, Bit ClkG
    , Bit ClkG, Bit WEA, Bit ENA, Bit WEB
    , Bit ENB) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\$Internal",Documentation="Var/Var"
{
 // $RAMDP - Variant Case
 //
 // If there is not a match for the address then the address is broken down until there is a match.
 //
 // Revision 2 - 11/08/05 Fixed bug 617
 // Description:$RAMBDP (var/var) uses wrong port's address for decode
 //_ Object Prototypes
 Object ( Variant InA) Input;  //_GUI 13,24
 Object ( Variant InB) Input:A;  //_GUI 13,33
 Object ( Variant AddrA) Input:B;  //_GUI 13,47
 Object ( Variant AddrB) Input:C;  //_GUI 13,61
 Object ( Bit ClkG) Input:D;  //_GUI 13,66
 //_ Attributes Resource="Global"
 Object ( Bit ClkG) Input:E;  //_GUI 13,69
 //_ Attributes Resource="Global"
 Object ( Bit WEA) Input:F;  //_GUI 13,75
 Object ( Bit ENA) Input:G;  //_GUI 13,82
 Object ( Bit WEB) Input:H;  //_GUI 13,89
 Object ( Bit ENB) Input:I;  //_GUI 13,96
 Object Output( Variant OutA) ;  //_GUI 241,76
 Object Output:A( Variant OutB) ;  //_GUI 242,128
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In1) ;  //_GUI 141,51
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 193,76
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 106,24
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 86,108
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 66,107
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 60,72
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 100,60
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 41,59
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 97,63
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 94,66
 Object ( Variant Out1) AND:A( Bit In1, Variant In2) ;  //_GUI 154,105
 Object ( Variant Out1) AND:B( Bit In1, Variant In2) ;  //_GUI 179,130
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 161,129
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In1) ;  //_GUI 149,106
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 201,128
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 54,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 91,69
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 111,36
 Object ( Variant Q) Reg:A( Variant D, Bit ClkG) ;  //_GUI 111,45
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 214,126
 Object ( Variant Out1) Cast:A( Variant Type, Variant Data) ;  //_GUI 214,74
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 41,45
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 65,71
 Object ( Variant Out1) AND:D( Bit In1, Variant In2) ;  //_GUI 160,50
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In1) ;  //_GUI 106,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In1) ;  //_GUI 103,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 103,33
 Object ( Bit Out) AND:E( Bit In1, Bit In2) ;  //_GUI 65,85
 Object ( Bit Out) AND:F( Bit In1, Bit In2) ;  //_GUI 86,122
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 79,109
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In0) ;  //_GUI 48,89
 Object ( Variant Out1) AND:G( Bit In1, Variant In2) ;  //_GUI 171,78
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 153,77
 Object ( Bit Out) AND:H( Bit In1, Bit In2) ;  //_GUI 65,78
 Object ( Bit Out) AND:I( Bit In1, Bit In2) ;  //_GUI 65,92
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In1) ;  //_GUI 60,79
 Object ( Bit Out) AND:J( Bit In1, Bit In2) ;  //_GUI 86,115
 Object ( Bit Out) AND:K( Bit In1, Bit In2) ;  //_GUI 86,129
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In0) ;  //_GUI 51,82
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In0) ;  //_GUI 45,96
 Object ( Variant OutA, Variant OutB) $RAMBDP( Variant InA
    , Variant InB, Variant AddrA, Variant AddrB, Bit ClkG
    , Bit ClkG, Bit WEA, Bit ENA, Bit WEB
    , Bit ENB) ;  //_GUI 111,53
 //_ Attributes Documentation="Var/MSB009"
 Object ( Variant OutA, Variant OutB) $RAMBDP:A( Variant InA
    , Variant InB, Variant AddrA, Variant AddrB, Bit ClkG
    , Bit ClkG, Bit WEA, Bit ENA, Bit WEB
    , Bit ENB) ;  //_GUI 111,91
 //_ Attributes Documentation="Var/MSB009"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In0) ;  //_GUI 57,60
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 66,121
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In0) ;  //_GUI 79,123
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In1) ;  //_GUI 57,86
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In1) ;  //_GUI 57,93

 //_ Behavior Topology
 Output.0 = Cast:A.0;  
 Output:A.0 = Cast.0;  
 Junction.0 = VariantIn:A.1;  
 Junction:A.0 = Reg:A.0;  //_GUI 142,48
 OR.0 = AND:D.0;  //_GUI 185,78, 185,53
 OR.1 = AND:G.0;  
 Junction:B.0 = Input.0;  
 AND.0 = Junction:M.1;  
 AND.1 = Junction:H.2;  //_GUI 55,113
 INVERT.0 = Junction:O.2;  //_GUI 61,110
 Junction:C.0 = Junction.2;  
 Junction:D.0 = VariantIn:A.0;  //_GUI 77,61, 77,50
 VariantIn.0 = Input:C.0;  
 Junction:E.0 = VariantIn.0;  
 Junction:F.0 = Input:D.0;  
 AND:A.0 = Junction:G.1;  
 AND:A.1 = $RAMBDP.1;  //_GUI 139,110, 139,58
 AND:B.0 = INVERT:A.0;  
 AND:B.1 = $RAMBDP:A.1;  //_GUI 136,135, 136,96
 INVERT:A.0 = Junction:G.2;  //_GUI 150,132
 Junction:G.0 = Reg.0;  //_GUI 150,39
 OR:A.0 = AND:A.0;  //_GUI 193,130, 193,108
 OR:A.1 = AND:B.0;  
 Junction:H.0 = Input:F.0;  
 Junction:I.0 = Input:E.0;  
 Reg.0 = Junction:R.1;  //_GUI 69,38, 69,61
 Reg.1 = Junction:I.0;  //_GUI 92,41
 Reg:A.0 = Junction.1;  
 Reg:A.1 = Junction:F.0;  //_GUI 95,50
 Cast.0 = Junction:L.1;  //_GUI 209,128, 209,34
 Cast.1 = OR:A.0;  
 Cast:A.0 = Junction:B.1;  //_GUI 211,76, 211,25
 Cast:A.1 = OR.0;  
 VariantIn:A.0 = Input:B.0;  
 AND:C.0 = Junction:C.1;  
 AND:C.1 = Junction:H.1;  
 AND:D.0 = Junction:A.1;  
 AND:D.1 = $RAMBDP.0;  
 Junction:J.0 = Junction:B.2;  
 Junction:K.0 = Junction:L.2;  
 Junction:L.0 = Input:A.0;  
 AND:E.0 = Junction:T.1;  
 AND:E.1 = Junction:N.1;  
 AND:F.0 = Junction:S.1;  
 AND:F.1 = Junction:N.2;  //_GUI 49,127
 Junction:M.0 = INVERT.0;  
 Junction:N.0 = Input:H.0;  
 AND:G.0 = INVERT:B.0;  
 AND:G.1 = $RAMBDP:A.0;  //_GUI 147,83, 147,93
 INVERT:B.0 = Junction:A.2;  //_GUI 142,80
 AND:H.0 = Junction:O.1;  
 AND:H.1 = Junction:P.1;  
 AND:I.0 = Junction:U.1;  
 AND:I.1 = Junction:Q.1;  
 Junction:O.0 = Junction:C.2;  
 AND:J.0 = Junction:M.2;  //_GUI 80,117
 AND:J.1 = Junction:P.2;  //_GUI 52,120
 AND:K.0 = Junction:S.2;  //_GUI 80,131
 AND:K.1 = Junction:Q.2;  //_GUI 46,134
 Junction:P.0 = Input:G.0;  
 Junction:Q.0 = Input:I.0;  
 $RAMBDP.0 = Junction:J.1;  
 $RAMBDP.1 = Junction:K.1;  
 $RAMBDP.2 = Junction:D.1;  
 $RAMBDP.3 = Junction:E.1;  
 $RAMBDP.4 = Junction:F.1;  
 $RAMBDP.5 = Junction:I.1;  
 $RAMBDP.6 = AND:C.0;  //_GUI 82,73, 82,74
 $RAMBDP.7 = AND:H.0;  //_GUI 84,76, 84,81
 $RAMBDP.8 = AND:E.0;  //_GUI 86,79, 86,88
 $RAMBDP.9 = AND:I.0;  //_GUI 88,82, 88,95
 $RAMBDP:A.0 = Junction:J.2;  //_GUI 107,93
 $RAMBDP:A.1 = Junction:K.2;  //_GUI 104,96
 $RAMBDP:A.2 = Junction:D.2;  //_GUI 101,99
 $RAMBDP:A.3 = Junction:E.2;  //_GUI 98,102
 $RAMBDP:A.4 = Junction:F.2;  //_GUI 95,105
 $RAMBDP:A.5 = Junction:I.2;  //_GUI 92,108
 $RAMBDP:A.6 = AND.0;  
 $RAMBDP:A.7 = AND:J.0;  //_GUI 102,114, 102,118
 $RAMBDP:A.8 = AND:F.0;  //_GUI 104,117, 104,125
 $RAMBDP:A.9 = AND:K.0;  //_GUI 106,120, 106,132
 Junction:R.0 = VariantIn.1;  
 INVERT:C.0 = Junction:U.2;  //_GUI 58,124
 Junction:S.0 = INVERT:C.0;  
 Junction:T.0 = Junction:R.2;  
 Junction:U.0 = Junction:T.2;  
}

Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) SyncQueue( Variant Data, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Synchronizers",Documentation="Var/Bit"
{
 // A data synchronizer for joining two or more data flow paths.  The object creates queues for each synchronized data path input. If there is a single Go, a queue will still be built.  To not build a queue in that case, use SyncQueuePass.
 //
 // Inputs:
 //
 // Variant Data: Single data path or list of data paths to synchronize.
 //
 // Bit ClkG: The global user clock if disconnected or a specific clock if connected.
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected.
 //
 // Variant Go: Go of GDBW.  Bit if single unsynchronized data path or a list of Gos, one for each data path to synchronize.
 //
 // Bit Wait: Wait of GDBW.  Defaults to 0 if disconnected.  Tells Done to hold off.
 //
 // Outputs:
 //
 // Variant Data: The single queued data or a list of the synchronized queued data.
 //
 // Bit ClkG: Clock input pass through
 //
 // Bit AClr: Clear input pass through
 //
 // Bit Done: Done of GDBW.  Data valid while high.
 //
 // Variant Busy: Busy of GDBW.  Tells Go (or each individual Go, if a List) to hold off.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 42,14
 Object ( Bit ClkG) Input:A;  //_GUI 42,17
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 42,20
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 42,29
 Object ( Bit Wait) Input:D;  //_GUI 106,40
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 112,6
 Object Output:A( Bit ClkG) ;  //_GUI 112,12
 Object Output:B( Bit AClr) ;  //_GUI 110,17
 Object Output:C( Bit Done) ;  //_GUI 112,29
 Object Output:D( Bit Busy) ;  //_GUI 51,45
 Object Text;  //_GUI 54,4,In the single Go case we are just a queue.
 Object ( MSB004 In) Input:E;  //_GUI 56,23
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit In) Input:F;  //_GUI 56,26
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Q) Reg( Variant D, Bit ClkG) ;  //_GUI 100,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In1) ;  //_GUI 95,12
 Object Text;  //_GUI 69,49,The Reg on the AlmostBusy is fine because AlmostBusySize is one bit, meening AlmostBusy turns on with 14 elements.  The registered Done will allow us to get one more Go in (15) on the next clock before we raise the Done that will stop any more GOs.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 48,17
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 39,43
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 51,20
 Object ( Variant O, Variant Count, Bit AlmBsy
    , Bit Done, Bit Busy) Queue_Shift( Variant D, Bit ClkG
    , Bit CLR, Variant DepthSz, Variant AlmBsySz, Bit Go
    , Bit Wait) ;  //_GUI 68,13

 //_ Behavior Topology
 Output.0 = Queue_Shift.0;  //_GUI 100,7, 100,15
 Output:A.0 = Junction.1;  
 Output:B.0 = Junction:B.0;  //_GUI 93,18, 93,12, 52,12
 Output:C.0 = Queue_Shift.3;  
 Output:D.0 = VouchBit.0;  
 Reg.0 = Queue_Shift.2;  //_GUI 92,23, 92,21
 Reg.1 = Junction.2;  //_GUI 96,26
 Junction.0 = Junction:A.0;  //_GUI 96,10, 49,10
 Junction:A.0 = Input:A.0;  
 VouchBit.0 = Reg.0;  //_GUI 38,46, 38,37, 119,37, 119,24
 Junction:B.0 = Input:B.0;  
 Queue_Shift.0 = Input.0;  
 Queue_Shift.1 = Junction:A.1;  
 Queue_Shift.2 = Junction:B.1;  
 Queue_Shift.3 = Input:E.0;  
 Queue_Shift.4 = Input:F.0;  
 Queue_Shift.5 = Input:C.0;  
 Queue_Shift.6 = Input:D.0;  //_GUI 113,33, 113,41
}

Object ( Variant Data, Bit ClkG, Bit AClr
    , Bit Done, List Busy) SyncQueue( List Data, Bit ClkG
    , Bit AClr, List Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Synchronizers",Documentation="List/List"
{
 // A data synchronizer for joining two or more data flow paths.  The object creates queues for each synchronized data path input. If there is a single Go, a queue will still be built.  To not build a queue in that case, use SyncQueuePass.
 //
 // Inputs:
 //
 // Variant Data: Single data path or list of data paths to synchronize.
 //
 // Bit ClkG: The global user clock if disconnected or a specific clock if connected.
 //
 // Bit AClr: Asynchronous clear.  Has a value of 0 if disconnected.
 //
 // Variant Go: Go of GDBW.  Bit if single unsynchronized data path or a list of Gos, one for each data path to synchronize.
 //
 // Bit Wait: Wait of GDBW.  Defaults to 0 if disconnected.  Tells Done to hold off.
 //
 // Outputs:
 //
 // Variant Data: The single queued data or a list of the synchronized queued data.
 //
 // Bit ClkG: Clock input pass through
 //
 // Bit AClr: Clear input pass through
 //
 // Bit Done: Done of GDBW.  Data valid while high.
 //
 // Variant Busy: Busy of GDBW.  Tells Go (or each individual Go, if a List) to hold off.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Data) Input;  //_GUI 12,36
 Object ( Bit ClkG) Input:A;  //_GUI 12,39
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 12,42
 //_ Attributes Constant="0"
 Object ( List Go) Input:C;  //_GUI 12,51
 Object ( Bit Wait) Input:D;  //_GUI 97,77
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 106,20
 Object Output:A( Bit ClkG) ;  //_GUI 106,24
 Object Output:B( Bit AClr) ;  //_GUI 106,28
 Object Output:C( Bit Done) ;  //_GUI 105,57
 Object Output:D( List Busy) ;  //_GUI 62,84
 Object ( Bit In) Input:E;  //_GUI 27,48
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) EqualZeroList( Variant In1) ;  //_GUI 63,33
 //_ Attributes Documentation="List"
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 103,73
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 22,51
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 62,53
 //_ Attributes Documentation="list"
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 87,33
 Object Text;  //_GUI 103,38,Wait if any queue has zero elements
 Object Text;  //_GUI 53,66,All DONEs will behave the same, so just take one and send it out for our Done.
 Object Text;  //_GUI 96,83,Also Wait if next stage tells us to.
 Object Text;  //_GUI 119,83,Send the same Wait to all of the queues.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 84,24
 Object Text;  //_GUI 104,45,The Reg on the AlmostBusy is fine because AlmostBusySize is one bit, meaning AlmostBusy turns on with 14 elements.  The registered Done will allow us to get one more Go in (15) on the next clock before we raise the Done that will stop any more GOs.
 Object Text;  //_GUI 38,3,We synchronize by waiting until all queues have at least one element.Arial,14,0,0
 Object Text;  //_GUI 40,13,One queue for each Data and Go pair.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 21,39
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 137,67
 Object ( List Out1, List Out2, List Out3) Junction:C
    ( List In3) ;  //_GUI 117,78
 Object ( List Out1, List Out2, List Out3) Junction:D
    ( List In1) ;  //_GUI 22,80
 Object ( MSB004 In) Input:F;  //_GUI 27,45
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 74,55
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 122,74
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 87,41
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 81,28
 Object ( Variant O, Variant Count, Variant AlmBsy
    , Variant Done, Variant Busy) Queue_Shift( Variant D, Bit ClkG
    , Bit CLR, Variant DepthSz, Variant AlmBsySz, Variant Go
    , Variant Wait) ;  //_GUI 37,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 24,42
 Object ( List Out) $Cast( Variant Data, List Type) ;  //_GUI 49,82
 Object ( Variant Out1) Cast:A( Variant Type, Variant Data) ;  //_GUI 27,84
 Object ( List Out1, List Out2, List Out3) Junction:G
    ( List In0) ;  //_GUI 48,80

 //_ Behavior Topology
 Output.0 = Queue_Shift.0;  //_GUI 57,21, 57,37
 Output:A.0 = Junction:A.1;  
 Output:B.0 = Junction:E.1;  
 Output:C.0 = VouchBit.0;  
 Output:D.0 = $Cast.0;  
 EqualZeroList.0 = Queue_Shift.1;  //_GUI 59,36, 59,40
 OR.0 = OR-NInput.0;  //_GUI 101,75, 101,36
 OR.1 = Input:D.0;  
 Junction.0 = Input:C.0;  
 PopLsb.0 = Queue_Shift.3;  //_GUI 58,56, 58,52
 OR-NInput.0 = EqualZeroList.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,25
 Junction:B.0 = Input:A.0;  
 Cast.0 = Junction:C.1;  //_GUI 118,69
 Cast.1 = ListFill.0;  //_GUI 137,77
 Junction:C.0 = Junction:G.1;  //_GUI 118,81
 Junction:D.0 = Junction.2;  
 VouchBit.0 = PopLsb.1;  
 ListFill.0 = OR.0;  
 ListFill.1 = Junction:C.2;  
 RegClr.0 = Queue_Shift.2;  
 RegClr.1 = Junction:A.2;  //_GUI 85,46
 RegClr.3 = Junction:E.2;  //_GUI 82,52
 Junction:E.0 = Junction:F.0;  //_GUI 25,29
 Queue_Shift.0 = Input.0;  
 Queue_Shift.1 = Junction:B.1;  
 Queue_Shift.2 = Junction:F.1;  
 Queue_Shift.3 = Input:F.0;  
 Queue_Shift.4 = Input:E.0;  
 Queue_Shift.5 = Junction.1;  
 Queue_Shift.6 = Cast.0;  //_GUI 55,64, 147,64
 Junction:F.0 = Input:B.0;  
 $Cast.0 = Cast:A.0;  
 $Cast.1 = Junction:G.2;  
 Cast:A.0 = Junction:D.2;  //_GUI 23,86
 Cast:A.1 = RegClr.0;  //_GUI 20,89, 20,75, 99,75, 99,44
 Junction:G.0 = Junction:D.1;  
}

Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 24,24
 Object Output( Variant Out1) ;  //_GUI 68,22
 Object Output:A( Variant Out2) ;  //_GUI 68,25
 Object Output:B( Variant Out3) ;  //_GUI 68,31
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 50,21
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2) UnPackLSB:A( Variant In1) ;  //_GUI 30,22
 //_ Attributes Documentation="Error"

 //_ Behavior Topology
 Output.0 = UnPackLSB.0;  
 Output:A.0 = UnPackLSB.1;  
 Output:B.0 = UnPackLSB:A.1;  //_GUI 46,32, 46,27
 UnPackLSB.0 = UnPackLSB:A.0;  
 UnPackLSB:A.0 = Input.0;  
}

Object ( List Out1, Variant Around) Transpose( List In1
    , List Around) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/list"
{
 // This object transposes a two dimensional list.
 //
 // Inputs:
 //
 // Variant input:	A two-dimensional list.  Each dimension must be a linear list only, which is an MSB or an LSB ordered list, not an arbitrary or a BIN ordered list.
 //
 // Variant Around:	A one-dimensional list representing the end points of the first dimension of the two-dimensional list around which the transposition will occur.
 //
 // Outputs:
 //
 // Variant output:	The transposed two-dimensional list.
 //
 // Variant Around:	A one-dimensional list representing the end points of the first dimension of the output two-dimensional list around which the transposition occurred.  This output can be used to transpose the array again back into its original form by sending the outputs of this transpose into the inputs of another transpose.
 //
 // Examples:
 //
 // A call to Transpose with a 3X2 array input constructed as such:
 // PackLSB(list (A, B), list (C, D), list (E, F))
 // And an Around input of PackLSB (Bit, Bit, Bit)
 // Produces a 2X3 array equivalently constructed as such:
 // list (PackLSB(A, C, E), PackLSB(B, D, F))
 // And an Around output equivalently constructed as such:
 // List (Bit, Bit)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 45,37
 Object ( List Around) Input:A;  //_GUI 45,45
 Object Output( List Out1) ;  //_GUI 114,42
 Object Output:A( Variant Around) ;  //_GUI 109,51
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 51,35
 Object ( List Out1) $TransposeCompose( Variant In1, Variant In2) ;  //_GUI 91,40
 //_ Attributes Documentation="list/list"
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 51,43
 Object ( Variant Out1, Variant Around) Transpose( Variant In1
    , Variant Around) ;  //_GUI 70,35
 //_ Attributes Documentation="list/list"
 Object ( Variant Out1, Variant Around) Transpose:A( Variant In1
    , Variant Around) ;  //_GUI 70,43
 //_ Attributes Documentation="list/list"
 Object Text;  //_GUI 35,17,We use the "around" here to maintain our original list dimension. This allows us to support multidemensional lists without using terminators.
 Object Text;  //_GUI 38,66,this object works with linear (LSB and MSB) lists only.

 //_ Behavior Topology
 Output.0 = $TransposeCompose.0;  
 Output:A.0 = Transpose:A.1;  //_GUI 85,52
 ListIn.0 = Input.0;  
 $TransposeCompose.0 = Transpose.0;  //_GUI 89,42, 89,37
 $TransposeCompose.1 = Transpose:A.0;  
 ListIn:A.0 = Input:A.0;  
 Transpose.0 = ListIn.1;  
 Transpose.1 = ListIn:A.1;  //_GUI 66,40, 66,45
 Transpose:A.0 = ListIn.0;  //_GUI 68,45, 68,43, 64,43, 64,40
 Transpose:A.1 = ListIn:A.0;  
}

Object ( Variant Out1, Variant Around) Transpose( Variant In1
    , Variant Around) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object transposes a two dimensional list.
 //
 // Inputs:
 //
 // Variant input:	A two-dimensional list.  Each dimension must be a linear list only, which is an MSB or an LSB ordered list, not an arbitrary or a BIN ordered list.
 //
 // Variant Around:	A one-dimensional list representing the end points of the first dimension of the two-dimensional list around which the transposition will occur.
 //
 // Outputs:
 //
 // Variant output:	The transposed two-dimensional list.
 //
 // Variant Around:	A one-dimensional list representing the end points of the first dimension of the output two-dimensional list around which the transposition occurred.  This output can be used to transpose the array again back into its original form by sending the outputs of this transpose into the inputs of another transpose.
 //
 // Examples:
 //
 // A call to Transpose with a 3X2 array input constructed as such:
 // PackLSB(list (A, B), list (C, D), list (E, F))
 // And an Around input of PackLSB (Bit, Bit, Bit)
 // Produces a 2X3 array equivalently constructed as such:
 // list (PackLSB(A, C, E), PackLSB(B, D, F))
 // And an Around output equivalently constructed as such:
 // List (Bit, Bit)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 45,37
 Object ( Variant Around) Input:A;  //_GUI 45,45
 Object Output( Variant Out1) ;  //_GUI 101,37
 Object Output:A( Variant Around) ;  //_GUI 101,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 85,37

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 86,44
 Junction.0 = Input.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,21
 Object ( Variant In2) Input:A;  //_GUI 28,24
 Object ( Variant In3) Input:B;  //_GUI 28,28
 Object Output( List Out1) ;  //_GUI 67,26
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 53,24
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 35,20

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:B.0;  
 ListOut.1 = ListOut:A.0;  //_GUI 49,26, 49,23
 ListOut:A.0 = Input:A.0;  
 ListOut:A.1 = Input.0;  
}

Object ( Bit Out1) SameListStruct( List In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="List/List"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,19
 Object ( List In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 83,23
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,17
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,26
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 69,21
 Object ( Bit Out1) $SameListStruct( Variant In1, Variant In2) ;  //_GUI 49,17
 //_ Attributes Documentation="List/List"
 Object ( Bit Out1) $SameListStruct:A( Variant In1, Variant In2) ;  //_GUI 49,26
 //_ Attributes Documentation="List/List"
 Object Text;  //_GUI 15,36,We call the $ level so NULL elements will match Var.The non $ version has empty lists (NULL) not matching Var (single element lists)

 //_ Behavior Topology
 Output.0 = AND.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 AND.0 = $SameListStruct.0;  //_GUI 68,23, 68,20
 AND.1 = $SameListStruct:A.0;  //_GUI 68,26, 68,29
 $SameListStruct.0 = ListIn.1;  
 $SameListStruct.1 = ListIn:A.1;  //_GUI 49,25, 39,25
 $SameListStruct:A.0 = ListIn.0;  //_GUI 45,28, 45,22
 $SameListStruct:A.1 = ListIn:A.0;  
}

Object ( Bit Out1) SameListStruct( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,19
 Object ( Variant In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 32,18,List nodes are same, send out True

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( List In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="List/Variant"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,19
 Object ( Variant In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 32,18,List nodes are different, send out False

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( Variant In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Variant/List"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,19
 Object ( List In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object Text;  //_GUI 32,18,List nodes are different, send out False
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( List In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="List/NULL"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,19
 Object ( NULL In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 32,18,One list is empty, send out False

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( NULL In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/List"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 22,19
 Object ( List In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object Text;  //_GUI 32,18,One list is empty, send out False
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( Variant In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="var/NULL"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,19
 Object ( NULL In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 32,18,One list has one element and the other list is empty, send out False
 Object Text;  //_GUI 32,33,This overload is actually ambiguous because it could also  mean that one list has one element that is a Var and the other list has one element that is a NULL inwhich case we should return a TRUE.  But we can't tell the difference between an empty list (NULL) and a single element list where the element is NULL.  Empty lists are more common than single element lists of NULL, so go with that.Once we recurse past the first List/List level, we call a $SameListStruct object to match NULL elements to Var and NULL elements.  That way a Var/NULL on the first level returns False and a Var/NULL on any other level returns True.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( NULL In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/var"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 22,19
 Object ( Variant In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 28,13,One list has one element and the other list is empty, send out False
 Object Text;  //_GUI 34,34,This overload is actually ambiguous because it could also  mean that one list has one element that is a Var and the other list has one element that is a NULL inwhich case we should return a TRUE.  But we can't tell the difference between an empty list (NULL) and a single element list where the element is NULL.  Empty lists are more common than single element lists of NULL, so go with that.Once we recurse past the first List/List level, we call a $SameListStruct object to match NULL elements to Var and NULL elements.  That way a Var/NULL on the first level returns False and a Var/NULL on any other level returns True.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameListStruct( NULL In2, NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/NULL"
{
 // Description:
 // this object determines whether the list or variant structure of the data presented at the two inputs are similar.  If they are not a zero is returned.
 //
 // Inputs:
 // In1 & In2: input data to be compared.
 //
 // Outputs:
 // Out1:  Boolean True or False output.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 22,19
 Object ( NULL In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object Text;  //_GUI 32,18,Both lists are empty, send out True
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) MustBeConst( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 25,29
 Object Output( Bit Out1) ;  //_GUI 57,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 33,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 33,26
 Object ( Bit Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 41,22

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction.0;  
 $Select.0 = Junction:A.1;  //_GUI 34,24
 $Select.1 = Junction:A.2;  
 $Select.2 = Junction.1;  
}

Object ( Variant Out1) MustBeConst( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 17,29
 Object Output( Variant Out1) ;  //_GUI 86,27
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 31,27
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 61,27
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 74,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 25,29
 Object ( Variant Out1) MustBeConst( Variant In1) ;  //_GUI 44,26
 Object ( Variant Out1) MustBeConst:A( Variant In1) ;  //_GUI 44,29

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = MustBeConst:A.0;  
 VariantOut.1 = MustBeConst.0;  
 Cast.0 = Junction.0;  //_GUI 74,19, 26,19
 Cast.1 = VariantOut.0;  
 Junction.0 = Input.0;  
 MustBeConst.0 = VariantIn.1;  
 MustBeConst:A.0 = VariantIn.0;  
}

Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="Variant"
{
 // Created Nov 2004; this is similar to the N_Bit_LSB_List only it does not fill in the extra length on the last element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 26,15
 Object ( Variant Lo) Input:A;  //_GUI 26,32
 Object ( Variant N) Input:B;  //_GUI 26,42
 Object Output( Variant Data) ;  //_GUI 120,32
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 77,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 38,42
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 41,31
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 67,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 34,32
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 56,36
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 53,38
 Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 96,30
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $NMin_Bit_LSB_List.0;  
 ListOut.0 = $Select.0;  
 ListOut.1 = Input.0;  //_GUI 77,16
 Junction.0 = Input:B.0;  
 Hi_N.0 = Junction:A.1;  
 Hi_N.1 = Junction.0;  //_GUI 39,36
 $Select.0 = Hi_N.0;  
 $Select.1 = Junction:A.0;  //_GUI 63,36, 63,26, 35,26
 $Select.2 = IsNULL.0;  
 Junction:A.0 = Input:A.0;  
 IsNULL.0 = Junction:B.1;  
 Junction:B.0 = Hi_N.1;  //_GUI 54,36
 $NMin_Bit_LSB_List.0 = ListOut.0;  //_GUI 89,32, 89,28
 $NMin_Bit_LSB_List.1 = Junction:B.2;  //_GUI 87,35, 87,50, 54,50
 $NMin_Bit_LSB_List.2 = Junction.1;  //_GUI 90,38, 90,43
}

Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, NULL Lo
    , Variant N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="leaf"
{
 // Nov 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 46,33
 Object ( NULL Lo) Input:A;  //_GUI 47,39
 Object ( Variant N) Input:B;  //_GUI 47,42
 Object Output( Variant Data) ;  //_GUI 77,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data) $NMin_Bit_LSB_List( NULL Hi, Variant Lo
    , Variant N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="NULL"
{
 // Created Nov 2004; this is similar to the N_Bit_LSB_List only it does not fill in the extra length on the last element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 26,15
 Object ( Variant Lo) Input:A;  //_GUI 26,32
 Object ( Variant N) Input:B;  //_GUI 26,42
 Object Output( Variant Data) ;  //_GUI 120,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 38,42
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 41,31
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 67,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 34,32
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 56,36
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 53,38
 Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 96,30
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $NMin_Bit_LSB_List.0;  
 Junction.0 = Input:B.0;  
 Hi_N.0 = Junction:A.1;  
 Hi_N.1 = Junction.0;  //_GUI 39,36
 $Select.0 = Hi_N.0;  
 $Select.1 = Junction:A.0;  //_GUI 63,36, 63,26, 35,26
 $Select.2 = IsNULL.0;  
 Junction:A.0 = Input:A.0;  
 IsNULL.0 = Junction:B.1;  
 Junction:B.0 = Hi_N.1;  //_GUI 54,36
 $NMin_Bit_LSB_List.0 = $Select.0;  //_GUI 77,32
 $NMin_Bit_LSB_List.1 = Junction:B.2;  //_GUI 87,35, 87,50, 54,50
 $NMin_Bit_LSB_List.2 = Junction.1;  //_GUI 90,38, 90,43
}

Object ( Bit CO, Bit OFL, List R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $ADSU_Pipe( List A, List B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="lsb list"
{
 // register each carry and the list
 //
 // Revision 2 - 11/08/05 AClrG to AClr
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 11,17
 Object ( List B) Input:A;  //_GUI 11,25
 Object ( Bit Add) Input:B;  //_GUI 26,54
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 26,57
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 52,72
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 52,75
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 48,93
 Object ( Bit Wait) Input:G;  //_GUI 125,105
 Object Output( Bit CO) ;  //_GUI 189,16
 Object Output:A( Bit OFL) ;  //_GUI 189,19
 Object Output:B( List R) ;  //_GUI 188,34
 Object Output:C( Variant PipeLen) ;  //_GUI 180,68
 Object Output:D( Bit ClkG) ;  //_GUI 177,72
 Object Output:E( Bit AClr) ;  //_GUI 176,75
 Object Output:F( Bit Done) ;  //_GUI 170,93
 Object Output:G( Bit Busy) ;  //_GUI 109,109
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 101,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 105,72
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 24,15
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 24,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 42,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 88,93
 Object ( Variant Size) ListSize( List List) ;  //_GUI 60,82
 //_ Attributes Documentation="List"
 Object ( List Out1, List Out2, List Out3) Junction:D
    ( List In0) ;  //_GUI 18,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 93,84
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 81,72
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 84,75
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 169,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In3) ;  //_GUI 160,96
 Object Text;  //_GUI 24,101,Coming into this operator should be slices of what was once two numbers to be added. We are adding each of the slices starting with the LSB on different clock cycles and passing the carry down.
 Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 68,15
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackBIN( Variant In1) ;  //_GUI 116,15
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 111,80
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 55,47
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 92,16
 Object ( Bit CO, Bit OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $ADSU_Pipe( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 138,15
 //_ Attributes Documentation="lsb list"

 //_ Behavior Topology
 Output.0 = $ADSU_Pipe.0;  
 Output:A.0 = $ADSU_Pipe.1;  
 Output:B.0 = ListOut.0;  
 Output:C.0 = Junction:E.0;  //_GUI 94,69
 Output:D.0 = Junction:A.1;  
 Output:E.0 = Junction.1;  
 Output:F.0 = Reg_Pipe.4;  
 Output:G.0 = Reg_Pipe.5;  //_GUI 104,110, 104,97
 Junction.0 = Junction:G.1;  
 Junction:A.0 = Junction:F.1;  
 ListIn.0 = Junction:D.1;  
 ListIn:A.0 = Input:A.0;  
 Junction:B.0 = Input:B.0;  
 Junction:C.0 = Input:F.0;  
 ListSize.0 = Junction:D.2;  //_GUI 19,85
 Junction:D.0 = Input.0;  
 Junction:E.0 = ListSize.0;  
 Junction:F.0 = Input:D.0;  
 Junction:G.0 = Input:E.0;  
 ListOut.0 = Reg_Pipe.0;  //_GUI 169,51, 147,51, 147,82
 ListOut.1 = $ADSU_Pipe.2;  //_GUI 169,23
 Junction:H.0 = Input:G.0;  //_GUI 161,106
 PackBIN.0 = ListIn.1;  
 PackBIN.1 = ListIn:A.1;  //_GUI 41,20, 41,25
 PackBIN.2 = Junction:B.0;  //_GUI 43,23
 PackBIN.3 = ADSU.0;  //_GUI 55,26, 55,49
 UnPackBIN.0 = RegOnGo.0;  
 Reg_Pipe.0 = ADSU.2;  //_GUI 111,55
 Reg_Pipe.1 = Junction:E.1;  
 Reg_Pipe.2 = Junction:A.2;  //_GUI 106,88
 Reg_Pipe.3 = Junction.2;  //_GUI 102,91
 Reg_Pipe.4 = Junction:C.1;  
 Reg_Pipe.5 = Junction:H.0;  
 ADSU.0 = ListIn.0;  //_GUI 38,49, 38,20
 ADSU.1 = ListIn:A.0;  //_GUI 35,52
 ADSU.2 = Junction:B.1;  
 ADSU.3 = Input:C.0;  
 RegOnGo.0 = PackBIN.0;  
 RegOnGo.1 = Junction:F.0;  //_GUI 82,21
 RegOnGo.2 = Junction:G.0;  //_GUI 85,24
 RegOnGo.3 = Junction:C.0;  //_GUI 89,27
 RegOnGo.4 = $ADSU_Pipe.7;  //_GUI 105,30, 105,38
 $ADSU_Pipe.0 = UnPackBIN.0;  
 $ADSU_Pipe.1 = UnPackBIN.1;  
 $ADSU_Pipe.2 = UnPackBIN.2;  
 $ADSU_Pipe.3 = UnPackBIN.3;  
 $ADSU_Pipe.4 = RegOnGo.1;  //_GUI 113,29, 113,21
 $ADSU_Pipe.5 = RegOnGo.2;  //_GUI 111,32, 111,24
 $ADSU_Pipe.6 = RegOnGo.3;  //_GUI 108,35, 108,27
 $ADSU_Pipe.7 = Junction:H.1;  //_GUI 161,38
}

Object ( Bit CO, Bit OFL, Variant R
    , Bit PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $ADSU_Pipe( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="leaf"
{
 // register each carry and the list
 //
 // Revision 2 - 11/08/05 AClrG to AClr
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,17
 Object ( Variant B) Input:A;  //_GUI 13,24
 Object ( Bit Add) Input:B;  //_GUI 26,54
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 26,57
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:D;  //_GUI 52,72
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 52,75
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:F;  //_GUI 48,90
 Object ( Bit Wait) Input:G;  //_GUI 125,102
 Object Output( Bit CO) ;  //_GUI 182,49
 Object Output:A( Bit OFL) ;  //_GUI 192,52
 Object Output:B( Variant R) ;  //_GUI 171,55
 Object Output:C( Bit PipeLen) ;  //_GUI 175,65
 Object Output:D( Bit ClkG) ;  //_GUI 177,72
 Object Output:E( Bit AClr) ;  //_GUI 176,75
 Object Output:F( Bit Done) ;  //_GUI 170,90
 Object Output:G( Bit Busy) ;  //_GUI 109,106
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 101,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 105,72
 Object ( Bit In) Input:H;  //_GUI 169,65
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackBIN
    ( Variant In1) ;  //_GUI 152,48
 Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 100,47
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 166,47
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 179,50
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 49,47
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 112,80

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = VouchBit:A.0;  
 Output:B.0 = UnPackBIN.2;  
 Output:C.0 = Input:H.0;  
 Output:D.0 = Junction:A.1;  
 Output:E.0 = Junction.1;  
 Output:F.0 = RegOnGo.3;  
 Output:G.0 = RegOnGo.4;  //_GUI 104,107, 104,94
 Junction.0 = Input:E.0;  
 Junction:A.0 = Input:D.0;  
 UnPackBIN.0 = RegOnGo.0;  //_GUI 150,51, 150,82
 PackBIN.0 = ADSU.0;  
 PackBIN.1 = ADSU.1;  
 PackBIN.2 = ADSU.2;  
 VouchBit.0 = UnPackBIN.0;  
 VouchBit:A.0 = UnPackBIN.1;  
 ADSU.0 = Input.0;  //_GUI 38,49, 38,18
 ADSU.1 = Input:A.0;  //_GUI 35,52, 35,25
 ADSU.2 = Input:B.0;  
 ADSU.3 = Input:C.0;  
 RegOnGo.0 = PackBIN.0;  //_GUI 111,82
 RegOnGo.1 = Junction:A.2;  //_GUI 106,85
 RegOnGo.2 = Junction.2;  //_GUI 102,88
 RegOnGo.3 = Input:F.0;  
 RegOnGo.4 = Input:G.0;  //_GUI 161,94, 161,103
}

Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 16,27
 Object ( Variant B) Input:A;  //_GUI 16,30
 Object ( Bit Add) Input:B;  //_GUI 16,59
 //_ Attributes Constant="1"
 Object ( Bit ClkG) Input:C;  //_GUI 16,65
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 16,68
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 16,71
 Object ( Bit Wait) Input:F;  //_GUI 127,77
 Object Output( Bit OFL) ;  //_GUI 128,44
 Object Output:A( Variant R) ;  //_GUI 128,51
 Object Output:B( Variant PipeLen) ;  //_GUI 128,56
 Object Output:C( Bit ClkG) ;  //_GUI 128,59
 Object Output:D( Bit AClr) ;  //_GUI 128,62
 Object Output:E( Bit Done) ;  //_GUI 128,71
 Object Output:F( Bit Busy) ;  //_GUI 17,77
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 22,26
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 55,40
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 116,49
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 40,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In3) ;  //_GUI 33,18
 Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 61,33
 //_ Attributes Documentation="Variant"
 Object ( NULL Out1) NULL;  //_GUI 42,24
 Object ( Variant Data) $NMin_Bit_LSB_List:A( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 65,14
 //_ Attributes Documentation="Variant"
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:B
    ( NULL In0) ;  //_GUI 60,26
 Object Text;  //_GUI 14,49,The Symmetrize will line up the decimal point on the fixed dataset.
 Object ( Variant BitsPerStageSG) Input:G;  //_GUI 48,45
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 40,16
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 81,60
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 76,59
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 89,12
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) $Add_Pipe
    ( Variant A, Variant B, Variant OrigDs, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 93,49
 //_ Attributes Documentation="lsb list"

 //_ Behavior Topology
 Output.0 = $Add_Pipe.0;  //_GUI 111,45, 111,51
 Output:A.0 = Context.0;  
 Output:B.0 = $Add_Pipe.2;  
 Output:C.0 = $Add_Pipe.3;  
 Output:D.0 = $Add_Pipe.4;  
 Output:E.0 = $Add_Pipe.5;  
 Output:F.0 = $Add_Pipe.6;  //_GUI 17,75
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
 Junction.0 = Input:G.0;  //_GUI 54,41, 54,46
 Context.0 = Junction:D.1;  //_GUI 114,51, 114,13
 Context.1 = $Add_Pipe.1;  
 MSB.0 = Symmetrize.1;  //_GUI 34,38
 Junction:A.0 = Symmetrize.0;  
 $NMin_Bit_LSB_List.0 = Junction:B.2;  
 $NMin_Bit_LSB_List.1 = MSB.0;  
 $NMin_Bit_LSB_List.2 = Junction.1;  
 $NMin_Bit_LSB_List:A.0 = Junction:B.0;  //_GUI 61,16
 $NMin_Bit_LSB_List:A.1 = MSB:A.0;  
 $NMin_Bit_LSB_List:A.2 = Junction.0;  //_GUI 56,22
 Junction:B.0 = NULL.0;  
 MSB:A.0 = Junction:A.2;  
 INVERT.0 = Junction:C.2;  //_GUI 77,63
 Junction:C.0 = Input:B.0;  
 Junction:D.0 = Junction:A.1;  //_GUI 34,13
 $Add_Pipe.0 = $NMin_Bit_LSB_List:A.0;  //_GUI 87,51, 87,17
 $Add_Pipe.1 = $NMin_Bit_LSB_List.0;  //_GUI 83,54, 83,36
 $Add_Pipe.2 = Junction:D.2;  //_GUI 90,57
 $Add_Pipe.3 = Junction:C.1;  
 $Add_Pipe.4 = INVERT.0;  
 $Add_Pipe.5 = Input:C.0;  
 $Add_Pipe.6 = Input:D.0;  
 $Add_Pipe.7 = Input:E.0;  
 $Add_Pipe.8 = Input:F.0;  //_GUI 131,75
}

Object ( Bit OFL, Variant S, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Floating A, Floating B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Floating"
{
 // Instructions inside....
 //
 // Updated:
 // Oct 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating A) Input;  //_GUI 27,133
 Object ( Floating B) Input:A;  //_GUI 27,136
 Object ( Bit Add) Input:B;  //_GUI 49,197
 //_ Attributes Constant="1"
 Object ( Bit ClkG) Input:C;  //_GUI 112,232
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 112,235
 Object ( Bit Go) Input:E;  //_GUI 118,247
 Object ( Bit Wait) Input:F;  //_GUI 1053,260
 Object Output( Bit OFL) ;  //_GUI 1101,85
 Object Output:A( Variant S) ;  //_GUI 1101,91
 Object Output:B( Variant PipeLen) ;  //_GUI 1101,96
 Object Output:C( Bit ClkG) ;  //_GUI 1059,103
 Object Output:D( Bit AClr) ;  //_GUI 1059,106
 Object Output:E( Bit Done) ;  //_GUI 1059,271
 Object Output:F( Bit Busy) ;  //_GUI 147,276
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 104,129
 Object Text;  //_GUI 530,152,if we're high in the top data bit (CO), which is likely, we need to increment the exponent
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 542,168
 Object Text;  //_GUI 709,268,So if our top bit is high (this was the extra bit we added to catch the co on the mantissa add) then we need to add one to the exponent and use the rest of the bits without the lsb as the mantissa resultotherwise we toss the top bitand we shift the thing so that the top bit is setand we subtract from the exponent that number of shiftsand we toss the top bit for our result
 Object Text;  //_GUI 492,73,yikes: if the mantissa ADSU resulted in a zero we need to zero the exponent; one of our top two data bits (after shift) has to be high or we ended up with zero; we subtract off the whole exponent to make it that way if necessary
 Object Text;  //_GUI 133,274,This is a compare: we could do the FromTwos on the S (which would make more sense), but that would lengthen the already long logic path; instead we just Subtract the other direction in parallel.
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 632,91
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 36,132
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 324,119
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 629,273
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 518,230
 Object Text;  //_GUI 8,31,Special Operations (not all of these are implemented)Operations on special numbers are well-defined by IEEE. In the simplest case, any operation with a NaN yields a NaN result. Other operations are as follows:Operation	 	Resultn / Infinity 	0Infinity x Infinity 	Infinitynonzero / 0 	InfinityInfinity + Infinity 	Infinity0 / 0 		NaNInfinity - Infinity 	NaNInfinity / Infinity 	NaNInfinity x 0 	NaNfromhttp://stevehollasch.com/cgindex/coding/ieeefloat.html
 Object Text;  //_GUI 188,7,Infinity = all the exponent bits high and the significand bits lowNaN = QNaN or SNaNQNaN = all the exponent bits high and the MSB significand bit highSNaN = all the exponent bits high and the MSB significand bit low (other significand bits high)Zero = all bits low, not including the sign bit
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 743,111
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 325,61
 Object Text;  //_GUI 343,101,either being NaN triggers OFL
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 351,62
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 442,94
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 330,96
 Object Text;  //_GUI 649,26,Infinity + Infinity = Infinity, or so the IEEE saysThat means if we're adding and we CO then we fill the exp data high. If we're subtracting and we OFL then we fill the exponent high as well.
 Object Text;  //_GUI 367,37,possibilities (subraction handled by sign negation):adding and both negativeadding and both positiveadding and the top negative (OFL)adding and the bottom negative (OFL)
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 61,195
 Object Text;  //_GUI 33,187,if we're subtracting then we negate the sign on the lower input
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 341,67
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 285,68
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 324,197
 //_ Attributes Documentation="Bit"
 Object ( Variant O) $Mux:B( Variant A, Variant B
    , Bit S) ;  //_GUI 324,213
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 318,204
 Object ( Variant O) $Mux:C( Variant A, Variant B
    , Bit S) ;  //_GUI 324,177
 //_ Attributes Documentation="Bit"
 Object ( Variant O) $Mux:D( Variant A, Variant B
    , Bit S) ;  //_GUI 324,155
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 318,184
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In1) ;  //_GUI 318,162
 Object Text;  //_GUI 302,225,We put these muxs in here to avoid having to have two Barrel Shifters and rounders
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 318,129
 Object Text;  //_GUI 72,3,So the plan here is this:1. Figure out which one has the larger exponent2. Scale the smaller one to have the same exponent as the larger one3. Add a bit and convert the numbers to twos compliment depending upon the sign bit4. Perform the add'5. If there's a CO, dec/inc the exponent6. Scale the result to fit the implicit bit model
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 1015,145
 Object ( Bit OFL, Bit ERNG_Data, Bit ERNG_FallOff
    , Bit Round, Variant FallOff, Variant Data) ShiftRightBy( Variant Data
    , Variant ShiftBy, Bit IsTwos) ;  //_GUI 342,178
 //_ Attributes Documentation="barrel with ranges"
 Object ( Variant O) $Mux:E( Variant A, Variant B
    , Bit S) ;  //_GUI 324,142
 //_ Attributes Documentation="Variant"
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 341,213
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In1) ;  //_GUI 318,149
 Object ( Bit SUB) Input:G;  //_GUI 141,132
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 458,187
 Object Text;  //_GUI 919,43,If OFL triggers, that's technically a NaN. You should OR the OFL bit with the high bit of the mantissa and the exponent bits in the case where you care about NaNs.Arial,20,255,1
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In1) ;  //_GUI 522,186
 Object ( Bit SUB) Input:H;  //_GUI 141,158
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 441,126,So because we're doing an ADSU and because we have sufficient accuracy for the lone sign bit as well as the carry out, we can get away with One's complement instead of Twos.
 Object ( Variant O) $Mux:F( Variant A, Variant B
    , Bit S) ;  //_GUI 679,206
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 952,167
 Object Text;  //_GUI 742,79,!UFL
 Object Text;  //_GUI 654,71,mant !=0(zero exp if mant = 0)
 Object Text;  //_GUI 888,71,The OFL on the extend means that the encoded mantissa is larger than the exponent dataset. This is likely an error in the design of the dataset, but we will try to handle the case anyway. It is unlikely that BitLen(MaskToNum(mantissa)) - BitLen(Exponent) > BitsPerStageSG so we won't worry about the timing on the NotZero for it.
 Object ( Bit SUB) Input:I;  //_GUI 680,94
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 530,231
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 531,232
 Object ( Variant O) $Mux:G( Variant A, Variant B
    , Bit S) ;  //_GUI 646,262
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant LSB) PopLsb:A( Variant In1) ;  //_GUI 608,261
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 607,275
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 627,258
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 622,269
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 682,113
 Object ( Variant O) $Mux:H( Variant A, Variant B
    , Bit S) ;  //_GUI 929,119
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AND:C( Variant In1, Variant In2) ;  //_GUI 742,90
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 728,84
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 647,62
 Object ( Variant O) $Mux:I( Variant A, Variant B
    , Bit S) ;  //_GUI 930,166
 //_ Attributes Documentation="Variant"
 Object ( Bit Out) AND:E( Bit In1, Bit In2) ;  //_GUI 900,165
 Object ( Bit Out) INVERT:D( Bit In1) ;  //_GUI 942,166
 Object ( Variant Out1, Variant LSB) PopLsb:B( Variant In1) ;  //_GUI 654,162
 Object ( Variant Out1, Variant LSB) PopLsb:C( Variant In1) ;  //_GUI 664,155
 Object ( Bit Out) AND:F( Bit In1, Bit In2) ;  //_GUI 674,162
 Object ( Bit Out) AND:G( Bit In1, Bit In2) ;  //_GUI 890,153
 Object ( Variant Out1, Variant LSB) PopLsb:D( Variant In1) ;  //_GUI 880,141
 Object ( Variant Out1, Variant LSB) PopLsb:E( Variant In1) ;  //_GUI 890,138
 Object ( Bit Out) AND:H( Bit In1, Bit In2) ;  //_GUI 904,141
 Object ( Bit Out) AND:I( Bit In1, Bit In2) ;  //_GUI 914,145
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 145,151
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 1046,99
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In3) ;  //_GUI 309,201
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In3) ;  //_GUI 306,198
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:M
    ( Variant In0) ;  //_GUI 99,153
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In1) ;  //_GUI 109,155
 Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 141,175
 Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 141,228
 Object Text;  //_GUI 328,132,So A has the larger exponent; that means we shift B
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In3) ;  //_GUI 489,124
 Object ( Variant Out1) PushMsb:A( Variant MSB, Variant In2) ;  //_GUI 532,141
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 652,213
 Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe:B( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 708,188
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:P
    ( Variant In0) ;  //_GUI 926,173
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Q
    ( Variant In0) ;  //_GUI 675,217
 Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe:C( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 708,137
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In3) ;  //_GUI 622,259
 Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 682,221
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackBIN
    ( Variant In1) ;  //_GUI 902,182
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:S
    ( Variant In1) ;  //_GUI 878,123
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In2) ;  //_GUI 704,184
 Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) ;  //_GUI 813,93
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In3) ;  //_GUI 690,68
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:V
    ( Variant In0) ;  //_GUI 727,198
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:W
    ( Variant In0) ;  //_GUI 723,97
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:X
    ( Variant In3) ;  //_GUI 773,109
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Y
    ( Variant In3) ;  //_GUI 773,112
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Z
    ( Bit In0) ;  //_GUI 783,124
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:a
    ( Bit In3) ;  //_GUI 784,139
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:b
    ( Bit In3) ;  //_GUI 784,142
 Object Text;  //_GUI 772,43,We are making a bold assumption here that none of these will output a NULL pipelength or data piece.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:c
    ( Variant In2) ;  //_GUI 719,109
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 1065,84
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 1089,83
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 1035,90
 Object ( Variant Out1) PushMsb:B( Variant MSB, Variant In2) ;  //_GUI 444,171
 Object ( Variant Out1) PushMsb:C( Variant MSB, Variant In2) ;  //_GUI 296,206
 Object ( Variant Out1) PushMsb:D( Variant MSB, Variant In2) ;  //_GUI 296,198
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 1064,193
 Object ( Bit In) Input:J;  //_GUI 1058,194
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) PushLsb:A( Variant In1, Variant LSB) ;  //_GUI 955,195
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:d
    ( Bit In3) ;  //_GUI 694,71
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:e
    ( Bit In3) ;  //_GUI 694,100
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:f
    ( Bit In3) ;  //_GUI 694,124
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:AA
    ( Bit In3) ;  //_GUI 694,141
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:BA
    ( Bit In3) ;  //_GUI 694,170
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:CA
    ( Bit In3) ;  //_GUI 694,192
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:DA
    ( Bit In3) ;  //_GUI 694,229
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:EA
    ( Bit In3) ;  //_GUI 696,74
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:FA
    ( Bit In3) ;  //_GUI 696,103
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:GA
    ( Bit In3) ;  //_GUI 696,127
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:HA
    ( Bit In3) ;  //_GUI 696,144
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:IA
    ( Bit In3) ;  //_GUI 696,173
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:JA
    ( Bit In3) ;  //_GUI 696,195
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:KA
    ( Bit In3) ;  //_GUI 696,232
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:LA
    ( Variant In3) ;  //_GUI 558,146
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:MA
    ( Variant In3) ;  //_GUI 558,124
 Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe:A
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) ;  //_GUI 601,201
 Object ( List Out1) PackBIN:A( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 586,95
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackBIN:A( Variant In1) ;  //_GUI 604,84
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 575,188
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 616,185
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 562,230
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 587,268
 Object ( List Out) ListOut:C( Variant In1, Variant In2) ;  //_GUI 573,200
 Object ( List Out) ListOut:D( Variant In1, Variant In2) ;  //_GUI 575,209
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:NA
    ( Variant In0) ;  //_GUI 558,198
 Object ( List Out) ListOut:E( Variant In1, Variant In2) ;  //_GUI 578,217
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:OA
    ( Bit In0) ;  //_GUI 591,240
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:PA
    ( Bit In0) ;  //_GUI 594,243
 Object ( Variant Out1, Variant Out2) ListIn:C( List In) ;  //_GUI 609,229
 Object ( Variant Out1, Variant Out2) ListIn:D( List In) ;  //_GUI 622,200
 Object ( Variant Out1) PushLsb:B( Variant In1, Variant LSB) ;  //_GUI 678,251
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:QA
    ( Bit In0) ;  //_GUI 699,235
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:RA
    ( Bit In3) ;  //_GUI 699,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:SA
    ( Bit In3) ;  //_GUI 699,106
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:TA
    ( Bit In3) ;  //_GUI 699,130
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:UA
    ( Bit In3) ;  //_GUI 699,156
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:VA
    ( Bit In3) ;  //_GUI 699,176
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:WA
    ( Bit In3) ;  //_GUI 699,207
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:XA
    ( Bit In1) ;  //_GUI 509,207
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:YA
    ( Variant In0) ;  //_GUI 520,172
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:ZA
    ( Bit In0) ;  //_GUI 560,133
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:aA
    ( Bit In0) ;  //_GUI 556,127
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:bA
    ( Bit In0) ;  //_GUI 554,130
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:cA
    ( Variant In3) ;  //_GUI 554,210
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:dA
    ( Variant In3) ;  //_GUI 590,136
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:eA
    ( Variant In3) ;  //_GUI 590,158
 Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe:D( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 145,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:fA
    ( Variant In0) ;  //_GUI 281,71
 Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe:E( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 141,75
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:AB
    ( Variant In0) ;  //_GUI 95,105
 Object ( List Out) ListOut:F( Variant In1, Variant In2) ;  //_GUI 106,200
 Object ( Variant Out1, Variant Out2) ListIn:E( List In) ;  //_GUI 265,201
 Object Text;  //_GUI 53,127,NaN and Infinity are handled by the pipe here, instead of using the exposer's internal gates
 Object ( Variant Out1, Variant Out2) ListIn:F( List In) ;  //_GUI 304,119
 Object ( List Out) ListOut:G( Variant In1, Variant In2) ;  //_GUI 110,104
 Object ( Bit Out) AND:J( Bit In1, Bit In2) ;  //_GUI 313,84
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:BB
    ( Variant In0) ;  //_GUI 91,156
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:CB
    ( Variant In3) ;  //_GUI 289,96
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:DB
    ( Variant In3) ;  //_GUI 298,88
 Object ( Bit Out) AND:K( Bit In1, Bit In2) ;  //_GUI 313,92
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:EB
    ( Bit In0) ;  //_GUI 129,232
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:FB
    ( Bit In3) ;  //_GUI 129,79
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:GB
    ( Bit In3) ;  //_GUI 129,112
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:HB
    ( Bit In3) ;  //_GUI 129,138
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:IB
    ( Bit In3) ;  //_GUI 129,161
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:JB
    ( Bit In3) ;  //_GUI 129,179
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:KB
    ( Bit In3) ;  //_GUI 129,208
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:LB
    ( Bit In0) ;  //_GUI 132,235
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:MB
    ( Bit In3) ;  //_GUI 132,82
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:NB
    ( Bit In3) ;  //_GUI 132,115
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:OB
    ( Bit In3) ;  //_GUI 132,141
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:PB
    ( Bit In3) ;  //_GUI 132,164
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:QB
    ( Bit In3) ;  //_GUI 132,182
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:RB
    ( Bit In3) ;  //_GUI 132,211
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:SB
    ( Bit In0) ;  //_GUI 135,247
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:TB
    ( Bit In3) ;  //_GUI 135,94
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:UB
    ( Bit In3) ;  //_GUI 135,118
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:VB
    ( Bit In3) ;  //_GUI 135,144
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:WB
    ( Bit In3) ;  //_GUI 135,167
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:XB
    ( Bit In3) ;  //_GUI 135,194
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:YB
    ( Bit In3) ;  //_GUI 135,214
 Object ( List Out) ListOut:H( Variant In1, Variant In2) ;  //_GUI 110,54
 Object ( Variant Out1, Variant Out2) ListIn:G( List In) ;  //_GUI 269,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:ZB
    ( Bit In3) ;  //_GUI 129,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:aB
    ( Bit In3) ;  //_GUI 132,65
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:bB
    ( Bit In3) ;  //_GUI 135,68
 Object ( List Out1) PackBIN:B( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7) ;  //_GUI 780,93
 Object ( List Out1) PackBIN:C( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7) ;  //_GUI 789,123
 Object ( List Out1) PackBIN:D( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7) ;  //_GUI 781,62
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) UnPackBIN:B
    ( Variant In1) ;  //_GUI 838,62
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:cB
    ( Variant In1) ;  //_GUI 281,156
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:dB
    ( Variant In1) ;  //_GUI 285,159
 Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe:B
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) ;  //_GUI 215,69
 Object ( Variant Out1, Variant Out2) ListIn:H( List In) ;  //_GUI 266,217
 Object ( List Out) ListOut:I( Variant In1, Variant In2) ;  //_GUI 166,231
 Object ( List Out) ListOut:J( Variant In1, Variant In2) ;  //_GUI 165,178
 Object ( Variant Out1, Variant Out2) ListIn:I( List In) ;  //_GUI 268,177
 Object ( List Out) ListOut:K( Variant In1, Variant In2) ;  //_GUI 162,128
 Object ( Variant Out1, Variant Out2) ListIn:J( List In) ;  //_GUI 304,128
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:eB
    ( Bit In3) ;  //_GUI 476,133
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:fB
    ( Bit In3) ;  //_GUI 479,127
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:AC
    ( Bit In3) ;  //_GUI 479,182
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:BC
    ( Bit In3) ;  //_GUI 482,130
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:CC
    ( Bit In3) ;  //_GUI 482,185
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:DC
    ( Bit In1) ;  //_GUI 512,192
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:EC
    ( Bit In1) ;  //_GUI 515,189
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:FC
    ( Variant In0) ;  //_GUI 161,238
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:GC
    ( Variant In3) ;  //_GUI 211,142
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:HC
    ( Variant In1) ;  //_GUI 196,124
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:IC
    ( Variant In1) ;  //_GUI 167,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:JC
    ( Variant In1) ;  //_GUI 199,118
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:KC
    ( Bit In3) ;  //_GUI 202,176
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) UnPackBIN:C
    ( Variant In1) ;  //_GUI 823,174
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 820,124
 //_ Attributes Documentation="ztlist"
 Object ( List Out1, List Out2, List Out3) Junction:LC
    ( List In0) ;  //_GUI 802,125
 Object Text;  //_GUI 706,245,Don't use the Busy on RegPipe unless you use the variant footprint and cast it.
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 708,222
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) Reg_Pipe:A( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 708,163
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) Reg_Pipe:B( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 704,64
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) Reg_Pipe:C( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 708,43
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:MC
    ( Bit In2) ;  //_GUI 516,136
 Object ( Variant Out1) Cast:A( Variant Type, Variant Data) ;  //_GUI 599,229
 //_ Attributes Documentation="ztlist"
 Object ( List Out1, List Out2, List Out3) Junction:NC
    ( List In0) ;  //_GUI 598,217
 Object ( Variant Out1) Cast:B( Variant Type, Variant Data) ;  //_GUI 219,93
 //_ Attributes Documentation="ztlist"
 Object ( List Out1, List Out2, List Out3) Junction:OC
    ( List In3) ;  //_GUI 212,94
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:D( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 564,120
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:E( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 566,142
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:F( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 558,95
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:G( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 494,95
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:H( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 494,120
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:I( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 145,105
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:J( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 145,55
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:K( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 144,201
 Object ( Variant Out1) PushLsb:C( Variant In1, Variant LSB) ;  //_GUI 515,280
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 62,98
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating:A
    ( Floating In1) ;  //_GUI 48,149
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7, Variant In8, Variant In9) ;  //_GUI 186,52
 Object ( List Out1) PackLSB:A( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7, Variant In8, Variant In9) ;  //_GUI 214,117
 Object ( List Out1) PackLSB:B( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7, Variant In8, Variant In9) ;  //_GUI 217,151
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9) UnPackLSB( Variant In1) ;  //_GUI 249,80
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9) UnPackLSB:A( Variant In1) ;  //_GUI 217,187
 Object ( Variant Out1) PushMsb:E( Variant MSB, Variant In2) ;  //_GUI 379,187
 Object ( Variant MSB, Variant Out2) PopMsb:B( Variant In1) ;  //_GUI 420,171
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:PC
    ( Bit In2) ;  //_GUI 417,225
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:QC
    ( Bit In3) ;  //_GUI 417,204
 Object ( Variant Out1) InvertEn( Variant In1, Bit En) ;  //_GUI 365,153
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:RC
    ( Bit In0) ;  //_GUI 374,232
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:SC
    ( Bit In3) ;  //_GUI 374,201
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:TC
    ( Bit In3) ;  //_GUI 374,222
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:UC
    ( Bit In0) ;  //_GUI 370,241
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:VC
    ( Bit In3) ;  //_GUI 370,195
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:WC
    ( Bit In3) ;  //_GUI 370,216
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:XC
    ( Bit In0) ;  //_GUI 372,244
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:YC
    ( Bit In3) ;  //_GUI 372,198
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:ZC
    ( Bit In3) ;  //_GUI 372,219
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:L( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 398,154
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:M( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 398,188
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:N( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 398,209
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:aC
    ( Variant In0) ;  //_GUI 431,210
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 424,127
 Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 407,137
 Object ( NULL Out1) NULL;  //_GUI 399,126
 Object ( Bit In) Input:K;  //_GUI 418,131
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:bC
    ( Variant In1) ;  //_GUI 393,192
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:cC
    ( Variant In1) ;  //_GUI 393,158
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:dC
    ( Variant In0) ;  //_GUI 378,155
 Object ( Variant Out1) PushMsb:F( Variant MSB, Variant In2) ;  //_GUI 379,147
 Object ( Variant BitsPerStageSG) Input:L;  //_GUI 401,141
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object Text;  //_GUI 365,133,if twice the bitlen is >= bitsPerStage then we need to insert a pipe stage here for timespec
 Object ( Variant Out1) InvertEn:A( Variant In1, Bit En) ;  //_GUI 528,168
 Object ( Variant Out1) PushMsb:G( Variant MSB, Variant In2) ;  //_GUI 498,152
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:eC
    ( Variant In1) ;  //_GUI 433,149
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:fC
    ( Variant In0) ;  //_GUI 512,154
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:AD
    ( Variant In3) ;  //_GUI 336,179
 Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero, Variant PipeLen, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) LeftJustify_Pipe( Variant Data, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 528,185
 Object ( Variant Out1) InvertEn:B( Variant In1, Bit En) ;  //_GUI 76,140
 Object ( Variant Out1) InvertEn:C( Variant In1, Bit En) ;  //_GUI 432,187
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 487,169
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe:A( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 708,111
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe:B( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 541,230
 Object ( Bit CI) Input:M;  //_GUI 141,135
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe:C( Variant A, Variant B, Variant Add
    , Variant CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 145,125
 Object Text;  //_GUI 322,112,Selects bigger exponent
 Object ( Variant MSB, Variant Out2) PopMsb:C( Variant In1) ;  //_GUI 508,171
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:BD
    ( Variant In0) ;  //_GUI 109,126
 Object ( Variant MSB, Variant Out2) PopMsb:D( Variant In1) ;  //_GUI 641,175
 Object Text;  //_GUI 653,176,remove implicit bit
 Object Text;  //_GUI 319,122,A
 Object Text;  //_GUI 319,118,B
 Object Text;  //_GUI 307,147,exp A-B
 Object Text;  //_GUI 304,141,exp B-A
 Object Text;  //_GUI 304,161,sign A
 Object Text;  //_GUI 304,153,sign B
 Object ( LSB002 Twos) Input:N;  //_GUI 440,172
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 342,155,sign of bigger
 Object Text;  //_GUI 311,183,mant A
 Object Text;  //_GUI 311,175,mant B
 Object Text;  //_GUI 343,172,smaller mant shifted right
 Object Text;  //_GUI 310,219,sign B
 Object Text;  //_GUI 310,212,sign A
 Object Text;  //_GUI 330,211,sign of smaller
 Object Text;  //_GUI 526,175,If result neg then inv result
 Object Text;  //_GUI 663,212,sgn bit
 Object Text;  //_GUI 663,219,CO
 Object Text;  //_GUI 621,175,LJust data
 Object Text;  //_GUI 639,187,shift num
 Object ( Variant Out1) PushMsb:H( Variant MSB, Variant In2) ;  //_GUI 347,162
 Object ( LSB002 Twos) Input:O;  //_GUI 343,161
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 301,79,MantA not zero
 Object Text;  //_GUI 301,91,MantB not zero
 Object Text;  //_GUI 301,98,BExpB all high
 Object Text;  //_GUI 300,86,BExpA all high
 Object Text;  //_GUI 322,83,A is NaN
 Object Text;  //_GUI 321,102,B is NaN
 Object Text;  //_GUI 326,69,Sign A
 Object Text;  //_GUI 326,73,Sign B
 Object Text;  //_GUI 349,72,Signs differ
 Object Text;  //_GUI 318,58,A and B's BExp all high
 Object Text;  //_GUI 315,39,Don't need to check Mant against zero to see of we have infinity because if isn't, then is NaN and will trigger OFL regardless.
 Object Text;  //_GUI 361,60,OFL for Inf - Inf
 Object Text;  //_GUI 580,93,OFL
 Object Text;  //_GUI 617,79,OFL
 Object Text;  //_GUI 566,117,Bigger Exp
 Object Text;  //_GUI 620,84,Bigger Exp
 Object Text;  //_GUI 351,218,Add of smaller
 Object Text;  //_GUI 434,195,Add of smaller
 Object Text;  //_GUI 434,183,Round bit
 Object Text;  //_GUI 454,207,Add of smaller
 Object Text;  //_GUI 457,153,bigger mant
 Object Text;  //_GUI 458,171,smaller mant
 Object Text;  //_GUI 490,196,add (or sub) the mantissas
 Object Text;  //_GUI 514,168,sgn bit
 Object Text;  //_GUI 548,165,CO
 Object Text;  //_GUI 530,214,Normalize the mantissa
 Object Text;  //_GUI 587,47,If shift num size is bigger than exponent size this means the exponent can not fully represent the mantissa range.  This is an unlikely and invalid (IEEE) case, but JIC, we check for it here and reduce the shift num to the size of the smaller exponent and use the OFL to zero the exponent.
 Object Text;  //_GUI 635,61,||||||||VCourier New,8,0,0
 Object ( Variant CO, Variant OFL, Variant R
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) ADSU_Pipe:D( Variant A, Variant B, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 703,87
 Object ( Bit Out) INVERT:E( Bit In1) ;  //_GUI 693,95
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:CD
    ( Bit In0) ;  //_GUI 685,94
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:DD
    ( Variant In0) ;  //_GUI 773,97
 Object ( Bit Out) AND:L( Bit In1, Bit In2) ;  //_GUI 659,63
 Object Text;  //_GUI 656,94,Shrink exponent when mantissa normalized smaller
 Object Text;  //_GUI 656,118,When the mantissa result carried, add one to the exponent.  Also add one (CI) if rounding the mantissa carried.
 Object Text;  //_GUI 514,259,Here we round our unshifted mantissa for possable use later if we didn't need to normalize because of a CO with the mantissa add.
 Object Text;  //_GUI 598,267,round CO
 Object Text;  //_GUI 593,277,round result
 Object Text;  //_GUI 640,254,If round carried, drop low bit, high bit is CO
 Object Text;  //_GUI 646,273,If round didnt carry, don't change
 Object Text;  //_GUI 724,114,Set to infinity if carries
 Object Text;  //_GUI 727,90,zero exp if underflows
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:ED
    ( Variant In0) ;  //_GUI 627,88
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:FD
    ( Variant In1) ;  //_GUI 627,92
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:GD
    ( Variant In0) ;  //_GUI 678,112
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:HD
    ( Variant In0) ;  //_GUI 631,189
 Object Text;  //_GUI 666,205,Shifted mant
 Object Text;  //_GUI 663,208,Unshifted mant
 Object Text;  //_GUI 729,41,OFL
 Object Text;  //_GUI 852,61,OFL
 Object Text;  //_GUI 852,64,shrunk exp
 Object Text;  //_GUI 852,67,expanded exp
 Object Text;  //_GUI 924,186,CO of mant add
 Object Text;  //_GUI 932,181,mantissa
 Object Text;  //_GUI 932,191,sgn bit
 Object Text;  //_GUI 941,119,if mant add carried, use expanded exp otherwise use shrunk exp.
 Object Text;  //_GUI 869,172,If exp before subtraction was all high and shift amount was zero, then result is also all high (infinity)
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:ID
    ( Variant In1) ;  //_GUI 627,112
 Object Text;  //_GUI 885,160,If exp before subtraction was all high
 Object Text;  //_GUI 905,131,Upper bits high and lower bits high after add
 Object Text;  //_GUI 852,70,Pre-Add upper high
 Object Text;  //_GUI 852,73,Pre-Add lower high
 Object Text;  //_GUI 852,76,Result shifted zero
 Object Text;  //_GUI 852,79,mant, CO, sgn bit
 Object Text;  //_GUI 657,145,upper bits of exp checked for all ones.  Checked against lower bits later.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:JD
    ( Variant In1) ;  //_GUI 875,149
 Object Text;  //_GUI 945,160,zero mant if infinity (exp all high)
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 964,167
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 994,167
 Object ( Bit Out) OR:C( Bit In1, Bit In2) ;  //_GUI 979,164
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:KD
    ( Variant In1) ;  //_GUI 975,91
 Object Text;  //_GUI 978,157,Set mant msb high if NaN (Quiet)
 Object Text;  //_GUI 432,165,we add two bits here: one for the co on the adsu and one to hold our sign bit
 Object Text;  //_GUI 345,119,this line changes depending on which one we chose

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = ListIn.0;  //_GUI 1077,92, 1077,89
 Output:B.0 = PushLsb.0;  //_GUI 1074,97
 Output:C.0 = RegOnGo.1;  
 Output:D.0 = RegOnGo.2;  
 Output:E.0 = RegOnGo.3;  //_GUI 1059,190, 1057,190
 Output:F.0 = NotZero_Pipe:A.7;  //_GUI 141,277
 Junction.0 = Junction:M.0;  //_GUI 100,130
 PopMsb.0 = InvertEn:A.0;  
 UExtnd.0 = Junction:FD.1;  
 UExtnd.1 = Junction:HD.0;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
 $Mux.0 = ListIn:F.1;  
 $Mux.1 = ListIn:F.0;  
 $Mux.2 = Junction:E.0;  //_GUI 319,127
 MSB.0 = Junction:I.1;  
 PopLsb.0 = Junction:G.2;  //_GUI 518,213, 523,213
 OR.0 = ADSU_Pipe:A.0;  
 OR.1 = ADSU_Pipe:A.2;  //_GUI 743,119
 AND.0 = Junction:CB.1;  //_GUI 290,63
 AND.1 = Junction:DB.1;  //_GUI 299,66
 AND:A.0 = AND.0;  
 AND:A.1 = XOR.0;  
 OR:A.0 = AND:A.0;  //_GUI 376,96, 376,65
 OR:A.1 = OR:B.0;  
 OR:B.0 = AND:J.0;  //_GUI 330,87
 OR:B.1 = AND:K.0;  //_GUI 323,101
 INVERT.0 = Input:B.0;  
 XOR.0 = Junction:A.1;  
 XOR.1 = Junction:fA.1;  
 Junction:A.0 = ListIn:G.1;  
 $Mux:A.0 = Junction:L.2;  
 $Mux:A.1 = Junction:K.2;  
 $Mux:A.2 = Junction:B.1;  
 $Mux:B.0 = Junction:dB.2;  //_GUI 286,215
 $Mux:B.1 = Junction:cB.2;  //_GUI 282,218
 $Mux:B.2 = Junction:B.2;  //_GUI 319,221
 Junction:B.0 = Junction:C.2;  
 $Mux:C.0 = Junction:K.1;  //_GUI 310,179
 $Mux:C.1 = Junction:L.1;  //_GUI 307,182
 $Mux:C.2 = Junction:C.1;  
 $Mux:D.0 = Junction:cB.1;  
 $Mux:D.1 = Junction:dB.1;  
 $Mux:D.2 = Junction:D.1;  
 Junction:C.0 = Junction:D.2;  
 Junction:D.0 = Junction:F.2;  
 Junction:E.0 = ListIn:J.1;  
 CollectFloating.0 = UnPackBIN.2;  //_GUI 1012,147, 1012,190
 CollectFloating.1 = $Mux:H.0;  //_GUI 939,150
 CollectFloating.2 = CollectMSB.0;  //_GUI 1015,170
 ShiftRightBy.0 = Junction:AD.2;  
 ShiftRightBy.1 = $Mux:E.0;  //_GUI 340,183, 340,145
 $Mux:E.0 = UnPackLSB.5;  //_GUI 273,144, 273,97
 $Mux:E.1 = ListIn:J.0;  //_GUI 315,147
 $Mux:E.2 = Junction:F.1;  
 INVERT:A.0 = $Mux:B.0;  
 Junction:F.0 = Junction:E.2;  
 INVERT:B.0 = InvertEn:C.0;  
 Junction:G.0 = PopMsb.1;  //_GUI 523,181, 552,181
 $Mux:F.0 = PopMsb:D.1;  //_GUI 658,208, 658,180
 $Mux:F.1 = $Mux:G.0;  //_GUI 656,211
 $Mux:F.2 = Junction:Q.1;  //_GUI 679,218
 AND:B.0 = INVERT:D.0;  
 AND:B.1 = UnPackBIN.0;  //_GUI 949,172, 949,184
 Junction:H.0 = PopLsb.0;  
 Zero.0 = Junction:H.2;  
 $Mux:G.0 = MSB.0;  //_GUI 643,264, 643,276
 $Mux:G.1 = PushMsb.0;  //_GUI 638,267
 $Mux:G.2 = Junction:J.1;  
 PopLsb:A.0 = Junction:I.0;  
 Junction:I.0 = ListIn:B.0;  //_GUI 602,276, 602,273
 PushMsb.0 = Junction:R.2;  
 PushMsb.1 = PopLsb:A.0;  
 Junction:J.0 = ListIn:B.1;  
 One.0 = Junction:GD.2;  //_GUI 679,116
 $Mux:H.0 = UnPackBIN:B.1;  //_GUI 929,67
 $Mux:H.1 = Junction:S.1;  
 $Mux:H.2 = Junction:P.0;  //_GUI 927,127
 AND:C.0 = AND:D.0;  //_GUI 742,87
 AND:C.1 = ADSU_Pipe:D.2;  
 AND:D.0 = Reg_Pipe:B.0;  //_GUI 728,66
 AND:D.1 = ADSU_Pipe:D.0;  
 INVERT:C.0 = UExtnd.0;  //_GUI 642,65
 $Mux:I.0 = AND:E.0;  
 $Mux:I.1 = AND:I.0;  //_GUI 924,171
 $Mux:I.2 = Junction:P.1;  
 AND:E.0 = AND:G.0;  
 AND:E.1 = UnPackBIN:B.5;  //_GUI 869,170, 869,79
 INVERT:D.0 = $Mux:I.0;  
 PopLsb:B.0 = Junction:ID.2;  //_GUI 628,165
 PopLsb:C.0 = PopLsb:B.0;  
 AND:F.0 = PopLsb:C.1;  
 AND:F.1 = PopLsb:B.1;  
 AND:G.0 = Junction:JD.2;  //_GUI 876,155
 AND:G.1 = UnPackBIN:B.4;  //_GUI 872,158, 872,76
 PopLsb:D.0 = Junction:S.2;  //_GUI 879,144
 PopLsb:E.0 = PopLsb:D.0;  
 AND:H.0 = PopLsb:E.1;  
 AND:H.1 = PopLsb:D.1;  
 AND:I.0 = AND:H.0;  
 AND:I.1 = Junction:JD.1;  
 Add_Pipe.0 = Junction.2;  //_GUI 105,153
 Add_Pipe.1 = Junction:N.1;  
 Add_Pipe.2 = Input:H.0;  
 Add_Pipe.3 = Junction:IB.2;  
 Add_Pipe.4 = Junction:PB.2;  
 Add_Pipe.5 = Junction:WB.2;  
 Add_Pipe.6 = UnPackLSB:A.5;  //_GUI 190,171, 190,204
 RegOnGo.0 = ListOut.0;  
 RegOnGo.1 = SyncReg_Pipe.3;  
 RegOnGo.2 = SyncReg_Pipe.4;  
 RegOnGo.3 = SyncReg_Pipe.5;  
 RegOnGo.4 = Input:F.0;  
 Junction:K.0 = PushMsb:C.0;  //_GUI 310,209
 Junction:L.0 = PushMsb:D.0;  
 Junction:M.0 = ExposeFloating:A.1;  
 Junction:N.0 = Junction:BD.2;  
 NotZero_Pipe.0 = Junction:N.2;  //_GUI 110,177
 NotZero_Pipe.1 = Junction:JB.2;  
 NotZero_Pipe.2 = Junction:QB.2;  
 NotZero_Pipe.3 = Junction:XB.2;  
 NotZero_Pipe.4 = UnPackLSB:A.6;  //_GUI 167,198, 167,207
 NotZero_Pipe:A.0 = Junction:M.2;  //_GUI 100,230
 NotZero_Pipe:A.1 = Junction:EB.1;  
 NotZero_Pipe:A.2 = Junction:LB.1;  
 NotZero_Pipe:A.3 = Junction:SB.1;  
 NotZero_Pipe:A.4 = UnPackLSB:A.8;  //_GUI 230,251
 Junction:O.0 = Junction:fC.0;  //_GUI 490,144, 513,144
 PushMsb:A.0 = Junction:YA.0;  //_GUI 521,143
 PushMsb:A.1 = PopMsb.0;  //_GUI 532,150, 552,150
 PopMsb:A.0 = UnPackBIN:A.2;  //_GUI 636,216, 636,129, 620,129, 620,92
 NotZero_Pipe:B.0 = Junction:HD.1;  
 NotZero_Pipe:B.1 = Junction:CA.2;  
 NotZero_Pipe:B.2 = Junction:JA.2;  
 NotZero_Pipe:B.3 = Junction:WA.2;  
 NotZero_Pipe:B.4 = UnPackBIN:C.5;  //_GUI 843,211, 843,191
 Junction:P.0 = UnPackBIN.1;  //_GUI 922,174, 922,187
 Junction:Q.0 = PopMsb:A.1;  
 NotZero_Pipe:C.0 = PopLsb:C.0;  //_GUI 684,139, 684,157
 NotZero_Pipe:C.1 = Junction:AA.2;  
 NotZero_Pipe:C.2 = Junction:HA.2;  
 NotZero_Pipe:C.3 = Junction:UA.2;  
 NotZero_Pipe:C.4 = UnPackBIN:C.3;  //_GUI 848,160, 848,185
 Junction:R.0 = Junction:J.0;  
 PackBIN.0 = $Mux:F.0;  //_GUI 682,219, 689,219
 PackBIN.1 = Junction:Q.2;  //_GUI 676,226
 PackBIN.2 = PopMsb:A.0;  //_GUI 672,229, 672,215
 UnPackBIN.0 = UnPackBIN:B.6;  //_GUI 866,185, 866,82
 Junction:S.0 = UnPackBIN:B.2;  //_GUI 879,70
 Junction:T.0 = Junction:V.0;  //_GUI 728,185
 SyncReg_Pipe.0 = PackBIN:D.0;  //_GUI 802,95, 802,65
 SyncReg_Pipe.1 = PackBIN:B.0;  //_GUI 798,98, 798,96
 SyncReg_Pipe.2 = NotZero_Pipe:C.4;  //_GUI 807,101, 807,151
 SyncReg_Pipe.3 = NotZero_Pipe:C.5;  //_GUI 810,104, 810,154
 SyncReg_Pipe.4 = Junction:LC.0;  //_GUI 803,110
 SyncReg_Pipe.5 = RegOnGo.4;  
 Junction:U.0 = Junction:W.0;  //_GUI 691,85, 724,85
 Junction:V.0 = NotZero_Pipe:B.3;  
 Junction:W.0 = ADSU_Pipe:D.3;  
 Junction:X.0 = Junction:Y.1;  
 Junction:Y.0 = Junction:V.1;  //_GUI 774,199
 Junction:Z.0 = ADSU_Pipe:D.6;  //_GUI 751,125, 751,107
 Junction:a.0 = Junction:b.1;  
 Junction:b.0 = NotZero_Pipe:B.6;  //_GUI 785,208
 Junction:c.0 = UnPackBIN:C.1;  //_GUI 737,110, 737,170, 840,170, 840,179
 ListIn.0 = RegOnGo.0;  //_GUI 1059,87, 1059,101
 VouchBit.0 = ListIn.1;  
 ListOut.0 = CollectFloating.0;  //_GUI 1035,148
 ListOut.1 = Junction:KD.1;  
 PushMsb:B.0 = Input:N.0;  
 PushMsb:B.1 = PopMsb:B.1;  
 PushMsb:C.0 = ListIn:H.1;  //_GUI 279,208, 279,219
 PushMsb:C.1 = ListIn:E.0;  //_GUI 276,211
 PushMsb:D.0 = ListIn:I.1;  //_GUI 296,179
 PushMsb:D.1 = ListIn:E.1;  
 PushLsb.0 = Input:J.0;  
 PushLsb.1 = PushLsb:A.0;  
 PushLsb:A.0 = SyncReg_Pipe.2;  //_GUI 852,197, 852,101
 PushLsb:A.1 = PushLsb:B.0;  //_GUI 934,200, 934,254
 Junction:d.0 = Junction:e.1;  
 Junction:e.0 = Junction:f.1;  
 Junction:f.0 = Junction:AA.1;  
 Junction:AA.0 = Junction:BA.1;  
 Junction:BA.0 = Junction:CA.1;  
 Junction:CA.0 = Junction:DA.1;  
 Junction:DA.0 = Junction:OA.1;  //_GUI 695,241
 Junction:EA.0 = Junction:FA.1;  
 Junction:FA.0 = Junction:GA.1;  
 Junction:GA.0 = Junction:HA.1;  
 Junction:HA.0 = Junction:IA.1;  
 Junction:IA.0 = Junction:JA.1;  
 Junction:JA.0 = Junction:KA.1;  
 Junction:KA.0 = Junction:PA.1;  //_GUI 697,244
 Junction:LA.0 = Junction:NA.0;  
 Junction:MA.0 = Junction:LA.1;  
 SyncReg_Pipe:A.0 = ListOut:C.0;  
 SyncReg_Pipe:A.1 = ListOut:D.0;  //_GUI 586,206
 SyncReg_Pipe:A.2 = Junction:OA.0;  //_GUI 592,209
 SyncReg_Pipe:A.3 = Junction:PA.0;  //_GUI 595,212
 SyncReg_Pipe:A.4 = Junction:NC.1;  
 SyncReg_Pipe:A.5 = NotZero_Pipe:B.7;  //_GUI 640,221, 640,203, 692,203, 692,211
 PackBIN:A.0 = Reg_Pipe:F.0;  
 PackBIN:A.1 = Reg_Pipe:D.0;  //_GUI 580,100
 PackBIN:A.2 = Reg_Pipe:E.0;  //_GUI 583,103, 583,144
 PackBIN:A.3 = ListOut:A.0;  
 UnPackBIN:A.0 = ListIn:D.1;  //_GUI 601,87, 601,198, 633,198
 ListOut:A.0 = LeftJustify_Pipe.2;  
 ListOut:A.1 = LeftJustify_Pipe.0;  //_GUI 575,187
 ListIn:A.0 = UnPackBIN:A.3;  
 ListOut:B.0 = ADSU_Pipe:B.2;  //_GUI 562,238
 ListOut:B.1 = ADSU_Pipe:B.0;  
 ListIn:B.0 = ListIn:D.0;  //_GUI 587,256, 633,256
 ListOut:C.0 = ListOut:B.0;  
 ListOut:C.1 = PackBIN:A.0;  //_GUI 573,198, 597,198
 ListOut:D.0 = ADSU_Pipe:B.3;  //_GUI 559,214, 559,241
 ListOut:D.1 = Junction:NA.2;  //_GUI 559,211
 Junction:NA.0 = LeftJustify_Pipe.4;  
 ListOut:E.0 = ADSU_Pipe:B.6;  //_GUI 578,250
 ListOut:E.1 = LeftJustify_Pipe.7;  //_GUI 569,219, 569,208
 Junction:OA.0 = ADSU_Pipe:B.4;  //_GUI 572,241, 572,244
 Junction:PA.0 = ADSU_Pipe:B.5;  //_GUI 574,244, 574,247
 ListIn:C.0 = Cast:A.0;  
 ListIn:D.0 = SyncReg_Pipe:A.0;  
 PushLsb:B.0 = SyncReg_Pipe:A.2;  //_GUI 644,253, 644,209
 PushLsb:B.1 = PushLsb:C.0;  //_GUI 678,283
 Junction:QA.0 = SyncReg_Pipe:A.5;  //_GUI 631,236, 631,218
 Junction:RA.0 = Junction:SA.1;  
 Junction:SA.0 = Junction:TA.1;  
 Junction:TA.0 = Junction:UA.1;  
 Junction:UA.0 = Junction:VA.1;  
 Junction:VA.0 = Junction:WA.1;  
 Junction:WA.0 = Junction:QA.0;  
 Junction:XA.0 = ADSU_Pipe.6;  //_GUI 510,189
 Junction:YA.0 = PopMsb:C.0;  
 Junction:ZA.0 = Reg_Pipe:H.4;  
 Junction:aA.0 = Reg_Pipe:H.2;  
 Junction:bA.0 = Reg_Pipe:H.3;  
 Junction:cA.0 = ListIn:C.1;  //_GUI 555,227, 620,227
 Junction:dA.0 = Junction:eA.1;  
 Junction:eA.0 = Junction:cA.1;  //_GUI 591,184, 555,184
 NotZero_Pipe:D.0 = Junction:AB.0;  //_GUI 96,26
 NotZero_Pipe:D.1 = Junction:ZB.1;  //_GUI 130,29
 NotZero_Pipe:D.2 = Junction:aB.1;  //_GUI 133,32
 NotZero_Pipe:D.3 = Junction:bB.1;  //_GUI 136,44
 NotZero_Pipe:D.4 = UnPackLSB:A.0;  //_GUI 243,47, 243,189
 Junction:fA.0 = ListIn:G.0;  
 NotZero_Pipe:E.0 = Junction:BB.0;  //_GUI 92,77
 NotZero_Pipe:E.1 = Junction:FB.2;  
 NotZero_Pipe:E.2 = Junction:MB.2;  
 NotZero_Pipe:E.3 = Junction:TB.2;  
 NotZero_Pipe:E.4 = UnPackLSB:A.2;  //_GUI 195,98, 195,108, 249,108, 249,195
 Junction:AB.0 = ExposeFloating.2;  
 ListOut:F.0 = Junction:BB.2;  //_GUI 92,205
 ListOut:F.1 = Junction:AB.2;  //_GUI 96,202
 ListIn:E.0 = UnPackLSB.7;  //_GUI 265,103
 ListIn:F.0 = UnPackLSB.3;  //_GUI 279,122, 279,91
 ListOut:G.0 = Junction:BD.0;  
 ListOut:G.1 = Junction.0;  //_GUI 105,106
 AND:J.0 = UnPackLSB.0;  //_GUI 313,82
 AND:J.1 = Junction:DB.2;  
 Junction:BB.0 = ExposeFloating:A.2;  
 Junction:CB.0 = ListIn:H.0;  //_GUI 290,222
 Junction:DB.0 = ListIn:I.0;  //_GUI 299,182
 AND:K.0 = UnPackLSB.2;  //_GUI 295,94, 295,88
 AND:K.1 = Junction:CB.2;  
 Junction:EB.0 = Input:C.0;  
 Junction:FB.0 = Junction:GB.1;  
 Junction:GB.0 = Junction:HB.1;  
 Junction:HB.0 = Junction:IB.1;  
 Junction:IB.0 = Junction:JB.1;  
 Junction:JB.0 = Junction:KB.1;  
 Junction:KB.0 = Junction:EB.0;  
 Junction:LB.0 = Input:D.0;  
 Junction:MB.0 = Junction:NB.1;  
 Junction:NB.0 = Junction:OB.1;  
 Junction:OB.0 = Junction:PB.1;  
 Junction:PB.0 = Junction:QB.1;  
 Junction:QB.0 = Junction:RB.1;  
 Junction:RB.0 = Junction:LB.0;  
 Junction:SB.0 = Input:E.0;  
 Junction:TB.0 = Junction:UB.1;  
 Junction:UB.0 = Junction:VB.1;  
 Junction:VB.0 = Junction:WB.1;  
 Junction:WB.0 = Junction:XB.1;  
 Junction:XB.0 = Junction:YB.1;  
 Junction:YB.0 = Junction:SB.0;  
 ListOut:H.0 = InvertEn:B.0;  //_GUI 87,59, 87,143
 ListOut:H.1 = ExposeFloating.0;  //_GUI 100,56, 100,100
 ListIn:G.0 = UnPackLSB.1;  //_GUI 269,85
 Junction:ZB.0 = Junction:FB.1;  
 Junction:aB.0 = Junction:MB.1;  
 Junction:bB.0 = Junction:TB.1;  
 PackBIN:B.0 = Junction:DD.0;  //_GUI 774,95
 PackBIN:B.1 = Junction:DD.1;  
 PackBIN:B.2 = ADSU_Pipe:A.3;  //_GUI 768,101, 768,122
 PackBIN:B.3 = NotZero_Pipe:C.3;  //_GUI 771,104, 771,148
 PackBIN:B.4 = Junction:X.1;  //_GUI 774,107
 PackBIN:B.5 = Junction:X.2;  
 PackBIN:B.6 = Junction:Y.2;  
 PackBIN:C.0 = Junction:Z.1;  
 PackBIN:C.1 = Junction:Z.2;  //_GUI 784,128
 PackBIN:C.2 = ADSU_Pipe:A.6;  
 PackBIN:C.3 = NotZero_Pipe:C.6;  //_GUI 751,134, 751,157
 PackBIN:C.4 = Junction:a.1;  //_GUI 785,137
 PackBIN:C.5 = Junction:a.2;  
 PackBIN:C.6 = Junction:b.2;  
 PackBIN:D.0 = Reg_Pipe:C.0;  //_GUI 752,64, 752,45
 PackBIN:D.1 = AND:C.0;  //_GUI 752,67
 PackBIN:D.2 = OR.0;  //_GUI 755,70, 755,114
 PackBIN:D.3 = NotZero_Pipe:C.2;  //_GUI 757,73, 757,145
 PackBIN:D.4 = Reg_Pipe:A.0;  //_GUI 759,76, 759,165
 PackBIN:D.5 = NotZero_Pipe:B.1;  //_GUI 761,79, 761,193
 PackBIN:D.6 = Reg_Pipe.0;  //_GUI 764,82, 764,224
 UnPackBIN:B.0 = SyncReg_Pipe.0;  //_GUI 832,65
 Junction:cB.0 = Junction:fA.2;  
 Junction:dB.0 = Junction:A.2;  
 SyncReg_Pipe:B.0 = PackLSB.0;  //_GUI 215,55
 SyncReg_Pipe:B.1 = PackLSB:A.0;  //_GUI 211,74, 211,115, 225,115
 SyncReg_Pipe:B.2 = NotZero_Pipe:E.4;  //_GUI 202,77, 202,89
 SyncReg_Pipe:B.3 = NotZero_Pipe:E.5;  //_GUI 203,80, 203,92
 SyncReg_Pipe:B.4 = Junction:OC.1;  //_GUI 213,86
 SyncReg_Pipe:B.5 = Reg_Pipe:N.5;  //_GUI 234,238, 398,238
 ListIn:H.0 = UnPackLSB.8;  //_GUI 262,220
 ListOut:I.0 = NotZero_Pipe:A.2;  
 ListOut:I.1 = NotZero_Pipe:A.0;  //_GUI 166,230
 ListOut:J.0 = NotZero_Pipe.2;  
 ListOut:J.1 = NotZero_Pipe.0;  //_GUI 165,177
 ListIn:I.0 = UnPackLSB.6;  //_GUI 268,100
 ListOut:K.0 = ADSU_Pipe:C.2;  
 ListOut:K.1 = ADSU_Pipe:C.0;  //_GUI 162,127
 ListIn:J.0 = UnPackLSB.4;  //_GUI 276,131, 276,94
 Junction:eB.0 = Junction:RC.1;  //_GUI 477,233
 Junction:fB.0 = Junction:AC.1;  
 Junction:AC.0 = Junction:UC.1;  //_GUI 480,242
 Junction:BC.0 = Junction:CC.1;  
 Junction:CC.0 = Junction:XC.1;  //_GUI 483,245
 Junction:DC.0 = ADSU_Pipe.5;  //_GUI 513,186
 Junction:EC.0 = ADSU_Pipe.4;  //_GUI 516,183
 Junction:FC.0 = NotZero_Pipe:A.3;  
 Junction:GC.0 = Junction:FC.1;  //_GUI 212,239
 Junction:HC.0 = Reg_Pipe:I.1;  //_GUI 197,110
 Junction:IC.0 = NotZero_Pipe:D.3;  //_GUI 168,35
 Junction:JC.0 = Junction:IC.1;  //_GUI 200,50
 Junction:KC.0 = NotZero_Pipe:A.6;  //_GUI 203,248
 UnPackBIN:C.0 = Cast.0;  //_GUI 823,142, 834,142, 834,127
 Cast.0 = Junction:LC.1;  
 Cast.1 = SyncReg_Pipe.6;  //_GUI 813,129
 Junction:LC.0 = PackBIN:C.0;  
 Reg_Pipe.0 = PackBIN.0;  
 Reg_Pipe.1 = Junction:T.2;  //_GUI 705,227
 Reg_Pipe.2 = Junction:DA.2;  
 Reg_Pipe.3 = Junction:KA.2;  
 Reg_Pipe.4 = Junction:QA.1;  
 Reg_Pipe.5 = UnPackBIN:C.6;  //_GUI 835,239
 Reg_Pipe:A.0 = AND:F.0;  
 Reg_Pipe:A.1 = Junction:T.1;  //_GUI 705,168
 Reg_Pipe:A.2 = Junction:BA.2;  
 Reg_Pipe:A.3 = Junction:IA.2;  
 Reg_Pipe:A.4 = Junction:VA.2;  
 Reg_Pipe:A.5 = UnPackBIN:C.4;  //_GUI 753,180, 753,204, 848,204, 848,188
 Reg_Pipe:B.0 = AND:L.0;  
 Reg_Pipe:B.1 = Junction:U.2;  
 Reg_Pipe:B.2 = Junction:d.2;  
 Reg_Pipe:B.3 = Junction:EA.2;  
 Reg_Pipe:B.4 = Junction:RA.2;  
 Reg_Pipe:B.5 = Junction:c.1;  
 Reg_Pipe:C.0 = UnPackBIN:A.0;  //_GUI 616,45
 Reg_Pipe:C.1 = Junction:U.1;  //_GUI 691,48
 Reg_Pipe:C.2 = Junction:d.1;  //_GUI 695,51
 Reg_Pipe:C.3 = Junction:EA.1;  //_GUI 697,54
 Reg_Pipe:C.4 = Junction:RA.1;  //_GUI 700,57
 Reg_Pipe:C.5 = UnPackBIN:C.0;  //_GUI 740,60, 740,172, 837,172, 837,176
 Junction:MC.0 = Reg_Pipe:F.5;  //_GUI 542,137, 542,112
 Cast:A.0 = Junction:NC.2;  
 Cast:A.1 = SyncReg_Pipe:A.6;  //_GUI 597,234, 597,221
 Junction:NC.0 = ListOut:E.0;  //_GUI 589,218
 Cast:B.0 = Junction:OC.2;  
 Cast:B.1 = SyncReg_Pipe:B.6;  //_GUI 215,98
 Junction:OC.0 = PackLSB:B.0;  //_GUI 213,112, 228,112
 Reg_Pipe:D.0 = Reg_Pipe:H.0;  
 Reg_Pipe:D.1 = Junction:MA.2;  
 Reg_Pipe:D.2 = Junction:aA.1;  
 Reg_Pipe:D.3 = Junction:bA.1;  
 Reg_Pipe:D.4 = Junction:ZA.1;  
 Reg_Pipe:D.5 = Junction:dA.0;  
 Reg_Pipe:E.0 = PushMsb:A.0;  
 Reg_Pipe:E.1 = Junction:LA.2;  
 Reg_Pipe:E.2 = Junction:aA.2;  //_GUI 557,150
 Reg_Pipe:E.3 = Junction:bA.2;  //_GUI 555,153
 Reg_Pipe:E.4 = Junction:ZA.2;  //_GUI 561,156
 Reg_Pipe:E.5 = Junction:eA.0;  
 Reg_Pipe:F.0 = Reg_Pipe:G.0;  
 Reg_Pipe:F.1 = Junction:MA.1;  //_GUI 554,100, 554,117, 559,117
 Reg_Pipe:F.2 = Reg_Pipe:G.2;  
 Reg_Pipe:F.3 = Reg_Pipe:G.3;  
 Reg_Pipe:F.4 = Reg_Pipe:G.4;  
 Reg_Pipe:F.5 = Junction:dA.1;  //_GUI 591,112
 Reg_Pipe:G.0 = OR:A.0;  
 Reg_Pipe:G.1 = Junction:O.1;  //_GUI 490,100
 Reg_Pipe:G.2 = Junction:fB.1;  //_GUI 480,103
 Reg_Pipe:G.3 = Junction:BC.1;  //_GUI 483,106
 Reg_Pipe:G.4 = Junction:eB.1;  //_GUI 477,109
 Reg_Pipe:G.5 = Junction:MC.1;  //_GUI 517,112
 Reg_Pipe:H.0 = $Mux.0;  
 Reg_Pipe:H.1 = Junction:O.2;  
 Reg_Pipe:H.2 = Junction:fB.2;  
 Reg_Pipe:H.3 = Junction:BC.2;  
 Reg_Pipe:H.4 = Junction:eB.2;  
 Reg_Pipe:H.5 = Junction:MC.0;  
 Reg_Pipe:I.0 = ListOut:G.0;  
 Reg_Pipe:I.1 = NotZero_Pipe:E.3;  //_GUI 140,110, 140,103, 159,103, 159,86
 Reg_Pipe:I.2 = Junction:GB.2;  
 Reg_Pipe:I.3 = Junction:NB.2;  
 Reg_Pipe:I.4 = Junction:UB.2;  
 Reg_Pipe:I.5 = UnPackLSB:A.3;  //_GUI 194,122, 194,198
 Reg_Pipe:J.0 = ListOut:H.0;  
 Reg_Pipe:J.1 = Junction:IC.0;  //_GUI 140,60, 140,50
 Reg_Pipe:J.2 = Junction:ZB.2;  
 Reg_Pipe:J.3 = Junction:aB.2;  
 Reg_Pipe:J.4 = Junction:bB.2;  
 Reg_Pipe:J.5 = UnPackLSB:A.1;  //_GUI 161,85, 198,85, 198,105, 246,105, 246,192
 Reg_Pipe:K.0 = ListOut:F.0;  
 Reg_Pipe:K.1 = Junction:FC.0;  //_GUI 141,206, 141,223, 162,223
 Reg_Pipe:K.2 = Junction:KB.2;  
 Reg_Pipe:K.3 = Junction:RB.2;  
 Reg_Pipe:K.4 = Junction:YB.2;  
 Reg_Pipe:K.5 = UnPackLSB:A.7;  //_GUI 167,218, 167,210
 PushLsb:C.0 = Junction:fC.2;  //_GUI 504,282, 504,166, 513,166
 PushLsb:C.1 = SyncReg_Pipe:B.2;  //_GUI 240,285, 240,77
 ExposeFloating.0 = Symmetrize.0;  //_GUI 48,101
 ExposeFloating:A.0 = Symmetrize.1;  
 PackLSB.0 = NotZero_Pipe:D.0;  //_GUI 174,54, 174,26
 PackLSB.1 = Reg_Pipe:J.0;  
 PackLSB.2 = NotZero_Pipe:E.0;  //_GUI 167,60, 167,77
 PackLSB.3 = Reg_Pipe:I.0;  //_GUI 170,63, 170,107
 PackLSB.4 = ListOut:K.0;  //_GUI 173,66
 PackLSB.5 = Add_Pipe.1;  //_GUI 176,69, 176,156
 PackLSB.6 = ListOut:J.0;  //_GUI 179,72, 179,181
 PackLSB.7 = Reg_Pipe:K.0;  //_GUI 183,75, 183,203
 PackLSB.8 = ListOut:I.0;  //_GUI 186,234
 PackLSB:A.0 = Junction:JC.1;  
 PackLSB:A.1 = Junction:JC.2;  //_GUI 200,122
 PackLSB:A.2 = Junction:HC.1;  
 PackLSB:A.3 = Junction:HC.2;  //_GUI 197,128
 PackLSB:A.4 = ADSU_Pipe:C.3;  //_GUI 191,131, 191,136
 PackLSB:A.5 = Add_Pipe.2;  //_GUI 198,134, 198,159
 PackLSB:A.6 = NotZero_Pipe.3;  //_GUI 201,137, 201,186
 PackLSB:A.7 = Junction:GC.1;  //_GUI 212,140
 PackLSB:A.8 = Junction:GC.2;  
 PackLSB:B.0 = NotZero_Pipe:D.6;  //_GUI 208,153, 208,44
 PackLSB:B.1 = Reg_Pipe:J.4;  //_GUI 206,156, 206,83, 164,83, 164,69
 PackLSB:B.2 = NotZero_Pipe:E.6;  //_GUI 204,159, 204,95
 PackLSB:B.3 = Reg_Pipe:I.4;  //_GUI 189,162, 189,119
 PackLSB:B.4 = ADSU_Pipe:C.6;  //_GUI 166,165, 166,145
 PackLSB:B.5 = Add_Pipe.5;  
 PackLSB:B.6 = NotZero_Pipe.6;  //_GUI 198,171, 198,195
 PackLSB:B.7 = Junction:KC.1;  //_GUI 203,174
 PackLSB:B.8 = Junction:KC.2;  
 UnPackLSB.0 = SyncReg_Pipe:B.0;  //_GUI 242,83, 242,71
 UnPackLSB:A.0 = Cast:B.0;  //_GUI 217,181, 231,181, 231,96
 PushMsb:E.0 = ShiftRightBy.3;  
 PushMsb:E.1 = ShiftRightBy.5;  //_GUI 366,192, 366,195
 PopMsb:B.0 = Reg_Pipe:M.0;  //_GUI 414,174
 Junction:PC.0 = ADSU_Pipe.7;  //_GUI 487,226
 Junction:QC.0 = Junction:PC.1;  
 InvertEn.0 = PushMsb:H.0;  //_GUI 358,155
 InvertEn.1 = $Mux:D.0;  
 Junction:RC.0 = SyncReg_Pipe:B.5;  //_GUI 237,233, 237,86
 Junction:SC.0 = Junction:TC.1;  
 Junction:TC.0 = Junction:RC.0;  
 Junction:UC.0 = NotZero_Pipe:A.4;  
 Junction:VC.0 = Junction:WC.1;  
 Junction:WC.0 = Junction:UC.0;  
 Junction:XC.0 = NotZero_Pipe:A.5;  
 Junction:YC.0 = Junction:ZC.1;  
 Junction:ZC.0 = Junction:XC.0;  
 Reg_Pipe:L.0 = Junction:dC.1;  
 Reg_Pipe:L.1 = Junction:cC.1;  
 Reg_Pipe:L.2 = Junction:VC.1;  //_GUI 371,162
 Reg_Pipe:L.3 = Junction:YC.1;  //_GUI 373,165
 Reg_Pipe:L.4 = Junction:SC.1;  //_GUI 375,168
 Reg_Pipe:L.5 = Junction:QC.1;  //_GUI 418,171
 Reg_Pipe:M.0 = PushMsb:E.0;  
 Reg_Pipe:M.1 = Junction:bC.1;  
 Reg_Pipe:M.2 = Junction:VC.2;  
 Reg_Pipe:M.3 = Junction:YC.2;  
 Reg_Pipe:M.4 = Junction:SC.2;  
 Reg_Pipe:M.5 = Junction:QC.0;  
 Reg_Pipe:N.0 = INVERT:A.0;  //_GUI 364,211, 364,216
 Reg_Pipe:N.1 = Junction:bC.2;  //_GUI 394,214
 Reg_Pipe:N.2 = Junction:WC.2;  
 Reg_Pipe:N.3 = Junction:ZC.2;  
 Reg_Pipe:N.4 = Junction:TC.2;  
 Reg_Pipe:N.5 = Junction:PC.0;  
 Junction:aC.0 = Reg_Pipe:N.0;  
 $Select.0 = NULL.0;  
 $Select.1 = Input:K.0;  
 $Select.2 = BitA_Ge_BitB.0;  //_GUI 424,140
 BitA_Ge_BitB.0 = PushMsb:F.0;  //_GUI 390,139
 BitA_Ge_BitB.1 = Input:L.0;  
 Junction:bC.0 = Junction:cC.2;  
 Junction:cC.0 = Junction:eC.0;  //_GUI 394,150
 Junction:dC.0 = InvertEn.0;  
 PushMsb:F.0 = Junction:AD.1;  //_GUI 337,149
 PushMsb:F.1 = Junction:dC.0;  
 InvertEn:A.0 = PopMsb:C.1;  //_GUI 524,170, 524,176
 InvertEn:A.1 = Junction:YA.1;  
 PushMsb:G.0 = Junction:eC.1;  //_GUI 498,150
 PushMsb:G.1 = ADSU_Pipe.3;  //_GUI 498,163, 502,163, 502,180
 Junction:eC.0 = $Select.0;  
 Junction:fC.0 = PushMsb:G.0;  
 Junction:AD.0 = $Mux:A.0;  //_GUI 337,200
 LeftJustify_Pipe.0 = Junction:G.1;  
 LeftJustify_Pipe.1 = Junction:EC.1;  
 LeftJustify_Pipe.2 = Junction:DC.1;  
 LeftJustify_Pipe.3 = Junction:XA.1;  
 LeftJustify_Pipe.4 = Junction:cA.0;  
 InvertEn:B.0 = ExposeFloating:A.0;  //_GUI 64,142
 InvertEn:B.1 = INVERT.0;  //_GUI 76,198
 InvertEn:C.0 = PopMsb:B.0;  //_GUI 432,173
 InvertEn:C.1 = Junction:aC.0;  
 ADSU_Pipe.0 = Reg_Pipe:L.0;  //_GUI 487,156
 ADSU_Pipe.1 = PushMsb:B.0;  
 ADSU_Pipe.2 = Junction:aC.1;  //_GUI 471,177, 471,211
 ADSU_Pipe.3 = INVERT:B.0;  //_GUI 468,180
 ADSU_Pipe.4 = Junction:AC.2;  
 ADSU_Pipe.5 = Junction:CC.2;  
 ADSU_Pipe.6 = Reg_Pipe:N.4;  //_GUI 474,189, 474,223
 ADSU_Pipe.7 = ADSU_Pipe:B.7;  //_GUI 507,192, 507,253
 ADSU_Pipe:A.0 = Junction:GD.1;  
 ADSU_Pipe:A.1 = One.0;  
 ADSU_Pipe:A.3 = Junction:R.1;  //_GUI 687,122, 687,197, 649,197, 649,227, 623,227
 ADSU_Pipe:A.4 = Junction:f.2;  
 ADSU_Pipe:A.5 = Junction:GA.2;  
 ADSU_Pipe:A.6 = Junction:TA.2;  
 ADSU_Pipe:A.7 = UnPackBIN:C.2;  //_GUI 734,134, 734,167, 845,167, 845,182
 ADSU_Pipe:B.0 = Junction:H.1;  
 ADSU_Pipe:B.1 = Zero.0;  
 ADSU_Pipe:B.3 = PopLsb.1;  //_GUI 528,241
 ADSU_Pipe:B.4 = Junction:EC.2;  //_GUI 516,244
 ADSU_Pipe:B.5 = Junction:DC.2;  //_GUI 513,247
 ADSU_Pipe:B.6 = Junction:XA.2;  //_GUI 510,250
 ADSU_Pipe:B.7 = ListIn:C.0;  //_GUI 620,253
 ADSU_Pipe:C.0 = Junction:BD.1;  
 ADSU_Pipe:C.1 = Junction.1;  
 ADSU_Pipe:C.2 = Input:G.0;  
 ADSU_Pipe:C.3 = Input:M.0;  
 ADSU_Pipe:C.4 = Junction:HB.2;  
 ADSU_Pipe:C.5 = Junction:OB.2;  
 ADSU_Pipe:C.6 = Junction:VB.2;  
 ADSU_Pipe:C.7 = UnPackLSB:A.4;  //_GUI 171,148, 171,201
 PopMsb:C.0 = ADSU_Pipe.2;  //_GUI 508,177
 Junction:BD.0 = ExposeFloating.1;  //_GUI 100,127, 100,103
 PopMsb:D.0 = ListIn:A.1;  //_GUI 627,178
 PushMsb:H.0 = Input:O.0;  
 PushMsb:H.1 = $Mux:C.0;  //_GUI 334,167
 ADSU_Pipe:D.0 = Junction:ED.1;  
 ADSU_Pipe:D.1 = UExtnd.1;  //_GUI 648,92, 648,96
 ADSU_Pipe:D.2 = Junction:CD.1;  
 ADSU_Pipe:D.3 = INVERT:E.0;  
 ADSU_Pipe:D.4 = Junction:e.2;  
 ADSU_Pipe:D.5 = Junction:FA.2;  
 ADSU_Pipe:D.6 = Junction:SA.2;  
 ADSU_Pipe:D.7 = Junction:c.0;  
 INVERT:E.0 = Junction:CD.2;  //_GUI 686,98
 Junction:CD.0 = Input:I.0;  
 Junction:DD.0 = Junction:W.1;  
 AND:L.0 = INVERT:C.0;  
 AND:L.1 = PopMsb:D.0;  //_GUI 651,68
 Junction:ED.0 = UnPackBIN:A.1;  
 Junction:FD.0 = Junction:ED.2;  
 Junction:GD.0 = Junction:ID.1;  
 Junction:HD.0 = ListIn:A.0;  
 Junction:ID.0 = Junction:FD.2;  
 Junction:JD.0 = UnPackBIN:B.3;  //_GUI 876,73
 ExposeMSB.0 = AND:B.0;  
 CollectMSB.0 = OR:C.0;  //_GUI 994,167
 CollectMSB.1 = ExposeMSB.1;  
 OR:C.0 = Junction:KD.2;  //_GUI 976,166
 OR:C.1 = ExposeMSB.0;  
 Junction:KD.0 = UnPackBIN:B.0;  //_GUI 976,64
}

Object ( Bit OFL, Complex R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Complex A, Complex B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Complex"
{
 // OFL is high on overflow error even if subtracting signed or unsigned types
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex A) Input;  //_GUI 15,32
 Object ( Complex B) Input:A;  //_GUI 15,42
 Object ( Bit Add) Input:B;  //_GUI 15,58
 //_ Attributes Constant="1"
 Object ( Bit ClkG) Input:C;  //_GUI 15,61
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 15,64
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 15,67
 Object ( Bit Wait) Input:F;  //_GUI 131,91
 Object Output( Bit OFL) ;  //_GUI 192,24
 Object Output:A( Complex R) ;  //_GUI 192,36
 Object Output:B( Variant PipeLen) ;  //_GUI 192,45
 Object Output:C( Bit ClkG) ;  //_GUI 153,61
 Object Output:D( Bit AClr) ;  //_GUI 153,64
 Object Output:E( Bit Done) ;  //_GUI 147,67
 Object Output:F( Bit Busy) ;  //_GUI 62,86
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 55,64
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 58,67
 Object Text;  //_GUI 96,5,So to handle the asymmetry, we pad each with a Reg_Pipe, the one being ripped out by a NULL
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 167,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 49,58
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 52,61
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 22,40
 Object ( Variant Real, Variant Imag) ExposeComplex:A( Complex In1) ;  //_GUI 28,30
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 166,34
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 143,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 77,22
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 77,51
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 143,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 140,70
 Object ( Variant N) BitA_Sub_BitB( Variant A, Variant B) ;  //_GUI 102,16
 Object ( Variant N) BitA_Sub_BitB:A( Variant A, Variant B) ;  //_GUI 101,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 92,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In3) ;  //_GUI 96,50
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 146,11
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In3) ;  //_GUI 92,20
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 62,51
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe:A
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 62,22
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 179,22
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 123,54
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:A( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 123,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 119,18

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = CollectComplex.0;  
 Output:B.0 = PushLsb.0;  //_GUI 156,46
 Output:C.0 = Reg_Pipe.2;  
 Output:D.0 = Reg_Pipe.3;  
 Output:E.0 = Reg_Pipe.4;  
 Output:F.0 = Add_Pipe.6;  
 Junction.0 = Input:D.0;  
 Junction:A.0 = Input:E.0;  
 OR.0 = ListIn.1;  
 OR.1 = ListIn:A.1;  //_GUI 165,27, 165,31, 159,31, 159,55
 Junction:B.0 = Input:B.0;  
 Junction:C.0 = Input:C.0;  
 ExposeComplex.0 = Input:A.0;  
 ExposeComplex:A.0 = Input.0;  
 CollectComplex.0 = ListIn.0;  //_GUI 162,36, 162,27
 CollectComplex.1 = ListIn:A.0;  //_GUI 162,39, 162,58
 ListIn.0 = Reg_Pipe:A.0;  //_GUI 141,25, 141,27
 ListOut.0 = Add_Pipe:A.1;  
 ListOut.1 = Add_Pipe:A.0;  
 ListOut:A.0 = Add_Pipe.1;  
 ListOut:A.1 = Add_Pipe.0;  
 ListIn:A.0 = Reg_Pipe.0;  
 Junction:D.0 = Input:F.0;  //_GUI 141,92
 BitA_Sub_BitB.0 = Junction:F.1;  //_GUI 97,18
 BitA_Sub_BitB.1 = Junction:G.2;  
 BitA_Sub_BitB:A.0 = Junction:E.2;  //_GUI 93,48
 BitA_Sub_BitB:A.1 = Junction:F.2;  
 Junction:E.0 = Add_Pipe:A.2;  
 Junction:F.0 = Add_Pipe.2;  //_GUI 97,59
 PushLsb.0 = Junction:G.1;  //_GUI 93,13
 PushLsb.1 = Junction:H.0;  //_GUI 120,16
 Junction:G.0 = Junction:E.0;  
 Add_Pipe.0 = ExposeComplex:A.1;  //_GUI 44,53
 Add_Pipe.1 = ExposeComplex.1;  //_GUI 38,56
 Add_Pipe.2 = Junction:B.1;  
 Add_Pipe.3 = Junction:C.1;  
 Add_Pipe.4 = Junction.1;  
 Add_Pipe.5 = Junction:A.1;  
 Add_Pipe.6 = Reg_Pipe.5;  
 Add_Pipe:A.0 = ExposeComplex:A.0;  //_GUI 44,24
 Add_Pipe:A.1 = ExposeComplex.0;  //_GUI 47,27, 47,42
 Add_Pipe:A.2 = Junction:B.0;  //_GUI 50,30
 Add_Pipe:A.3 = Junction:C.0;  //_GUI 53,33
 Add_Pipe:A.4 = Junction.0;  //_GUI 56,36
 Add_Pipe:A.5 = Junction:A.0;  //_GUI 59,39
 Add_Pipe:A.6 = Reg_Pipe:A.5;  
 VouchBit.0 = OR.0;  
 Reg_Pipe.0 = ListOut:A.0;  //_GUI 89,56, 89,54
 Reg_Pipe.1 = BitA_Sub_BitB:A.0;  //_GUI 116,59
 Reg_Pipe.2 = Add_Pipe.3;  
 Reg_Pipe.3 = Add_Pipe.4;  
 Reg_Pipe.4 = Add_Pipe.5;  
 Reg_Pipe.5 = Junction:D.0;  
 Reg_Pipe:A.0 = ListOut.0;  //_GUI 89,27, 89,25
 Reg_Pipe:A.1 = Junction:H.2;  //_GUI 120,30
 Reg_Pipe:A.2 = Add_Pipe:A.3;  
 Reg_Pipe:A.3 = Add_Pipe:A.4;  
 Reg_Pipe:A.4 = Add_Pipe:A.5;  
 Reg_Pipe:A.5 = Junction:D.1;  //_GUI 141,42
 Junction:H.0 = BitA_Sub_BitB.0;  
}

Object ( List OFL, List R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( List A, List B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/List/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 8,30
 Object ( List B) Input:A;  //_GUI 8,39
 Object ( Bit Add) Input:B;  //_GUI 8,46
 //_ Attributes Constant="1"
 Object ( Bit ClkG) Input:C;  //_GUI 8,52
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 8,55
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 8,58
 Object ( Bit Wait) Input:F;  //_GUI 161,70
 //_ Attributes Constant="0"
 Object Output( List OFL) ;  //_GUI 162,27
 Object Output:A( List R) ;  //_GUI 162,36
 Object Output:B( Variant PipeLen) ;  //_GUI 162,45
 Object Output:C( Bit ClkG) ;  //_GUI 162,48
 Object Output:D( Bit AClr) ;  //_GUI 162,51
 Object Output:E( Bit Done) ;  //_GUI 162,63
 Object Output:F( Bit Busy) ;  //_GUI 9,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,58
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 148,25
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 103,32
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 14,37
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 14,28
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 39,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 42,55
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 33,46
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 148,34
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 131,25
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 70,5
 Object ( List Out) ListOut:C( Variant In1, Variant In2) ;  //_GUI 70,63
 Object ( Variant Out1, Variant Out2) ListIn:C( List In) ;  //_GUI 131,34
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 55,5
 //_ Attributes Documentation="complex"
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe:A
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 55,63
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = SyncRegPair_Pipe.4;  
 Output:C.0 = SyncRegPair_Pipe.5;  
 Output:D.0 = SyncRegPair_Pipe.6;  
 Output:E.0 = SyncRegPair_Pipe.9;  
 Output:F.0 = Add_Pipe:A.6;  //_GUI 9,62, 49,62, 49,83
 Junction.0 = Input:E.0;  
 ListOut.0 = ListIn:C.1;  //_GUI 148,33, 142,33
 ListOut.1 = ListIn:B.1;  
 SyncRegPair_Pipe.0 = ListOut:B.0;  //_GUI 84,34, 84,8
 SyncRegPair_Pipe.1 = ListOut:C.0;  //_GUI 84,37, 84,66
 SyncRegPair_Pipe.2 = Add_Pipe.2;  //_GUI 87,40, 87,13
 SyncRegPair_Pipe.3 = Add_Pipe:A.2;  //_GUI 87,43, 87,71
 SyncRegPair_Pipe.4 = Add_Pipe:A.3;  //_GUI 90,46, 90,74
 SyncRegPair_Pipe.5 = Add_Pipe:A.4;  //_GUI 93,49, 93,77
 SyncRegPair_Pipe.6 = Add_Pipe.5;  //_GUI 96,52, 96,22
 SyncRegPair_Pipe.7 = Add_Pipe:A.5;  //_GUI 96,55, 96,80
 SyncRegPair_Pipe.8 = Input:F.0;  //_GUI 165,67
 ListIn.0 = Input:A.0;  
 ListIn:A.0 = Input.0;  
 Junction:A.0 = Input:C.0;  
 Junction:B.0 = Input:D.0;  
 Junction:C.0 = Input:B.0;  
 ListOut:A.0 = ListIn:C.0;  
 ListOut:A.1 = ListIn:B.0;  //_GUI 145,36, 145,30
 ListIn:B.0 = SyncRegPair_Pipe.0;  //_GUI 124,28, 124,34
 ListOut:B.0 = Add_Pipe.1;  
 ListOut:B.1 = Add_Pipe.0;  
 ListOut:C.0 = Add_Pipe:A.1;  
 ListOut:C.1 = Add_Pipe:A.0;  
 ListIn:C.0 = SyncRegPair_Pipe.1;  
 Add_Pipe.0 = ListIn:A.1;  //_GUI 28,7, 28,30
 Add_Pipe.1 = ListIn.1;  //_GUI 31,10, 31,39
 Add_Pipe.2 = Junction:C.0;  //_GUI 34,13
 Add_Pipe.3 = Junction:A.0;  //_GUI 40,16
 Add_Pipe.4 = Junction:B.0;  //_GUI 43,19
 Add_Pipe.5 = Junction.0;  //_GUI 46,22
 Add_Pipe.6 = SyncRegPair_Pipe.7;  //_GUI 127,25, 127,55
 Add_Pipe:A.0 = ListIn:A.0;  //_GUI 28,65, 28,33
 Add_Pipe:A.1 = ListIn.0;  //_GUI 31,68, 31,42
 Add_Pipe:A.2 = Junction:C.2;  //_GUI 34,71
 Add_Pipe:A.3 = Junction:A.2;  //_GUI 40,74
 Add_Pipe:A.4 = Junction:B.2;  //_GUI 43,77
 Add_Pipe:A.5 = Junction.2;  //_GUI 46,80
 Add_Pipe:A.6 = SyncRegPair_Pipe.8;  //_GUI 127,83, 127,58
}

Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, List B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Var/List/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,18
 Object ( List B) Input:A;  //_GUI 23,25
 Object ( Bit Add) Input:B;  //_GUI 23,28
 //_ Attributes Constant="1"
 Object ( Bit ClkG) Input:C;  //_GUI 23,31
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 23,34
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 23,37
 Object ( Bit Wait) Input:F;  //_GUI 74,43
 //_ Attributes Constant="0"
 Object Output( Variant OFL) ;  //_GUI 75,22
 Object Output:A( Variant R) ;  //_GUI 75,25
 Object Output:B( Variant PipeLen) ;  //_GUI 75,28
 Object Output:C( Bit ClkG) ;  //_GUI 75,31
 Object Output:D( Bit AClr) ;  //_GUI 75,34
 Object Output:E( Bit Done) ;  //_GUI 75,37
 Object Output:F( Bit Busy) ;  //_GUI 24,43
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,17
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 31,25
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 49,21
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = Add_Pipe.0;  
 Output:A.0 = Add_Pipe.1;  
 Output:B.0 = Add_Pipe.2;  
 Output:C.0 = Add_Pipe.3;  
 Output:D.0 = Add_Pipe.4;  
 Output:E.0 = Add_Pipe.5;  
 Output:F.0 = Add_Pipe.6;  //_GUI 24,41
 ListFill.0 = Input.0;  
 ListFill.1 = Junction.0;  
 Junction.0 = Input:A.0;  
 Add_Pipe.0 = ListFill.0;  //_GUI 47,23, 47,20
 Add_Pipe.1 = Junction.1;  
 Add_Pipe.2 = Input:B.0;  
 Add_Pipe.3 = Input:C.0;  
 Add_Pipe.4 = Input:D.0;  
 Add_Pipe.5 = Input:E.0;  
 Add_Pipe.6 = Input:F.0;  //_GUI 78,41
}

Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( List A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/Var/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 22,18
 Object ( Variant B) Input:A;  //_GUI 22,21
 Object ( Bit Add) Input:B;  //_GUI 22,28
 //_ Attributes Constant="1"
 Object ( Bit ClkG) Input:C;  //_GUI 22,31
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 22,34
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 22,37
 Object ( Bit Wait) Input:F;  //_GUI 74,43
 //_ Attributes Constant="0"
 Object Output( Variant OFL) ;  //_GUI 75,22
 Object Output:A( Variant R) ;  //_GUI 75,25
 Object Output:B( Variant PipeLen) ;  //_GUI 75,28
 Object Output:C( Bit ClkG) ;  //_GUI 75,31
 Object Output:D( Bit AClr) ;  //_GUI 75,34
 Object Output:E( Bit Done) ;  //_GUI 75,37
 Object Output:F( Bit Busy) ;  //_GUI 23,43
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,20
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 28,18
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Bit Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 49,21
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = Add_Pipe.0;  
 Output:A.0 = Add_Pipe.1;  
 Output:B.0 = Add_Pipe.2;  
 Output:C.0 = Add_Pipe.3;  
 Output:D.0 = Add_Pipe.4;  
 Output:E.0 = Add_Pipe.5;  
 Output:F.0 = Add_Pipe.6;  //_GUI 23,41
 ListFill.0 = Input:A.0;  
 ListFill.1 = Junction.2;  //_GUI 29,25
 Junction.0 = Input.0;  
 Add_Pipe.0 = Junction.1;  //_GUI 49,19
 Add_Pipe.1 = ListFill.0;  //_GUI 45,26
 Add_Pipe.2 = Input:B.0;  
 Add_Pipe.3 = Input:C.0;  
 Add_Pipe.4 = Input:D.0;  
 Add_Pipe.5 = Input:E.0;  
 Add_Pipe.6 = Input:F.0;  //_GUI 78,41
}

Object ( List OFL, List R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( List A, List B, List Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 8,30
 Object ( List B) Input:A;  //_GUI 8,38
 Object ( List Add) Input:B;  //_GUI 8,46
 Object ( Bit ClkG) Input:C;  //_GUI 8,52
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 8,55
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 8,58
 Object ( Bit Wait) Input:F;  //_GUI 161,70
 //_ Attributes Constant="0"
 Object Output( List OFL) ;  //_GUI 162,27
 Object Output:A( List R) ;  //_GUI 162,36
 Object Output:B( Variant PipeLen) ;  //_GUI 162,45
 Object Output:C( Bit ClkG) ;  //_GUI 162,48
 Object Output:D( Bit AClr) ;  //_GUI 162,51
 Object Output:E( Bit Done) ;  //_GUI 162,63
 Object Output:F( Bit Busy) ;  //_GUI 9,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,58
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 14,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 39,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 42,55
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 14,44
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 14,28
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 148,25
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 103,32
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 148,34
 Object ( Variant Out1, Variant Out2) ListIn:C( List In) ;  //_GUI 131,25
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 70,5
 Object ( List Out) ListOut:C( Variant In1, Variant In2) ;  //_GUI 70,63
 Object ( Variant Out1, Variant Out2) ListIn:D( List In) ;  //_GUI 131,34
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Variant Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 55,63
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe:A
    ( Variant A, Variant B, Variant Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 55,5

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = SyncRegPair_Pipe.4;  
 Output:C.0 = SyncRegPair_Pipe.5;  
 Output:D.0 = SyncRegPair_Pipe.6;  
 Output:E.0 = SyncRegPair_Pipe.9;  
 Output:F.0 = Add_Pipe.6;  //_GUI 9,62, 49,62, 49,83
 Junction.0 = Input:E.0;  
 ListIn.0 = Input:A.0;  
 Junction:A.0 = Input:C.0;  
 Junction:B.0 = Input:D.0;  
 ListIn:A.0 = Input:B.0;  
 ListIn:B.0 = Input.0;  
 ListOut.0 = ListIn:D.1;  //_GUI 148,33, 142,33
 ListOut.1 = ListIn:C.1;  
 SyncRegPair_Pipe.0 = ListOut:B.0;  //_GUI 84,34, 84,8
 SyncRegPair_Pipe.1 = ListOut:C.0;  //_GUI 84,37, 84,66
 SyncRegPair_Pipe.2 = Add_Pipe:A.2;  //_GUI 87,40, 87,13
 SyncRegPair_Pipe.3 = Add_Pipe.2;  //_GUI 87,43, 87,71
 SyncRegPair_Pipe.4 = Add_Pipe.3;  //_GUI 90,46, 90,74
 SyncRegPair_Pipe.5 = Add_Pipe.4;  //_GUI 93,49, 93,77
 SyncRegPair_Pipe.6 = Add_Pipe:A.5;  //_GUI 96,52, 96,22
 SyncRegPair_Pipe.7 = Add_Pipe.5;  //_GUI 96,55, 96,80
 SyncRegPair_Pipe.8 = Input:F.0;  //_GUI 165,67
 ListOut:A.0 = ListIn:D.0;  
 ListOut:A.1 = ListIn:C.0;  //_GUI 145,36, 145,30
 ListIn:C.0 = SyncRegPair_Pipe.0;  //_GUI 124,28, 124,34
 ListOut:B.0 = Add_Pipe:A.1;  
 ListOut:B.1 = Add_Pipe:A.0;  
 ListOut:C.0 = Add_Pipe.1;  
 ListOut:C.1 = Add_Pipe.0;  
 ListIn:D.0 = SyncRegPair_Pipe.1;  
 Add_Pipe.0 = ListIn:B.0;  //_GUI 28,65, 28,33
 Add_Pipe.1 = ListIn.0;  //_GUI 31,68, 31,41
 Add_Pipe.2 = ListIn:A.0;  //_GUI 34,71, 34,49
 Add_Pipe.3 = Junction:A.2;  //_GUI 40,74
 Add_Pipe.4 = Junction:B.2;  //_GUI 43,77
 Add_Pipe.5 = Junction.2;  //_GUI 46,80
 Add_Pipe.6 = SyncRegPair_Pipe.8;  //_GUI 127,83, 127,58
 Add_Pipe:A.0 = ListIn:B.1;  //_GUI 28,7, 28,30
 Add_Pipe:A.1 = ListIn.1;  //_GUI 31,10, 31,38
 Add_Pipe:A.2 = ListIn:A.1;  //_GUI 34,13, 34,46
 Add_Pipe:A.3 = Junction:A.0;  //_GUI 40,16
 Add_Pipe:A.4 = Junction:B.0;  //_GUI 43,19
 Add_Pipe:A.5 = Junction.0;  //_GUI 46,22
 Add_Pipe:A.6 = SyncRegPair_Pipe.7;  //_GUI 127,25, 127,55
}

Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, List B, List Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Var/List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,18
 Object ( List B) Input:A;  //_GUI 23,25
 Object ( List Add) Input:B;  //_GUI 23,28
 Object ( Bit ClkG) Input:C;  //_GUI 23,31
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 23,34
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 23,37
 Object ( Bit Wait) Input:F;  //_GUI 74,43
 //_ Attributes Constant="0"
 Object Output( Variant OFL) ;  //_GUI 75,22
 Object Output:A( Variant R) ;  //_GUI 75,25
 Object Output:B( Variant PipeLen) ;  //_GUI 75,28
 Object Output:C( Bit ClkG) ;  //_GUI 75,31
 Object Output:D( Bit AClr) ;  //_GUI 75,34
 Object Output:E( Bit Done) ;  //_GUI 75,37
 Object Output:F( Bit Busy) ;  //_GUI 24,43
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,17
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 31,25
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Variant Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 49,21
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = Add_Pipe.0;  
 Output:A.0 = Add_Pipe.1;  
 Output:B.0 = Add_Pipe.2;  
 Output:C.0 = Add_Pipe.3;  
 Output:D.0 = Add_Pipe.4;  
 Output:E.0 = Add_Pipe.5;  
 Output:F.0 = Add_Pipe.6;  //_GUI 24,41
 ListFill.0 = Input.0;  
 ListFill.1 = Junction.0;  
 Junction.0 = Input:A.0;  
 Add_Pipe.0 = ListFill.0;  //_GUI 47,23, 47,20
 Add_Pipe.1 = Junction.1;  
 Add_Pipe.2 = Input:B.0;  
 Add_Pipe.3 = Input:C.0;  
 Add_Pipe.4 = Input:D.0;  
 Add_Pipe.5 = Input:E.0;  
 Add_Pipe.6 = Input:F.0;  //_GUI 78,41
}

Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( List A, Variant B, List Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="List/Var/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 22,18
 Object ( Variant B) Input:A;  //_GUI 22,21
 Object ( List Add) Input:B;  //_GUI 22,28
 Object ( Bit ClkG) Input:C;  //_GUI 22,31
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:D;  //_GUI 22,34
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:E;  //_GUI 22,37
 Object ( Bit Wait) Input:F;  //_GUI 74,43
 //_ Attributes Constant="0"
 Object Output( Variant OFL) ;  //_GUI 75,22
 Object Output:A( Variant R) ;  //_GUI 75,25
 Object Output:B( Variant PipeLen) ;  //_GUI 75,28
 Object Output:C( Bit ClkG) ;  //_GUI 75,31
 Object Output:D( Bit AClr) ;  //_GUI 75,34
 Object Output:E( Bit Done) ;  //_GUI 75,37
 Object Output:F( Bit Busy) ;  //_GUI 23,43
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 32,20
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 28,18
 Object ( Variant OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) Add_Pipe
    ( Variant A, Variant B, Variant Add, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 49,21
 //_ Attributes Documentation="complex"

 //_ Behavior Topology
 Output.0 = Add_Pipe.0;  
 Output:A.0 = Add_Pipe.1;  
 Output:B.0 = Add_Pipe.2;  
 Output:C.0 = Add_Pipe.3;  
 Output:D.0 = Add_Pipe.4;  
 Output:E.0 = Add_Pipe.5;  
 Output:F.0 = Add_Pipe.6;  //_GUI 23,41
 ListFill.0 = Input:A.0;  
 ListFill.1 = Junction.2;  //_GUI 29,25
 Junction.0 = Input.0;  
 Add_Pipe.0 = Junction.1;  //_GUI 49,19
 Add_Pipe.1 = ListFill.0;  //_GUI 45,26
 Add_Pipe.2 = Input:B.0;  
 Add_Pipe.3 = Input:C.0;  
 Add_Pipe.4 = Input:D.0;  
 Add_Pipe.5 = Input:E.0;  
 Add_Pipe.6 = Input:F.0;  //_GUI 78,41
}

Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced"
{
 // Same as SyncReg_Pipe except only for joining two pipelines.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,5
 Object ( Variant B) Input:A;  //_GUI 24,8
 Object ( Variant PipeLenA) Input:B;  //_GUI 16,22
 Object ( Variant PipeLenB) Input:C;  //_GUI 16,25
 Object ( Bit ClkG) Input:D;  //_GUI 48,26
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 48,29
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 25,39
 Object ( Bit GoB) Input:G;  //_GUI 25,42
 Object ( Bit Wait) Input:H;  //_GUI 67,69
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 86,5
 Object Output:A( Variant B) ;  //_GUI 86,8
 Object Output:B( Variant PipeLenA) ;  //_GUI 92,16
 Object Output:C( Variant PipeLenB) ;  //_GUI 92,19
 Object Output:D( Variant FullPipeLen) ;  //_GUI 88,26
 Object Output:E( Bit ClkG) ;  //_GUI 75,29
 Object Output:F( Bit AClr) ;  //_GUI 75,32
 Object Output:G( Bit BusyA) ;  //_GUI 99,49
 Object Output:H( Bit BusyB) ;  //_GUI 99,52
 Object Output:I( Bit Done) ;  //_GUI 75,57
 Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) ;  //_GUI 52,19
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 73,48
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 30,4
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 24,21
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 33,38
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 47,40
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 59,48
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 79,15
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 73,4
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 86,47
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 86,50

 //_ Behavior Topology
 Output.0 = ListIn:B.1;  
 Output:A.0 = ListIn:B.0;  
 Output:B.0 = ListIn:A.1;  
 Output:C.0 = ListIn:A.0;  
 Output:D.0 = SyncReg_Pipe.2;  
 Output:E.0 = SyncReg_Pipe.3;  
 Output:F.0 = SyncReg_Pipe.4;  
 Output:G.0 = VouchBit.0;  
 Output:H.0 = VouchBit:A.0;  
 Output:I.0 = SyncReg_Pipe.5;  //_GUI 75,36
 SyncReg_Pipe.0 = ListOut.0;  //_GUI 52,7
 SyncReg_Pipe.1 = ListOut:A.0;  
 SyncReg_Pipe.2 = Input:D.0;  
 SyncReg_Pipe.3 = Input:E.0;  
 SyncReg_Pipe.4 = Junction.0;  //_GUI 48,36
 SyncReg_Pipe.5 = Input:H.0;  
 ListIn.0 = Cast.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ListOut:A.0 = Input:C.0;  
 ListOut:A.1 = Input:B.0;  
 ListOut:B.0 = Input:G.0;  
 ListOut:B.1 = Input:F.0;  
 Junction.0 = ListOut:B.0;  
 Cast.0 = Junction.2;  //_GUI 48,50
 Cast.1 = SyncReg_Pipe.6;  //_GUI 52,53
 ListIn:A.0 = SyncReg_Pipe.1;  //_GUI 75,18, 75,24
 ListIn:B.0 = SyncReg_Pipe.0;  //_GUI 73,13, 71,13
 VouchBit.0 = ListIn.1;  
 VouchBit:A.0 = ListIn.0;  
}

Object ( NULL A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( NULL A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="NULL/var/var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,12
 Object ( Variant B) Input:A;  //_GUI 24,15
 Object ( Variant PipeLenA) Input:B;  //_GUI 24,18
 Object ( Variant PipeLenB) Input:C;  //_GUI 24,21
 Object ( Bit ClkG) Input:D;  //_GUI 24,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 24,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 24,33
 Object ( Bit GoB) Input:G;  //_GUI 24,39
 Object ( Bit Wait) Input:H;  //_GUI 35,45
 //_ Attributes Constant="0"
 Object Output( NULL A) ;  //_GUI 36,12
 Object Output:A( Variant B) ;  //_GUI 36,15
 Object Output:B( Variant PipeLenA) ;  //_GUI 36,18
 Object Output:C( Variant PipeLenB) ;  //_GUI 36,21
 Object Output:D( Variant FullPipeLen) ;  //_GUI 36,24
 Object Output:E( Bit ClkG) ;  //_GUI 36,27
 Object Output:F( Bit AClr) ;  //_GUI 36,30
 Object Output:G( Bit BusyA) ;  //_GUI 36,33
 Object Output:H( Bit BusyB) ;  //_GUI 36,36
 Object Output:I( Bit Done) ;  //_GUI 36,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,21
 Object Text;  //_GUI 24,49,If no data then don't forward Goes and PipeLen

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:C.0 = Junction.1;  
 Output:D.0 = Junction.2;  //_GUI 32,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:H.0 = Input:H.0;  //_GUI 32,37, 32,43, 39,43
 Output:I.0 = Input:G.0;  
 Junction.0 = Input:C.0;  
}

Object ( Variant A, NULL B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , NULL B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="var/NULL/var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 21,12
 Object ( NULL B) Input:A;  //_GUI 21,15
 Object ( Variant PipeLenA) Input:B;  //_GUI 21,18
 Object ( Variant PipeLenB) Input:C;  //_GUI 21,21
 Object ( Bit ClkG) Input:D;  //_GUI 21,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 21,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 21,33
 Object ( Bit GoB) Input:G;  //_GUI 21,36
 Object ( Bit Wait) Input:H;  //_GUI 33,45
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 34,12
 Object Output:A( NULL B) ;  //_GUI 34,15
 Object Output:B( Variant PipeLenA) ;  //_GUI 34,18
 Object Output:C( Variant PipeLenB) ;  //_GUI 34,21
 Object Output:D( Variant FullPipeLen) ;  //_GUI 34,24
 Object Output:E( Bit ClkG) ;  //_GUI 34,27
 Object Output:F( Bit AClr) ;  //_GUI 34,30
 Object Output:G( Bit BusyA) ;  //_GUI 34,33
 Object Output:H( Bit BusyB) ;  //_GUI 34,36
 Object Output:I( Bit Done) ;  //_GUI 34,39
 Object Text;  //_GUI 23,49,If no data then don't forward Goes and PipeLen
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 29,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Junction.1;  
 Output:D.0 = Junction.2;  //_GUI 30,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:G.0 = Input:H.0;  //_GUI 31,34, 31,43, 37,43
 Output:I.0 = Input:F.0;  //_GUI 28,40, 28,34
 Junction.0 = Input:B.0;  
}

Object ( NULL A, Variant B, NULL PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( NULL A
    , Variant B, NULL PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="NULL/var/NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,12
 Object ( Variant B) Input:A;  //_GUI 24,15
 Object ( NULL PipeLenA) Input:B;  //_GUI 24,18
 Object ( Variant PipeLenB) Input:C;  //_GUI 24,21
 Object ( Bit ClkG) Input:D;  //_GUI 24,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 24,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 24,33
 Object ( Bit GoB) Input:G;  //_GUI 24,39
 Object ( Bit Wait) Input:H;  //_GUI 35,45
 //_ Attributes Constant="0"
 Object Output( NULL A) ;  //_GUI 36,12
 Object Output:A( Variant B) ;  //_GUI 36,15
 Object Output:B( NULL PipeLenA) ;  //_GUI 36,18
 Object Output:C( Variant PipeLenB) ;  //_GUI 36,21
 Object Output:D( Variant FullPipeLen) ;  //_GUI 36,24
 Object Output:E( Bit ClkG) ;  //_GUI 36,27
 Object Output:F( Bit AClr) ;  //_GUI 36,30
 Object Output:G( Bit BusyA) ;  //_GUI 36,33
 Object Output:H( Bit BusyB) ;  //_GUI 36,36
 Object Output:I( Bit Done) ;  //_GUI 36,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,21
 Object Text;  //_GUI 24,49,If no data then don't forward Goes and PipeLen

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Input:B.0;  
 Output:C.0 = Junction.1;  
 Output:D.0 = Junction.2;  //_GUI 32,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:H.0 = Input:H.0;  //_GUI 32,37, 32,43, 39,43
 Output:I.0 = Input:G.0;  
 Junction.0 = Input:C.0;  
}

Object ( Variant A, NULL B, Variant PipeLenA
    , NULL PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , NULL B, Variant PipeLenA, NULL PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="var/NULL/var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 21,12
 Object ( NULL B) Input:A;  //_GUI 21,15
 Object ( Variant PipeLenA) Input:B;  //_GUI 21,18
 Object ( NULL PipeLenB) Input:C;  //_GUI 21,21
 Object ( Bit ClkG) Input:D;  //_GUI 21,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 21,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 21,33
 Object ( Bit GoB) Input:G;  //_GUI 21,36
 Object ( Bit Wait) Input:H;  //_GUI 33,45
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 34,12
 Object Output:A( NULL B) ;  //_GUI 34,15
 Object Output:B( Variant PipeLenA) ;  //_GUI 34,18
 Object Output:C( NULL PipeLenB) ;  //_GUI 34,21
 Object Output:D( Variant FullPipeLen) ;  //_GUI 34,24
 Object Output:E( Bit ClkG) ;  //_GUI 34,27
 Object Output:F( Bit AClr) ;  //_GUI 34,30
 Object Output:G( Bit BusyA) ;  //_GUI 34,33
 Object Output:H( Bit BusyB) ;  //_GUI 34,36
 Object Output:I( Bit Done) ;  //_GUI 34,39
 Object Text;  //_GUI 23,49,If no data then don't forward Goes and PipeLen
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 29,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Junction.1;  
 Output:C.0 = Input:C.0;  
 Output:D.0 = Junction.2;  //_GUI 30,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:G.0 = Input:H.0;  //_GUI 31,34, 31,43, 37,43
 Output:I.0 = Input:F.0;  //_GUI 28,40, 28,34
 Junction.0 = Input:B.0;  
}

Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, NULL PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="var/var/NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,5
 Object ( Variant B) Input:A;  //_GUI 24,8
 Object ( NULL PipeLenA) Input:B;  //_GUI 16,22
 Object ( Variant PipeLenB) Input:C;  //_GUI 16,25
 Object ( Bit ClkG) Input:D;  //_GUI 48,26
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 48,29
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 25,39
 Object ( Bit GoB) Input:G;  //_GUI 25,42
 Object ( Bit Wait) Input:H;  //_GUI 67,69
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 86,5
 Object Output:A( Variant B) ;  //_GUI 86,8
 Object Output:B( Variant PipeLenA) ;  //_GUI 92,16
 Object Output:C( Variant PipeLenB) ;  //_GUI 92,19
 Object Output:D( Variant FullPipeLen) ;  //_GUI 88,26
 Object Output:E( Bit ClkG) ;  //_GUI 75,29
 Object Output:F( Bit AClr) ;  //_GUI 75,32
 Object Output:G( Bit BusyA) ;  //_GUI 99,49
 Object Output:H( Bit BusyB) ;  //_GUI 99,52
 Object Output:I( Bit Done) ;  //_GUI 75,57
 Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) ;  //_GUI 52,19
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 73,48
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 30,4
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 24,21
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 33,38
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 47,40
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 59,48
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 79,15
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 73,4
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 86,47
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 86,50

 //_ Behavior Topology
 Output.0 = ListIn:B.1;  
 Output:A.0 = ListIn:B.0;  
 Output:B.0 = ListIn:A.1;  
 Output:C.0 = ListIn:A.0;  
 Output:D.0 = SyncReg_Pipe.2;  
 Output:E.0 = SyncReg_Pipe.3;  
 Output:F.0 = SyncReg_Pipe.4;  
 Output:G.0 = VouchBit.0;  
 Output:H.0 = VouchBit:A.0;  
 Output:I.0 = SyncReg_Pipe.5;  //_GUI 75,36
 SyncReg_Pipe.0 = ListOut.0;  //_GUI 52,7
 SyncReg_Pipe.1 = ListOut:A.0;  
 SyncReg_Pipe.2 = Input:D.0;  
 SyncReg_Pipe.3 = Input:E.0;  
 SyncReg_Pipe.4 = Junction.0;  //_GUI 48,36
 SyncReg_Pipe.5 = Input:H.0;  
 ListIn.0 = Cast.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ListOut:A.0 = Input:C.0;  
 ListOut:A.1 = Input:B.0;  
 ListOut:B.0 = Input:G.0;  
 ListOut:B.1 = Input:F.0;  
 Junction.0 = ListOut:B.0;  
 Cast.0 = Junction.2;  //_GUI 48,50
 Cast.1 = SyncReg_Pipe.6;  //_GUI 52,53
 ListIn:A.0 = SyncReg_Pipe.1;  //_GUI 75,18, 75,24
 ListIn:B.0 = SyncReg_Pipe.0;  //_GUI 73,13, 71,13
 VouchBit.0 = ListIn.1;  
 VouchBit:A.0 = ListIn.0;  
}

Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, NULL PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="var/var/var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,5
 Object ( Variant B) Input:A;  //_GUI 24,8
 Object ( Variant PipeLenA) Input:B;  //_GUI 16,22
 Object ( NULL PipeLenB) Input:C;  //_GUI 16,25
 Object ( Bit ClkG) Input:D;  //_GUI 48,26
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 48,29
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 25,39
 Object ( Bit GoB) Input:G;  //_GUI 25,42
 Object ( Bit Wait) Input:H;  //_GUI 67,69
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 86,5
 Object Output:A( Variant B) ;  //_GUI 86,8
 Object Output:B( Variant PipeLenA) ;  //_GUI 92,16
 Object Output:C( Variant PipeLenB) ;  //_GUI 92,19
 Object Output:D( Variant FullPipeLen) ;  //_GUI 88,26
 Object Output:E( Bit ClkG) ;  //_GUI 75,29
 Object Output:F( Bit AClr) ;  //_GUI 75,32
 Object Output:G( Bit BusyA) ;  //_GUI 99,49
 Object Output:H( Bit BusyB) ;  //_GUI 99,52
 Object Output:I( Bit Done) ;  //_GUI 75,57
 Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) ;  //_GUI 52,19
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 73,48
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 30,4
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 24,21
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 33,38
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 47,40
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 59,48
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 79,15
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 73,4
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 86,47
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 86,50

 //_ Behavior Topology
 Output.0 = ListIn:B.1;  
 Output:A.0 = ListIn:B.0;  
 Output:B.0 = ListIn:A.1;  
 Output:C.0 = ListIn:A.0;  
 Output:D.0 = SyncReg_Pipe.2;  
 Output:E.0 = SyncReg_Pipe.3;  
 Output:F.0 = SyncReg_Pipe.4;  
 Output:G.0 = VouchBit.0;  
 Output:H.0 = VouchBit:A.0;  
 Output:I.0 = SyncReg_Pipe.5;  //_GUI 75,36
 SyncReg_Pipe.0 = ListOut.0;  //_GUI 52,7
 SyncReg_Pipe.1 = ListOut:A.0;  
 SyncReg_Pipe.2 = Input:D.0;  
 SyncReg_Pipe.3 = Input:E.0;  
 SyncReg_Pipe.4 = Junction.0;  //_GUI 48,36
 SyncReg_Pipe.5 = Input:H.0;  
 ListIn.0 = Cast.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ListOut:A.0 = Input:C.0;  
 ListOut:A.1 = Input:B.0;  
 ListOut:B.0 = Input:G.0;  
 ListOut:B.1 = Input:F.0;  
 Junction.0 = ListOut:B.0;  
 Cast.0 = Junction.2;  //_GUI 48,50
 Cast.1 = SyncReg_Pipe.6;  //_GUI 52,53
 ListIn:A.0 = SyncReg_Pipe.1;  //_GUI 75,18, 75,24
 ListIn:B.0 = SyncReg_Pipe.0;  //_GUI 73,13, 71,13
 VouchBit.0 = ListIn.1;  
 VouchBit:A.0 = ListIn.0;  
}

Object ( Variant A, Variant B, NULL PipeLenA
    , NULL PipeLenB, NULL FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, NULL PipeLenA, NULL PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="var/var/NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 21,12
 Object ( Variant B) Input:A;  //_GUI 21,15
 Object ( NULL PipeLenA) Input:B;  //_GUI 21,18
 Object ( NULL PipeLenB) Input:C;  //_GUI 21,21
 Object ( Bit ClkG) Input:D;  //_GUI 21,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 21,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 21,33
 Object ( Bit GoB) Input:G;  //_GUI 21,36
 Object ( Bit Wait) Input:H;  //_GUI 33,45
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 34,12
 Object Output:A( Variant B) ;  //_GUI 34,15
 Object Output:B( NULL PipeLenA) ;  //_GUI 34,18
 Object Output:C( NULL PipeLenB) ;  //_GUI 34,21
 Object Output:D( NULL FullPipeLen) ;  //_GUI 34,24
 Object Output:E( Bit ClkG) ;  //_GUI 34,27
 Object Output:F( Bit AClr) ;  //_GUI 34,30
 Object Output:G( Bit BusyA) ;  //_GUI 34,33
 Object Output:H( Bit BusyB) ;  //_GUI 34,36
 Object Output:I( Bit Done) ;  //_GUI 34,39
 Object Text;  //_GUI 23,49,The two datapaths have the same pipelen (0) so are already synchronized.  Pass one of the Goes through.  Send the Wait to both of the Busies.
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 29,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 30,36
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:B
    ( NULL In1) ;  //_GUI 29,21

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Junction.1;  
 Output:C.0 = Junction:B.1;  
 Output:D.0 = Junction:B.2;  //_GUI 30,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:G.0 = Junction:A.1;  //_GUI 31,34
 Output:H.0 = Junction:A.2;  
 Output:I.0 = Input:G.0;  //_GUI 28,40, 28,37
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:H.0;  //_GUI 31,43, 37,43
 Junction:B.0 = Junction.2;  
}

Object ( Variant A, NULL B, NULL PipeLenA
    , NULL PipeLenB, NULL FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , NULL B, NULL PipeLenA, NULL PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="var/NULL/NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 21,12
 Object ( NULL B) Input:A;  //_GUI 21,15
 Object ( NULL PipeLenA) Input:B;  //_GUI 21,18
 Object ( NULL PipeLenB) Input:C;  //_GUI 21,21
 Object ( Bit ClkG) Input:D;  //_GUI 21,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 21,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 21,33
 Object ( Bit GoB) Input:G;  //_GUI 21,36
 Object ( Bit Wait) Input:H;  //_GUI 33,45
 //_ Attributes Constant="0"
 Object Output( Variant A) ;  //_GUI 34,12
 Object Output:A( NULL B) ;  //_GUI 34,15
 Object Output:B( NULL PipeLenA) ;  //_GUI 34,18
 Object Output:C( NULL PipeLenB) ;  //_GUI 34,21
 Object Output:D( NULL FullPipeLen) ;  //_GUI 34,24
 Object Output:E( Bit ClkG) ;  //_GUI 34,27
 Object Output:F( Bit AClr) ;  //_GUI 34,30
 Object Output:G( Bit BusyA) ;  //_GUI 34,33
 Object Output:H( Bit BusyB) ;  //_GUI 34,36
 Object Output:I( Bit Done) ;  //_GUI 34,39
 Object Text;  //_GUI 23,49,The two datapaths have the same pipelen (0) so are already synchronized.  Pass one of the Goes through.  Send the Wait to both of the Busies.
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 29,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 30,36
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:B
    ( NULL In1) ;  //_GUI 29,21

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Junction.1;  
 Output:C.0 = Junction:B.1;  
 Output:D.0 = Junction:B.2;  //_GUI 30,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:G.0 = Junction:A.1;  //_GUI 31,34
 Output:H.0 = Junction:A.2;  
 Output:I.0 = Input:G.0;  //_GUI 28,40, 28,37
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:H.0;  //_GUI 31,43, 37,43
 Junction:B.0 = Junction.2;  
}

Object ( NULL A, NULL B, NULL PipeLenA
    , NULL PipeLenB, NULL FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( NULL A
    , NULL B, NULL PipeLenA, NULL PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="NULL/NULL/NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 21,12
 Object ( NULL B) Input:A;  //_GUI 21,15
 Object ( NULL PipeLenA) Input:B;  //_GUI 21,18
 Object ( NULL PipeLenB) Input:C;  //_GUI 21,21
 Object ( Bit ClkG) Input:D;  //_GUI 21,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 21,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 21,33
 Object ( Bit GoB) Input:G;  //_GUI 21,36
 Object ( Bit Wait) Input:H;  //_GUI 33,45
 //_ Attributes Constant="0"
 Object Output( NULL A) ;  //_GUI 34,12
 Object Output:A( NULL B) ;  //_GUI 34,15
 Object Output:B( NULL PipeLenA) ;  //_GUI 34,18
 Object Output:C( NULL PipeLenB) ;  //_GUI 34,21
 Object Output:D( NULL FullPipeLen) ;  //_GUI 34,24
 Object Output:E( Bit ClkG) ;  //_GUI 34,27
 Object Output:F( Bit AClr) ;  //_GUI 34,30
 Object Output:G( Bit BusyA) ;  //_GUI 34,33
 Object Output:H( Bit BusyB) ;  //_GUI 34,36
 Object Output:I( Bit Done) ;  //_GUI 34,39
 Object Text;  //_GUI 23,49,The two datapaths have the same pipelen (0) so are already synchronized.  Pass one of the Goes through.  Send the Wait to both of the Busies.
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 29,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 30,36
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:B
    ( NULL In1) ;  //_GUI 29,21

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Junction.1;  
 Output:C.0 = Junction:B.1;  
 Output:D.0 = Junction:B.2;  //_GUI 30,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:G.0 = Junction:A.1;  //_GUI 31,34
 Output:H.0 = Junction:A.2;  
 Output:I.0 = Input:G.0;  //_GUI 28,40, 28,37
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:H.0;  //_GUI 31,43, 37,43
 Junction:B.0 = Junction.2;  
}

Object ( NULL A, Variant B, NULL PipeLenA
    , NULL PipeLenB, NULL FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( NULL A
    , Variant B, NULL PipeLenA, NULL PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="NULL/var/NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 21,12
 Object ( Variant B) Input:A;  //_GUI 21,15
 Object ( NULL PipeLenA) Input:B;  //_GUI 21,18
 Object ( NULL PipeLenB) Input:C;  //_GUI 21,21
 Object ( Bit ClkG) Input:D;  //_GUI 21,27
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:E;  //_GUI 21,30
 //_ Attributes Constant="0"
 Object ( Bit GoA) Input:F;  //_GUI 21,33
 Object ( Bit GoB) Input:G;  //_GUI 21,36
 Object ( Bit Wait) Input:H;  //_GUI 33,45
 //_ Attributes Constant="0"
 Object Output( NULL A) ;  //_GUI 34,12
 Object Output:A( Variant B) ;  //_GUI 34,15
 Object Output:B( NULL PipeLenA) ;  //_GUI 34,18
 Object Output:C( NULL PipeLenB) ;  //_GUI 34,21
 Object Output:D( NULL FullPipeLen) ;  //_GUI 34,24
 Object Output:E( Bit ClkG) ;  //_GUI 34,27
 Object Output:F( Bit AClr) ;  //_GUI 34,30
 Object Output:G( Bit BusyA) ;  //_GUI 34,33
 Object Output:H( Bit BusyB) ;  //_GUI 34,36
 Object Output:I( Bit Done) ;  //_GUI 34,39
 Object Text;  //_GUI 23,49,The two datapaths have the same pipelen (0) so are already synchronized.  Pass one of the Goes through.  Send the Wait to both of the Busies.
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 29,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 30,36
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:B
    ( NULL In1) ;  //_GUI 29,21

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Junction.1;  
 Output:C.0 = Junction:B.1;  
 Output:D.0 = Junction:B.2;  //_GUI 30,25
 Output:E.0 = Input:D.0;  
 Output:F.0 = Input:E.0;  
 Output:G.0 = Junction:A.1;  //_GUI 31,34
 Output:H.0 = Junction:A.2;  
 Output:I.0 = Input:G.0;  //_GUI 28,40, 28,37
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:H.0;  //_GUI 31,43, 37,43
 Junction:B.0 = Junction.2;  
}

Object ( Variant Out1, Variant LSB) $ListPopLsb( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,18
 Object ( Variant In2) Input:A;  //_GUI 15,31
 Object Output( Variant Out1) ;  //_GUI 51,18
 Object Output:A( Variant LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List Out1, Variant LSB) $ListPopLsb( Variant In1
    , List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,24
 Object ( List In2) Input:A;  //_GUI 15,31
 Object Output( List Out1) ;  //_GUI 68,25
 Object Output:A( Variant LSB) ;  //_GUI 68,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,23
 Object ( Variant Out1, Variant LSB) $ListPopLsb( Variant In1
    , Variant In2) ;  //_GUI 37,29
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = $ListPopLsb.1;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $ListPopLsb.0;  //_GUI 51,28, 51,31
 ListOut.1 = Input.0;  
 $ListPopLsb.0 = ListIn.1;  
 $ListPopLsb.1 = ListIn.0;  
}

Object ( NULL Out1, Variant LSB) $ListPopLsb( NULL In1
    , Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,18
 Object ( Variant In2) Input:A;  //_GUI 15,31
 Object Output( NULL Out1) ;  //_GUI 51,18
 Object Output:A( Variant LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL Out1, NULL LSB) $ListPopLsb( NULL In1
    , NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,18
 Object ( NULL In2) Input:A;  //_GUI 15,31
 Object Output( NULL Out1) ;  //_GUI 51,18
 Object Output:A( NULL LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant Out1, NULL LSB) $ListPopLsb( Variant In1
    , NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,18
 Object ( NULL In2) Input:A;  //_GUI 15,31
 Object Output( Variant Out1) ;  //_GUI 51,18
 Object Output:A( NULL LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,21
 Object ( Variant In2) Input:A;  //_GUI 28,24
 Object Output( List Out1) ;  //_GUI 51,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 35,20

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( List Hi, Variant Lo) $BisectList_High( Variant MSB
    , List List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 22,28
 Object ( List List) Input:A;  //_GUI 22,33
 Object Output( List Hi) ;  //_GUI 104,29
 Object Output:A( Variant Lo) ;  //_GUI 102,35
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( List Out1) PackMSB( Variant In2, Variant In3) ;  //_GUI 84,27
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object ( Variant Out1, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 34,31
 //_ Attributes Documentation="ztlist"
 Object ( Variant Hi, Variant Lo) $BisectList_Low( Variant List
    , Variant LSB) ;  //_GUI 54,31
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = PackMSB.0;  
 Output:A.0 = $BisectList_Low.1;  
 PackMSB.0 = Input.0;  
 PackMSB.1 = $BisectList_Low.0;  //_GUI 82,32, 82,33
 ListPopLsb.0 = Input:A.0;  
 $BisectList_Low.0 = ListPopLsb.0;  
 $BisectList_Low.1 = ListPopLsb.1;  
}

Object ( Variant Hi, Variant Lo) $BisectList_High( Variant MSB
    , Variant List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 22,28
 Object ( Variant List) Input:A;  //_GUI 22,33
 Object Output( Variant Hi) ;  //_GUI 95,28
 Object Output:A( Variant Lo) ;  //_GUI 67,33
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List RightUpper, List RightLower) PossibleRightShifts( Variant Data
    , Variant Size, Bit IsTwos) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 30,23
 Object ( Variant Size) Input:A;  //_GUI 40,35
 Object ( Bit IsTwos) Input:B;  //_GUI 41,46
 //_ Attributes Constant="0"
 Object Output( List RightUpper) ;  //_GUI 166,31
 Object Output:A( List RightLower) ;  //_GUI 178,43
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 64,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 93,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 78,36
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 153,29
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 156,41
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 83,15
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 101,43
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 86,51
 //_ Attributes Documentation="PadLeft"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 141,20
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 64,13
 Object Text;  //_GUI 10,56,This object creates LSB lists of all the possible right shifts for a dataset.It's true: this object is a bit of a mystery, but here's the basic plan. We pop bits off of the right of our incoming data and pad the top of the remaining data with zeros. This is our standard shift. The falloff data is built from the popped-off data.
 Object ( Variant Out1) PushLsb:A( Variant In1, Variant LSB) ;  //_GUI 128,18
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 49,21
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 41,2
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 40,23
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 71,2
 Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Variant Size, Bit IsTwos) ;  //_GUI 94,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 54,46
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 104,3
 //_ Attributes Documentation="ztlist/ztlist"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 PushLsb.0 = Input:A.0;  
 PushLsb.1 = PopLsb.1;  //_GUI 59,39
 Junction.0 = PopLsb.0;  
 Junction:A.0 = PushLsb.0;  
 ListOut.0 = Junction:B.1;  //_GUI 150,34, 150,21
 ListOut.1 = PossibleRightShifts.0;  //_GUI 146,31, 146,34
 ListOut:A.0 = ReverseBits.0;  
 ListOut:A.1 = PossibleRightShifts.1;  //_GUI 136,43, 136,37
 Zero.0 = PopMsb.1;  
 ReverseBits.0 = UExtnd.1;  //_GUI 98,46, 98,56
 UExtnd.0 = Junction:B.2;  //_GUI 86,28, 142,28
 UExtnd.1 = Junction:A.2;  //_GUI 79,56
 Junction:B.0 = PushLsb:A.0;  
 PopMsb.0 = Junction:A.0;  //_GUI 64,29, 79,29
 PushLsb:A.0 = OR.0;  //_GUI 128,6
 PushLsb:A.1 = Junction.1;  
 PopLsb.0 = Junction:C.1;  
 PopMsb:A.0 = Junction:C.0;  
 Junction:C.0 = Input.0;  
 AND.0 = PopMsb:A.0;  
 AND.1 = Junction:D.0;  //_GUI 55,7
 PossibleRightShifts.0 = Junction.2;  
 PossibleRightShifts.1 = Junction:A.1;  
 PossibleRightShifts.2 = Junction:D.1;  //_GUI 91,40, 91,47
 Junction:D.0 = Input:B.0;  
 OR.0 = AND.0;  
 OR.1 = Zero.0;  //_GUI 98,8, 98,18
}

Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Bit Data
    , Variant Size, Bit IsTwos) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="leaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 26,43
 Object ( Variant Size) Input:A;  //_GUI 15,49
 Object ( Bit IsTwos) Input:B;  //_GUI 29,59
 //_ Attributes Constant="0"
 Object Output( Variant RightUpper) ;  //_GUI 95,24
 Object Output:A( Variant RightLower) ;  //_GUI 92,41
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 79,41
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 69,21
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 52,39
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 64,39
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 21,47
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 61,55
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 41,43
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 83,22
 //_ Attributes Documentation="ztlist/ztlist"

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = Junction.1;  
 Junction.0 = ReverseBits.0;  
 Zero.0 = Junction.0;  //_GUI 69,35, 80,35
 PushLsb.0 = PopMsb.1;  //_GUI 48,41, 48,52
 PushLsb.1 = Junction:A.1;  
 ReverseBits.0 = PushLsb.0;  
 PopMsb.0 = Input:A.0;  
 AND.0 = Junction:A.2;  //_GUI 42,57
 AND.1 = Input:B.0;  
 Junction:A.0 = Input.0;  
 OR.0 = Zero.0;  
 OR.1 = AND.0;  //_GUI 83,58
}

Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), =, !)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ne_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,! (0 == 0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ne_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != ! 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ne_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != ! 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant "#0", Variant "#1") Deselect( Variant In1
    , Bit S) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced"
{
 // Does a compile time deselect between two output paths.  Can be thought of as a compile time demultiplexer. Used to be the $SelectOut object.  The path that is not selected should get removed with sourceless removal.  Sometimes sourceless removal doesn't remove everything that was desired, so it is recommended that the Select object be used in conjunction with Deselect.
 //
 // Inputs:
 //
 // Variant input: The input that will become #0 or #1.
 //
 // Bit S: This select bit must be a constant or compile will halt.  A value of 0 causes the input to be connected to the #0 output and the #1 output is internally left hanging causing sourceless removal to take effect.  A value of 1 causes the input to be connected to the #1 output and the #0 output is internally left hanging causing sourceless removal to take effect.
 //
 // Outputs:
 //
 // Variant #0: A pass through of the input if S is 0, internally disconnected otherwise.
 //
 // Variant #1: A pass through of the input if S is 1, internally disconnected otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,19
 Object ( Bit S) Input:A;  //_GUI 28,22
 //_ Attributes Constant="0"
 Object Output( Variant "#0") ;  //_GUI 48,19
 Object Output:A( Variant "#1") ;  //_GUI 48,22
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 34,18

 //_ Behavior Topology
 Output.0 = $SelectOut.0;  
 Output:A.0 = $SelectOut.1;  
 $SelectOut.0 = Input.0;  
 $SelectOut.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is less than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Lt_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Lt_BitB.0 = MSB.0;  
 $BitA_Lt_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is less than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 18,23,(0 < 0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is less than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 31,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Lt_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Lt_BitB.0 = Input.0;  
 $BitA_Lt_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is less than to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object Text;  //_GUI 8,29,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Lt_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Lt_BitB.0 = MSB.0;  
 $BitA_Lt_BitB.1 = Input:A.0;  
}

Object ( Variant Out1) $ConvBExpGrow( Variant Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 8,15
 Object ( Variant Data) Input:A;  //_GUI 8,25
 Object Output( Variant Out1) ;  //_GUI 92,20
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 19,23
 //_ Attributes Documentation="bit"
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 19,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 14,25
 Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 65,20
 Object ( Variant Out1) DupBit( Bit Bit, Variant DupSize) ;  //_GUI 50,11
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 38,10
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In3) ;  //_GUI 33,21
 Object Text;  //_GUI 6,52,BExp - Bias = BExp + (-Bias) = SExp = SExp = SignExt + Bias = BExp(4) = BExp(5)000  - 011  = 000  +   101   = 101  = -3   = 1101    + 0111 = 0100    = 01100001  - 011  = 001  +   101   = 110  = -2   = 1101    + 0111 = 0101    = 01101010  - 011  = 010  +   101   = 111  = -1   = 1101    + 0111 = 0110    = 01100011  - 011  = 011  +   101   = 000  =  0   = 0000    + 0111 = 0111    = 01101100  - 011  = 100  +   101   = 001  =  1   = 0001    + 0111 = 1000    = 10000101  - 011  = 101  +   101   = 010  =  2   = 0010    + 0111 = 1001    = 10001110  - 011  = 110  +   101   = 011  =  3   = 0011    + 0111 = 1010    = 10010111  - 011  = 111  +   101   = 100  = (4)  = 0100    + 0111 = 1011    = 10011Courier New,8,0,0
 Object Text;  //_GUI 7,32,To expand a biased exponent1. remove bias2. sign extend3. add biasThis can be done a lot faster by observing the pattern below
 Object Text;  //_GUI 6,79,For example a 4 bit binary number represented by the bit positions A through DABCD expanded by 3 bits turns into  ___AAAABCDWhich is A followed by the inverse of A for all expanded bits, followed by the rest of the previously existing bits B, C and D.Courier New,8,0,0
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 80,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 14,15

 //_ Behavior Topology
 Output.0 = Context.0;  
 ExposeMSB.0 = Junction.1;  
 Lo_N.0 = Junction:B.1;  
 Lo_N.1 = Junction.0;  //_GUI 15,19
 Junction.0 = Input:A.0;  
 CollectMSB.0 = Junction:A.2;  
 CollectMSB.1 = DupBit.0;  //_GUI 62,25, 62,14
 CollectMSB.2 = ExposeMSB.1;  
 DupBit.0 = INVERT.0;  
 DupBit.1 = Lo_N.0;  
 INVERT.0 = Junction:A.1;  //_GUI 34,13
 Junction:A.0 = ExposeMSB.0;  //_GUI 34,25
 Context.0 = Junction:B.0;  //_GUI 80,7, 15,7
 Context.1 = CollectMSB.0;  
 Junction:B.0 = Input.0;  
}

Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) $ConvBExpShrink
    ( Variant Type, Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 6,22
 Object ( Variant Data) Input:A;  //_GUI 6,28
 Object Output( Bit SetToMaxPos) ;  //_GUI 171,17
 Object Output:A( Bit SetTo0) ;  //_GUI 165,26
 Object Output:B( Variant Out3) ;  //_GUI 145,39
 Object Text;  //_GUI 4,98,For example a 7 bit binary number represented by the bit positions A through GABCDEFG Shrunk by 3 bits turns into AEFGThere is no error if B,C and D all have the same value as the inverse of A.If they are not the inverse of A and A is high, output SetToMaxPos. If they are not the inverse of A and A is low, output SetToZero.Courier New,8,0,0
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 37,20
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 50,16
 //_ Attributes Documentation="bit"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 69,15
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 90,16
 Object ( Bit Out1) AND-NInput( Variant In1) ;  //_GUI 109,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 105,18
 Object Text;  //_GUI 6,45,To shrink a biased exponent1. remove bias2. Remove high bits. If high bit low and others not then error to MaxPos.  If high bit high and others not, send to zero.3. add biasThis can be done a lot faster by observing the pattern below in an expand:
 Object Text;  //_GUI 6,69,BExp - Bias = BExp + (-Bias) = SExp = SExp = SignExt + Bias = BExp(4) = BExp(5) = BExp(2) 000  - 011  = 000  +   101   = 101  = -3   = 1101    + 0111 = 0100    = 01100   = sz    001  - 011  = 001  +   101   = 110  = -2   = 1101    + 0111 = 0101    = 01101   = sz010  - 011  = 010  +   101   = 111  = -1   = 1101    + 0111 = 0110    = 01100   = 00011  - 011  = 011  +   101   = 000  =  0   = 0000    + 0111 = 0111    = 01101   = 01100  - 011  = 100  +   101   = 001  =  1   = 0001    + 0111 = 1000    = 10000   = 10101  - 011  = 101  +   101   = 010  =  2   = 0010    + 0111 = 1001    = 10001   = 11110  - 011  = 110  +   101   = 011  =  3   = 0011    + 0111 = 1010    = 10010   = mp111  - 011  = 111  +   101   = 100  = (4)  = 0100    + 0111 = 1011    = 10011   = mpCourier New,8,0,0
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 65,17
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 81,39
 Object ( Variant Out1, Variant Out1) ExposeMSB:A( Variant In1) ;  //_GUI 16,20
 //_ Attributes Documentation="bit"
 Object Text;  //_GUI 13,11,Shrink Type by one bit because will put MSB back on later
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 129,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 12,22
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 109,16
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 125,23
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 130,14
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 140,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 83,17
 Object ( Bit Out1) AND-NInput:A( Variant In1) ;  //_GUI 109,30
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 154,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 104,41

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = AND:A.0;  
 Output:B.0 = Context.0;  
 Lo_N.0 = Input:A.0;  //_GUI 35,22, 35,29
 Lo_N.1 = ExposeMSB:A.1;  
 ExposeMSB.0 = Lo_N.0;  //_GUI 48,19, 48,22
 INVERT.0 = Junction:A.1;  
 CollectMSB.0 = Junction:C.1;  
 CollectMSB.1 = ExposeMSB.1;  
 AND-NInput.0 = Junction.2;  //_GUI 106,26
 Junction.0 = CollectMSB.0;  
 Junction:A.0 = ExposeMSB.0;  
 CollectMSB:A.0 = Junction:A.2;  //_GUI 66,41
 CollectMSB:A.1 = Lo_N.1;  //_GUI 48,44, 48,25
 ExposeMSB:A.0 = Junction:B.1;  
 Context.0 = Junction:B.2;  //_GUI 100,39, 100,37, 13,37
 Context.1 = Junction:D.1;  
 Junction:B.0 = Input.0;  
 OR-NInput.0 = Junction.1;  
 INVERT:A.0 = AND-NInput.0;  
 AND.0 = Junction:A.0;  //_GUI 130,9, 66,9
 AND.1 = OR-NInput.0;  
 AND:A.0 = INVERT:A.0;  
 AND:A.1 = Junction:C.2;  //_GUI 84,29
 Junction:C.0 = INVERT.0;  
 AND-NInput:A.0 = Junction:D.0;  //_GUI 105,33
 OR.0 = AND.0;  
 OR.1 = AND-NInput:A.0;  //_GUI 154,33
 Junction:D.0 = CollectMSB:A.0;  
}

Object ( Variant Out1) InvertEn( Variant In1, Bit En) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\Advanced"
{
 // Conditionally inverts the input data (similar to an XOR).
 //
 // Inputs:
 //
 // Variant input: data
 //
 // Bit EN: Enable the invert when high or pass through when low.
 //
 // Outputs:
 //
 // Variant output: Conditionally inverted data.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,19
 Object ( Bit En) Input:A;  //_GUI 19,26
 //_ Attributes Constant="1"
 Object Output( Variant Out1) ;  //_GUI 68,17
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 30,17
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 51,15
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 25,19

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 INVERT.0 = Junction.1;  
 $Mux.0 = Junction.0;  //_GUI 26,17
 $Mux.1 = INVERT.0;  
 $Mux.2 = Input:A.0;  //_GUI 37,23, 37,27
 Junction.0 = Input.0;  
}

Object ( NULL Out1) InvertEn( NULL In1, Bit En) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal",Documentation="NULL"
{
 // Conditionally inverts the input data (similar to an XOR).
 //
 // Inputs:
 //
 // Variant input: data
 //
 // Bit EN: Enable the invert when high or pass through when low.
 //
 // Outputs:
 //
 // Variant output: Conditionally inverted data.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,19
 Object ( Bit En) Input:A;  //_GUI 19,26
 Object Output( NULL Out1) ;  //_GUI 32,19

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant O) RoundUp( Bit Round, Variant D) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Round) Input;  //_GUI 23,18
 Object ( Variant D) Input:A;  //_GUI 23,24
 Object Output( Variant O) ;  //_GUI 86,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 37,24
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 40,25
 Object Text;  //_GUI 38,41,if we can round here without overflowing, we'll do it; we could multiplex with the CO, but this OR gate should just take every bit high, which would be the same thing only more efficient
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 72,26
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 50,23

 //_ Behavior Topology
 Output.0 = OR.0;  
 Junction.0 = Input:A.0;  
 Zero.0 = Junction.2;  //_GUI 38,28
 OR.0 = ADSU.0;  //_GUI 72,25
 OR.1 = ADSU.2;  
 ADSU.0 = Junction.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = Input.0;  //_GUI 31,34, 31,19
}

Object ( Variant O) RoundUp( NULL Round, Variant D) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Round) Input;  //_GUI 23,18
 Object ( Variant D) Input:A;  //_GUI 23,24
 Object Output( Variant O) ;  //_GUI 32,24

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) OR( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\OR"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,22
 Object ( Variant In2) Input:A;  //_GUI 21,25
 Object ( Variant In3) Input:B;  //_GUI 21,29
 Object ( Variant In4) Input:C;  //_GUI 21,32
 Object Output( Variant Out1) ;  //_GUI 64,26
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 27,21
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 48,24
 Object ( Variant Out1) OR:B( Variant In1, Variant In2) ;  //_GUI 27,28

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
 OR:A.0 = OR.0;  //_GUI 43,26, 43,24
 OR:A.1 = OR:B.0;  //_GUI 43,29, 43,31
 OR:B.0 = Input:B.0;  
 OR:B.1 = Input:C.0;  
}

Object ( Bit Out1) OR( Bit In1, Bit In2
    , Bit In3, Bit In4) 
//_ Attributes TreeGroup="System\\Communications\\Implementors\\HClib",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 17,22
 Object ( Bit In2) Input:A;  //_GUI 17,25
 Object ( Bit In3) Input:B;  //_GUI 17,29
 Object ( Bit In4) Input:C;  //_GUI 17,32
 Object Output( Bit Out1) ;  //_GUI 52,26
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 23,28
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 23,21
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 40,24

 //_ Behavior Topology
 Output.0 = OR:B.0;  
 OR.0 = Input:B.0;  
 OR.1 = Input:C.0;  
 OR:A.0 = Input.0;  
 OR:A.1 = Input:A.0;  
 OR:B.0 = OR:A.0;  //_GUI 40,24
 OR:B.1 = OR.0;  //_GUI 40,31
}

Object ( Bit Unsigned, Bit Signed, Bit "Fixed Point"
    , Bit "Floating Point", Bit Complex) StaticType( Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\Advanced"
{
 // Description:
 // Synthsis Parameter Object
 //
 // This object is used in synthesis to selectively synthesize based on Static Data Set types.  It's outputs are used to drive the #S inputs of $Select objects.  Only one input will ever be asserted for any one synthesis.
 //
 // Inputs:
 // Type: incoming data
 //
 // Outputs:
 // (the following outputs are asserted if the input corresponds)
 // Unsigned:
 // Signed:
 // Fixed Point:
 // Floating Point:
 // Complex:
 //
 // Date:
 // May 17, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 48,20
 Object Output( Bit Unsigned) ;  //_GUI 112,94
 Object Output:A( Bit Signed) ;  //_GUI 112,98
 Object Output:B( Bit "Fixed Point") ;  //_GUI 112,102
 Object Output:C( Bit "Floating Point") ;  //_GUI 112,106
 Object Output:D( Bit Complex) ;  //_GUI 112,110
 Object ( MSB032 In) Input:A;  //_GUI 48,30
 //_ Attributes PromoteToParentObject="False",Constant="$(NodeInfo:0:WidgetHandling)"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29, Variant Out30, Variant Out31
    , Variant Out32) ExposeMSB( Variant In1) ;  //_GUI 71,28

 //_ Behavior Topology
 Output.0 = ExposeMSB.31;  //_GUI 103,95, 103,123
 Output:A.0 = ExposeMSB.30;  //_GUI 100,99, 100,120
 Output:B.0 = ExposeMSB.29;  //_GUI 97,103, 97,117
 Output:C.0 = ExposeMSB.28;  //_GUI 86,107, 86,114
 Output:D.0 = ExposeMSB.27;  
 ExposeMSB.0 = Input:A.0;  
}

Object ( Bit C, Bit Out1) SHR( Bit In2
    , Bit C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="Bit"
{
 // Bit case for SHR
 //
 // Date Last Modified:
 // 26 June 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In2) Input;  //_GUI 7,17
 Object ( Bit C) Input:A;  //_GUI 8,25
 //_ Attributes Constant="0"
 Object Output( Bit C) ;  //_GUI 46,17
 Object Output:A( Bit Out1) ;  //_GUI 46,25

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit C, Variant Out1) SHR( Variant In2
    , Bit C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters",Documentation="Bit_Carry"
{
 // Shift Right with Carry
 //
 // This object simply realigns bits and does not consume any physical resources.
 //
 // Inputs:
 // In1- Input Data
 // C- Carry-In Bit
 //
 // Outputs:
 // C- Carry-Out Bit
 // Out2- Output Data
 //
 // Date Last Modified:
 // Mar/2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 7,24
 Object ( Bit C) Input:A;  //_GUI 9,42
 //_ Attributes Constant="0"
 Object Output( Bit C) ;  //_GUI 150,18
 Object Output:A( Variant Out1) ;  //_GUI 157,31
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 110,16
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 110,31
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 123,31
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 52,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 38,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 104,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 31,24
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 141,29

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = Context.0;  
 $Cast.0 = Lo_N.1;  //_GUI 99,21, 99,28
 $Cast.1 = Junction:A.0;  //_GUI 105,18
 ListOut.0 = Lo_N.0;  //_GUI 87,36, 87,25
 ListOut.1 = Junction:A.1;  
 LSB.0 = ListOut.0;  
 Lo_N.0 = Junction:B.1;  
 Lo_N.1 = Junction.1;  //_GUI 39,28
 Junction.0 = Input:A.0;  //_GUI 39,43
 Junction:A.0 = Junction.2;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:B.0;  //_GUI 141,14, 32,14
 Context.1 = LSB.0;  
}

Object ( Variant C, Variant Out2) SHR( Variant In1
    , Variant C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters",Documentation="Var_Carry"
{
 // Shift Right with Carry
 //
 // This object simply realigns bits and does not consume any physical resources.  The input data will be shifted one bit for every bit in the C dataset.
 //
 // Inputs:
 // In1- Input Data
 // C- Carry-In Bits
 //
 // Outputs:
 // C- Carry-Out Bits
 // Out2- Output Data
 //
 // Date Last Modified:
 // Nov/2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 17,27
 Object ( Variant C) Input:A;  //_GUI 19,45
 Object Output( Variant C) ;  //_GUI 162,21
 Object Output:A( Variant Out2) ;  //_GUI 153,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 107,34
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 120,34
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 49,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In3) ;  //_GUI 35,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 101,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 27,27
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 141,32
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 150,19

 //_ Behavior Topology
 Output.0 = Context:A.0;  
 Output:A.0 = Context.0;  
 ListOut.0 = Lo_N.0;  //_GUI 84,39, 84,28
 ListOut.1 = Junction:A.1;  
 LSB.0 = ListOut.0;  
 Lo_N.0 = Junction:B.1;  
 Lo_N.1 = Junction.1;  //_GUI 36,31
 Junction.0 = Input:A.0;  //_GUI 36,46
 Junction:A.0 = Junction.2;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:B.0;  //_GUI 141,13, 28,13
 Context.1 = LSB.0;  
 Context:A.0 = Junction:A.0;  //_GUI 102,21
 Context:A.1 = Lo_N.1;  //_GUI 96,24, 96,31
}

Object ( NULL C, Variant Out2) SHR( Variant In1
    , NULL C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 39,48
 Object ( NULL C) Input:A;  //_GUI 39,57
 Object Output( NULL C) ;  //_GUI 132,36
 Object Output:A( Variant Out2) ;  //_GUI 133,53

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 63,37, 63,58
 Output:A.0 = Input.0;  //_GUI 86,54, 86,49
}

Object ( Bit C, Floating Out2) SHR( Floating In1
    , Variant C) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 10,17
 Object ( Variant C) Input:A;  //_GUI 10,20
 Object Output( Bit C) ;  //_GUI 42,17
 Object Output:A( Floating Out2) ;  //_GUI 42,20
 Object ( Bit C, Floating Out2) SHR_Twos( Floating In1
    , Variant CTypeOnly) ;  //_GUI 22,16
 //_ Attributes Documentation="Floating"

 //_ Behavior Topology
 Output.0 = SHR_Twos.0;  
 Output:A.0 = SHR_Twos.1;  
 SHR_Twos.0 = Input.0;  
 SHR_Twos.1 = Input:A.0;  
}

Object ( Variant O, Variant Count, Bit AlmBsy
    , Bit Done, Bit Busy) Queue_Shift( Variant D, Bit ClkG
    , Bit CLR, Variant DepthSz, Variant AlmBsySz, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\Advanced"
{
 // A FIFO queue implementation that utilizes a shift register rather than addressable memory.  If lists are passed in for D and Go (and out of O, Count, AlmBsy, Done and Busy) then a list of independent Queue_Shifts is built.  In this case, no synchronizing is performed among the Queue_Shifts.
 //
 // Inputs:
 //
 // Var/List D: Write data or a list of write data.
 //
 // Bit ClkG: Write and read clock.  If disconnected defaults to the user global clock.
 //
 // Bit Clr: Clears the queue and any errors.  If disconnected, defaults to 0.
 //
 // Var DepthSz: The bitwidth of the data type defines the size of the memory allocated (2^NumOfBits(DepthSz) - 1 elements)
 //
 // Var AlmBsyBits: Defines when the AlmBsy bits come on.
 //
 // Bit/List Go: The Go of GDBW.  Ignored if Busy high.  If a list of bits, the corresponding D list's element is queued.
 //
 // Bit/List Wait: The Wait of GDBW.  Holds off the corresponding Done.  If a bit and disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Var/List O: Read or output data.  Available while Done is high.
 //
 // Var/List Count: The number of elements in the queue.
 //
 // Bit/List AlmBsy: The queue is almost full (2^NumOfBits(AlmBsyBits) - 1 or less empty spaces left)
 //
 // Bit/List Done: The output data (O) is ready and valid.  Done is held off by the Wait input.
 //
 // Bit/List Busy: There is no more room for data to be written into the queue.  Go should drop and will be ignored.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 28,4
 Object ( Bit ClkG) Input:A;  //_GUI 15,49
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:B;  //_GUI 15,52
 //_ Attributes Constant="0"
 Object ( Variant DepthSz) Input:C;  //_GUI 21,62
 Object ( Variant AlmBsySz) Input:D;  //_GUI 21,70
 Object ( Bit Go) Input:E;  //_GUI 13,78
 Object ( Bit Wait) Input:F;  //_GUI 9,98
 //_ Attributes Constant="0"
 Object Output( Variant O) ;  //_GUI 152,31
 Object Output:A( Variant Count) ;  //_GUI 154,40
 Object Output:B( Bit AlmBsy) ;  //_GUI 162,52
 Object Output:C( Bit Done) ;  //_GUI 168,89
 Object Output:D( Bit Busy) ;  //_GUI 168,99
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 40,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 82,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 103,40
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 107,60
 //_ Attributes Documentation="Variant"
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 123,60
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 28,35
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 137,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 136,62
 Object Text;  //_GUI 126,74,We don't want the user to hurt themselves by wrapping.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 24,36
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 17,96
 Object Text;  //_GUI 16,107,RD_EN = !Wait && Count
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 110,69
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 103,62
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 30,91
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 25,60
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 39,8
 Object ( Bit CO, Variant Count) UpDownCount( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR, Bit UpDown) ;  //_GUI 58,9
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 125,51
 Object ( Bit Out1) EqualZero:B( Variant In1) ;  //_GUI 140,50
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 119,62
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 17,90
 Object Text;  //_GUI 48,60,DepthSize should be 4,5,6,7, or 8.
 Object Text;  //_GUI 49,72,AlmostBusySize should be less than DepthSize.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 43,44
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 22,14
 //_ Attributes Documentation="Variant/Variant"
 Object ( Variant Out1) Dec( Variant In1) ;  //_GUI 107,38
 Object ( Variant QAddr, Variant QDepth) RegDepthAddr( Variant D
    , Bit ClkG, Bit EN, Variant Addr) ;  //_GUI 119,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In3) ;  //_GUI 49,34

 //_ Behavior Topology
 Output.0 = RegDepthAddr.0;  
 Output:A.0 = Junction:A.1;  //_GUI 147,41, 147,14
 Output:B.0 = EqualZero:B.0;  
 Output:C.0 = Junction:G.2;  //_GUI 155,90, 155,45
 Output:D.0 = Junction:C.1;  //_GUI 153,100, 153,63
 Junction.0 = AND.0;  
 Junction:A.0 = UpDownCount.1;  
 Junction:B.0 = Junction:A.2;  //_GUI 83,41
 INVERT.0 = Junction:E.1;  
 EqualZero.0 = Junction:F.1;  
 AND.0 = Junction:D.1;  
 AND.1 = INVERT:A.0;  //_GUI 28,87, 147,87
 INVERT:A.0 = Junction:C.2;  
 Junction:C.0 = EqualZero.0;  
 Junction:D.0 = Input:E.0;  //_GUI 21,37, 21,79
 INVERT:B.0 = Input:F.0;  
 EqualZero:A.0 = Junction:E.2;  //_GUI 104,72
 Junction:E.0 = Junction:B.2;  
 AND:A.0 = INVERT:C.0;  
 AND:A.1 = INVERT:B.0;  //_GUI 29,96, 29,99
 MSB.0 = Input:C.0;  
 One.0 = MSB.0;  //_GUI 35,11
 UpDownCount.0 = One.0;  
 UpDownCount.1 = Junction:H.1;  //_GUI 50,14
 UpDownCount.2 = XOR.0;  
 UpDownCount.3 = Input:B.0;  //_GUI 53,20, 53,53
 UpDownCount.4 = Junction:D.0;  //_GUI 25,23
 Lo_N.0 = Junction:F.0;  //_GUI 120,53
 Lo_N.1 = Input:D.0;  //_GUI 83,56, 83,71
 EqualZero:B.0 = Lo_N.0;  
 Junction:F.0 = INVERT.0;  
 INVERT:C.0 = EqualZero:A.0;  //_GUI 17,83, 121,83
 Junction:G.0 = AND:A.0;  //_GUI 44,94
 XOR.0 = Junction.0;  //_GUI 11,16, 11,29, 41,29
 XOR.1 = Junction:G.1;  //_GUI 16,19, 16,26, 44,26
 Dec.0 = Junction:B.1;  
 RegDepthAddr.0 = Input.0;  //_GUI 105,32, 105,5
 RegDepthAddr.1 = Junction:H.2;  
 RegDepthAddr.2 = Junction.1;  
 RegDepthAddr.3 = Dec.0;  
 Junction:H.0 = Input:A.0;  //_GUI 50,50
}

Object ( List O, List Count, List AlmBsy
    , List Done, List Busy) Queue_Shift( List D, Bit ClkG
    , Bit CLR, Variant DepthSz, Variant AlmBsySz, List Go
    , List Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Memory\\Advanced",Documentation="List/List"
{
 // A FIFO queue implementation that utilizes a shift register rather than addressable memory.  If lists are passed in for D and Go (and out of O, Count, AlmBsy, Done and Busy) then a list of independent Queue_Shifts is built.  In this case, no synchronizing is performed among the Queue_Shifts.
 //
 // Inputs:
 //
 // Var/List D: Write data or a list of write data.
 //
 // Bit ClkG: Write and read clock.  If disconnected defaults to the user global clock.
 //
 // Bit Clr: Clears the queue and any errors.  If disconnected, defaults to 0.
 //
 // Var DepthSz: The bitwidth of the data type defines the size of the memory allocated (2^NumOfBits(DepthSz) - 1 elements)
 //
 // Var AlmBsyBits: Defines when the AlmBsy bits come on.
 //
 // Bit/List Go: The Go of GDBW.  Ignored if Busy high.  If a list of bits, the corresponding D list's element is queued.
 //
 // Bit/List Wait: The Wait of GDBW.  Holds off the corresponding Done.  If a bit and disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Var/List O: Read or output data.  Available while Done is high.
 //
 // Var/List Count: The number of elements in the queue.
 //
 // Bit/List AlmBsy: The queue is almost full (2^NumOfBits(AlmBsyBits) - 1 or less empty spaces left)
 //
 // Bit/List Done: The output data (O) is ready and valid.  Done is held off by the Wait input.
 //
 // Bit/List Busy: There is no more room for data to be written into the queue.  Go should drop and will be ignored.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 24,51
 Object ( Bit ClkG) Input:A;  //_GUI 24,57
 //_ Attributes Resource="Global"
 Object ( Bit CLR) Input:B;  //_GUI 24,60
 //_ Attributes Constant="0"
 Object ( Variant DepthSz) Input:C;  //_GUI 24,63
 Object ( Variant AlmBsySz) Input:D;  //_GUI 24,66
 Object ( List Go) Input:E;  //_GUI 24,70
 Object ( List Wait) Input:F;  //_GUI 97,103
 Object Output( List O) ;  //_GUI 121,43
 Object Output:A( List Count) ;  //_GUI 121,52
 Object Output:B( List AlmBsy) ;  //_GUI 121,61
 Object Output:C( List Done) ;  //_GUI 121,70
 Object Output:D( List Busy) ;  //_GUI 49,103
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,49
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 30,68
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 36,101
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 46,57
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 49,60
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 52,63
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 55,66
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 108,41
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 108,50
 Object ( List Out) ListOut:C( Variant In1, Variant In2) ;  //_GUI 108,59
 Object ( List Out) ListOut:D( Variant In1, Variant In2) ;  //_GUI 108,68
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 103,101
 Object ( Variant O, Variant Count, Variant AlmBsy
    , Variant Done, Variant Busy) Queue_Shift( Variant D, Bit ClkG
    , Bit CLR, Variant DepthSz, Variant AlmBsySz, Variant Go
    , Variant Wait) ;  //_GUI 67,14
 Object ( Variant O, Variant Count, Variant AlmBsy
    , Variant Done, Variant Busy) Queue_Shift:A( Variant D, Bit ClkG
    , Bit CLR, Variant DepthSz, Variant AlmBsySz, Variant Go
    , Variant Wait) ;  //_GUI 67,76

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut:B.0;  
 Output:B.0 = ListOut:C.0;  
 Output:C.0 = ListOut:D.0;  
 Output:D.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:E.0;  
 ListOut.0 = Queue_Shift:A.4;  //_GUI 25,106, 25,96
 ListOut.1 = Queue_Shift.4;  //_GUI 28,103, 28,99, 62,99, 62,34
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:C.0;  
 Junction:C.0 = Input:D.0;  
 ListOut:A.0 = Queue_Shift:A.0;  //_GUI 105,46, 105,78
 ListOut:A.1 = Queue_Shift.0;  //_GUI 105,43, 105,16
 ListOut:B.0 = Queue_Shift:A.1;  //_GUI 102,55, 102,81
 ListOut:B.1 = Queue_Shift.1;  //_GUI 102,52, 102,19
 ListOut:C.0 = Queue_Shift:A.2;  //_GUI 99,64, 99,84
 ListOut:C.1 = Queue_Shift.2;  //_GUI 99,61, 99,22
 ListOut:D.0 = Queue_Shift:A.3;  //_GUI 96,73, 96,93
 ListOut:D.1 = Queue_Shift.3;  //_GUI 96,70, 96,31
 ListIn:B.0 = Input:F.0;  
 Queue_Shift.0 = ListIn.1;  //_GUI 44,16, 44,51
 Queue_Shift.1 = Junction.0;  //_GUI 47,19
 Queue_Shift.2 = Junction:A.0;  //_GUI 50,22
 Queue_Shift.3 = Junction:B.0;  //_GUI 53,25
 Queue_Shift.4 = Junction:C.0;  //_GUI 56,28
 Queue_Shift.5 = ListIn:A.1;  //_GUI 59,31, 59,70
 Queue_Shift.6 = ListIn:B.1;  //_GUI 93,34, 93,99, 118,99, 118,103
 Queue_Shift:A.0 = ListIn.0;  //_GUI 44,78, 44,54
 Queue_Shift:A.1 = Junction.2;  //_GUI 47,81
 Queue_Shift:A.2 = Junction:A.2;  //_GUI 50,84
 Queue_Shift:A.3 = Junction:B.2;  //_GUI 53,87
 Queue_Shift:A.4 = Junction:C.2;  //_GUI 56,90
 Queue_Shift:A.5 = ListIn:A.0;  //_GUI 59,93, 59,73
 Queue_Shift:A.6 = ListIn:B.0;  //_GUI 121,96, 121,106
}

Object ( Bit Out1) EqualZeroList( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced"
{
 // Performs an EqualZero on each element of a list and returns the results as a list of bits.  A Variant input and output represents a single element list.  EqualZeroList differs from EqualZero with list inputs in that EqualZero compares all bits together and will output a bit.
 //
 // Inputs:
 //
 // Variant input: The input value(s); usually a list.  The list elements can be any dataset supported by the EqualZero operator.
 //
 // Outputs:
 //
 // Variant output: The output bit(s); usually a list of bits. A bit is high if its respective input element is equal to zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 4,20
 Object Output( Bit Out1) ;  //_GUI 23,20
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 10,18

 //_ Behavior Topology
 Output.0 = EqualZero.0;  
 EqualZero.0 = Input.0;  
}

Object ( List Out1) EqualZeroList( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Comparators\\Async\\Advanced",Documentation="List"
{
 // Performs an EqualZero on each element of a list and returns the results as a list of bits.  A Variant input and output represents a single element list.  EqualZeroList differs from EqualZero with list inputs in that EqualZero compares all bits together and will output a bit.
 //
 // Inputs:
 //
 // Variant input: The input value(s); usually a list.  The list elements can be any dataset supported by the EqualZero operator.
 //
 // Outputs:
 //
 // Variant output: The output bit(s); usually a list of bits. A bit is high if its respective input element is equal to zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 12,23
 Object Output( List Out1) ;  //_GUI 77,23
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,21
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 55,21
 Object ( Variant Out1) EqualZeroList( Variant In1) ;  //_GUI 37,16
 //_ Attributes Documentation="List"
 Object ( Variant Out1) EqualZeroList:A( Variant In1) ;  //_GUI 37,27
 //_ Attributes Documentation="List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = EqualZeroList:A.0;  //_GUI 52,26, 52,30
 ListOut.1 = EqualZeroList.0;  //_GUI 52,23, 52,19
 EqualZeroList.0 = ListIn.1;  //_GUI 35,19, 35,23
 EqualZeroList:A.0 = ListIn.0;  //_GUI 35,30, 35,26
}

Object ( NULL Out2, Variant Out1) UnPackLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In",Documentation="var"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Revision 2 - 12/07/06
 // Changed from a Var split to a pass-through with NULL.  See Bug 508
 // Revision 1 - 11/13/2002
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,33
 Object Output( NULL Out2) ;  //_GUI 45,25
 Object Output:A( Variant Out1) ;  //_GUI 44,33
 Object ( Bit In) Input:A;  //_GUI 25,13
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:B( Bit Warning) ;  //_GUI 36,13
 //_ Attributes Trap="UnPackLSB - Attempt to UnPack non-List data set."
 Object Text;  //_GUI 23,44,A List should be propogated to this object, in which case the List overload will be instantiated.  In this case however, we have received a non-List type.  We simply pass it along on the lower output, remove the upper output by casting it to NULL and raise a warning message.
 Object ( NULL Out1) NULL;  //_GUI 29,23

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
 Output:B.0 = Input:A.0;  
}

Object ( Variant Out1, Variant Out2) UnPackLSB( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 13,24
 Object Output( Variant Out1) ;  //_GUI 38,23
 Object Output:A( Variant Out2) ;  //_GUI 38,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,22

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( List Out1) $TransposeCompose( List In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 45,34
 Object ( List In2) Input:A;  //_GUI 45,43
 Object Output( List Out1) ;  //_GUI 113,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 100,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 51,41
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 51,32
 Object ( List Out1) $TransposeCompose( Variant In1, Variant In2) ;  //_GUI 73,32
 //_ Attributes Documentation="list/list"
 Object ( List Out1) $TransposeCompose:A( Variant In1, Variant In2) ;  //_GUI 73,41
 //_ Attributes Documentation="list/list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = $TransposeCompose:A.0;  //_GUI 95,38, 95,44
 ListOut.1 = $TransposeCompose.0;  
 ListIn.0 = Input:A.0;  
 ListIn:A.0 = Input.0;  
 $TransposeCompose.0 = ListIn:A.1;  
 $TransposeCompose.1 = ListIn.1;  //_GUI 68,37, 68,43
 $TransposeCompose:A.0 = ListIn:A.0;  //_GUI 71,43, 71,40, 65,40, 65,37
 $TransposeCompose:A.1 = ListIn.0;  
}

Object ( List Out1) $TransposeCompose( List In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 45,34
 Object ( Variant In2) Input:A;  //_GUI 45,37
 Object Output( List Out1) ;  //_GUI 65,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,33

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( List Out1) $TransposeCompose( Variant In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 45,34
 Object ( List In1) Input:A;  //_GUI 45,37
 Object Output( List Out1) ;  //_GUI 65,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,33

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( List Out1) $TransposeCompose( Variant In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 45,34
 Object ( Variant In1) Input:A;  //_GUI 45,37
 Object Output( List Out1) ;  //_GUI 65,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,33

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( Bit Out1) $SameListStruct( List In1, List In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,19
 Object ( List In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 81,23
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,17
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,26
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 69,21
 Object ( Bit Out1) $SameListStruct( Variant In1, Variant In2) ;  //_GUI 46,17
 //_ Attributes Documentation="List/List"
 Object ( Bit Out1) $SameListStruct:A( Variant In1, Variant In2) ;  //_GUI 46,26
 //_ Attributes Documentation="List/List"

 //_ Behavior Topology
 Output.0 = AND.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 AND.0 = $SameListStruct.0;  //_GUI 65,23, 65,20
 AND.1 = $SameListStruct:A.0;  //_GUI 65,26, 65,29
 $SameListStruct.0 = ListIn.1;  
 $SameListStruct.1 = ListIn:A.1;  //_GUI 43,22, 43,28
 $SameListStruct:A.0 = ListIn.0;  //_GUI 46,26, 41,26, 41,22
 $SameListStruct:A.1 = ListIn:A.0;  
}

Object ( Bit Out1) $SameListStruct( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,19
 Object ( Variant In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 32,18,List nodes are same, send out True

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( List In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="List/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,19
 Object ( NULL In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 32,15,We have an element (empty) and a list, send out False

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( NULL In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 22,19
 Object ( List In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 32,18,We have an element (empty) and a list, send out False

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( Variant In1, NULL In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,19
 Object ( NULL In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 34,14,One element is empty, the other is not, but still the same list structure, send out True.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( NULL In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 22,19
 Object ( Variant In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,29
 Object ( Bit In) Input:B;  //_GUI 55,29
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 34,13,One element is empty, the other is not, but still the same list structure, send out True.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( NULL In2, NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 22,19
 Object ( NULL In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object Text;  //_GUI 32,18,Both elements are empty, send out True
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( List In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="List/Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,19
 Object ( Variant In2) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 32,18,List nodes are different, send out False

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SameListStruct( Variant In2, List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Variant/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,19
 Object ( List In1) Input:A;  //_GUI 22,28
 Object Output( Bit Out1) ;  //_GUI 64,25
 Object Text;  //_GUI 32,18,List nodes are different, send out False
 Object ( Bit In) Input:B;  //_GUI 58,25
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\PackBIN",Icon="Exposer_Out"
{
 // Packs input elements into a BIN-shaped List
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 9,12
 Object ( Variant In2) Input:A;  //_GUI 9,15
 Object ( Variant In3) Input:B;  //_GUI 9,21
 Object ( Variant In4) Input:C;  //_GUI 9,24
 Object Output( List Out1) ;  //_GUI 52,17
 Object ( List Out1) PackBIN( Variant In1, Variant In2) ;  //_GUI 38,15
 Object ( List Out1) PackBIN:A( Variant In1, Variant In2) ;  //_GUI 20,11
 Object ( List Out1) PackBIN:B( Variant In1, Variant In2) ;  //_GUI 20,20

 //_ Behavior Topology
 Output.0 = PackBIN.0;  
 PackBIN.0 = PackBIN:A.0;  //_GUI 34,17, 34,14
 PackBIN.1 = PackBIN:B.0;  //_GUI 35,20, 35,23
 PackBIN:A.0 = Input.0;  
 PackBIN:A.1 = Input:A.0;  
 PackBIN:B.0 = Input:B.0;  
 PackBIN:B.1 = Input:C.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackBIN( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\UnPackBIN",Icon="Exposer_In"
{
 // Unpacks a BIN-shaped List into its data elements.
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 8,17
 Object Output( Variant Out1) ;  //_GUI 54,12
 Object Output:A( Variant Out2) ;  //_GUI 54,15
 Object Output:B( Variant Out3) ;  //_GUI 54,21
 Object Output:C( Variant Out4) ;  //_GUI 54,24
 Object ( Variant Out2, Variant Out1) UnPackBIN( Variant In1) ;  //_GUI 14,15
 Object ( Variant Out2, Variant Out1) UnPackBIN:A( Variant In1) ;  //_GUI 37,11
 Object ( Variant Out2, Variant Out1) UnPackBIN:B( Variant In1) ;  //_GUI 37,20

 //_ Behavior Topology
 Output.0 = UnPackBIN:A.0;  
 Output:A.0 = UnPackBIN:A.1;  
 Output:B.0 = UnPackBIN:B.0;  
 Output:C.0 = UnPackBIN:B.1;  
 UnPackBIN.0 = Input.0;  
 UnPackBIN:A.0 = UnPackBIN.0;  //_GUI 33,14, 33,17
 UnPackBIN:B.0 = UnPackBIN.1;  //_GUI 33,23, 33,20
}

Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 40,39
 Object ( Variant PipeLen) Input:A;  //_GUI 11,58
 Object ( Bit ClkG) Input:B;  //_GUI 40,68
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 40,71
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 40,86
 Object ( Bit Wait) Input:E;  //_GUI 40,91
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 123,19
 Object Output:A( Variant PipeLen) ;  //_GUI 137,28
 Object Output:B( Bit ClkG) ;  //_GUI 109,42
 Object Output:C( Bit AClr) ;  //_GUI 109,45
 Object Output:D( Bit Done) ;  //_GUI 113,48
 Object Output:E( Bit Busy) ;  //_GUI 57,96
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 18,58
 Object Output:F( Bit Trap) ;  //_GUI 35,28
 //_ Attributes Trap="PipeLen is required."
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 24,56
 //_ Attributes Documentation="list"
 Object ( Bit Out1) IsVariant( Variant Type) ;  //_GUI 23,26
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 125,26
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 91,35
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 60,38

 //_ Behavior Topology
 Output.0 = Reg_Pipe.0;  //_GUI 113,20, 113,37
 Output:A.0 = PushLsb.0;  
 Output:B.0 = Reg_Pipe.2;  
 Output:C.0 = Reg_Pipe.3;  
 Output:D.0 = Reg_Pipe.4;  
 Output:E.0 = RegOnGo.4;  //_GUI 57,52
 Junction.0 = Input:A.0;  
 Output:F.0 = IsVariant.0;  
 PopLsb.0 = Junction.1;  
 IsVariant.0 = Junction.0;  //_GUI 19,29
 PushLsb.0 = Reg_Pipe.1;  //_GUI 117,28, 117,40
 PushLsb.1 = PopLsb.1;  //_GUI 125,61
 Reg_Pipe.0 = RegOnGo.0;  //_GUI 81,37, 81,40
 Reg_Pipe.1 = PopLsb.0;  //_GUI 88,40, 88,58
 Reg_Pipe.2 = RegOnGo.1;  
 Reg_Pipe.3 = RegOnGo.2;  
 Reg_Pipe.4 = RegOnGo.3;  
 Reg_Pipe.5 = Input:E.0;  //_GUI 107,92
 RegOnGo.0 = Input.0;  
 RegOnGo.1 = Input:B.0;  //_GUI 51,43, 51,69
 RegOnGo.2 = Input:C.0;  //_GUI 54,46, 54,72
 RegOnGo.3 = Input:D.0;  //_GUI 48,49, 48,87
 RegOnGo.4 = Reg_Pipe.5;  
}

Object ( Variant Q, Bit PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Bit PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 40,39
 Object ( Bit PipeLen) Input:A;  //_GUI 29,55
 Object ( Bit ClkG) Input:B;  //_GUI 40,61
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 40,64
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 40,86
 Object ( Bit Wait) Input:E;  //_GUI 40,91
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 99,31
 Object Output:A( Bit PipeLen) ;  //_GUI 99,34
 Object Output:B( Bit ClkG) ;  //_GUI 72,42
 Object Output:C( Bit AClr) ;  //_GUI 72,45
 Object Output:D( Bit Done) ;  //_GUI 85,48
 Object Output:E( Bit Busy) ;  //_GUI 57,96
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 57,38

 //_ Behavior Topology
 Output.0 = RegOnGo.0;  //_GUI 85,32, 85,40
 Output:A.0 = Input:A.0;  //_GUI 33,35
 Output:B.0 = RegOnGo.1;  
 Output:C.0 = RegOnGo.2;  
 Output:D.0 = RegOnGo.3;  
 Output:E.0 = RegOnGo.4;  
 RegOnGo.0 = Input.0;  
 RegOnGo.1 = Input:B.0;  //_GUI 51,43, 51,62
 RegOnGo.2 = Input:C.0;  //_GUI 54,46, 54,65
 RegOnGo.3 = Input:D.0;  //_GUI 48,49, 48,87
 RegOnGo.4 = Input:E.0;  //_GUI 107,52, 107,92
}

Object ( Variant Q, NULL PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , NULL PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 31,39
 Object ( NULL PipeLen) Input:A;  //_GUI 27,52
 Object ( Bit ClkG) Input:B;  //_GUI 32,60
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 32,63
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 40,86
 Object ( Bit Wait) Input:E;  //_GUI 40,91
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 100,39
 Object Output:A( NULL PipeLen) ;  //_GUI 46,52
 Object Output:B( Bit ClkG) ;  //_GUI 38,60
 Object Output:C( Bit AClr) ;  //_GUI 38,63
 Object Output:D( Bit Done) ;  //_GUI 61,86
 Object Output:E( Bit Busy) ;  //_GUI 61,91

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Input:B.0;  
 Output:C.0 = Input:C.0;  
 Output:D.0 = Input:D.0;  
 Output:E.0 = Input:E.0;  
}

Object ( NULL Q, NULL PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( NULL D
    , NULL PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 31,39
 Object ( NULL PipeLen) Input:A;  //_GUI 27,52
 Object ( Bit ClkG) Input:B;  //_GUI 32,60
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 32,63
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 40,86
 Object ( Bit Wait) Input:E;  //_GUI 40,91
 //_ Attributes Constant="0"
 Object Output( NULL Q) ;  //_GUI 100,39
 Object Output:A( NULL PipeLen) ;  //_GUI 46,52
 Object Output:B( Bit ClkG) ;  //_GUI 38,60
 Object Output:C( Bit AClr) ;  //_GUI 38,63
 Object Output:D( Bit Done) ;  //_GUI 61,86
 Object Output:E( Bit Busy) ;  //_GUI 61,91

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Input:B.0;  
 Output:C.0 = Input:C.0;  
 Output:D.0 = Input:D.0;  
 Output:E.0 = Input:E.0;  
}

Object ( NULL Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( NULL D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 31,39
 Object ( Variant PipeLen) Input:A;  //_GUI 27,52
 Object ( Bit ClkG) Input:B;  //_GUI 32,60
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 32,63
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 40,86
 Object ( Bit Wait) Input:E;  //_GUI 40,91
 //_ Attributes Constant="0"
 Object Output( NULL Q) ;  //_GUI 100,39
 Object Output:A( Variant PipeLen) ;  //_GUI 46,52
 Object Output:B( Bit ClkG) ;  //_GUI 38,60
 Object Output:C( Bit AClr) ;  //_GUI 38,63
 Object Output:D( Bit Done) ;  //_GUI 61,86
 Object Output:E( Bit Busy) ;  //_GUI 61,91

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Input:B.0;  
 Output:C.0 = Input:C.0;  
 Output:D.0 = Input:D.0;  
 Output:E.0 = Input:E.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3) UnPackBIN
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\UnPackBIN",Icon="Exposer_In"
{
 // Unpacks a BIN-shaped List into its data elements.
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 5,18
 Object Output( Variant Out1) ;  //_GUI 48,17
 Object Output:A( Variant Out2) ;  //_GUI 48,22
 Object Output:B( Variant Out3) ;  //_GUI 48,25
 Object ( Variant Out2, Variant Out1) UnPackBIN( Variant In1) ;  //_GUI 14,16
 Object ( Variant Out2, Variant Out1) UnPackBIN:A( Variant In1) ;  //_GUI 31,21

 //_ Behavior Topology
 Output.0 = UnPackBIN.0;  
 Output:A.0 = UnPackBIN:A.0;  
 Output:B.0 = UnPackBIN:A.1;  
 UnPackBIN.0 = Input.0;  
 UnPackBIN:A.0 = UnPackBIN.1;  //_GUI 29,24, 29,21
}

Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\PackBIN",Icon="Exposer_Out"
{
 // Packs input elements into a BIN-shaped List
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,14
 Object ( Variant In2) Input:A;  //_GUI 14,19
 Object ( Variant In3) Input:B;  //_GUI 14,22
 Object Output( List Out1) ;  //_GUI 52,15
 Object ( List Out1) PackBIN( Variant In1, Variant In2) ;  //_GUI 38,13
 Object ( List Out1) PackBIN:A( Variant In1, Variant In2) ;  //_GUI 20,18

 //_ Behavior Topology
 Output.0 = PackBIN.0;  
 PackBIN.0 = Input.0;  
 PackBIN.1 = PackBIN:A.0;  //_GUI 35,18, 35,21
 PackBIN:A.0 = Input:A.0;  
 PackBIN:A.1 = Input:B.0;  
}

Object ( Bit OFL, List R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) $Add_Pipe
    ( List A, List B, Variant OrigDs, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="lsb list"
{
 // register each carry and the list
 //
 // Revision 2 - 11/08/05 AClrG to AClr
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 11,17
 Object ( List B) Input:A;  //_GUI 11,25
 Object ( Variant OrigDs) Input:B;  //_GUI 10,43
 Object ( Bit Add) Input:C;  //_GUI 26,54
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:D;  //_GUI 26,57
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:E;  //_GUI 52,72
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:F;  //_GUI 52,75
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:G;  //_GUI 48,93
 Object ( Bit Wait) Input:H;  //_GUI 125,105
 Object Output( Bit OFL) ;  //_GUI 189,16
 Object Output:A( List R) ;  //_GUI 188,34
 Object Output:B( Variant PipeLen) ;  //_GUI 180,68
 Object Output:C( Bit ClkG) ;  //_GUI 177,72
 Object Output:D( Bit AClr) ;  //_GUI 176,75
 Object Output:E( Bit Done) ;  //_GUI 170,93
 Object Output:F( Bit Busy) ;  //_GUI 109,109
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 24,15
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 24,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 88,93
 Object ( Variant Size) ListSize( List List) ;  //_GUI 60,82
 //_ Attributes Documentation="List"
 Object ( List Out1, List Out2, List Out3) Junction:B
    ( List In0) ;  //_GUI 18,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 93,84
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 81,72
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 84,75
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 169,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 160,96
 Object Text;  //_GUI 24,101,Coming into this operator should be slices of what was once two numbers to be added. We are adding each of the slices starting with the LSB on different clock cycles and passing the carry down.
 Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 68,15
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackBIN( Variant In1) ;  //_GUI 116,15
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 111,80
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 55,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 101,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 105,72
 Object ( Bit OFL, Variant R, Variant PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) $Add_Pipe
    ( Variant A, Variant B, Variant OrigDs, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 138,15
 //_ Attributes Documentation="lsb list"
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 93,16

 //_ Behavior Topology
 Output.0 = $Add_Pipe.0;  
 Output:A.0 = ListOut.0;  
 Output:B.0 = Junction:C.0;  //_GUI 94,69
 Output:C.0 = Junction:H.1;  
 Output:D.0 = Junction:G.1;  
 Output:E.0 = Reg_Pipe.4;  
 Output:F.0 = Reg_Pipe.5;  //_GUI 104,110, 104,97
 ListIn.0 = Junction:B.1;  
 ListIn:A.0 = Input:A.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:G.0;  
 ListSize.0 = Junction:B.2;  //_GUI 19,85
 Junction:B.0 = Input.0;  
 Junction:C.0 = ListSize.0;  
 Junction:D.0 = Input:E.0;  
 Junction:E.0 = Input:F.0;  
 ListOut.0 = Reg_Pipe.0;  //_GUI 169,51, 147,51, 147,82
 ListOut.1 = $Add_Pipe.1;  //_GUI 169,20
 Junction:F.0 = Input:H.0;  //_GUI 161,106
 PackBIN.0 = ListIn.1;  
 PackBIN.1 = ListIn:A.1;  //_GUI 41,20, 41,25
 PackBIN.2 = Junction.0;  //_GUI 43,23
 PackBIN.3 = ADSU.0;  //_GUI 68,37, 73,37
 UnPackBIN.0 = RegOnGo.0;  
 Reg_Pipe.0 = ADSU.2;  //_GUI 111,55
 Reg_Pipe.1 = Junction:C.1;  
 Reg_Pipe.2 = Junction:H.2;  //_GUI 106,88
 Reg_Pipe.3 = Junction:G.2;  //_GUI 102,91
 Reg_Pipe.4 = Junction:A.1;  
 Reg_Pipe.5 = Junction:F.0;  
 ADSU.0 = ListIn.0;  //_GUI 38,49, 38,20
 ADSU.1 = ListIn:A.0;  //_GUI 35,52
 ADSU.2 = Junction.1;  
 ADSU.3 = Input:D.0;  
 Junction:G.0 = Junction:E.1;  
 Junction:H.0 = Junction:D.1;  
 $Add_Pipe.0 = UnPackBIN.0;  
 $Add_Pipe.1 = UnPackBIN.1;  
 $Add_Pipe.2 = Input:B.0;  //_GUI 136,23, 136,44
 $Add_Pipe.3 = UnPackBIN.2;  //_GUI 133,26, 133,23
 $Add_Pipe.4 = UnPackBIN.3;  //_GUI 130,29, 130,26
 $Add_Pipe.5 = RegOnGo.1;  //_GUI 113,32, 113,21
 $Add_Pipe.6 = RegOnGo.2;  //_GUI 111,35, 111,24
 $Add_Pipe.7 = RegOnGo.3;  //_GUI 108,38, 108,27
 $Add_Pipe.8 = Junction:F.1;  //_GUI 161,41
 RegOnGo.0 = PackBIN.0;  
 RegOnGo.1 = Junction:D.0;  //_GUI 82,21
 RegOnGo.2 = Junction:E.0;  //_GUI 85,24
 RegOnGo.3 = Junction:A.0;  //_GUI 89,27
 RegOnGo.4 = $Add_Pipe.6;  //_GUI 105,30, 105,41
}

Object ( Bit OFL, Variant R, Bit PipeLen
    , Bit ClkG, Bit AClr, Bit Done, Bit Busy) $Add_Pipe
    ( Variant A, Variant B, Variant OrigDs, Bit Add
    , Bit CI, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="leaf"
{
 // register each carry and the list
 //
 // Revision 2 - 11/08/05 AClrG to AClr
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,17
 Object ( Variant B) Input:A;  //_GUI 13,24
 Object ( Variant OrigDs) Input:B;  //_GUI 13,29
 Object ( Bit Add) Input:C;  //_GUI 23,54
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:D;  //_GUI 23,57
 //_ Attributes Constant="0"
 Object ( Bit ClkG) Input:E;  //_GUI 52,72
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:F;  //_GUI 52,75
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:G;  //_GUI 48,90
 Object ( Bit Wait) Input:H;  //_GUI 131,102
 Object Output( Bit OFL) ;  //_GUI 161,49
 Object Output:A( Variant R) ;  //_GUI 161,52
 Object Output:B( Bit PipeLen) ;  //_GUI 175,65
 Object Output:C( Bit ClkG) ;  //_GUI 177,72
 Object Output:D( Bit AClr) ;  //_GUI 176,75
 Object Output:E( Bit Done) ;  //_GUI 170,90
 Object Output:F( Bit Busy) ;  //_GUI 115,106
 Object ( Bit In) Input:I;  //_GUI 169,65
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 148,47
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 50,47
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 85,47
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 72,44
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 46,57
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 135,48
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 104,47
 Object Text;  //_GUI 50,26,When adding unsigned, OFL when COWhen subtracting unsigned, OFL when not COWhen adding or subtracting signed, OFL when OFL
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 107,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 111,72
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 118,80

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = ListIn.0;  
 Output:B.0 = Input:I.0;  
 Output:C.0 = Junction:B.1;  
 Output:D.0 = Junction:A.1;  
 Output:E.0 = RegOnGo.3;  
 Output:F.0 = RegOnGo.4;  //_GUI 110,107, 110,94
 VouchBit.0 = ListIn.1;  
 ADSU.0 = Input.0;  //_GUI 38,49, 38,18
 ADSU.1 = Input:A.0;  //_GUI 35,52, 35,25
 ADSU.2 = Input:C.0;  
 ADSU.3 = Junction.1;  
 $ResolveError.0 = XOR.0;  //_GUI 82,49
 $ResolveError.1 = ADSU.1;  
 $ResolveError.2 = Input:B.0;  //_GUI 80,55, 80,61, 32,61, 32,30
 XOR.0 = Junction.0;  //_GUI 47,46
 XOR.1 = ADSU.0;  
 Junction.0 = Input:D.0;  
 ListIn.0 = RegOnGo.0;  //_GUI 133,51, 133,82
 ListOut.0 = ADSU.2;  //_GUI 104,55
 ListOut.1 = $ResolveError.0;  
 Junction:A.0 = Input:F.0;  
 Junction:B.0 = Input:E.0;  
 RegOnGo.0 = ListOut.0;  //_GUI 117,82, 117,50
 RegOnGo.1 = Junction:B.2;  //_GUI 112,85
 RegOnGo.2 = Junction:A.2;  //_GUI 108,88
 RegOnGo.3 = Input:G.0;  
 RegOnGo.4 = Input:H.0;  //_GUI 167,94, 167,103
}

Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 // Returns 1 if input data does not equal zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 13,17
 Object ( Bit ClkG) Input:A;  //_GUI 10,20
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 10,23
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 10,35
 Object ( Bit Wait) Input:D;  //_GUI 38,54
 //_ Attributes Constant="0"
 Object Output( Bit NotZero) ;  //_GUI 62,10
 Object Output:A( Bit IsZero) ;  //_GUI 62,13
 Object Output:B( Bit AllHigh) ;  //_GUI 62,17
 Object Output:C( Variant PipeLen) ;  //_GUI 51,26
 Object Output:D( Bit ClkG) ;  //_GUI 46,29
 Object Output:E( Bit AClr) ;  //_GUI 46,32
 Object Output:F( Bit Done) ;  //_GUI 46,35
 Object Output:G( Bit Busy) ;  //_GUI 25,49
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 52,11
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 49,13
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 26,16

 //_ Behavior Topology
 Output.0 = Junction.1;  //_GUI 50,11
 Output:A.0 = INVERT.0;  
 Output:B.0 = Gate-NInput_Pipe.0;  
 Output:C.0 = Gate-NInput_Pipe.3;  
 Output:D.0 = Gate-NInput_Pipe.4;  
 Output:E.0 = Gate-NInput_Pipe.5;  
 Output:F.0 = Gate-NInput_Pipe.6;  
 Output:G.0 = Gate-NInput_Pipe.7;  //_GUI 25,44, 26,44
 INVERT.0 = Junction.2;  
 Junction.0 = Gate-NInput_Pipe.1;  //_GUI 50,21
 Gate-NInput_Pipe.0 = Input.0;  
 Gate-NInput_Pipe.1 = Input:A.0;  
 Gate-NInput_Pipe.2 = Input:B.0;  
 Gate-NInput_Pipe.3 = Input:C.0;  
 Gate-NInput_Pipe.4 = Input:D.0;  //_GUI 43,46, 42,46
}

Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , NULL PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) NotZero_Pipe( NULL Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="NULL"
{
 // Returns 1 if input data does not equal zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Val) Input;  //_GUI 13,17
 Object ( Bit ClkG) Input:A;  //_GUI 10,20
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 10,23
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 10,26
 Object ( Bit Wait) Input:D;  //_GUI 28,41
 //_ Attributes Constant="0"
 Object Output( Bit NotZero) ;  //_GUI 46,4
 Object Output:A( Bit IsZero) ;  //_GUI 46,7
 Object Output:B( Bit AllHigh) ;  //_GUI 46,10
 Object Output:C( NULL PipeLen) ;  //_GUI 39,17
 Object Output:D( Bit ClkG) ;  //_GUI 30,20
 Object Output:E( Bit AClr) ;  //_GUI 30,23
 Object Output:F( Bit Done) ;  //_GUI 30,26
 Object Output:G( Bit Busy) ;  //_GUI 15,36
 Object ( Bit In) Input:E;  //_GUI 34,4
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit In) Input:F;  //_GUI 28,7
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 40,4

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Input:F.0;  
 Output:B.0 = Junction.2;  //_GUI 41,11
 Output:C.0 = Input.0;  
 Output:D.0 = Input:A.0;  
 Output:E.0 = Input:B.0;  
 Output:F.0 = Input:C.0;  
 Output:G.0 = Input:D.0;  //_GUI 15,33, 32,33
 Junction.0 = Input:E.0;  
}

Object ( Variant Q, Variant PipeLen, Variant FullPipeLen
    , Bit ClkG, Bit AClr, Bit Done, Variant Busy) SyncReg_Pipe
    ( List D, List PipeLen, Bit ClkG, Bit AClr
    , List Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced"
{
 // This object is for padding the pipe length of different pipelines so that they all have the same pipeline length. You pass the PipeLen parameter a list of pipe lengths of the same structure as your D and Go inputs. You will get a list of Busy signals out that you need to Cast to match the incoming Go signal. The FullPipeLen will be the stage lenth for the entire pipe stage, and the PipeLen will be a list of individual pipe lengths, as they were modified for synchronization. This object will always be a passthrough for the longest pipe length coming in. That means if all the incoming pipe lengths are equal, the entire object will turn into a passthrough.
 //
 // This object is unlike the SyncReg object in that it will not produce any stalls for any of the incoming pipelines.  It only passes the Wait through to each pipeline's Busy.  This object assumes all incoming pipelines had some common fork point for which each pipeline's PipeLen is the number of stages since that fork point.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 12,21
 Object ( List PipeLen) Input:A;  //_GUI 10,29
 Object ( Bit ClkG) Input:B;  //_GUI 97,48
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 97,51
 //_ Attributes Constant="0"
 Object ( List Go) Input:D;  //_GUI 65,54
 Object ( Bit Wait) Input:E;  //_GUI 91,72
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 177,29
 Object Output:A( Variant PipeLen) ;  //_GUI 161,33
 Object Output:B( Variant FullPipeLen) ;  //_GUI 161,37
 Object Output:C( Bit ClkG) ;  //_GUI 153,48
 Object Output:D( Bit AClr) ;  //_GUI 153,51
 Object Output:E( Bit Done) ;  //_GUI 157,54
 Object Output:F( Variant Busy) ;  //_GUI 128,64
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 21,29
 Object ( Variant N) BitA_Sub_BitB( Variant A, Variant B) ;  //_GUI 106,8
 Object Text;  //_GUI 10,38,So We're using the $Selects here to ensure that BitA_Sub_BitB only applies to the leaves
 Object ( Variant OFL, Variant Out1) DiffExtnd( Variant Type
    , Variant Data) ;  //_GUI 53,25
 //_ Attributes Documentation="var/List"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 48,15
 Object ( Variant Min, Variant Max) OrderDatasetList( List List) ;  //_GUI 22,11
 Object ( Bit Out1) SameListStruct( Variant In1, Variant In2) ;  //_GUI 81,85
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 74,45
 Object ( List Out1, List Out2, List Out3) Junction:C
    ( List In0) ;  //_GUI 71,54
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 96,85
 Object Output:G( Bit Trap) ;  //_GUI 111,87
 //_ Attributes Trap="PipeLen and Go list structures must be identical."
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 111,62
 //_ Attributes Documentation="ztlist"
 Object ( List Out1, List Out2, List Out3) Junction:D
    ( List In0) ;  //_GUI 110,54
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) List_Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 123,41
 //_ Attributes Documentation="list"
 Object Text;  //_GUI 17,107,This object is for padding the pipe length of different objects all on one pipe stage. You pass the PipeLen parameter a list of pipe lengths of the same structure as your D and Go inputs. You will get a list of Busy signals out that you need to Cast to match the incoming Go signal. The FullPipeLen will be the stage lenth for the entire pipe stage, and the PipeLen will be a list of individual pipe lengths, as they were modified for synchronization. This object will always be a passthrough for the longest pipe length coming in. That means if all the incoming pipe lengths are equal, the entire object will turn into a passthrough.

 //_ Behavior Topology
 Output.0 = List_Reg_Pipe.0;  //_GUI 153,30, 153,43
 Output:A.0 = BitA_Sub_BitB.0;  //_GUI 161,11
 Output:B.0 = Junction:A.1;  //_GUI 135,38, 135,16
 Output:C.0 = List_Reg_Pipe.2;  
 Output:D.0 = List_Reg_Pipe.3;  
 Output:E.0 = List_Reg_Pipe.4;  
 Output:F.0 = Cast.0;  
 Junction.0 = Input:A.0;  
 BitA_Sub_BitB.0 = Junction:A.0;  //_GUI 49,10
 BitA_Sub_BitB.1 = OrderDatasetList.0;  
 DiffExtnd.0 = Junction:A.2;  //_GUI 49,27
 DiffExtnd.1 = Junction.1;  
 Junction:A.0 = OrderDatasetList.1;  
 OrderDatasetList.0 = Junction.0;  
 SameListStruct.0 = Junction:B.2;  //_GUI 75,87
 SameListStruct.1 = Junction:C.2;  //_GUI 72,90
 Junction:B.0 = DiffExtnd.1;  //_GUI 63,46
 Junction:C.0 = Input:D.0;  
 INVERT.0 = SameListStruct.0;  
 Output:G.0 = INVERT.0;  
 Cast.0 = Junction:D.2;  
 Cast.1 = List_Reg_Pipe.5;  //_GUI 105,67, 105,58
 Junction:D.0 = Junction:C.1;  
 List_Reg_Pipe.0 = Input.0;  //_GUI 104,43, 104,22
 List_Reg_Pipe.1 = Junction:B.1;  
 List_Reg_Pipe.2 = Input:B.0;  
 List_Reg_Pipe.3 = Input:C.0;  
 List_Reg_Pipe.4 = Junction:D.1;  
 List_Reg_Pipe.5 = Input:E.0;  //_GUI 143,58, 143,73
}

Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\PackBIN",Icon="Exposer_Out"
{
 // Packs input elements into a BIN-shaped List
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 12,15
 Object ( Variant In2) Input:A;  //_GUI 12,18
 Object ( Variant In3) Input:B;  //_GUI 12,21
 Object ( Variant In4) Input:C;  //_GUI 12,28
 Object ( Variant In5) Input:D;  //_GUI 12,31
 Object ( Variant In6) Input:E;  //_GUI 12,34
 Object ( Variant In7) Input:F;  //_GUI 12,37
 Object Output( List Out1) ;  //_GUI 55,17
 Object ( List Out1) PackBIN( Variant In1, Variant In2) ;  //_GUI 41,15
 Object ( List Out1) PackBIN:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 23,14
 Object ( List Out1) PackBIN:B( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 22,27

 //_ Behavior Topology
 Output.0 = PackBIN.0;  
 PackBIN.0 = PackBIN:A.0;  
 PackBIN.1 = PackBIN:B.0;  //_GUI 39,20, 39,30
 PackBIN:A.0 = Input.0;  
 PackBIN:A.1 = Input:A.0;  
 PackBIN:A.2 = Input:B.0;  
 PackBIN:B.0 = Input:C.0;  
 PackBIN:B.1 = Input:D.0;  
 PackBIN:B.2 = Input:E.0;  
 PackBIN:B.3 = Input:F.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) UnPackBIN
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\UnPackBIN",Icon="Exposer_In"
{
 // Unpacks a BIN-shaped List into its data elements.
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,21
 Object Output( Variant Out1) ;  //_GUI 55,15
 Object Output:A( Variant Out2) ;  //_GUI 55,18
 Object Output:B( Variant Out3) ;  //_GUI 55,21
 Object Output:C( Variant Out4) ;  //_GUI 55,27
 Object Output:D( Variant Out5) ;  //_GUI 55,30
 Object Output:E( Variant Out6) ;  //_GUI 55,33
 Object Output:F( Variant Out7) ;  //_GUI 55,36
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackBIN( Variant In1) ;  //_GUI 40,26
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackBIN:A
    ( Variant In1) ;  //_GUI 40,14
 Object ( Variant Out2, Variant Out1) UnPackBIN:B( Variant In1) ;  //_GUI 21,19

 //_ Behavior Topology
 Output.0 = UnPackBIN:A.0;  
 Output:A.0 = UnPackBIN:A.1;  
 Output:B.0 = UnPackBIN:A.2;  
 Output:C.0 = UnPackBIN.0;  
 Output:D.0 = UnPackBIN.1;  
 Output:E.0 = UnPackBIN.2;  
 Output:F.0 = UnPackBIN.3;  
 UnPackBIN.0 = UnPackBIN:B.1;  //_GUI 38,29, 38,24
 UnPackBIN:A.0 = UnPackBIN:B.0;  //_GUI 38,17, 38,21
 UnPackBIN:B.0 = Input.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7, Variant In8, Variant In9) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,24
 Object ( Variant In2) Input:A;  //_GUI 33,27
 Object ( Variant In3) Input:B;  //_GUI 33,30
 Object ( Variant In4) Input:C;  //_GUI 33,33
 Object ( Variant In5) Input:D;  //_GUI 33,36
 Object ( Variant In6) Input:E;  //_GUI 33,39
 Object ( Variant In7) Input:F;  //_GUI 33,42
 Object ( Variant In8) Input:G;  //_GUI 33,45
 Object ( Variant In9) Input:H;  //_GUI 33,50
 Object Output( List Out1) ;  //_GUI 69,48
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7, Variant In8) ;  //_GUI 38,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 55,46

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
 PackLSB.3 = Input:C.0;  
 PackLSB.4 = Input:D.0;  
 PackLSB.5 = Input:E.0;  
 PackLSB.6 = Input:F.0;  
 PackLSB.7 = Input:G.0;  
 ListOut.0 = Input:H.0;  
 ListOut.1 = PackLSB.0;  //_GUI 52,48, 52,26
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9) UnPackLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 30,28
 Object Output( Variant Out1) ;  //_GUI 72,26
 Object Output:A( Variant Out2) ;  //_GUI 72,29
 Object Output:B( Variant Out3) ;  //_GUI 72,32
 Object Output:C( Variant Out4) ;  //_GUI 72,35
 Object Output:D( Variant Out5) ;  //_GUI 72,38
 Object Output:E( Variant Out6) ;  //_GUI 72,41
 Object Output:F( Variant Out7) ;  //_GUI 72,44
 Object Output:G( Variant Out8) ;  //_GUI 72,47
 Object Output:H( Variant Out9) ;  //_GUI 72,51
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 36,26
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8) UnPackLSB:A( Variant In1) ;  //_GUI 57,25

 //_ Behavior Topology
 Output.0 = UnPackLSB:A.0;  
 Output:A.0 = UnPackLSB:A.1;  
 Output:B.0 = UnPackLSB:A.2;  
 Output:C.0 = UnPackLSB:A.3;  
 Output:D.0 = UnPackLSB:A.4;  
 Output:E.0 = UnPackLSB:A.5;  
 Output:F.0 = UnPackLSB:A.6;  
 Output:G.0 = UnPackLSB:A.7;  
 Output:H.0 = UnPackLSB.1;  //_GUI 54,52, 54,31
 UnPackLSB.0 = Input.0;  
 UnPackLSB:A.0 = UnPackLSB.0;  
}

Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero, Variant PipeLen, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) LeftJustify_Pipe( Variant Data, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 // This object performs this action (only more efficiently):
 //
 // ShiftLeft(Data,Bitlen(Data)-MaskToNum(mostSig(Data)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 20,36
 Object ( Bit ClkG) Input:A;  //_GUI 20,42
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 20,45
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 20,54
 Object ( Bit Wait) Input:D;  //_GUI 214,72
 //_ Attributes Constant="0"
 Object Output( Variant ShiftedData) ;  //_GUI 215,22
 Object Output:A( Variant ShiftMask) ;  //_GUI 215,34
 Object Output:B( Variant ShiftNum) ;  //_GUI 215,42
 Object Output:C( Bit Zero) ;  //_GUI 215,45
 Object Output:D( Variant PipeLen) ;  //_GUI 215,48
 Object Output:E( Bit ClkG) ;  //_GUI 215,51
 Object Output:F( Bit AClr) ;  //_GUI 215,54
 Object Output:G( Bit Done) ;  //_GUI 215,66
 Object Output:H( Bit Busy) ;  //_GUI 21,76
 Object Text;  //_GUI 34,15,round up to the nearest power of two.
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 78,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 74,25
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 187,23
 Object ( Variant Out1) "2^N_Bits"( Variant In1) ;  //_GUI 60,23
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 78,23
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 36,23
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 187,32
 Object ( Variant Val) Encoder( Variant Mask) ;  //_GUI 48,23
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 189,40
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 177,42
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 203,20
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 203,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In3) ;  //_GUI 32,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 199,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 183,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 183,27
 Object Text;  //_GUI 32,140,This object performs this action (only more efficiently):ShiftLeft(Data,Bitlen(Data)-MaskToNum(mostSig(Data)))
 Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $LeftJustify_Pipe( Variant Val, Variant ShBy, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 94,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 79,54
 Object ( Variant NotZero, Variant IsZero, Variant AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 94,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 90,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 87,45
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 113,35
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 160,34
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 135,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 173,46
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 161,44

 //_ Behavior Topology
 Output.0 = Context.0;  
 Output:A.0 = Context:A.0;  
 Output:B.0 = AND.0;  
 Output:C.0 = Junction:I.1;  //_GUI 203,46, 203,47
 Output:D.0 = SyncRegPair_Pipe.4;  
 Output:E.0 = SyncRegPair_Pipe.5;  
 Output:F.0 = SyncRegPair_Pipe.6;  
 Output:G.0 = SyncRegPair_Pipe.9;  
 Output:H.0 = $LeftJustify_Pipe.7;  //_GUI 21,58
 PadRight.0 = Junction:A.2;  //_GUI 75,34
 PadRight.1 = Junction.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = "2^N_Bits".0;  
 Hi_N.0 = UnPackLSB.0;  //_GUI 177,25, 177,36
 Hi_N.1 = Junction:E.1;  
 "2^N_Bits".0 = Encoder.0;  
 ExposeBIN.0 = Junction:A.1;  
 Zero.0 = Junction:B.2;  
 Lo_N.0 = UnPackLSB.1;  //_GUI 180,34, 180,39
 Lo_N.1 = Junction:E.2;  //_GUI 184,37
 Encoder.0 = Zero.0;  
 AND.0 = UnPackLSB.2;  
 AND.1 = INVERT.0;  
 INVERT.0 = Junction:I.0;  //_GUI 174,45
 Context.0 = Junction:C.1;  
 Context.1 = Hi_N.0;  
 Context:A.0 = Junction:C.2;  //_GUI 200,34
 Context:A.1 = Lo_N.1;  
 Junction:B.0 = Junction.0;  
 Junction:C.0 = Junction:D.1;  //_GUI 200,20
 Junction:D.0 = Junction:B.1;  //_GUI 33,20
 Junction:E.0 = Junction:D.2;  
 $LeftJustify_Pipe.0 = PadRight.1;  
 $LeftJustify_Pipe.1 = ExposeBIN.1;  //_GUI 92,40, 92,28
 $LeftJustify_Pipe.2 = Junction:G.1;  
 $LeftJustify_Pipe.3 = Junction:H.1;  
 $LeftJustify_Pipe.4 = Junction:F.1;  
 $LeftJustify_Pipe.5 = SyncRegPair_Pipe.7;  //_GUI 118,58, 118,76, 161,76, 161,58
 Junction:F.0 = Input:C.0;  
 CompareUnary_Pipe.0 = Junction.2;  //_GUI 33,64
 CompareUnary_Pipe.1 = Junction:G.2;  //_GUI 91,67
 CompareUnary_Pipe.2 = Junction:H.2;  //_GUI 88,70
 CompareUnary_Pipe.3 = Junction:F.2;  //_GUI 80,82
 CompareUnary_Pipe.4 = SyncRegPair_Pipe.8;  //_GUI 158,85, 158,61
 Junction:G.0 = Input:A.0;  
 Junction:H.0 = Input:B.0;  
 PackLSB.0 = $LeftJustify_Pipe.0;  
 PackLSB.1 = $LeftJustify_Pipe.1;  
 PackLSB.2 = $LeftJustify_Pipe.2;  
 UnPackLSB.0 = SyncRegPair_Pipe.0;  
 SyncRegPair_Pipe.0 = PackLSB.0;  //_GUI 135,38
 SyncRegPair_Pipe.1 = CompareUnary_Pipe.1;  //_GUI 126,40, 126,67
 SyncRegPair_Pipe.2 = $LeftJustify_Pipe.3;  //_GUI 129,43, 129,46
 SyncRegPair_Pipe.3 = CompareUnary_Pipe.3;  //_GUI 131,46, 131,73
 SyncRegPair_Pipe.4 = $LeftJustify_Pipe.4;  
 SyncRegPair_Pipe.5 = $LeftJustify_Pipe.5;  
 SyncRegPair_Pipe.6 = $LeftJustify_Pipe.6;  
 SyncRegPair_Pipe.7 = CompareUnary_Pipe.6;  //_GUI 133,58, 133,82
 SyncRegPair_Pipe.8 = Input:D.0;  //_GUI 218,70
 Junction:I.0 = VouchBit.0;  
 VouchBit.0 = SyncRegPair_Pipe.1;  //_GUI 158,47, 158,40
}

Object ( Variant N) BitA_Sub_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // This object produces  data set whose bitlength equals bitlength A - bitlength B.  The numeric value of the output will be 0.
 //
 // Inputs:
 // A - bitlength is significant parameter
 // B - bitlength is significant parameter
 //
 // Outputs:
 // N - bitlength of N (LSB order) = bitlength of A - bitlength of B
 //
 // Date:
 // 11 Oct 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 26,36
 Object ( Variant B) Input:A;  //_GUI 26,39
 Object Output( Variant N) ;  //_GUI 63,36
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A - BitLength B.Arial,8,0,1
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 39,35
 Object ( Bit Out1) BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 39,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 35,36
 Object Output:A( Bit Trap) ;  //_GUI 55,48
 //_ Attributes Trap="A is less than B: Can't represent negative bits."
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,34
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Lo_N.0 = Junction:A.1;  
 Lo_N.1 = Junction.1;  
 BitA_Lt_BitB.0 = Junction:A.2;  //_GUI 36,48
 BitA_Lt_BitB.1 = Junction.2;  //_GUI 33,51
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Output:A.0 = BitA_Lt_BitB.0;  
 Zero.0 = Lo_N.0;  
}

Object ( Variant N) BitA_Sub_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 26,36
 Object ( NULL B) Input:A;  //_GUI 26,39
 Object Output( Variant N) ;  //_GUI 57,36
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A - BitLength B.Arial,8,0,1
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 33,34
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 45,34
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 LSB.0 = Input.0;  
 Zero.0 = LSB.0;  
}

Object ( NULL N) BitA_Sub_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 26,36
 Object ( NULL B) Input:A;  //_GUI 26,39
 Object Output( NULL N) ;  //_GUI 57,36
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A - BitLength B.Arial,8,0,1

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL N) BitA_Sub_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 26,36
 Object ( Variant B) Input:A;  //_GUI 26,39
 Object Output( NULL N) ;  //_GUI 57,36
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A - BitLength B.Arial,8,0,1
 Object Output:A( Bit Trap) ;  //_GUI 56,44
 //_ Attributes Trap="A is less than B: Can't represent negative bits."
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 39,42
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 35,36
 Object Text;  //_GUI 29,52,B could be a NULL wrapped in a contextual dataset.  If it really doesn't have zero bits, send out a user trap.

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = BitA_Ne_BitB.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 36,44
 BitA_Ne_BitB.1 = Input:A.0;  //_GUI 33,47, 33,40
 Junction.0 = Input.0;  
}

Object ( List Out1) PackMSB( Variant In2, Variant In3) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\PackMSB",Icon="Exposer_Out"
{
 // Packs input elements into an MSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 14,19
 Object ( Variant In3) Input:A;  //_GUI 14,22
 Object Output( List Out1) ;  //_GUI 35,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 20,18

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), <)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 49,35
 Object ( Bit In) Input:B;  //_GUI 43,35
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 49,35
 Object ( Bit In) Input:B;  //_GUI 43,35
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 24,46,0 is less than anything greater than zero.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 49,35
 Object ( Bit In) Input:B;  //_GUI 43,35
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 24,46,anything greater than zero is not less than 0.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) DupBit( Bit Bit, Bit DupSize) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // The input Bit is duplicated into all of the bits in the dataset DupSize.
 //
 // Inputs:
 //
 // Bit Bit: This is the bit that will be duplicated.
 //
 // Variant DupSize: This is the dataset that will be filled with the bit Bit.
 //
 // Outputs:
 //
 // Variant output: The output dataset is the same as DupSize.  Its value is either a binary value all ones or all zeros depending upon the value of the Bit input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Bit) Input;  //_GUI 45,30
 Object ( Bit DupSize) Input:A;  //_GUI 45,41
 Object Output( Bit Out1) ;  //_GUI 59,30

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) DupBit( Bit Bit, Variant DupSize) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // The input Bit is duplicated into all of the bits in the dataset DupSize.
 //
 // Inputs:
 //
 // Bit Bit: This is the bit that will be duplicated.
 //
 // Variant DupSize: This is the dataset that will be filled with the bit Bit.
 //
 // Outputs:
 //
 // Variant output: The output dataset is the same as DupSize.  Its value is either a binary value all ones or all zeros depending upon the value of the Bit input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Bit) Input;  //_GUI 45,30
 Object ( Variant DupSize) Input:A;  //_GUI 45,41
 Object Output( Variant Out1) ;  //_GUI 119,37
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 94,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,41
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 59,39
 Object ( Variant Out1) DupBit( Bit Bit, Variant DupSize) ;  //_GUI 79,36
 Object ( Variant Out1) DupBit:A( Bit Bit, Variant DupSize) ;  //_GUI 79,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In1) ;  //_GUI 73,37
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 107,35

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = DupBit:A.0;  //_GUI 94,47
 VariantOut.1 = DupBit.0;  
 Junction.0 = Input:A.0;  
 VariantIn.0 = Junction.1;  
 DupBit.0 = Junction:A.1;  
 DupBit.1 = VariantIn.1;  
 DupBit:A.0 = Junction:A.2;  //_GUI 74,46
 DupBit:A.1 = VariantIn.0;  //_GUI 70,49
 Junction:A.0 = Input.0;  //_GUI 74,31
 Cast.0 = Junction.0;  //_GUI 107,34, 54,34
 Cast.1 = VariantOut.0;  
}

Object ( NULL Out1) DupBit( Bit Bit, NULL DupSize) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // The input Bit is duplicated into all of the bits in the dataset DupSize.
 //
 // Inputs:
 //
 // Bit Bit: This is the bit that will be duplicated.
 //
 // Variant DupSize: This is the dataset that will be filled with the bit Bit.
 //
 // Outputs:
 //
 // Variant output: The output dataset is the same as DupSize.  Its value is either a binary value all ones or all zeros depending upon the value of the Bit input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Bit) Input;  //_GUI 45,30
 Object ( NULL DupSize) Input:A;  //_GUI 45,41
 Object Output( NULL Out1) ;  //_GUI 58,41

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) AND-NInput( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\Advanced"
{
 // All bits are ANDed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ANDing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 78,29
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 26,29
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 40,29
 //_ Attributes Documentation="var/bit"
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 64,27
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 14,29

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantIn.0 = BIN.0;  
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
 $Cast.0 = $AND-NInput.0;  
 BIN.0 = Input.0;  
}

Object ( Bit Out1) AND-NInput( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="bit"
{
 // All bits are ANDed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ANDing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) AND-NInput( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="NULL"
{
 // All bits are ANDed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ANDing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 10,31
 Object Output( NULL Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29, Variant Out30, Variant Out31
    , Variant Out32) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object Output:Z( Variant Out27) ;  //_GUI 80,115
 Object Output:a( Variant Out28) ;  //_GUI 80,118
 Object Output:b( Variant Out29) ;  //_GUI 80,121
 Object Output:c( Variant Out30) ;  //_GUI 80,124
 Object Output:d( Variant Out31) ;  //_GUI 80,127
 Object Output:e( Variant Out32) ;  //_GUI 80,130
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29, Variant Out30, Variant Out31) ExposeMSB
    ( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 Output:Z.0 = ExposeMSB.25;  
 Output:a.0 = ExposeMSB.26;  
 Output:b.0 = ExposeMSB.27;  
 Output:c.0 = ExposeMSB.28;  
 Output:d.0 = ExposeMSB.29;  
 Output:e.0 = ExposeMSB.30;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant C, Variant Out2) SHR_Twos( Variant In1
    , Variant CTypeOnly) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\Advanced"
{
 // Performs a compile-time shift right, similar to SHR, except that the input value is assumed to be a twos-complement number and the right shift is performed with a sign-extend, a.k.a. arithmetic shift right.
 //
 // Inputs:
 //
 // Variant input: The data to be shifted to the right.  The right shift amount is determined by the size of CTypeOnly.  Because of this, the shift amount is determined at compile time.
 //
 // Variant CTypeOnly: The bit size of this input is the amount the input is shifted to produce the output.
 //
 // Outputs:
 //
 // Variant C: The value shifted out the right (least significant) side from a right shift.  The same dataset as CTypeOnly.
 //
 // Variant output: The results of the compile-time arithmetic right shift.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 37,65
 Object ( Variant CTypeOnly) Input:A;  //_GUI 40,83
 Object Output( Variant C) ;  //_GUI 188,63
 Object Output:A( Variant Out2) ;  //_GUI 190,72
 Object ( Variant C, Variant Out1) SHR( Variant In2
    , Variant C) ;  //_GUI 114,64
 //_ Attributes Documentation="Bit_Carry"
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 159,61
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 56,54
 //_ Attributes Documentation="var"
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 87,54
 Object Text;  //_GUI 62,46,If the top bit is high, push in high
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 48,65
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 58,72
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 57,83
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 56,63
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 176,70

 //_ Behavior Topology
 Output.0 = Cast.0;  
 Output:A.0 = Context.0;  
 SHR.0 = MSB.0;  
 SHR.1 = AND.0;  //_GUI 97,69
 Cast.0 = Junction:A.1;  //_GUI 140,63, 140,84
 Cast.1 = SHR.0;  
 PopMsb.0 = Junction.0;  //_GUI 49,57
 AND.0 = PopMsb.0;  
 AND.1 = AllOnes.0;  //_GUI 79,59, 79,75
 Junction.0 = Input.0;  
 AllOnes.0 = Junction:A.0;  
 Junction:A.0 = Input:A.0;  
 MSB.0 = Junction.1;  
 Context.0 = Junction.2;  //_GUI 158,72, 158,90, 49,90
 Context.1 = SHR.1;  //_GUI 124,75
}

Object ( List C, List Out2) SHR_Twos( List In1
    , Variant CTypeOnly) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 37,65
 Object ( Variant CTypeOnly) Input:A;  //_GUI 36,83
 Object Output( List C) ;  //_GUI 137,59
 Object Output:A( List Out2) ;  //_GUI 138,74
 Object ( Variant C, Variant Out2) SHR_Twos( Variant In1
    , Variant CTypeOnly) ;  //_GUI 79,66
 //_ Attributes Documentation="var"
 Object ( Variant C, Variant Out2) SHR_Twos:A( Variant In1
    , Variant CTypeOnly) ;  //_GUI 79,57
 //_ Attributes Documentation="var"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In3) ;  //_GUI 70,70
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 47,63
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 115,57
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 115,72

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 SHR_Twos.0 = ListIn.0;  
 SHR_Twos.1 = Junction.2;  
 SHR_Twos:A.0 = ListIn.1;  //_GUI 58,59
 SHR_Twos:A.1 = Junction.1;  //_GUI 71,62
 Junction.0 = Input:A.0;  //_GUI 71,84
 ListIn.0 = Input.0;  
 ListOut.0 = SHR_Twos.0;  //_GUI 109,62, 109,68
 ListOut.1 = SHR_Twos:A.0;  
 ListOut:A.0 = SHR_Twos.1;  //_GUI 101,77, 101,71
 ListOut:A.1 = SHR_Twos:A.1;  //_GUI 104,74, 104,62
}

Object ( NULL C, Variant Out2) SHR_Twos( Variant In1
    , NULL CTypeOnly) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 37,65
 Object ( NULL CTypeOnly) Input:A;  //_GUI 40,83
 Object Output( NULL C) ;  //_GUI 188,64
 Object Output:A( Variant Out2) ;  //_GUI 190,72

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 133,65, 133,84
 Output:A.0 = Input.0;  //_GUI 113,73, 113,66
}

Object ( Bit C, Floating Out2) SHR_Twos( Floating In1
    , Variant CTypeOnly) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 10,17
 Object ( Variant CTypeOnly) Input:A;  //_GUI 16,38
 Object Output( Bit C) ;  //_GUI 143,19
 Object Output:A( Floating Out2) ;  //_GUI 156,29
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 78,18
 Object ( Variant Out1) BitLength( Variant In1) ;  //_GUI 26,36
 //_ Attributes Documentation="zterm"
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 22,15
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 122,27
 Object ( Bit CI) Input:B;  //_GUI 73,28
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit SUB) Input:C;  //_GUI 72,25
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 113,17
 Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) ;  //_GUI 49,18

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 Output:A.0 = CollectFloating.0;  
 ADSU.0 = SymmetrizeNW.0;  
 ADSU.1 = SymmetrizeNW.1;  
 ADSU.2 = Input:C.0;  
 ADSU.3 = Input:B.0;  
 BitLength.0 = Input:A.0;  
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 106,29, 106,17
 CollectFloating.1 = ADSU.2;  //_GUI 96,32
 CollectFloating.2 = ExposeFloating.2;  //_GUI 38,35
 INVERT.0 = ADSU.0;  
 SymmetrizeNW.0 = ExposeFloating.1;  
 SymmetrizeNW.1 = BitLength.0;  //_GUI 44,23, 44,39
}

Object ( Bit CO, Variant Count) UpDownCount( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR, Bit Up) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="Var/Bit/Bit"
{
 // This is a single or multi-bit enable up/down count object, which creates N counters depending on the number of enable (EN) bits. Larger counters at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Var/List CBy: Count by.  The dataset of CBy determines the size of the internal accumulator(s).  The value of CBy is what is added when EN is high.  CBy can have a different value each time EN is high.  If CBy is a List of Variants and EN and Up are Bits, the counters have a nested behavior such that a roll over of one will increment the next most significant counter in the list. If CBy is a Variant (MSBxxx, LSBxxx or BINxxx datasets) and EN and Up are multiple bits, then each counter has the same size accumulator but independent EN and Up controls.  If CBy, EN and Up are all lists, each counter can have a different CBy dataset and value as well as EN and Up controls.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit/Var/List EN: A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Bit CLR: Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Bit/Var/List Up: A set of Up bits for the list of counters (one bit per counter).  High means count up, low means count down.  This signal is ignored if EN is low.  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list Up input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Outputs:
 //
 // Bit/List CO: Carry Out bit(s).  If the internal accumulator rolls over (or not under), this bit goes high.  Has the same list structure as EN.
 //
 // Var/List Count: Count output(s).  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 7,33
 Object ( Bit ClkG) Input:A;  //_GUI 76,45
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 76,48
 //_ Attributes Constant="1"
 Object ( Bit CLR) Input:C;  //_GUI 76,51
 //_ Attributes Constant="0"
 Object ( Bit Up) Input:D;  //_GUI 8,61
 Object Output( Bit CO) ;  //_GUI 137,17
 Object Output:A( Variant Count) ;  //_GUI 131,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 88,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 90,39
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 92,42
 Object ( Variant Q) RegClr( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 96,32
 Object ( Variant Q) RegClr:A( Variant D, Bit ClkG
    , Bit EN, Bit CLR) ;  //_GUI 96,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 36,33
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 54,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 111,34
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 52,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 43,39
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 16,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 13,33
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 123,15
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 118,30
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 64,29

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = Context.0;  
 Junction.0 = Input:A.0;  //_GUI 89,46
 Junction:A.0 = Input:B.0;  //_GUI 91,49
 Junction:B.0 = Input:C.0;  //_GUI 93,52
 RegClr.0 = ADSU.2;  //_GUI 85,34, 85,37
 RegClr.1 = Junction.2;  
 RegClr.2 = Junction:A.2;  
 RegClr.3 = Junction:B.2;  
 RegClr:A.0 = ADSU.0;  //_GUI 86,19, 86,31
 RegClr:A.1 = Junction.1;  //_GUI 89,22
 RegClr:A.2 = Junction:A.1;  //_GUI 91,25
 RegClr:A.3 = Junction:B.1;  //_GUI 93,28
 Junction:C.0 = LSB.0;  
 Cast.0 = Junction:C.0;  //_GUI 37,25
 Cast.1 = Junction:D.0;  //_GUI 22,28, 22,12, 112,12
 Junction:D.0 = RegClr.0;  
 INVERT.0 = Junction:E.2;  
 Junction:E.0 = Input:D.0;  //_GUI 44,62
 LSB.0 = Junction:F.1;  
 Junction:F.0 = Input.0;  
 $Cast.0 = RegClr:A.0;  
 Context.0 = Junction:F.0;  //_GUI 118,9, 14,9
 Context.1 = Junction:D.1;  
 ADSU.0 = Cast.0;  
 ADSU.1 = Junction:C.1;  
 ADSU.2 = Junction:E.1;  //_GUI 44,37
 ADSU.3 = INVERT.0;  
}

Object ( List CO, List Count) UpDownCount( Variant CBy
    , Bit ClkG, List EN, Bit CLR, List Up) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="Var/List/List"
{
 // This is a single or multi-bit enable up/down count object, which creates N counters depending on the number of enable (EN) bits. Larger counters at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Var/List CBy: Count by.  The dataset of CBy determines the size of the internal accumulator(s).  The value of CBy is what is added when EN is high.  CBy can have a different value each time EN is high.  If CBy is a List of Variants and EN and Up are Bits, the counters have a nested behavior such that a roll over of one will increment the next most significant counter in the list. If CBy is a Variant (MSBxxx, LSBxxx or BINxxx datasets) and EN and Up are multiple bits, then each counter has the same size accumulator but independent EN and Up controls.  If CBy, EN and Up are all lists, each counter can have a different CBy dataset and value as well as EN and Up controls.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit/Var/List EN: A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Bit CLR: Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Bit/Var/List Up: A set of Up bits for the list of counters (one bit per counter).  High means count up, low means count down.  This signal is ignored if EN is low.  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list Up input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Outputs:
 //
 // Bit/List CO: Carry Out bit(s).  If the internal accumulator rolls over (or not under), this bit goes high.  Has the same list structure as EN.
 //
 // Var/List Count: Count output(s).  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 25,23
 Object ( Bit ClkG) Input:A;  //_GUI 25,26
 Object ( List EN) Input:B;  //_GUI 25,31
 Object ( Bit CLR) Input:C;  //_GUI 25,37
 Object ( List Up) Input:D;  //_GUI 25,44
 Object Output( List CO) ;  //_GUI 116,7
 Object Output:A( List Count) ;  //_GUI 114,56
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 54,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 63,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 57,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 35,29
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 35,42
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 97,5
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 99,54
 Object ( Variant CO, Variant Count) UpDownCount( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant UpDown) ;  //_GUI 72,5
 Object ( Variant CO, Variant Count) UpDownCount:A( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant UpDown) ;  //_GUI 73,54

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:C.0;  
 Junction:B.0 = Input:A.0;  
 ListIn.0 = Input:B.0;  
 ListIn:A.0 = Input:D.0;  
 ListOut.0 = UpDownCount:A.0;  //_GUI 93,10, 93,56
 ListOut.1 = UpDownCount.0;  
 ListOut:A.0 = UpDownCount:A.1;  
 ListOut:A.1 = UpDownCount.1;  //_GUI 97,56, 97,41, 90,41, 90,10
 UpDownCount.0 = Junction.0;  //_GUI 55,7
 UpDownCount.1 = Junction:B.0;  //_GUI 58,10
 UpDownCount.2 = ListIn.1;  //_GUI 61,13, 61,31
 UpDownCount.3 = Junction:A.0;  //_GUI 64,16
 UpDownCount.4 = ListIn:A.1;  //_GUI 67,19, 67,44
 UpDownCount:A.0 = Junction.2;  //_GUI 55,56
 UpDownCount:A.1 = Junction:B.2;  //_GUI 58,59
 UpDownCount:A.2 = ListIn.0;  //_GUI 61,62, 61,34
 UpDownCount:A.3 = Junction:A.2;  //_GUI 64,65
 UpDownCount:A.4 = ListIn:A.0;  //_GUI 67,68, 67,47
}

Object ( List CO, List Count) UpDownCount( List CBy
    , Bit ClkG, List EN, Bit CLR, List Up) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="List/List/List"
{
 // This is a single or multi-bit enable up/down count object, which creates N counters depending on the number of enable (EN) bits. Larger counters at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Var/List CBy: Count by.  The dataset of CBy determines the size of the internal accumulator(s).  The value of CBy is what is added when EN is high.  CBy can have a different value each time EN is high.  If CBy is a List of Variants and EN and Up are Bits, the counters have a nested behavior such that a roll over of one will increment the next most significant counter in the list. If CBy is a Variant (MSBxxx, LSBxxx or BINxxx datasets) and EN and Up are multiple bits, then each counter has the same size accumulator but independent EN and Up controls.  If CBy, EN and Up are all lists, each counter can have a different CBy dataset and value as well as EN and Up controls.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit/Var/List EN: A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Bit CLR: Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Bit/Var/List Up: A set of Up bits for the list of counters (one bit per counter).  High means count up, low means count down.  This signal is ignored if EN is low.  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list Up input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Outputs:
 //
 // Bit/List CO: Carry Out bit(s).  If the internal accumulator rolls over (or not under), this bit goes high.  Has the same list structure as EN.
 //
 // Var/List Count: Count output(s).  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List CBy) Input;  //_GUI 25,20
 Object ( Bit ClkG) Input:A;  //_GUI 25,26
 Object ( List EN) Input:B;  //_GUI 25,31
 Object ( Bit CLR) Input:C;  //_GUI 25,37
 Object ( List Up) Input:D;  //_GUI 25,44
 Object Output( List CO) ;  //_GUI 116,7
 Object Output:A( List Count) ;  //_GUI 114,56
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 63,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 57,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 35,29
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 35,42
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 97,5
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 99,54
 Object ( Variant CO, Variant Count) UpDownCount( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant UpDown) ;  //_GUI 72,5
 Object ( Variant CO, Variant Count) UpDownCount:A( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant UpDown) ;  //_GUI 73,54
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 35,18

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:A.0;  
 ListIn.0 = Input:B.0;  
 ListIn:A.0 = Input:D.0;  
 ListOut.0 = UpDownCount:A.0;  //_GUI 93,10, 93,56
 ListOut.1 = UpDownCount.0;  
 ListOut:A.0 = UpDownCount:A.1;  
 ListOut:A.1 = UpDownCount.1;  //_GUI 97,56, 97,41, 90,41, 90,10
 UpDownCount.0 = ListIn:B.1;  //_GUI 55,7, 55,20
 UpDownCount.1 = Junction:A.0;  //_GUI 58,10
 UpDownCount.2 = ListIn.1;  //_GUI 61,13, 61,31
 UpDownCount.3 = Junction.0;  //_GUI 64,16
 UpDownCount.4 = ListIn:A.1;  //_GUI 67,19, 67,44
 UpDownCount:A.0 = ListIn:B.0;  //_GUI 55,56, 55,23
 UpDownCount:A.1 = Junction:A.2;  //_GUI 58,59
 UpDownCount:A.2 = ListIn.0;  //_GUI 61,62, 61,34
 UpDownCount:A.3 = Junction.2;  //_GUI 64,65
 UpDownCount:A.4 = ListIn:A.0;  //_GUI 67,68, 67,47
 ListIn:B.0 = Input.0;  
}

Object ( Variant CO, Variant Count) UpDownCount( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant Up) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\Advanced",Documentation="with EN"
{
 // This is a single or multi-bit enable up/down count object, which creates N counters depending on the number of enable (EN) bits. Larger counters at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Var/List CBy: Count by.  The dataset of CBy determines the size of the internal accumulator(s).  The value of CBy is what is added when EN is high.  CBy can have a different value each time EN is high.  If CBy is a List of Variants and EN and Up are Bits, the counters have a nested behavior such that a roll over of one will increment the next most significant counter in the list. If CBy is a Variant (MSBxxx, LSBxxx or BINxxx datasets) and EN and Up are multiple bits, then each counter has the same size accumulator but independent EN and Up controls.  If CBy, EN and Up are all lists, each counter can have a different CBy dataset and value as well as EN and Up controls.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit/Var/List EN: A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Bit CLR: Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Bit/Var/List Up: A set of Up bits for the list of counters (one bit per counter).  High means count up, low means count down.  This signal is ignored if EN is low.  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list Up input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Outputs:
 //
 // Bit/List CO: Carry Out bit(s).  If the internal accumulator rolls over (or not under), this bit goes high.  Has the same list structure as EN.
 //
 // Var/List Count: Count output(s).  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx, BINxxx, Signed (no OFL) Fixed (no OFL) and List.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant CBy) Input;  //_GUI 28,29
 Object ( Bit ClkG) Input:A;  //_GUI 28,32
 Object ( Variant EN) Input:B;  //_GUI 28,36
 Object ( Bit CLR) Input:C;  //_GUI 28,40
 Object ( Variant Up) Input:D;  //_GUI 28,44
 Object Output( Variant CO) ;  //_GUI 71,31
 Object Output:A( Variant Count) ;  //_GUI 71,34
 Object ( Variant CO, Variant Count) UpDownCount( Variant CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant UpDown) ;  //_GUI 54,30
 Object Text;  //_GUI 29,52,Convert multi-bit EN and Up datasets to bit lists then call the list overload
 Object ( List Out1) Bit_List( Variant In1) ;  //_GUI 35,34
 Object ( List Out1) Bit_List:A( Variant In1) ;  //_GUI 35,42

 //_ Behavior Topology
 Output.0 = UpDownCount.0;  
 Output:A.0 = UpDownCount.1;  
 UpDownCount.0 = Input.0;  //_GUI 52,32, 52,30
 UpDownCount.1 = Input:A.0;  //_GUI 50,35, 50,33
 UpDownCount.2 = Bit_List.0;  //_GUI 49,38, 49,37
 UpDownCount.3 = Input:C.0;  
 UpDownCount.4 = Bit_List:A.0;  //_GUI 49,44, 49,45
 Bit_List.0 = Input:B.0;  
 Bit_List:A.0 = Input:D.0;  
}

Object ( NULL CO, NULL Count) UpDownCount( NULL CBy
    , Bit ClkG, Variant EN, Bit CLR, Variant Up) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Controllers\\$Internal",Documentation="NULL/var/var"
{
 // This is a single or multi-bit enable up/down count object, which creates N counters depending on the number of enable (EN) bits. Larger counters at higher frequencies may have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Var/List CBy: Count by.  The dataset of CBy determines the size of the internal accumulator(s).  The value of CBy is what is added when EN is high.  CBy can have a different value each time EN is high.  If CBy is a List of Variants and EN and Up are Bits, the counters have a nested behavior such that a roll over of one will increment the next most significant counter in the list. If CBy is a Variant (MSBxxx, LSBxxx or BINxxx datasets) and EN and Up are multiple bits, then each counter has the same size accumulator but independent EN and Up controls.  If CBy, EN and Up are all lists, each counter can have a different CBy dataset and value as well as EN and Up controls.
 //
 // Bit ClkG: Global clock if disconnected or a specific clock if connected
 //
 // Bit/Var/List EN: A set of Enable bits for the list of counters (one bit per counter).  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list EN input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Bit CLR: Asynchronous clear.  Clears all of the counters.  If disconnected defaults to 0.
 //
 // Bit/Var/List Up: A set of Up bits for the list of counters (one bit per counter).  High means count up, low means count down.  This signal is ignored if EN is low.  If this input is a variant, it is converted to a list of the same structure and then follows the same rules as a list Up input.  For example, LSB003 would be converted to a three element LSB ordered list of bits.  En and Up must have the same dataset.  If EN, Up and CBy are all lists, they must have the same list structure.
 //
 // Outputs:
 //
 // Bit/List CO: Carry Out bit(s).  If the internal accumulator rolls over (or not under), this bit goes high.  Has the same list structure as EN.
 //
 // Var/List Count: Count output(s).  The result of the count.  This is the output of the internal accumulator register.  The list elements have the same dataset(s) as CBy and has the same list structure as EN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL CBy) Input;  //_GUI 25,23
 Object ( Bit ClkG) Input:A;  //_GUI 25,26
 Object ( Variant EN) Input:B;  //_GUI 25,31
 Object ( Bit CLR) Input:C;  //_GUI 25,37
 Object ( Variant Up) Input:D;  //_GUI 25,44
 Object Output( NULL CO) ;  //_GUI 82,23
 Object Output:A( NULL Count) ;  //_GUI 82,28
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 75,23

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 76,29
 Junction.0 = Input.0;  
}

Object ( Variant QAddr, Variant QDepth) RegDepthAddr( Variant D
    , Bit ClkG, Bit EN, Variant Addr) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\Advanced"
{
 // RegDepth instantiates a cascading shift register, or set of pipelines.  The number of stages (n) is specified by 2^(bitlength of the Addr input).  n registers are then recursively tiled, producing a pipeline with latency n.  The QAddr output is the contents of the register with the address Addr in the register chain.
 //
 // Inputs:
 //
 // Variant D: The input data that will be registered.
 //
 // Bit ClkG: The clock for the operation.  If disconnected, defaults to ClkG, the global user clock signal.
 //
 // Bit EN: Enables the registering (shifting) of the register depth chain.  If disconnected, defaults to 1.
 //
 // Variant Addr: The address of the register in the register chain to send out the QAddr output.
 //
 // Outputs:
 //
 // Variant QAddr: The output of register number "Addr" in the register chain.
 //
 // Variant QDepth: The output of the last register in the register chain.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 8,15
 Object ( Bit ClkG) Input:A;  //_GUI 8,18
 //_ Attributes Resource="Global"
 Object ( Bit EN) Input:B;  //_GUI 8,21
 //_ Attributes Constant="1"
 Object ( Variant Addr) Input:C;  //_GUI 8,28
 Object Output( Variant QAddr) ;  //_GUI 122,17
 Object Output:A( Variant QDepth) ;  //_GUI 122,26
 Object ( Variant Q, Variant Value) RegClrDepthVal( Variant D
    , Bit ClkG, Bit EN, Bit CLR, Variant depth) ;  //_GUI 42,14
 Object ( Variant Data) List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 85,17
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 23,28
 Object ( Bit CLR) Input:D;  //_GUI 24,24
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) "2^N_Bits"( Variant In1) ;  //_GUI 29,26
 Object ( Variant Data, Variant Size) N_Bit_LSB_List( Variant Data
    , Variant N) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 32,15
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 19,13
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 110,15
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 110,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 14,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 105,16

 //_ Behavior Topology
 Output.0 = Context.0;  
 Output:A.0 = Context:A.0;  
 RegClrDepthVal.0 = Junction:A.1;  
 RegClrDepthVal.1 = Input:A.0;  
 RegClrDepthVal.2 = Input:B.0;  
 RegClrDepthVal.3 = Input:D.0;  
 RegClrDepthVal.4 = "2^N_Bits".0;  //_GUI 41,28, 41,29
 List_Mux_Sel.0 = N_Bit_LSB_List.0;  
 List_Mux_Sel.1 = Junction.2;  //_GUI 85,34, 24,34
 Junction.0 = Input:C.0;  
 "2^N_Bits".0 = Junction.1;  
 N_Bit_LSB_List.0 = RegClrDepthVal.1;  
 N_Bit_LSB_List.1 = Junction:A.0;  //_GUI 62,22, 62,9, 33,9
 Junction:A.0 = LSB.0;  
 LSB.0 = Junction:B.1;  
 Context.0 = Junction:C.1;  
 Context.1 = List_Mux_Sel.0;  
 Context:A.0 = Junction:C.2;  //_GUI 106,26
 Context:A.1 = RegClrDepthVal.0;  //_GUI 101,29, 101,14, 58,14
 Junction:B.0 = Input.0;  
 Junction:C.0 = Junction:B.0;  //_GUI 106,5, 15,5
}

Object ( Variant QAddr, Variant QDepth) RegDepthAddr( Variant D
    , Bit ClkG, Bit EN, NULL Addr) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 8,15
 Object ( Bit ClkG) Input:A;  //_GUI 8,18
 Object ( Bit EN) Input:B;  //_GUI 8,21
 Object ( NULL Addr) Input:C;  //_GUI 8,28
 Object Output( Variant QAddr) ;  //_GUI 18,15
 Object Output:A( Variant QDepth) ;  //_GUI 18,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 14,15

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 15,19
 Junction.0 = Input.0;  
}

Object ( List Out1) PackBIN( Variant In1, Variant In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\PackBIN",Icon="Exposer_Out"
{
 // Packs input elements into a BIN-shaped List
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 9,13
 Object ( Variant In2) Input:A;  //_GUI 9,16
 Object Output( List Out1) ;  //_GUI 30,14
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 16,12

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( Variant Out1, Variant Out2) UnPackBIN( List In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\UnPackBIN",Icon="Exposer_In",Documentation="List"
{
 // Unpacks a BIN-shaped List into its data elements.
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,11
 Object Output( Variant Out1) ;  //_GUI 36,10
 Object Output:A( Variant Out2) ;  //_GUI 36,13
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,9

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( NULL Out2, Variant Out1) UnPackBIN( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\BIN\\UnPackBIN",Icon="Exposer_In"
{
 // Unpacks a BIN-shaped List into its data elements.
 //
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 8,37
 Object Output( NULL Out2) ;  //_GUI 40,29
 Object Output:A( Variant Out1) ;  //_GUI 39,37
 Object ( Bit In) Input:A;  //_GUI 25,13
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:B( Bit Error) ;  //_GUI 36,13
 //_ Attributes Trap="UnPackBIN - Attempt to UnPack non-List data set."
 Object Text;  //_GUI 18,48,A List should be propogated to this object, in which case the List overload will be instantiated.  In this case however, we have received a non-List type.  We simply pass it along on the lower output, remove the upper output by casting it to NULL and raise a warning message.
 Object ( NULL Out1) NULL;  //_GUI 24,27

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
 Output:B.0 = Input:A.0;  
}

Object ( Bit Out1) IsVariant( Variant Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 // Returns true if the input dataset has not yet been resolved to a non-variant dataset.  Returns false in all other cases.  This object will always return FALSE if the "Enforce Variant Resolution" compiler option is enabled.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be Variant.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is currently Variant and "Enforce Variant Resolution" is disabled, 0 otherwise.
 //
 // Date:
 // January 26, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 43,22
 Object Output( Bit Out1) ;  //_GUI 95,31
 Object ( Bit In) Input:A;  //_GUI 43,31
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:DSNum), 1, =)"
 Object ( Bit GlobalToForceDrill-In) Input:B;  //_GUI 43,27
 //_ Attributes Resource="Global",PromoteToParentObject="False"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsVariant( Bit Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="bit"
{
 // Returns true if the input dataset has not yet been resolved to a non-variant dataset.  Returns false in all other cases.  This object will always return FALSE if the "Enforce Variant Resolution" compiler option is enabled.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be Variant.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is currently Variant and "Enforce Variant Resolution" is disabled, 0 otherwise.
 //
 // Date:
 // January 26, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 43,21
 Object Output( Bit Out1) ;  //_GUI 78,21
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 54,19
 //_ Attributes Documentation="ztlist"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 // Same as OR,AND,XOR-NInput only clocked for timing.
 //
 // This object (Gate-NInput_Pipe) combines all bits (lists and everything) into a single bit.
 //
 // Where as Gate-List_Pipe combines all list elements into a single element that is the size of one of the input list's elements.
 //
 // Where as Gate-NInputList_Pipe calls Gate_NInput_Pipe on each list element producing an equivelently shaped list of bit elements.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 22,13
 Object ( Bit ClkG) Input:A;  //_GUI 52,91
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 52,94
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 52,97
 Object ( Bit Wait) Input:D;  //_GUI 206,113
 //_ Attributes Constant="0"
 Object Output( Bit AND) ;  //_GUI 242,13
 Object Output:A( Bit OR) ;  //_GUI 237,42
 Object Output:B( Bit XOR) ;  //_GUI 239,54
 Object Output:C( Variant PipeLen) ;  //_GUI 275,72
 Object Output:D( Bit ClkG) ;  //_GUI 237,77
 Object Output:E( Bit AClr) ;  //_GUI 236,80
 Object Output:F( Bit Done) ;  //_GUI 239,83
 Object Output:G( Bit Busy) ;  //_GUI 108,117
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 38,11
 Object ( Variant BitsPerStageSG) Input:E;  //_GUI 25,27
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 39,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 33,27
 Object Text;  //_GUI 18,35,We think this object is at least twice as fast as the standard adder.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 92,91
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 95,94
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 260,70
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 189,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 189,68
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 191,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 191,71
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 217,60
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In3) ;  //_GUI 217,86
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 194,83
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 194,57
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 107,24
 //_ Attributes Documentation="leaf"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 165,11
 Object ( Variant Out1) MSB:B( Variant In1) ;  //_GUI 166,37
 Object ( Variant Out1) MSB:C( Variant In1) ;  //_GUI 166,63
 Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 68,21
 //_ Attributes Documentation="Variant"
 Object ( NULL Out1) NULL;  //_GUI 58,14
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 198,64
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 198,38
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe:B( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 198,12

 //_ Behavior Topology
 Output.0 = Gate-NInput_Pipe:B.0;  
 Output:A.0 = Gate-NInput_Pipe:A.1;  
 Output:B.0 = Gate-NInput_Pipe.2;  //_GUI 231,55, 231,72
 Output:C.0 = CollectLSB.0;  
 Output:D.0 = Gate-NInput_Pipe.4;  
 Output:E.0 = Gate-NInput_Pipe.5;  
 Output:F.0 = Gate-NInput_Pipe.6;  
 Output:G.0 = $Gate-NInput_Pipe.7;  //_GUI 100,118, 100,47
 MSB.0 = Input.0;  
 PushLsb.0 = Junction.1;  
 PushLsb.1 = Junction.2;  //_GUI 34,31
 Junction.0 = Input:E.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = Input:B.0;  
 CollectLSB.0 = $Gate-NInput_Pipe.3;  //_GUI 256,72, 256,102, 135,102, 135,35
 CollectLSB.1 = Gate-NInput_Pipe.3;  
 Junction:C.0 = Junction:D.1;  
 Junction:D.0 = Junction:A.1;  //_GUI 190,92
 Junction:E.0 = Junction:F.1;  
 Junction:F.0 = Junction:B.1;  //_GUI 192,95
 Junction:G.0 = Junction:H.1;  
 Junction:H.0 = Input:D.0;  //_GUI 218,114
 Junction:I.0 = $Gate-NInput_Pipe.6;  //_GUI 146,84, 146,44
 Junction:J.0 = Junction:I.0;  
 $Gate-NInput_Pipe.0 = $NMin_Bit_LSB_List.0;  //_GUI 88,26
 $Gate-NInput_Pipe.1 = Junction:A.0;  //_GUI 93,29
 $Gate-NInput_Pipe.2 = Junction:B.0;  //_GUI 96,32
 $Gate-NInput_Pipe.3 = Input:C.0;  //_GUI 89,44, 89,98
 $Gate-NInput_Pipe.4 = Gate-NInput_Pipe.7;  //_GUI 141,47, 141,87
 MSB:A.0 = $Gate-NInput_Pipe.0;  //_GUI 154,14, 154,26
 MSB:B.0 = $Gate-NInput_Pipe.1;  //_GUI 161,40, 161,29
 MSB:C.0 = $Gate-NInput_Pipe.2;  //_GUI 154,66, 154,32
 $NMin_Bit_LSB_List.0 = NULL.0;  
 $NMin_Bit_LSB_List.1 = MSB.0;  //_GUI 55,26, 55,14
 $NMin_Bit_LSB_List.2 = PushLsb.0;  
 Gate-NInput_Pipe.0 = MSB:C.0;  
 Gate-NInput_Pipe.1 = Junction:D.2;  
 Gate-NInput_Pipe.2 = Junction:F.2;  
 Gate-NInput_Pipe.3 = Junction:I.1;  
 Gate-NInput_Pipe.4 = Junction:H.0;  
 Gate-NInput_Pipe:A.0 = MSB:B.0;  
 Gate-NInput_Pipe:A.1 = Junction:C.2;  
 Gate-NInput_Pipe:A.2 = Junction:E.2;  
 Gate-NInput_Pipe:A.3 = Junction:J.2;  
 Gate-NInput_Pipe:A.4 = Junction:G.0;  
 Gate-NInput_Pipe:B.0 = MSB:A.0;  
 Gate-NInput_Pipe:B.1 = Junction:C.1;  //_GUI 190,17
 Gate-NInput_Pipe:B.2 = Junction:E.1;  //_GUI 192,20
 Gate-NInput_Pipe:B.3 = Junction:J.1;  //_GUI 195,32
 Gate-NInput_Pipe:B.4 = Junction:G.1;  //_GUI 218,35
}

Object ( Bit AND, Bit OR, Bit XOR
    , NULL PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe( Bit Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined",Documentation="Bit"
{
 // Same as OR,AND,XOR-NInput only clocked for timing.
 //
 // This object (Gate-NInput_Pipe) combines all bits (lists and everything) into a single bit.
 //
 // Where as Gate-List_Pipe combines all list elements into a single element that is the size of one of the input list's elements.
 //
 // Where as Gate-NInputList_Pipe calls Gate_NInput_Pipe on each list element producing an equivelently shaped list of bit elements.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Val) Input;  //_GUI 18,12
 Object ( Bit ClkG) Input:A;  //_GUI 6,24
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 6,27
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 6,30
 Object ( Bit Wait) Input:D;  //_GUI 44,45
 //_ Attributes Constant="0"
 Object Output( Bit AND) ;  //_GUI 94,4
 Object Output:A( Bit OR) ;  //_GUI 94,8
 Object Output:B( Bit XOR) ;  //_GUI 94,12
 Object Output:C( NULL PipeLen) ;  //_GUI 58,18
 Object Output:D( Bit ClkG) ;  //_GUI 70,24
 Object Output:E( Bit AClr) ;  //_GUI 69,27
 Object Output:F( Bit Done) ;  //_GUI 72,30
 Object Output:G( Bit Busy) ;  //_GUI 42,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 72,12
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 63,12
 Object ( NULL Out1) NULL;  //_GUI 45,16

 //_ Behavior Topology
 Output.0 = Junction:A.0;  //_GUI 64,5
 Output:A.0 = Junction.0;  //_GUI 73,9
 Output:B.0 = Junction.1;  
 Output:C.0 = NULL.0;  
 Output:D.0 = Input:A.0;  
 Output:E.0 = Input:B.0;  
 Output:F.0 = Input:C.0;  
 Output:G.0 = Input:D.0;  //_GUI 34,52, 34,35, 48,35
 Junction.0 = Junction:A.1;  
 Junction:A.0 = Input.0;  
}

Object ( List OFL, List Out1) DiffExtnd( Variant Type
    , List Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/List"
{
 // This object extends data to be the maximum of the datalength and the type length.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 54,29
 Object ( List Data) Input:A;  //_GUI 54,33
 Object Output( List OFL) ;  //_GUI 154,23
 Object Output:A( List Out1) ;  //_GUI 149,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 75,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 60,31
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 134,31
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 137,21
 Object ( Variant OFL, Variant Out1) DiffExtnd( Variant Type
    , Variant Data) ;  //_GUI 86,44
 //_ Attributes Documentation="var/List"
 Object ( Variant OFL, Variant Out1) DiffExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 85,28
 //_ Attributes Documentation="var/List"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = DiffExtnd.1;  //_GUI 128,36, 128,49
 ListOut.1 = DiffExtnd:A.1;  
 ListOut:A.0 = DiffExtnd.0;  //_GUI 121,26, 121,46
 ListOut:A.1 = DiffExtnd:A.0;  //_GUI 116,23, 116,30
 DiffExtnd.0 = Junction.2;  //_GUI 76,46
 DiffExtnd.1 = ListIn.0;  //_GUI 71,49
 DiffExtnd:A.0 = Junction.1;  
 DiffExtnd:A.1 = ListIn.1;  
}

Object ( Bit OFL, Variant Out1) DiffExtnd( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="leaf"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 15,12
 Object ( Variant Data) Input:A;  //_GUI 15,15
 Object Output( Bit OFL) ;  //_GUI 103,16
 Object Output:A( Variant Out1) ;  //_GUI 101,19
 Object ( Variant N) BitA_Sub_BitB( Variant A, Variant B) ;  //_GUI 62,14
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 86,15
 //_ Attributes Documentation="PadLeft"
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 29,11
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 23,15

 //_ Behavior Topology
 Output.0 = UExtnd.0;  
 Output:A.0 = UExtnd.1;  
 BitA_Sub_BitB.0 = OrderDatasets.1;  
 BitA_Sub_BitB.1 = OrderDatasets.0;  //_GUI 53,19, 53,13
 UExtnd.0 = BitA_Sub_BitB.0;  
 UExtnd.1 = Junction.2;  //_GUI 86,29, 24,29
 OrderDatasets.0 = Input.0;  
 OrderDatasets.1 = Junction.1;  
 Junction.0 = Input:A.0;  
}

Object ( Bit OFL, Variant Out1) DiffExtnd( NULL Type
    , Variant Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL/var"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 15,12
 Object ( Variant Data) Input:A;  //_GUI 15,15
 Object Output( Bit OFL) ;  //_GUI 41,9
 Object Output:A( Variant Out1) ;  //_GUI 28,15
 Object ( Bit In) Input:B;  //_GUI 32,9
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit OFL, NULL Out1) DiffExtnd( NULL Type
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="NULL/NULL"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 15,12
 Object ( NULL Data) Input:A;  //_GUI 15,15
 Object Output( Bit OFL) ;  //_GUI 43,9
 Object Output:A( NULL Out1) ;  //_GUI 30,15
 Object ( Bit In) Input:B;  //_GUI 34,9
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit OFL, Variant Out1) DiffExtnd( Variant Type
    , NULL Data) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Converters\\$Internal",Documentation="var/NULL"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 15,12
 Object ( NULL Data) Input:A;  //_GUI 15,15
 Object Output( Bit OFL) ;  //_GUI 56,12
 Object Output:A( Variant Out1) ;  //_GUI 54,15
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 39,11
 //_ Attributes Documentation="PadLeft"

 //_ Behavior Topology
 Output.0 = UExtnd.0;  
 Output:A.0 = UExtnd.1;  
 UExtnd.0 = Input.0;  
 UExtnd.1 = Input:A.0;  
}

Object ( Variant Min, Variant Max) OrderDatasetList( Variant List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="leaf"
{
 // Pulls the min and max elements out of a list
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 20,19
 Object Output( Variant Min) ;  //_GUI 56,19
 Object Output:A( Variant Max) ;  //_GUI 56,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 44,19

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 45,25
 Junction.0 = Input.0;  
}

Object ( NULL Min, NULL Max) OrderDatasetList( NULL List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL List) Input;  //_GUI 20,19
 Object Output( NULL Min) ;  //_GUI 56,19
 Object Output:A( NULL Max) ;  //_GUI 56,24
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 44,19

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 45,25
 Junction.0 = Input.0;  
}

Object ( Variant Min, Variant Max) OrderDatasetList( List List) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 // Pulls the min and max elements out of a list
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 12,25
 Object Output( Variant Min) ;  //_GUI 177,9
 Object Output:A( Variant Max) ;  //_GUI 177,21
 Object ( Variant Out1, Variant Out1, Variant LSB) ListPopLsb
    ( Variant In1) ;  //_GUI 41,23
 //_ Attributes Documentation="var"
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 60,26
 Object ( Variant Min, Variant Max) OrderDatasets:A( Variant In1
    , Variant In2) ;  //_GUI 126,6
 Object ( Variant Min, Variant Max) OrderDatasets:B( Variant In1
    , Variant In2) ;  //_GUI 126,16
 Object Text;  //_GUI 43,45,we have a bit of confusion here over whether our list included null entries or whether it was just an even number of items in the list
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 165,7
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 83,7
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 83,29
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant D
    , Bit S) ;  //_GUI 83,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 78,14
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In1) ;  //_GUI 78,23
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 165,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In1) ;  //_GUI 78,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 160,26
 Object ( Variant Min, Variant Max) OrderDatasetList( Variant List) ;  //_GUI 99,6
 //_ Attributes Documentation="leaf"
 Object ( Variant Size) ListSize( List List) ;  //_GUI 22,11
 //_ Attributes Documentation="List"
 Object ( Bit Out1) BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 37,12
 Object ( List Out1, List Out2, List Out3) Junction:D
    ( List In0) ;  //_GUI 21,25
 Object ( LSB002 B) Input:A;  //_GUI 33,16
 //_ Attributes PromoteToParentObject="False",Constant="2"

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 ListPopLsb.0 = Junction:D.1;  
 OrderDatasets.0 = ListPopLsb.1;  
 OrderDatasets.1 = ListPopLsb.2;  
 OrderDatasets:A.0 = OrderDatasetList.0;  
 OrderDatasets:A.1 = $SelectOut:B.0;  //_GUI 119,11, 119,21
 OrderDatasets:B.0 = OrderDatasetList.1;  //_GUI 116,18
 OrderDatasets:B.1 = $SelectOut:A.0;  //_GUI 126,31
 $Select.0 = OrderDatasets:A.0;  //_GUI 151,9, 151,8
 $Select.1 = $SelectOut:B.1;  //_GUI 151,12, 151,28, 100,28, 100,24
 $Select.2 = Junction:C.1;  //_GUI 161,15
 $SelectOut.0 = ListPopLsb.0;  //_GUI 53,9
 $SelectOut.1 = Junction.1;  //_GUI 83,15
 $SelectOut:A.0 = OrderDatasets.1;  
 $SelectOut:A.1 = Junction:B.1;  
 $SelectOut:B.0 = OrderDatasets.0;  //_GUI 75,21
 $SelectOut:B.1 = Junction:A.1;  
 Junction.0 = BitA_Eq_BitB.0;  
 Junction:A.0 = Junction.2;  
 $Select:A.0 = OrderDatasets:B.1;  
 $Select:A.1 = $SelectOut:A.1;  //_GUI 155,24, 155,34
 $Select:A.2 = Junction:C.2;  
 Junction:B.0 = Junction:A.2;  
 Junction:C.0 = Junction:B.2;  //_GUI 161,38, 79,38
 OrderDatasetList.0 = $SelectOut.0;  
 ListSize.0 = Junction:D.0;  
 BitA_Eq_BitB.0 = ListSize.0;  
 BitA_Eq_BitB.1 = Input:A.0;  
 Junction:D.0 = Input.0;  
}

Object ( List Q, List PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) List_Reg_Pipe( List D
    , List PipeLen, Bit ClkG, Bit AClr, List Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List D) Input;  //_GUI 22,15
 Object ( List PipeLen) Input:A;  //_GUI 24,28
 Object ( Bit ClkG) Input:B;  //_GUI 66,42
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 66,45
 //_ Attributes Constant="0"
 Object ( List Go) Input:D;  //_GUI 21,46
 Object ( Bit Wait) Input:E;  //_GUI 60,66
 //_ Attributes Constant="0"
 Object Output( List Q) ;  //_GUI 155,15
 Object Output:A( List PipeLen) ;  //_GUI 147,25
 Object Output:B( Bit ClkG) ;  //_GUI 122,42
 Object Output:C( Bit AClr) ;  //_GUI 122,45
 Object Output:D( Bit Done) ;  //_GUI 126,48
 Object Output:E( Variant Busy) ;  //_GUI 142,57
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 38,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 123,13
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 111,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 81,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 84,45
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 37,26
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 128,23
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 40,44
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 91,57
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 124,55
 //_ Attributes Documentation="ztlist"
 Object ( List Out1, List Out2, List Out3) Junction:C
    ( List In0) ;  //_GUI 31,46
 Object Text;  //_GUI 34,79,This object was made in addition to RegPipe because of difficult feedback issues on the busy signal.
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) List_Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 92,35
 //_ Attributes Documentation="list"
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Variant Busy) List_Reg_Pipe:A( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) ;  //_GUI 92,13
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = List_Reg_Pipe.2;  
 Output:C.0 = List_Reg_Pipe.3;  
 Output:D.0 = List_Reg_Pipe.4;  
 Output:E.0 = Cast.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = List_Reg_Pipe.0;  //_GUI 118,18, 118,37
 ListOut.1 = List_Reg_Pipe:A.0;  
 Junction.0 = Input:E.0;  //_GUI 112,67
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:C.0;  
 ListIn:A.0 = Input:A.0;  
 ListOut:A.0 = List_Reg_Pipe.1;  //_GUI 121,28, 121,40
 ListOut:A.1 = List_Reg_Pipe:A.1;  //_GUI 114,25, 114,18
 ListIn:B.0 = Junction:C.1;  
 ListOut:B.0 = List_Reg_Pipe.5;  //_GUI 84,62, 84,52
 ListOut:B.1 = List_Reg_Pipe:A.5;  //_GUI 78,59, 78,30
 Cast.0 = Junction:C.2;  //_GUI 117,57, 117,72, 32,72
 Cast.1 = ListOut:B.0;  
 Junction:C.0 = Input:D.0;  
 List_Reg_Pipe.0 = ListIn.0;  //_GUI 68,37, 68,18
 List_Reg_Pipe.1 = ListIn:A.0;  //_GUI 65,40, 65,31
 List_Reg_Pipe.2 = Junction:A.1;  
 List_Reg_Pipe.3 = Junction:B.1;  
 List_Reg_Pipe.4 = ListIn:B.0;  
 List_Reg_Pipe.5 = Junction.0;  
 List_Reg_Pipe:A.0 = ListIn.1;  
 List_Reg_Pipe:A.1 = ListIn:A.1;  //_GUI 71,18, 71,28
 List_Reg_Pipe:A.2 = Junction:A.0;  //_GUI 82,21
 List_Reg_Pipe:A.3 = Junction:B.0;  //_GUI 85,24
 List_Reg_Pipe:A.4 = ListIn:B.1;  //_GUI 74,27, 74,34, 57,34, 57,46
 List_Reg_Pipe:A.5 = Junction.1;  //_GUI 112,30
}

Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) List_Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="leaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 9,14
 Object ( Variant PipeLen) Input:A;  //_GUI 23,17
 Object ( Bit ClkG) Input:B;  //_GUI 30,20
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 31,23
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 26,26
 Object ( Bit Wait) Input:E;  //_GUI 42,46
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 75,14
 Object Output:A( Variant PipeLen) ;  //_GUI 62,17
 Object Output:B( Bit ClkG) ;  //_GUI 55,20
 Object Output:C( Bit AClr) ;  //_GUI 55,23
 Object Output:D( Bit Done) ;  //_GUI 72,26
 Object Output:E( Bit Busy) ;  //_GUI 69,36
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 37,13
 //_ Attributes Documentation="bit"

 //_ Behavior Topology
 Output.0 = Reg_Pipe.0;  
 Output:A.0 = Reg_Pipe.1;  
 Output:B.0 = Reg_Pipe.2;  
 Output:C.0 = Reg_Pipe.3;  
 Output:D.0 = Reg_Pipe.4;  
 Output:E.0 = Reg_Pipe.5;  //_GUI 37,37
 Reg_Pipe.0 = Input.0;  
 Reg_Pipe.1 = Input:A.0;  
 Reg_Pipe.2 = Input:B.0;  
 Reg_Pipe.3 = Input:C.0;  
 Reg_Pipe.4 = Input:D.0;  
 Reg_Pipe.5 = Input:E.0;  //_GUI 53,47
}

Object ( Variant Q, NULL PipeLen, Bit ClkG
    , Bit AClr, Variant Done, Bit Busy) List_Reg_Pipe( Variant D
    , NULL PipeLen, Bit ClkG, Bit AClr, Variant Go
    , Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 16,10
 Object ( NULL PipeLen) Input:A;  //_GUI 12,23
 Object ( Bit ClkG) Input:B;  //_GUI 17,31
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 17,34
 //_ Attributes Constant="0"
 Object ( Variant Go) Input:D;  //_GUI 25,57
 Object ( Bit Wait) Input:E;  //_GUI 25,62
 //_ Attributes Constant="0"
 Object Output( Variant Q) ;  //_GUI 85,10
 Object Output:A( NULL PipeLen) ;  //_GUI 31,23
 Object Output:B( Bit ClkG) ;  //_GUI 23,31
 Object Output:C( Bit AClr) ;  //_GUI 23,34
 Object Output:D( Variant Done) ;  //_GUI 46,57
 Object Output:E( Bit Busy) ;  //_GUI 46,62

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
 Output:B.0 = Input:B.0;  
 Output:C.0 = Input:C.0;  
 Output:D.0 = Input:D.0;  
 Output:E.0 = Input:E.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7, Variant In8) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 32,23
 Object ( Variant In2) Input:A;  //_GUI 32,26
 Object ( Variant In3) Input:B;  //_GUI 32,29
 Object ( Variant In4) Input:C;  //_GUI 32,32
 Object ( Variant In5) Input:D;  //_GUI 32,35
 Object ( Variant In6) Input:E;  //_GUI 32,38
 Object ( Variant In7) Input:F;  //_GUI 32,41
 Object ( Variant In8) Input:G;  //_GUI 32,46
 Object Output( List Out1) ;  //_GUI 68,44
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7) ;  //_GUI 38,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,42

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
 PackLSB.3 = Input:C.0;  
 PackLSB.4 = Input:D.0;  
 PackLSB.5 = Input:E.0;  
 PackLSB.6 = Input:F.0;  
 ListOut.0 = Input:G.0;  
 ListOut.1 = PackLSB.0;  //_GUI 51,44, 51,25
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8) UnPackLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,27
 Object Output( Variant Out1) ;  //_GUI 70,25
 Object Output:A( Variant Out2) ;  //_GUI 70,28
 Object Output:B( Variant Out3) ;  //_GUI 70,31
 Object Output:C( Variant Out4) ;  //_GUI 70,34
 Object Output:D( Variant Out5) ;  //_GUI 70,37
 Object Output:E( Variant Out6) ;  //_GUI 70,40
 Object Output:F( Variant Out7) ;  //_GUI 70,43
 Object Output:G( Variant Out8) ;  //_GUI 70,47
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 34,25
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) UnPackLSB:A
    ( Variant In1) ;  //_GUI 55,24

 //_ Behavior Topology
 Output.0 = UnPackLSB:A.0;  
 Output:A.0 = UnPackLSB:A.1;  
 Output:B.0 = UnPackLSB:A.2;  
 Output:C.0 = UnPackLSB:A.3;  
 Output:D.0 = UnPackLSB:A.4;  
 Output:E.0 = UnPackLSB:A.5;  
 Output:F.0 = UnPackLSB:A.6;  
 Output:G.0 = UnPackLSB.1;  //_GUI 52,48, 52,30
 UnPackLSB.0 = Input.0;  
 UnPackLSB:A.0 = UnPackLSB.0;  
}

Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $LeftJustify_Pipe( Variant Val, Variant ShBy, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 43,20
 Object ( Variant ShBy) Input:A;  //_GUI 44,54
 Object ( Bit ClkG) Input:B;  //_GUI 43,86
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:C;  //_GUI 43,89
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:D;  //_GUI 43,97
 Object ( Bit Wait) Input:E;  //_GUI 287,99
 Object Output( Variant Val) ;  //_GUI 290,26
 Object Output:A( Variant ShiftMask) ;  //_GUI 290,36
 Object Output:B( Variant ShiftNum) ;  //_GUI 290,48
 Object Output:C( Variant PipeLen) ;  //_GUI 289,55
 Object Output:D( Bit ClkG) ;  //_GUI 289,63
 Object Output:E( Bit AClr) ;  //_GUI 289,66
 Object Output:F( Bit Done) ;  //_GUI 289,69
 Object Output:G( Bit Busy) ;  //_GUI 45,141
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 66,77
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 266,46
 Object ( Variant C, Variant Out2) SHL( Variant In1
    , Variant C) ;  //_GUI 67,50
 //_ Attributes Documentation="Bit_Carry"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 56,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 60,54
 Object Text;  //_GUI 65,65,If ExposeBIN's input is bit, the top output is NULL
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 254,45
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 134,38
 Object ( Variant O) Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 267,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 244,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 60,79
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) ;  //_GUI 252,28
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2) ;  //_GUI 252,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In3) ;  //_GUI 247,37
 Object Text;  //_GUI 38,59,Initially ShBy is half the size of Val
 Object Text;  //_GUI 132,23,If any of the most significant ShBy number of bits are high, we pass through the unshifted data.
 Object Text;  //_GUI 212,12,Reduce ShBy by half and recurse.  Some stages passthrough.
 Object Text;  //_GUI 247,12,If any of the most significant ShBy number of bits are high, we pass through the unshifted ShiftMask.
 Object Text;  //_GUI 279,40,Add a most significant bit to ShiftNum
 Object ( Variant RndUp, Variant RndDn, Bit Rounded) Log2_Bits
    ( Variant Type) ;  //_GUI 20,6
 Object ( Variant BitsPerStageSG) Input:F;  //_GUI 14,8
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant N) BitA_Mod_BitB( Variant A, Variant B) ;  //_GUI 82,9
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 123,9
 //_ Attributes Documentation="NULL"
 Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) ;  //_GUI 143,9
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 168,56
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 187,53
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 150,50
 Object ( Variant C, Variant Out2) SHL:A( Variant In1
    , Variant C) ;  //_GUI 117,35
 //_ Attributes Documentation="Bit_Carry"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In3) ;  //_GUI 60,39
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputPass_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 93,50
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:A( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 94,19
 Object Text;  //_GUI 169,38,Optional pipeline register based upon BitsPerStage.  Last stage always registers
 Object Text;  //_GUI 99,13,Constant
 Object Text;  //_GUI 98,45,Constant
 Object Text;  //_GUI 99,80,Constant
 Object Text;  //_GUI 99,121,Constant
 Object Text;  //_GUI 173,80,Constant
 Object Text;  //_GUI 173,121,Constant
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 88,69
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 85,57
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In3) ;  //_GUI 82,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 129,54
 Object ( Variant Q, Variant PipeLen, Bit ClkG
    , Bit AClr, Bit Done, Bit Busy) Reg_Pipe:B( Variant D
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Go
    , Bit Wait) ;  //_GUI 212,56
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 206,69
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 203,66
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In0) ;  //_GUI 200,63
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:M
    ( Variant In3) ;  //_GUI 238,47
 Object ( Variant N) BitA_Add_BitB( Variant A, Variant B) ;  //_GUI 249,53
 Object ( Variant N) BitA_Add_BitB:A( Variant A, Variant B) ;  //_GUI 188,82
 Object Text;  //_GUI 173,89,Constant
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 117,60
 Object Text;  //_GUI 216,87,Constant
 Object Text;  //_GUI 216,122,Constant
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In1) ;  //_GUI 113,36
 Object Text;  //_GUI 95,89,This object is pipelined or pass through depending on the width of the OR gate and BitsPerStage
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In2) ;  //_GUI 120,72
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In3) ;  //_GUI 230,72
 Object Text;  //_GUI 169,2,Register this stage if (0 == Mod (ShBy, Log2Dn (BitsPerStageSG)/2))
 Object ( LSB002 In) Input:G;  //_GUI 38,13
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 45,5,DivBy2
 Object Text;  //_GUI 169,10,BitsPerStageSG RegEvery64            363            216            215            1Courier New,8,0,0
 Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $LeftJustify_Pipe( Variant Val, Variant ShBy, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 211,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In1) ;  //_GUI 235,54
 Object ( Variant RndUp, Variant RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, Variant B) ;  //_GUI 42,9
 //_ Attributes Documentation="var/var"
 Object ( Variant RndUp, Variant RndDn, Bit Rounded) Log2_Bits:A
    ( Variant Type) ;  //_GUI 63,2

 //_ Behavior Topology
 Output.0 = $LeftJustify_Pipe.0;  
 Output:A.0 = Mux:A.0;  
 Output:B.0 = CollectMSB.0;  
 Output:C.0 = BitA_Add_BitB.0;  
 Output:D.0 = Reg_Pipe:B.2;  
 Output:E.0 = Reg_Pipe:B.3;  
 Output:F.0 = Reg_Pipe:B.4;  
 Output:G.0 = Gate-NInputPass_Pipe.7;  //_GUI 45,96, 92,96, 92,73
 ExposeBIN.0 = Junction:C.1;  
 CollectMSB.0 = INVERT.0;  
 CollectMSB.1 = $LeftJustify_Pipe.2;  //_GUI 242,51, 242,33
 SHL.0 = Junction.2;  //_GUI 57,52
 SHL.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 INVERT.0 = Junction:M.2;  
 Mux.0 = SHL:A.1;  
 Mux.1 = Junction:O.2;  //_GUI 114,43
 Mux.2 = Junction:I.0;  //_GUI 130,46
 Mux:A.0 = CollectBIN.0;  //_GUI 265,36, 265,31
 Mux:A.1 = CollectBIN:A.0;  
 Mux:A.2 = Junction:M.1;  //_GUI 267,44, 239,44
 Junction:B.0 = $LeftJustify_Pipe.1;  
 Junction:C.0 = Junction:A.2;  
 CollectBIN.0 = Junction:B.1;  
 CollectBIN.1 = Junction:D.1;  //_GUI 248,33
 CollectBIN:A.0 = Junction:D.2;  
 CollectBIN:A.1 = Junction:B.2;  //_GUI 245,41
 Junction:D.0 = Junction:C.2;  //_GUI 248,120, 61,120
 Log2_Bits.0 = Input:F.0;  
 BitA_Mod_BitB.0 = Log2_Bits:A.1;  //_GUI 82,7
 BitA_Mod_BitB.1 = $BitA_Div_BitB.1;  
 IsNULL.0 = BitA_Mod_BitB.0;  
 "Constant->N_Bits".0 = IsNULL.0;  
 Reg_Pipe.0 = ListOut.0;  //_GUI 163,58, 163,53
 Reg_Pipe.1 = "Constant->N_Bits".0;  //_GUI 166,61, 166,12
 Reg_Pipe.2 = Gate-NInputPass_Pipe.4;  
 Reg_Pipe.3 = Gate-NInputPass_Pipe.5;  
 Reg_Pipe.4 = Gate-NInputPass_Pipe.6;  
 Reg_Pipe.5 = Reg_Pipe:B.5;  
 ListIn.0 = Reg_Pipe.0;  //_GUI 185,56, 185,58
 ListOut.0 = Junction:I.1;  
 ListOut.1 = Mux.0;  //_GUI 146,52, 146,41
 SHL:A.0 = Junction:O.1;  
 SHL:A.1 = Junction:E.2;  
 Junction:E.0 = Junction:A.0;  
 Gate-NInputPass_Pipe.0 = SHL.0;  
 Gate-NInputPass_Pipe.1 = Junction:H.2;  
 Gate-NInputPass_Pipe.2 = Junction:G.2;  
 Gate-NInputPass_Pipe.3 = Junction:F.2;  
 Gate-NInputPass_Pipe.4 = Junction:P.0;  
 Reg_Pipe:A.0 = Junction.1;  
 Reg_Pipe:A.1 = Junction:N.0;  //_GUI 80,24, 80,48, 118,48
 Reg_Pipe:A.2 = Junction:H.1;  //_GUI 83,27
 Reg_Pipe:A.3 = Junction:G.1;  //_GUI 86,30
 Reg_Pipe:A.4 = Junction:F.1;  //_GUI 89,33
 Reg_Pipe:A.5 = Junction:P.1;  //_GUI 110,46, 121,46
 Junction:F.0 = Input:D.0;  //_GUI 89,98
 Junction:G.0 = Input:C.0;  //_GUI 86,90
 Junction:H.0 = Input:B.0;  //_GUI 83,87
 Junction:I.0 = Gate-NInputPass_Pipe.1;  
 Reg_Pipe:B.0 = ListIn.0;  
 Reg_Pipe:B.1 = Junction:R.0;  //_GUI 209,61, 209,55
 Reg_Pipe:B.2 = Junction:L.1;  
 Reg_Pipe:B.3 = Junction:K.1;  
 Reg_Pipe:B.4 = Junction:J.1;  
 Reg_Pipe:B.5 = Junction:Q.0;  
 Junction:J.0 = Reg_Pipe.4;  
 Junction:K.0 = Reg_Pipe.3;  
 Junction:L.0 = Reg_Pipe.2;  
 Junction:M.0 = Reg_Pipe:B.0;  //_GUI 239,58
 BitA_Add_BitB.0 = Junction:R.1;  
 BitA_Add_BitB.1 = BitA_Add_BitB:A.0;  //_GUI 243,58, 243,85
 BitA_Add_BitB:A.0 = Reg_Pipe.1;  //_GUI 186,84, 186,61
 BitA_Add_BitB:A.1 = Junction:N.2;  //_GUI 118,87
 Junction:N.0 = Gate-NInputPass_Pipe.3;  
 Junction:O.0 = Reg_Pipe:A.0;  //_GUI 114,21
 Junction:P.0 = Reg_Pipe.5;  
 Junction:Q.0 = Input:E.0;  //_GUI 231,73, 291,73
 $LeftJustify_Pipe.0 = ListIn.1;  //_GUI 198,27
 $LeftJustify_Pipe.1 = ExposeBIN.0;  //_GUI 192,30, 192,79
 $LeftJustify_Pipe.2 = Junction:L.0;  //_GUI 201,33
 $LeftJustify_Pipe.3 = Junction:K.0;  //_GUI 204,36
 $LeftJustify_Pipe.4 = Junction:J.0;  //_GUI 207,45
 $LeftJustify_Pipe.5 = Junction:Q.1;  //_GUI 231,48
 Junction:R.0 = $LeftJustify_Pipe.3;  //_GUI 236,36
 $BitA_Div_BitB.0 = Log2_Bits.1;  
 $BitA_Div_BitB.1 = Input:G.0;  
 Log2_Bits:A.0 = Junction:E.1;  //_GUI 61,5
}

Object ( Variant Val, Variant ShiftMask, NULL ShiftNum
    , NULL PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $LeftJustify_Pipe( Variant Val, NULL ShBy, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 24,21
 Object ( NULL ShBy) Input:A;  //_GUI 24,31
 Object ( Bit ClkG) Input:B;  //_GUI 24,37
 Object ( Bit AClr) Input:C;  //_GUI 24,40
 Object ( Bit Go) Input:D;  //_GUI 24,43
 Object ( Bit Wait) Input:E;  //_GUI 60,50
 Object Output( Variant Val) ;  //_GUI 61,21
 Object Output:A( Variant ShiftMask) ;  //_GUI 61,24
 Object Output:B( NULL ShiftNum) ;  //_GUI 61,31
 Object Output:C( NULL PipeLen) ;  //_GUI 61,34
 Object Output:D( Bit ClkG) ;  //_GUI 61,37
 Object Output:E( Bit AClr) ;  //_GUI 61,40
 Object Output:F( Bit Done) ;  //_GUI 61,43
 Object Output:G( Bit Busy) ;  //_GUI 26,50
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 34,23
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,21
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:A
    ( NULL In0) ;  //_GUI 54,31

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = Junction:A.1;  
 Output:C.0 = Junction:A.2;  //_GUI 55,35
 Output:D.0 = Input:B.0;  
 Output:E.0 = Input:C.0;  
 Output:F.0 = Input:D.0;  
 Output:G.0 = Input:E.0;  //_GUI 26,47, 64,47
 ExposeMSB.0 = Junction.2;  //_GUI 31,26
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
}

Object ( Variant NotZero, Variant IsZero, Variant AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 37,28
 Object ( Bit ClkG) Input:A;  //_GUI 37,31
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 37,34
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 37,46
 Object ( Bit Wait) Input:D;  //_GUI 64,54
 //_ Attributes Constant="0"
 Object Output( Variant NotZero) ;  //_GUI 81,22
 Object Output:A( Variant IsZero) ;  //_GUI 81,25
 Object Output:B( Variant AllHigh) ;  //_GUI 81,28
 Object Output:C( Variant PipeLen) ;  //_GUI 65,37
 Object Output:D( Bit ClkG) ;  //_GUI 65,40
 Object Output:E( Bit AClr) ;  //_GUI 65,43
 Object Output:F( Bit Done) ;  //_GUI 65,46
 Object Output:G( Bit Busy) ;  //_GUI 39,56
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputList_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 43,27
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 69,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In3) ;  //_GUI 65,25

 //_ Behavior Topology
 Output.0 = Junction.1;  //_GUI 66,23
 Output:A.0 = INVERT.0;  
 Output:B.0 = Gate-NInputList_Pipe.0;  
 Output:C.0 = Gate-NInputList_Pipe.3;  
 Output:D.0 = Gate-NInputList_Pipe.4;  
 Output:E.0 = Gate-NInputList_Pipe.5;  
 Output:F.0 = Gate-NInputList_Pipe.6;  
 Output:G.0 = Gate-NInputList_Pipe.7;  //_GUI 39,50
 Gate-NInputList_Pipe.0 = Input.0;  
 Gate-NInputList_Pipe.1 = Input:A.0;  
 Gate-NInputList_Pipe.2 = Input:B.0;  
 Gate-NInputList_Pipe.3 = Input:C.0;  
 Gate-NInputList_Pipe.4 = Input:D.0;  //_GUI 70,50, 70,55
 INVERT.0 = Junction.2;  
 Junction.0 = Gate-NInputList_Pipe.1;  //_GUI 66,32
}

Object ( List NotZero, List IsZero, List AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe( List Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Val) Input;  //_GUI 36,37
 Object ( Bit ClkG) Input:A;  //_GUI 36,42
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 36,45
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 36,57
 Object ( Bit Wait) Input:D;  //_GUI 192,76
 //_ Attributes Constant="0"
 Object Output( List NotZero) ;  //_GUI 193,29
 Object Output:A( List IsZero) ;  //_GUI 193,37
 Object Output:B( List AllHigh) ;  //_GUI 193,45
 Object Output:C( Variant PipeLen) ;  //_GUI 193,51
 Object Output:D( Bit ClkG) ;  //_GUI 193,54
 Object Output:E( Bit AClr) ;  //_GUI 193,57
 Object Output:F( Bit Done) ;  //_GUI 193,69
 Object Output:G( Bit Busy) ;  //_GUI 37,74
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 42,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 66,57
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 63,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 60,42
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 177,27
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 177,35
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 177,43
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 93,38
 Object ( List Out1) PackLSB:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 93,11
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 148,40
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB:A
    ( Variant In1) ;  //_GUI 148,27
 Object Text;  //_GUI 114,80,We synchronize the Dones and the data just in case the list is hetrogeneous.  If the list is homogeneous, this object becomes a pass-through.
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 119,38
 Object ( Variant NotZero, Variant IsZero, Variant AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 71,38
 Object ( Variant NotZero, Variant IsZero, Variant AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 71,11

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = ListOut:B.0;  
 Output:C.0 = SyncRegPair_Pipe.4;  
 Output:D.0 = SyncRegPair_Pipe.5;  
 Output:E.0 = SyncRegPair_Pipe.6;  
 Output:F.0 = SyncRegPair_Pipe.9;  
 Output:G.0 = CompareUnary_Pipe.7;  //_GUI 37,61
 ListIn.0 = Input.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:A.0;  
 ListOut.0 = UnPackLSB.0;  //_GUI 173,32, 173,42
 ListOut.1 = UnPackLSB:A.0;  
 ListOut:A.0 = UnPackLSB.1;  //_GUI 164,40, 164,45
 ListOut:A.1 = UnPackLSB:A.1;  //_GUI 170,37, 170,32
 ListOut:B.0 = UnPackLSB.2;  
 ListOut:B.1 = UnPackLSB:A.2;  //_GUI 167,45, 167,35
 PackLSB.0 = CompareUnary_Pipe.0;  
 PackLSB.1 = CompareUnary_Pipe.1;  
 PackLSB.2 = CompareUnary_Pipe.2;  
 PackLSB:A.0 = CompareUnary_Pipe:A.0;  
 PackLSB:A.1 = CompareUnary_Pipe:A.1;  
 PackLSB:A.2 = CompareUnary_Pipe:A.2;  
 UnPackLSB.0 = SyncRegPair_Pipe.1;  
 UnPackLSB:A.0 = SyncRegPair_Pipe.0;  //_GUI 139,30
 SyncRegPair_Pipe.0 = PackLSB:A.0;  //_GUI 119,14
 SyncRegPair_Pipe.1 = PackLSB.0;  //_GUI 111,43, 111,41
 SyncRegPair_Pipe.2 = CompareUnary_Pipe:A.3;  //_GUI 116,46, 116,22
 SyncRegPair_Pipe.3 = CompareUnary_Pipe.3;  
 SyncRegPair_Pipe.4 = CompareUnary_Pipe.4;  
 SyncRegPair_Pipe.5 = CompareUnary_Pipe.5;  
 SyncRegPair_Pipe.6 = CompareUnary_Pipe:A.6;  //_GUI 113,58, 113,31
 SyncRegPair_Pipe.7 = CompareUnary_Pipe.6;  //_GUI 104,61, 104,58
 SyncRegPair_Pipe.8 = Input:D.0;  //_GUI 196,73
 CompareUnary_Pipe.0 = ListIn.0;  
 CompareUnary_Pipe.1 = Junction:B.1;  
 CompareUnary_Pipe.2 = Junction:A.1;  
 CompareUnary_Pipe.3 = Junction.1;  
 CompareUnary_Pipe.4 = SyncRegPair_Pipe.8;  //_GUI 91,77, 142,77, 142,64
 CompareUnary_Pipe:A.0 = ListIn.1;  //_GUI 58,13, 58,37
 CompareUnary_Pipe:A.1 = Junction:B.0;  //_GUI 61,16
 CompareUnary_Pipe:A.2 = Junction:A.0;  //_GUI 64,19
 CompareUnary_Pipe:A.3 = Junction.0;  //_GUI 67,31
 CompareUnary_Pipe:A.4 = SyncRegPair_Pipe.7;  //_GUI 142,34, 142,61
}

Object ( Bit NotZero, Bit IsZero, Bit AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe( Floating Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Val) Input;  //_GUI 17,44
 Object ( Bit ClkG) Input:A;  //_GUI 17,49
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 17,52
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 17,64
 Object ( Bit Wait) Input:D;  //_GUI 154,83
 //_ Attributes Constant="0"
 Object Output( Bit NotZero) ;  //_GUI 155,46
 Object Output:A( Bit IsZero) ;  //_GUI 155,49
 Object Output:B( Bit AllHigh) ;  //_GUI 155,52
 Object Output:C( Variant PipeLen) ;  //_GUI 155,58
 Object Output:D( Bit ClkG) ;  //_GUI 155,61
 Object Output:E( Bit AClr) ;  //_GUI 155,64
 Object Output:F( Bit Done) ;  //_GUI 155,76
 Object Output:G( Bit Busy) ;  //_GUI 19,79
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 47,64
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 44,52
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 41,49
 Object Text;  //_GUI 92,89,We synchronize the AllHigh result with the Zero result.  If the two results are the same PipeLen, this object becomes a pass-through.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 38,44
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 130,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 127,49
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 143,50
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 143,47
 Object ( Bit Out1) VouchBit:B( Variant In1) ;  //_GUI 143,44
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 23,42
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,42
 Object Text;  //_GUI 67,38,Ignore the sign bit because (+0 == -0)
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 99,45
 Object ( Variant NotZero, Variant IsZero, Variant AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 67,45
 Object ( Variant NotZero, Variant IsZero, Variant AllHigh
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) CompareUnary_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 67,11

 //_ Behavior Topology
 Output.0 = VouchBit:B.0;  
 Output:A.0 = VouchBit:A.0;  
 Output:B.0 = VouchBit.0;  
 Output:C.0 = SyncRegPair_Pipe.4;  
 Output:D.0 = SyncRegPair_Pipe.5;  
 Output:E.0 = SyncRegPair_Pipe.6;  
 Output:F.0 = SyncRegPair_Pipe.9;  
 Output:G.0 = CompareUnary_Pipe.7;  //_GUI 19,68
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:A.0;  
 Junction:C.0 = MSB.0;  
 INVERT.0 = Junction:D.0;  //_GUI 128,47
 Junction:D.0 = SyncRegPair_Pipe.1;  
 VouchBit.0 = SyncRegPair_Pipe.0;  //_GUI 125,53, 125,47
 VouchBit:A.0 = Junction:D.1;  
 VouchBit:B.0 = INVERT.0;  
 MSB.0 = Input.0;  
 VariantIn.0 = Junction:C.1;  
 SyncRegPair_Pipe.0 = CompareUnary_Pipe:A.2;  //_GUI 99,19
 SyncRegPair_Pipe.1 = CompareUnary_Pipe.1;  
 SyncRegPair_Pipe.2 = CompareUnary_Pipe:A.3;  //_GUI 96,53, 96,22
 SyncRegPair_Pipe.3 = CompareUnary_Pipe.3;  
 SyncRegPair_Pipe.4 = CompareUnary_Pipe.4;  
 SyncRegPair_Pipe.5 = CompareUnary_Pipe.5;  
 SyncRegPair_Pipe.6 = CompareUnary_Pipe:A.6;  //_GUI 93,65, 93,31
 SyncRegPair_Pipe.7 = CompareUnary_Pipe.6;  //_GUI 90,68, 90,65
 SyncRegPair_Pipe.8 = Input:D.0;  //_GUI 158,80
 CompareUnary_Pipe.0 = VariantIn.0;  
 CompareUnary_Pipe.1 = Junction:B.1;  
 CompareUnary_Pipe.2 = Junction:A.1;  
 CompareUnary_Pipe.3 = Junction.1;  
 CompareUnary_Pipe.4 = SyncRegPair_Pipe.8;  //_GUI 87,85, 123,85, 123,71
 CompareUnary_Pipe:A.0 = Junction:C.0;  //_GUI 39,13
 CompareUnary_Pipe:A.1 = Junction:B.0;  //_GUI 42,16
 CompareUnary_Pipe:A.2 = Junction:A.0;  //_GUI 45,19
 CompareUnary_Pipe:A.3 = Junction.0;  //_GUI 48,31
 CompareUnary_Pipe:A.4 = SyncRegPair_Pipe.7;  //_GUI 122,34, 122,68
}

Object ( Variant Out1) $AND-NInput( Variant In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="var/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,24
 Object ( Bit In2) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,22
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 43,22
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = AND.0;  
 VariantIn.0 = Input.0;  
 AND.0 = $AND-NInput.0;  
 AND.1 = Input:A.0;  //_GUI 59,32
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
}

Object ( Variant Out1) $AND-NInput( Variant In1, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,20
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 16,18
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1) $AND-NInput:A( Variant In1, Variant In2) ;  //_GUI 30,18
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = AND.0;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = Input.0;  
 AND.0 = $AND-NInput:A.0;  //_GUI 59,21
 AND.1 = $AND-NInput.0;  //_GUI 59,32
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
 $AND-NInput:A.0 = VariantIn:A.1;  
 $AND-NInput:A.1 = VariantIn:A.0;  
}

Object ( Variant Out1) $AND-NInput( Bit In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In2) Input;  //_GUI 10,24
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = AND.0;  
 VariantIn.0 = Input:A.0;  
 AND.0 = Input.0;  
 AND.1 = $AND-NInput.0;  //_GUI 59,32
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
}

Object ( Bit Out1) $AND-NInput( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$AND",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,24
 Object ( Bit In2) Input:A;  //_GUI 11,27
 Object Output( Bit Out1) ;  //_GUI 31,25
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 17,23

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29, Variant Out30, Variant Out31) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object Output:Z( Variant Out27) ;  //_GUI 80,115
 Object Output:a( Variant Out28) ;  //_GUI 80,118
 Object Output:b( Variant Out29) ;  //_GUI 80,121
 Object Output:c( Variant Out30) ;  //_GUI 80,124
 Object Output:d( Variant Out31) ;  //_GUI 80,127
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29, Variant Out30) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 Output:Z.0 = ExposeMSB.25;  
 Output:a.0 = ExposeMSB.26;  
 Output:b.0 = ExposeMSB.27;  
 Output:c.0 = ExposeMSB.28;  
 Output:d.0 = ExposeMSB.29;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Data, Variant Size) N_Bit_LSB_List( Variant Data
    , Variant N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object cuts the incoming Data dataset into pieces whose dataset and bit length is the same as the dataset and bit length of the N data input.  (Leading 0s are appended if necessary.)  These elements are then packed into an LSB-shaped List.  If Data input has a bit length of 21 (or 20 or 19) and the N input has a bit length of 3, Data output will be a List congaing 7 3-bit elements.  The order of the Bits in this List is identical to the order of the Bits in the Data input.
 //
 // Inputs:
 //
 // Variant Data: A set of bits of any dataset.
 //
 // Variant N:	The dataset (implies the number of bits) for each element of the output list.
 //
 // Outputs:
 //
 // Variant Data: The LSB ordered list with the input Data bits divided into the list elements where each list element has the N dataset and is therefore the same number of bits as N.
 //
 // Variant Size: Contains one Bit for every element in the Data List.  Has a dataset of LSBxxx.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 14,17
 Object ( Variant N) Input:A;  //_GUI 14,20
 Object Output( Variant Data) ;  //_GUI 81,20
 Object Output:A( Variant Size) ;  //_GUI 81,27
 Object ( Variant DataLeft, Variant DataOut) $N_Bit_List( Variant Data
    , Variant N, Variant Pattern) ;  //_GUI 62,16
 //_ Attributes Documentation="var"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 23,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 20,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 58,24
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 45,22
 Object ( Variant RndUp, Variant RndDn) BitADivBitB( Variant A
    , Variant B) ;  //_GUI 28,23

 //_ Behavior Topology
 Output.0 = $N_Bit_List.1;  
 Output:A.0 = Junction:B.2;  //_GUI 59,28
 $N_Bit_List.0 = Junction.1;  
 $N_Bit_List.1 = Junction:A.1;  
 $N_Bit_List.2 = Junction:B.1;  //_GUI 62,25
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = LSB.0;  
 LSB.0 = BitADivBitB.0;  
 BitADivBitB.0 = Junction.2;  //_GUI 24,25
 BitADivBitB.1 = Junction:A.2;  //_GUI 21,28
}

Object ( Variant Data, Bit Size) N_Bit_LSB_List( Variant Data
    , NULL N) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object cuts the incoming Data dataset into pieces whose dataset and bit length is the same as the dataset and bit length of the N data input.  (Leading 0s are appended if necessary.)  These elements are then packed into an LSB-shaped List.  If Data input has a bit length of 21 (or 20 or 19) and the N input has a bit length of 3, Data output will be a List congaing 7 3-bit elements.  The order of the Bits in this List is identical to the order of the Bits in the Data input.
 //
 // Inputs:
 //
 // Variant Data: A set of bits of any dataset.
 //
 // Variant N:	The dataset (implies the number of bits) for each element of the output list.
 //
 // Outputs:
 //
 // Variant Data: The LSB ordered list with the input Data bits divided into the list elements where each list element has the N dataset and is therefore the same number of bits as N.
 //
 // Variant Size: Contains one Bit for every element in the Data List.  Has a dataset of LSBxxx.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 20,34
 Object ( NULL N) Input:A;  //_GUI 20,37
 Object Output( Variant Data) ;  //_GUI 143,34
 Object Output:A( Bit Size) ;  //_GUI 143,37
 Object ( Bit In) Input:B;  //_GUI 139,37
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit AND, Bit OR, Bit XOR
    , Bit PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="leaf"
{
 // just one register
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 10,17
 Object ( Bit ClkG) Input:A;  //_GUI 52,72
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 52,75
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 48,90
 Object ( Bit Wait) Input:D;  //_GUI 125,102
 Object Output( Bit AND) ;  //_GUI 181,37
 Object Output:A( Bit OR) ;  //_GUI 193,50
 Object Output:B( Bit XOR) ;  //_GUI 182,58
 Object Output:C( Bit PipeLen) ;  //_GUI 175,65
 Object Output:D( Bit ClkG) ;  //_GUI 177,72
 Object Output:E( Bit AClr) ;  //_GUI 176,75
 Object Output:F( Bit Done) ;  //_GUI 170,90
 Object Output:G( Bit Busy) ;  //_GUI 109,106
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 101,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 105,72
 Object ( Bit In) Input:E;  //_GUI 169,65
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackBIN
    ( Variant In1) ;  //_GUI 135,48
 Object ( List Out1) PackBIN( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 100,47
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 48,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 48,51
 Object ( Bit Out1) AND-NInput( Variant In1) ;  //_GUI 53,41
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 53,49
 Object ( Bit Out1) XOR-NInput( Variant In1) ;  //_GUI 53,57
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 169,37
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 169,50
 Object ( Bit Out1) VouchBit:B( Variant In1) ;  //_GUI 169,58
 Object ( Variant Q, Bit ClkG, Bit AClr
    , Bit Done, Bit Busy) RegOnGo( Variant D, Bit ClkG
    , Bit AClr, Bit Go, Bit Wait) ;  //_GUI 111,80

 //_ Behavior Topology
 Output.0 = VouchBit.0;  //_GUI 179,38
 Output:A.0 = VouchBit:A.0;  //_GUI 179,51
 Output:B.0 = VouchBit:B.0;  //_GUI 179,59
 Output:C.0 = Input:E.0;  
 Output:D.0 = Junction:A.1;  
 Output:E.0 = Junction.1;  
 Output:F.0 = RegOnGo.3;  
 Output:G.0 = RegOnGo.4;  //_GUI 104,107, 104,94
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:A.0;  
 UnPackBIN.0 = RegOnGo.0;  //_GUI 129,51, 129,82
 PackBIN.0 = AND-NInput.0;  //_GUI 83,49, 83,44
 PackBIN.1 = OR-NInput.0;  
 PackBIN.2 = XOR-NInput.0;  //_GUI 83,55, 83,60
 Junction:B.0 = Input.0;  //_GUI 49,18
 Junction:C.0 = Junction:B.2;  
 AND-NInput.0 = Junction:B.1;  
 OR-NInput.0 = Junction:C.1;  
 XOR-NInput.0 = Junction:C.2;  //_GUI 49,60
 VouchBit.0 = UnPackBIN.0;  //_GUI 158,40, 158,50
 VouchBit:A.0 = UnPackBIN.1;  
 VouchBit:B.0 = UnPackBIN.2;  //_GUI 159,61, 159,56
 RegOnGo.0 = PackBIN.0;  
 RegOnGo.1 = Junction:A.2;  //_GUI 106,85
 RegOnGo.2 = Junction.2;  //_GUI 102,88
 RegOnGo.3 = Input:C.0;  
 RegOnGo.4 = Input:D.0;  //_GUI 161,94, 161,103
}

Object ( List AND, List OR, List XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $Gate-NInput_Pipe( List Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\$Internal",Documentation="lsb list"
{
 // register each carry and the list
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Val) Input;  //_GUI 11,17
 Object ( Bit ClkG) Input:A;  //_GUI 52,83
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 52,86
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 52,89
 Object ( Bit Wait) Input:D;  //_GUI 111,91
 Object Output( List AND) ;  //_GUI 202,17
 Object Output:A( List OR) ;  //_GUI 203,27
 Object Output:B( List XOR) ;  //_GUI 204,37
 Object Output:C( Variant PipeLen) ;  //_GUI 140,54
 Object Output:D( Bit ClkG) ;  //_GUI 148,57
 Object Output:E( Bit AClr) ;  //_GUI 147,60
 Object Output:F( Bit Done) ;  //_GUI 150,63
 Object Output:G( Bit Busy) ;  //_GUI 108,109
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 24,15
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 81,48
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 84,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 88,63
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 164,15
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 170,25
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 176,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 130,66
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 107,44
 //_ Attributes Documentation="leaf"
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $Gate-NInput_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 107,15
 //_ Attributes Documentation="leaf"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = ListOut:B.0;  
 Output:C.0 = $Gate-NInput_Pipe.3;  
 Output:D.0 = $Gate-NInput_Pipe.4;  
 Output:E.0 = $Gate-NInput_Pipe.5;  
 Output:F.0 = $Gate-NInput_Pipe.6;  
 Output:G.0 = $Gate-NInput_Pipe.7;  //_GUI 100,110, 100,67
 ListIn.0 = Input.0;  
 Junction.0 = Input:A.0;  //_GUI 82,84
 Junction:A.0 = Input:B.0;  //_GUI 85,87
 Junction:B.0 = Input:C.0;  //_GUI 89,90
 ListOut.0 = $Gate-NInput_Pipe.0;  //_GUI 164,46
 ListOut.1 = $Gate-NInput_Pipe:A.0;  
 ListOut:A.0 = $Gate-NInput_Pipe.1;  //_GUI 150,30, 150,49
 ListOut:A.1 = $Gate-NInput_Pipe:A.1;  //_GUI 150,27, 150,20
 ListOut:B.0 = $Gate-NInput_Pipe.2;  //_GUI 144,40, 144,52
 ListOut:B.1 = $Gate-NInput_Pipe:A.2;  //_GUI 144,37, 144,23
 Junction:C.0 = Input:D.0;  //_GUI 131,92
 $Gate-NInput_Pipe.0 = ListIn.0;  //_GUI 44,46, 44,20
 $Gate-NInput_Pipe.1 = Junction.2;  
 $Gate-NInput_Pipe.2 = Junction:A.2;  
 $Gate-NInput_Pipe.3 = Junction:B.2;  
 $Gate-NInput_Pipe.4 = Junction:C.0;  
 $Gate-NInput_Pipe:A.0 = ListIn.1;  
 $Gate-NInput_Pipe:A.1 = Junction.1;  //_GUI 82,20
 $Gate-NInput_Pipe:A.2 = Junction:A.1;  //_GUI 85,23
 $Gate-NInput_Pipe:A.3 = Junction:B.1;  //_GUI 89,35
 $Gate-NInput_Pipe:A.4 = Junction:C.1;  //_GUI 131,38
}

Object ( Variant Remnant, Variant Out1, Variant LSB) ListPopLsb
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="var"
{
 // Documentation for ListPopLSB (1,n)
 // (One input, n outputs)
 //
 // This set of objects removes and returns the least significant n-1 elements from a list and the remnant of the list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: This is the remnant of the list after the least significant n-1 elements have been removed.  If more than n elements are in the list that is passed in, a list is passed out of the Remnant output.  If an n-element list was passed in, the most significant element (a single-element list) will be passed out.  If a less-than-n-element list was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 // . . .
 // Variant output: One output for each of elements 2 through n-1.  If there are less list elements than this output number, than a NULL will be output.
 // . . .
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant Remnant) ;  //_GUI 48,15
 Object Output:A( Variant Out1) ;  //_GUI 48,18
 Object Output:B( Variant LSB) ;  //_GUI 48,21
 Object ( Variant Out1, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 34,14
 //_ Attributes Documentation="list"
 Object ( Variant Out1, Variant LSB) ListPopLsb:A( Variant In1) ;  //_GUI 21,17
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListPopLsb.0;  
 Output:A.0 = ListPopLsb.1;  
 Output:B.0 = ListPopLsb:A.1;  
 ListPopLsb.0 = ListPopLsb:A.0;  //_GUI 34,19
 ListPopLsb:A.0 = Input.0;  
}

Object ( NULL Remnant, NULL Out1, NULL LSB) ListPopLsb
    ( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="null"
{
 // Documentation for ListPopLSB (1,n)
 // (One input, n outputs)
 //
 // This set of objects removes and returns the least significant n-1 elements from a list and the remnant of the list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: This is the remnant of the list after the least significant n-1 elements have been removed.  If more than n elements are in the list that is passed in, a list is passed out of the Remnant output.  If an n-element list was passed in, the most significant element (a single-element list) will be passed out.  If a less-than-n-element list was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 // . . .
 // Variant output: One output for each of elements 2 through n-1.  If there are less list elements than this output number, than a NULL will be output.
 // . . .
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,19
 Object Output( NULL Remnant) ;  //_GUI 39,19
 Object Output:A( NULL Out1) ;  //_GUI 39,23
 Object Output:B( NULL LSB) ;  //_GUI 39,27
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 22,19
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction:A
    ( NULL In1) ;  //_GUI 22,23

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction:A.1;  
 Output:B.0 = Junction:A.2;  //_GUI 23,28
 Junction.0 = Input.0;  
 Junction:A.0 = Junction.2;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6
    , Variant In7) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 32,22
 Object ( Variant In2) Input:A;  //_GUI 32,25
 Object ( Variant In3) Input:B;  //_GUI 32,28
 Object ( Variant In4) Input:C;  //_GUI 32,31
 Object ( Variant In5) Input:D;  //_GUI 32,34
 Object ( Variant In6) Input:E;  //_GUI 32,37
 Object ( Variant In7) Input:F;  //_GUI 32,42
 Object Output( List Out1) ;  //_GUI 69,40
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6) ;  //_GUI 37,21
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 55,38

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
 PackLSB.3 = Input:C.0;  
 PackLSB.4 = Input:D.0;  
 PackLSB.5 = Input:E.0;  
 ListOut.0 = Input:F.0;  
 ListOut.1 = PackLSB.0;  //_GUI 51,40, 51,24
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) UnPackLSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,26
 Object Output( Variant Out1) ;  //_GUI 68,24
 Object Output:A( Variant Out2) ;  //_GUI 68,27
 Object Output:B( Variant Out3) ;  //_GUI 68,30
 Object Output:C( Variant Out4) ;  //_GUI 68,33
 Object Output:D( Variant Out5) ;  //_GUI 68,36
 Object Output:E( Variant Out6) ;  //_GUI 68,39
 Object Output:F( Variant Out7) ;  //_GUI 68,43
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 32,24
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6) UnPackLSB:A( Variant In1) ;  //_GUI 53,23

 //_ Behavior Topology
 Output.0 = UnPackLSB:A.0;  
 Output:A.0 = UnPackLSB:A.1;  
 Output:B.0 = UnPackLSB:A.2;  
 Output:C.0 = UnPackLSB:A.3;  
 Output:D.0 = UnPackLSB:A.4;  
 Output:E.0 = UnPackLSB:A.5;  
 Output:F.0 = UnPackLSB.1;  //_GUI 50,44, 50,29
 UnPackLSB.0 = Input.0;  
 UnPackLSB:A.0 = UnPackLSB.0;  
}

Object ( Variant RndUp, Variant RndDn, Bit Rounded) Log2_Bits
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Performs a log base two of the dataset size of the input.  The result is given as the size of the output datasets.
 //
 // A single bit input returns a NULL dataset (zero bits).
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant RndUp: The bit size result of Log base two of the bit size of input rounded up.
 //
 // Variant RndDn: The bit size result of Log base two of the bit size of input rounded down.
 //
 // Bit Rounded: Value of 1 if the result was not an even integer and was rounded.
 //
 // Example:
 //
 // Input	RndUp	RndDn	Rounded
 // Bit (1)	NULL (0)	NULL (0)	0
 // MSB002	Bit (1)	Bit (1)	0
 // MSB003	MSB002	Bit(1)	1
 // MSB004	MSB002	MSB002	0
 // MSB005	MSB003	MSB002	1
 // MSB064	MSB006	MSB006	0
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 8,29
 Object Output( Variant RndUp) ;  //_GUI 99,15
 Object Output:A( Variant RndDn) ;  //_GUI 99,31
 Object Output:B( Bit Rounded) ;  //_GUI 99,40
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 64,38
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 65,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 61,31
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 46,27
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 17,27
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 86,38
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 86,13
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 80,40
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 45,12
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 42,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 77,31
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 30,27

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = Junction:C.1;  
 Output:B.0 = INVERT.0;  
 EqualZero.0 = Junction.2;  //_GUI 62,41
 Zero.0 = Junction.1;  
 Junction.0 = ExposeMSB.1;  
 ExposeMSB.0 = Junction:B.1;  
 BitLength.0 = Input.0;  
 INVERT.0 = Junction:A.1;  
 $Select.0 = Zero:A.0;  
 $Select.1 = Junction:C.0;  //_GUI 78,18
 $Select.2 = Junction:A.0;  //_GUI 81,21
 Junction:A.0 = EqualZero.0;  
 Zero:A.0 = Junction:B.0;  //_GUI 43,15
 Junction:B.0 = MSB.0;  
 Junction:C.0 = Zero.0;  
 MSB.0 = BitLength.0;  
}

Object ( NULL RndUp, NULL RndDn, Bit Rounded) Log2_Bits
    ( Bit Type) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 20,29
 Object Output( NULL RndUp) ;  //_GUI 40,13
 Object Output:A( NULL RndDn) ;  //_GUI 40,21
 Object Output:B( Bit Rounded) ;  //_GUI 40,29
 Object ( Bit In) Input:A;  //_GUI 34,29
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( NULL Out1) NULL;  //_GUI 28,19
 Object ( NULL Out1) NULL:A;  //_GUI 28,11

 //_ Behavior Topology
 Output.0 = NULL:A.0;  
 Output:A.0 = NULL.0;  
 Output:B.0 = Input:A.0;  
}

Object ( Variant N) BitA_Mod_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // This object produces  data set whose bitlength equals bitlength A %(modulus) bitlength B.  The numeric value of the output will be 0.
 //
 // Inputs:
 // A - bitlength is significant parameter
 // B - bitlength is significant parameter
 //
 // Outputs:
 // N - bitlength of N = bitlength of A % bitlength of B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,18
 Object ( Variant B) Input:A;  //_GUI 24,21
 Object Output( Variant N) ;  //_GUI 65,19
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 32,16
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 32,19
 Object ( Variant N) $BitA_Mod_BitB( Variant A, Variant B) ;  //_GUI 46,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Mod_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Mod_BitB.0 = MSB.0;  
 $BitA_Mod_BitB.1 = MSB:A.0;  
}

Object ( Variant N) BitA_Mod_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,19
 Object ( NULL B) Input:A;  //_GUI 24,22
 Object Output( Variant N) ;  //_GUI 64,20
 Object Text;  //_GUI 27,30,Let the $ version take care of the error.
 Object ( Variant N) $BitA_Mod_BitB( Variant A, Variant B) ;  //_GUI 44,18
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Mod_BitB.0;  
 $BitA_Mod_BitB.0 = Input.0;  
 $BitA_Mod_BitB.1 = Input:A.0;  
}

Object ( Variant N) BitA_Mod_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,18
 Object ( NULL B) Input:A;  //_GUI 24,21
 Object Output( Variant N) ;  //_GUI 64,19
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 32,16
 Object Text;  //_GUI 14,33,input A could be a contextual dataset derived from NULL.  In this case the MSB will strip it down to a NULL and pass it on to the $ version.
 Object ( Variant N) $BitA_Mod_BitB( Variant A, Variant B) ;  //_GUI 45,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Mod_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Mod_BitB.0 = MSB.0;  
 $BitA_Mod_BitB.1 = Input:A.0;  
}

Object ( Variant N) BitA_Mod_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,18
 Object ( Variant B) Input:A;  //_GUI 24,21
 Object Output( Variant N) ;  //_GUI 64,19
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 32,19
 Object Text;  //_GUI 14,33,input B could be a contextual dataset derived from NULL.  In this case the MSB will strip it down to a NULL and pass it on to the $ version.
 Object ( Variant N) $BitA_Mod_BitB( Variant A, Variant B) ;  //_GUI 45,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Mod_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Mod_BitB.0 = Input.0;  
 $BitA_Mod_BitB.1 = MSB.0;  
}

Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputPass_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined"
{
 // Gate-NInputListPass_Pipe has the same behavior as Gate-NInputList_Pipe except that gates with smaller numbers of inputs are fully asynchronous.  Once a frequency dependent threshold is reached, registers are added to make the object synchronous.
 // When the number of inputs is so large that a synchronous gate tree is built, the last stage is asynchronous and is smaller than the described threshold.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 29,16
 Object ( Bit ClkG) Input:A;  //_GUI 69,94
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 69,97
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 69,109
 Object ( Bit Wait) Input:D;  //_GUI 317,111
 //_ Attributes Constant="0"
 Object Output( Bit AND) ;  //_GUI 332,17
 Object Output:A( Bit OR) ;  //_GUI 332,46
 Object Output:B( Bit XOR) ;  //_GUI 332,58
 Object Output:C( Variant PipeLen) ;  //_GUI 332,70
 Object Output:D( Bit ClkG) ;  //_GUI 332,79
 Object Output:E( Bit AClr) ;  //_GUI 332,82
 Object Output:F( Bit Done) ;  //_GUI 332,87
 Object Output:G( Bit Busy) ;  //_GUI 103,123
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 45,14
 Object ( Variant BitsPerStageSG) Input:E;  //_GUI 23,34
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 37,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,34
 Object Text;  //_GUI 35,40,We think the pipelined portion of the object is at least twice as fast as the standard adder.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 151,94
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 154,97
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 285,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 240,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 240,71
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 242,48
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 242,74
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 276,63
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In3) ;  //_GUI 276,89
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 245,86
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 245,60
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) $Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 166,27
 //_ Attributes Documentation="leaf"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 224,14
 Object ( Variant Out1) MSB:B( Variant In1) ;  //_GUI 225,40
 Object ( Variant Out1) MSB:C( Variant In1) ;  //_GUI 225,66
 Object ( Variant Data) $NMin_Bit_LSB_List( Variant Hi, Variant Lo
    , Variant N) ;  //_GUI 127,24
 //_ Attributes Documentation="Variant"
 Object ( NULL Out1) NULL;  //_GUI 117,17
 Object ( Bit Out1) BitA_Le_BitB( Variant A, Variant B) ;  //_GUI 65,48
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In1) ;  //_GUI 61,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In1) ;  //_GUI 31,37
 Object Text;  //_GUI 171,152,If the input is small enough, just use the gates without pipelining.
 Object ( Bit Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 320,15
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 320,44
 Object ( Bit Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 320,56
 Object ( Bit Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 320,85
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 320,68
 Object ( Bit Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 90,121
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 91,27
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 81,50
 Object ( Variant Out1) AND-NInput( Variant In1) ;  //_GUI 168,127
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 168,135
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) XOR-NInput( Variant In1) ;  //_GUI 168,143
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In1) ;  //_GUI 107,129
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In1) ;  //_GUI 107,137
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 183,127
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 183,135
 Object ( Bit Out1) VouchBit:B( Variant In1) ;  //_GUI 183,143
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In0) ;  //_GUI 240,94
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Q
    ( Bit In0) ;  //_GUI 242,97
 Object ( NULL Out1) NULL:A;  //_GUI 289,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In1) ;  //_GUI 81,102
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In3) ;  //_GUI 316,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:T
    ( Bit In3) ;  //_GUI 316,63
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:U
    ( Bit In3) ;  //_GUI 316,75
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:V
    ( Bit In3) ;  //_GUI 316,92
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant In1
    , Bit S) ;  //_GUI 322,110
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In0) ;  //_GUI 316,102
 Object ( Bit Out1) VouchBit:C( Variant In1) ;  //_GUI 336,109
 Object ( Bit Out1) VouchBit:D( Variant In1) ;  //_GUI 336,112
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputPass_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 252,15
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputPass_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 252,41
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputPass_Pipe:B( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 252,67
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:X
    ( Bit In0) ;  //_GUI 147,109
 Object Text;  //_GUI 51,57,If the input is <= BitsPerStage (1/2 the size of a pipelined gate stage) then just do the gates without pipelining.

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Output:B.0 = $Select:B.0;  
 Output:C.0 = $Select:D.0;  
 Output:D.0 = Junction:P.1;  //_GUI 309,80, 309,95
 Output:E.0 = Junction:Q.1;  //_GUI 311,83, 311,98
 Output:F.0 = $Select:C.0;  
 Output:G.0 = $Select:E.0;  
 MSB.0 = Input.0;  
 PushLsb.0 = Junction.1;  
 PushLsb.1 = Junction:L.1;  
 Junction.0 = Input:E.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = Input:B.0;  
 CollectLSB.0 = $Gate-NInput_Pipe.3;  //_GUI 283,69, 283,101, 194,101, 194,38
 CollectLSB.1 = Gate-NInputPass_Pipe:B.3;  //_GUI 285,78
 Junction:C.0 = Junction:D.1;  
 Junction:D.0 = Junction:P.0;  
 Junction:E.0 = Junction:F.1;  
 Junction:F.0 = Junction:Q.0;  
 Junction:G.0 = Junction:H.1;  
 Junction:H.0 = VouchBit:C.0;  //_GUI 277,107, 348,107, 348,112
 Junction:I.0 = $Gate-NInput_Pipe.6;  //_GUI 205,87, 205,47
 Junction:J.0 = Junction:I.0;  
 $Gate-NInput_Pipe.0 = $NMin_Bit_LSB_List.0;  //_GUI 147,29
 $Gate-NInput_Pipe.1 = Junction:A.0;  //_GUI 152,32
 $Gate-NInput_Pipe.2 = Junction:B.0;  //_GUI 155,35
 $Gate-NInput_Pipe.3 = Junction:X.0;  //_GUI 148,47
 $Gate-NInput_Pipe.4 = Gate-NInputPass_Pipe:B.7;  //_GUI 200,50, 200,90
 MSB:A.0 = $Gate-NInput_Pipe.0;  //_GUI 213,17, 213,29
 MSB:B.0 = $Gate-NInput_Pipe.1;  //_GUI 220,43, 220,32
 MSB:C.0 = $Gate-NInput_Pipe.2;  //_GUI 213,69, 213,35
 $NMin_Bit_LSB_List.0 = NULL.0;  
 $NMin_Bit_LSB_List.1 = $SelectOut.0;  
 $NMin_Bit_LSB_List.2 = PushLsb.0;  //_GUI 112,32, 112,36
 BitA_Le_BitB.0 = Junction:K.2;  //_GUI 62,50
 BitA_Le_BitB.1 = Junction:L.2;  //_GUI 32,53
 Junction:K.0 = MSB.0;  //_GUI 62,17
 Junction:L.0 = Junction.2;  
 $Select.0 = Gate-NInputPass_Pipe.0;  
 $Select.1 = VouchBit.0;  //_GUI 303,20, 303,130
 $Select.2 = Junction:S.1;  //_GUI 317,23
 $Select:A.0 = Gate-NInputPass_Pipe:A.1;  
 $Select:A.1 = VouchBit:A.0;  //_GUI 305,49, 305,138
 $Select:A.2 = Junction:S.2;  
 $Select:B.0 = Gate-NInputPass_Pipe:B.2;  //_GUI 280,58, 280,75
 $Select:B.1 = VouchBit:B.0;  //_GUI 307,61, 307,146
 $Select:B.2 = Junction:T.2;  
 $Select:C.0 = Gate-NInputPass_Pipe:B.6;  
 $Select:C.1 = Junction:X.1;  //_GUI 313,90, 313,110
 $Select:C.2 = Junction:V.2;  
 $Select:D.0 = CollectLSB.0;  
 $Select:D.1 = NULL:A.0;  //_GUI 299,73
 $Select:D.2 = Junction:U.2;  
 $Select:E.0 = $Gate-NInput_Pipe.7;  //_GUI 86,123, 86,114, 159,114, 159,50
 $Select:E.1 = VouchBit:D.0;  //_GUI 90,119, 348,119, 348,115
 $Select:E.2 = Junction:R.2;  //_GUI 82,129
 $SelectOut.0 = Junction:K.1;  
 $SelectOut.1 = Junction:M.0;  //_GUI 82,32
 Junction:M.0 = BitA_Le_BitB.0;  
 AND-NInput.0 = Junction:N.1;  
 OR-NInput.0 = Junction:O.1;  
 XOR-NInput.0 = Junction:O.2;  //_GUI 108,146
 Junction:N.0 = $SelectOut.1;  //_GUI 108,32
 Junction:O.0 = Junction:N.2;  
 VouchBit.0 = AND-NInput.0;  
 VouchBit:A.0 = OR-NInput.0;  
 VouchBit:B.0 = XOR-NInput.0;  
 Junction:P.0 = Junction:A.1;  
 Junction:Q.0 = Junction:B.1;  
 Junction:R.0 = Junction:M.2;  
 Junction:S.0 = Junction:T.1;  
 Junction:T.0 = Junction:U.1;  
 Junction:U.0 = Junction:V.1;  
 Junction:V.0 = Junction:W.0;  
 $SelectOut:A.0 = Input:D.0;  
 $SelectOut:A.1 = Junction:W.2;  //_GUI 317,115
 Junction:W.0 = Junction:R.1;  
 VouchBit:C.0 = $SelectOut:A.0;  
 VouchBit:D.0 = $SelectOut:A.1;  
 Gate-NInputPass_Pipe.0 = MSB:A.0;  
 Gate-NInputPass_Pipe.1 = Junction:C.1;  //_GUI 241,20
 Gate-NInputPass_Pipe.2 = Junction:E.1;  //_GUI 243,23
 Gate-NInputPass_Pipe.3 = Junction:J.1;  //_GUI 246,35
 Gate-NInputPass_Pipe.4 = Junction:G.1;  //_GUI 277,38
 Gate-NInputPass_Pipe:A.0 = MSB:B.0;  
 Gate-NInputPass_Pipe:A.1 = Junction:C.2;  
 Gate-NInputPass_Pipe:A.2 = Junction:E.2;  
 Gate-NInputPass_Pipe:A.3 = Junction:J.2;  
 Gate-NInputPass_Pipe:A.4 = Junction:G.0;  
 Gate-NInputPass_Pipe:B.0 = MSB:C.0;  
 Gate-NInputPass_Pipe:B.1 = Junction:D.2;  
 Gate-NInputPass_Pipe:B.2 = Junction:F.2;  
 Gate-NInputPass_Pipe:B.3 = Junction:I.1;  
 Gate-NInputPass_Pipe:B.4 = Junction:H.0;  
 Junction:X.0 = Input:C.0;  
}

Object ( Variant N) BitA_Add_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // This object produces  data set whose bitlength equals bitlength A + bitlength B.  The numeric value of the output will be 0.
 //
 // Inputs:
 // A - bitlength is significant parameter
 // B - bitlength is significant parameter
 //
 // Outputs:
 // N - bitlength of N (LSB order) = bitlength of A + bitlength of B
 //
 // Date:
 // 11 Oct 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 27,36
 Object ( Variant B) Input:A;  //_GUI 27,39
 Object Output( Variant N) ;  //_GUI 72,37
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A + BitLength B.Arial,8,0,1
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 46,34
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 46,37
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 58,35
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 34,34
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 34,37

 //_ Behavior Topology
 Output.0 = CollectLSB.0;  
 Zero.0 = LSB.0;  
 Zero:A.0 = LSB:A.0;  
 CollectLSB.0 = Zero.0;  
 CollectLSB.1 = Zero:A.0;  
 LSB.0 = Input.0;  
 LSB:A.0 = Input:A.0;  
}

Object ( Variant N) BitA_Add_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 27,36
 Object ( Variant B) Input:A;  //_GUI 27,39
 Object Output( Variant N) ;  //_GUI 60,39
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A + BitLength B.Arial,8,0,1
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 46,37
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 34,37

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = LSB.0;  
 LSB.0 = Input:A.0;  
}

Object ( Variant N) BitA_Add_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 27,36
 Object ( NULL B) Input:A;  //_GUI 27,39
 Object Output( Variant N) ;  //_GUI 60,36
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A + BitLength B.Arial,8,0,1
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 46,34
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 34,34

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = LSB.0;  
 LSB.0 = Input.0;  
}

Object ( NULL N) BitA_Add_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 27,36
 Object ( NULL B) Input:A;  //_GUI 27,39
 Object Output( NULL N) ;  //_GUI 37,36
 Object Text;  //_GUI 28,16,This object produces a data set whose BitLength equals BitLength A + BitLength B.Arial,8,0,1

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant RndUp, Variant RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 // This object produces  data set whose bitlength equals bitlength A/ bitlength B.  If A is not evenly divisible by B, the remainder will show up as one bit of padding and a warning message will be issued.  The numeric value of the output will be 0.
 //
 // Inputs:
 // A - bitlength is significant parameter
 // B - bitlength is significant parameter
 //
 // Outputs:
 // N - bitlength of N = bitlength of A / bitlength of B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,18
 Object ( Variant B) Input:A;  //_GUI 26,34
 Object Output( Variant RndUp) ;  //_GUI 118,42
 Object Output:A( Variant RndDn) ;  //_GUI 118,50
 Object Output:B( Bit E) ;  //_GUI 90,57
 Object ( Bit Constant) Input:B;  //_GUI 83,57
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), %, 0, =, !)"
 Object ( MSB032 Constant) Input:C;  //_GUI 84,42
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), /, F)"
 Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) ;  //_GUI 98,40
 Object ( Variant N_Bits) "Constant->N_Bits":A( Variant Constant) ;  //_GUI 98,48
 Object ( MSB032 Constant) Input:D;  //_GUI 84,50
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), /, f)"

 //_ Behavior Topology
 Output.0 = "Constant->N_Bits".0;  
 Output:A.0 = "Constant->N_Bits":A.0;  
 Output:B.0 = Input:B.0;  
 "Constant->N_Bits".0 = Input:C.0;  
 "Constant->N_Bits":A.0 = Input:D.0;  
}

Object ( NULL RndUp, NULL RndDn, Bit E) $BitA_Div_BitB
    ( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,19
 Object ( Variant B) Input:A;  //_GUI 24,27
 Object Output( NULL RndUp) ;  //_GUI 64,15
 Object Output:A( NULL RndDn) ;  //_GUI 64,19
 Object Output:B( Bit E) ;  //_GUI 64,26
 Object ( Bit In) Input:B;  //_GUI 58,26
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 26,36,0 divided by anything is 0
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 57,19

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 58,16
 Output:A.0 = Junction.1;  
 Output:B.0 = Input:B.0;  
 Junction.0 = Input.0;  
}

Object ( NULL RndUp, NULL RndDn, Bit E) $BitA_Div_BitB
    ( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,19
 Object ( NULL B) Input:A;  //_GUI 24,27
 Object Output( NULL RndUp) ;  //_GUI 64,14
 Object Output:A( NULL RndDn) ;  //_GUI 64,19
 Object Output:B( Bit E) ;  //_GUI 66,28
 Object Text;  //_GUI 26,36,0 divided by anything is 0
 Object ( Bit Constant) Input:B;  //_GUI 59,28
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 58,19

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 59,15
 Output:A.0 = Junction.1;  
 Output:B.0 = Input:B.0;  
 Junction.0 = Input.0;  
}

Object ( NULL RndUp, NULL RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,18
 Object ( NULL B) Input:A;  //_GUI 26,34
 Object Output( NULL RndUp) ;  //_GUI 60,29
 Object Output:A( NULL RndDn) ;  //_GUI 60,34
 Object Output:B( Bit E) ;  //_GUI 58,43
 Object ( Bit Constant) Input:B;  //_GUI 52,43
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 54,34

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 55,30
 Output:A.0 = Junction.1;  
 Output:B.0 = Input:B.0;  
 Junction.0 = Input:A.0;  
}

Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputList_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced"
{
 // Gate-NInputList_Pipe calls Gate_NInput_Pipe on each list element producing an equivelently shaped list of bit elements.
 //
 // Where as Gate-NInput_Pipe combines all bits (lists and everything) into a single bit.
 //
 // Where as Gate-List_Pipe combines all list elements into a single element that is the size of one of the input list's elements.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 37,23
 Object ( Bit ClkG) Input:A;  //_GUI 37,26
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 37,29
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 37,41
 Object ( Bit Wait) Input:D;  //_GUI 56,53
 //_ Attributes Constant="0"
 Object Output( Bit AND) ;  //_GUI 63,23
 Object Output:A( Bit OR) ;  //_GUI 63,26
 Object Output:B( Bit XOR) ;  //_GUI 63,29
 Object Output:C( Variant PipeLen) ;  //_GUI 63,32
 Object Output:D( Bit ClkG) ;  //_GUI 63,35
 Object Output:E( Bit AClr) ;  //_GUI 63,38
 Object Output:F( Bit Done) ;  //_GUI 63,41
 Object Output:G( Bit Busy) ;  //_GUI 43,50
 Object ( Bit AND, Bit OR, Bit XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInput_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 43,22

 //_ Behavior Topology
 Output.0 = Gate-NInput_Pipe.0;  
 Output:A.0 = Gate-NInput_Pipe.1;  
 Output:B.0 = Gate-NInput_Pipe.2;  
 Output:C.0 = Gate-NInput_Pipe.3;  
 Output:D.0 = Gate-NInput_Pipe.4;  
 Output:E.0 = Gate-NInput_Pipe.5;  
 Output:F.0 = Gate-NInput_Pipe.6;  
 Output:G.0 = Gate-NInput_Pipe.7;  
 Gate-NInput_Pipe.0 = Input.0;  
 Gate-NInput_Pipe.1 = Input:A.0;  
 Gate-NInput_Pipe.2 = Input:B.0;  
 Gate-NInput_Pipe.3 = Input:C.0;  
 Gate-NInput_Pipe.4 = Input:D.0;  
}

Object ( List AND, List OR, List XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputList_Pipe( List Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\ArithmeticOps\\$Internal\\Pipelined\\Advanced",Documentation="list"
{
 // Gate-NInputList_Pipe calls Gate_NInput_Pipe on each list element producing an equivelently shaped list of bit elements.
 //
 // Where as Gate-NInput_Pipe combines all bits (lists and everything) into a single bit.
 //
 // Where as Gate-List_Pipe combines all list elements into a single element that is the size of one of the input list's elements.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Val) Input;  //_GUI 7,35
 Object ( Bit ClkG) Input:A;  //_GUI 7,40
 //_ Attributes Resource="Global"
 Object ( Bit AClr) Input:B;  //_GUI 7,43
 //_ Attributes Constant="0"
 Object ( Bit Go) Input:C;  //_GUI 7,55
 Object ( Bit Wait) Input:D;  //_GUI 163,74
 //_ Attributes Constant="0"
 Object Output( List AND) ;  //_GUI 164,27
 Object Output:A( List OR) ;  //_GUI 164,35
 Object Output:B( List XOR) ;  //_GUI 164,43
 Object Output:C( Variant PipeLen) ;  //_GUI 164,49
 Object Output:D( Bit ClkG) ;  //_GUI 164,52
 Object Output:E( Bit AClr) ;  //_GUI 164,55
 Object Output:F( Bit Done) ;  //_GUI 164,67
 Object Output:G( Bit Busy) ;  //_GUI 8,72
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 13,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 37,55
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 34,43
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 31,40
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 148,25
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 148,33
 Object ( List Out) ListOut:B( Variant In1, Variant In2) ;  //_GUI 148,41
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 64,36
 Object ( List Out1) PackLSB:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 64,9
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB
    ( Variant In1) ;  //_GUI 119,38
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB:A
    ( Variant In1) ;  //_GUI 119,25
 Object Text;  //_GUI 85,78,We synchronize the Dones and the data just in case the list is hetrogeneous.  If the list is homogeneous, this object becomes a pass-through.
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputList_Pipe( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 42,9
 Object ( Variant AND, Variant OR, Variant XOR
    , Variant PipeLen, Bit ClkG, Bit AClr, Bit Done
    , Bit Busy) Gate-NInputList_Pipe:A( Variant Val, Bit ClkG, Bit AClr
    , Bit Go, Bit Wait) ;  //_GUI 42,36
 Object ( Variant A, Variant B, Variant PipeLenA
    , Variant PipeLenB, Variant FullPipeLen, Bit ClkG, Bit AClr
    , Bit BusyA, Bit BusyB, Bit Done) SyncRegPair_Pipe( Variant A
    , Variant B, Variant PipeLenA, Variant PipeLenB, Bit ClkG
    , Bit AClr, Bit GoA, Bit GoB, Bit Wait) ;  //_GUI 90,36

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 Output:B.0 = ListOut:B.0;  
 Output:C.0 = SyncRegPair_Pipe.4;  
 Output:D.0 = SyncRegPair_Pipe.5;  
 Output:E.0 = SyncRegPair_Pipe.6;  
 Output:F.0 = SyncRegPair_Pipe.9;  
 Output:G.0 = Gate-NInputList_Pipe:A.7;  //_GUI 8,59
 ListIn.0 = Input.0;  
 Junction.0 = Input:C.0;  
 Junction:A.0 = Input:B.0;  
 Junction:B.0 = Input:A.0;  
 ListOut.0 = UnPackLSB.0;  //_GUI 144,30, 144,40
 ListOut.1 = UnPackLSB:A.0;  
 ListOut:A.0 = UnPackLSB.1;  //_GUI 135,38, 135,43
 ListOut:A.1 = UnPackLSB:A.1;  //_GUI 141,35, 141,30
 ListOut:B.0 = UnPackLSB.2;  
 ListOut:B.1 = UnPackLSB:A.2;  //_GUI 138,43, 138,33
 PackLSB.0 = Gate-NInputList_Pipe:A.0;  
 PackLSB.1 = Gate-NInputList_Pipe:A.1;  
 PackLSB.2 = Gate-NInputList_Pipe:A.2;  
 PackLSB:A.0 = Gate-NInputList_Pipe.0;  
 PackLSB:A.1 = Gate-NInputList_Pipe.1;  
 PackLSB:A.2 = Gate-NInputList_Pipe.2;  
 UnPackLSB.0 = SyncRegPair_Pipe.1;  
 UnPackLSB:A.0 = SyncRegPair_Pipe.0;  //_GUI 110,28
 Gate-NInputList_Pipe.0 = ListIn.1;  //_GUI 29,11, 29,35
 Gate-NInputList_Pipe.1 = Junction:B.0;  //_GUI 32,14
 Gate-NInputList_Pipe.2 = Junction:A.0;  //_GUI 35,17
 Gate-NInputList_Pipe.3 = Junction.0;  //_GUI 38,29
 Gate-NInputList_Pipe.4 = SyncRegPair_Pipe.7;  //_GUI 113,32, 113,59
 Gate-NInputList_Pipe:A.0 = ListIn.0;  
 Gate-NInputList_Pipe:A.1 = Junction:B.1;  
 Gate-NInputList_Pipe:A.2 = Junction:A.1;  
 Gate-NInputList_Pipe:A.3 = Junction.1;  
 Gate-NInputList_Pipe:A.4 = SyncRegPair_Pipe.8;  //_GUI 62,75, 113,75, 113,62
 SyncRegPair_Pipe.0 = PackLSB:A.0;  //_GUI 90,12
 SyncRegPair_Pipe.1 = PackLSB.0;  //_GUI 82,41, 82,39
 SyncRegPair_Pipe.2 = Gate-NInputList_Pipe.3;  //_GUI 87,44, 87,20
 SyncRegPair_Pipe.3 = Gate-NInputList_Pipe:A.3;  
 SyncRegPair_Pipe.4 = Gate-NInputList_Pipe:A.4;  
 SyncRegPair_Pipe.5 = Gate-NInputList_Pipe:A.5;  
 SyncRegPair_Pipe.6 = Gate-NInputList_Pipe.6;  //_GUI 84,56, 84,29
 SyncRegPair_Pipe.7 = Gate-NInputList_Pipe:A.6;  //_GUI 75,59, 75,56
 SyncRegPair_Pipe.8 = Input:D.0;  //_GUI 167,71
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29, Variant Out30) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object Output:Z( Variant Out27) ;  //_GUI 80,115
 Object Output:a( Variant Out28) ;  //_GUI 80,118
 Object Output:b( Variant Out29) ;  //_GUI 80,121
 Object Output:c( Variant Out30) ;  //_GUI 80,124
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 Output:Z.0 = ExposeMSB.25;  
 Output:a.0 = ExposeMSB.26;  
 Output:b.0 = ExposeMSB.27;  
 Output:c.0 = ExposeMSB.28;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant DataLeft, List DataOut) $N_Bit_List( Variant Data
    , Variant N, Variant Pattern) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 // This object splits up the bits of the variant input into a BIN ordered list with each element having the dataset of N (implying the number of bits).
 //
 // Inputs:
 //
 // Variant Data: A set of bits of any dataset.
 //
 // Variant N: The dataset (implies the number of bits) for each element of the output list.
 //
 // Outputs:
 //
 // Variant Data: The Bin ordered list with the input Data bits divided into the list elements where each list element has the N dataset and is therefore the same number of bits as N.
 //
 // Variant Size: The number of elements in the output list Data.  This number is represented by the number of Bits of Size which is of dataset BINxxx.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 20,33
 Object ( Variant N) Input:A;  //_GUI 20,36
 Object ( Variant Pattern) Input:B;  //_GUI 20,40
 Object Output( Variant DataLeft) ;  //_GUI 102,33
 Object Output:A( List DataOut) ;  //_GUI 102,37
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 26,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,36
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 83,35
 Object ( Variant DataLeft, Variant DataOut) $N_Bit_List( Variant Data
    , Variant N, Variant Pattern) ;  //_GUI 49,32
 //_ Attributes Documentation="var"
 Object ( Variant DataLeft, Variant DataOut) $N_Bit_List:A( Variant Data
    , Variant N, Variant Pattern) ;  //_GUI 49,49
 //_ Attributes Documentation="var"

 //_ Behavior Topology
 Output.0 = $N_Bit_List.0;  
 Output:A.0 = ListOut.0;  
 VariantIn.0 = Input:B.0;  
 Junction.0 = Input:A.0;  
 ListOut.0 = $N_Bit_List:A.1;  //_GUI 74,40, 74,54
 ListOut.1 = $N_Bit_List.1;  
 $N_Bit_List.0 = $N_Bit_List:A.0;  //_GUI 49,28, 69,28, 69,51
 $N_Bit_List.1 = Junction.1;  
 $N_Bit_List.2 = VariantIn.1;  
 $N_Bit_List:A.0 = Input.0;  //_GUI 47,51, 47,34
 $N_Bit_List:A.1 = Junction.2;  //_GUI 44,54
 $N_Bit_List:A.2 = VariantIn.0;  //_GUI 41,57, 41,43
}

Object ( Variant DataLeft, Variant DataOut) $N_Bit_List( Variant Data
    , Variant N, Bit Pattern) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="bit"
{
 // This object splits up the bits of the variant input into a BIN ordered list with each element having the dataset of N (implying the number of bits).
 //
 // Inputs:
 //
 // Variant Data: A set of bits of any dataset.
 //
 // Variant N: The dataset (implies the number of bits) for each element of the output list.
 //
 // Outputs:
 //
 // Variant Data: The Bin ordered list with the input Data bits divided into the list elements where each list element has the N dataset and is therefore the same number of bits as N.
 //
 // Variant Size: The number of elements in the output list Data.  This number is represented by the number of Bits of Size which is of dataset BINxxx.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 20,34
 Object ( Variant N) Input:A;  //_GUI 20,37
 Object ( Bit Pattern) Input:B;  //_GUI 20,41
 Object Output( Variant DataLeft) ;  //_GUI 59,34
 Object Output:A( Variant DataOut) ;  //_GUI 59,38
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 30,33
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 47,36
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,37

 //_ Behavior Topology
 Output.0 = Lo_N.0;  
 Output:A.0 = Context.0;  
 Lo_N.0 = Input.0;  
 Lo_N.1 = Junction.1;  
 Context.0 = Junction.2;  //_GUI 43,38, 43,43, 27,43
 Context.1 = Lo_N.1;  //_GUI 40,41
 Junction.0 = Input:A.0;  
}

Object ( Variant RndUp, Variant RndDn) BitADivBitB( Variant A
    , Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp",Documentation="Var/Var"
{
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 37,20
 Object ( Variant B) Input:A;  //_GUI 37,23
 Object Output( Variant RndUp) ;  //_GUI 77,20
 Object Output:A( Variant RndDn) ;  //_GUI 77,23
 Object ( Variant RndUp, Variant RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, Variant B) ;  //_GUI 59,19
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 45,18
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 45,21

 //_ Behavior Topology
 Output.0 = $BitA_Div_BitB.0;  
 Output:A.0 = $BitA_Div_BitB.1;  
 $BitA_Div_BitB.0 = MSB.0;  
 $BitA_Div_BitB.1 = MSB:A.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
}

Object ( Variant RndUp, Variant RndDn) BitADivBitB( Variant A
    , NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp",Documentation="Var/NULL"
{
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 37,20
 Object ( NULL B) Input:A;  //_GUI 37,23
 Object Output( Variant RndUp) ;  //_GUI 77,20
 Object Output:A( Variant RndDn) ;  //_GUI 77,23
 Object ( Variant RndUp, Variant RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, Variant B) ;  //_GUI 59,19
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 45,18

 //_ Behavior Topology
 Output.0 = $BitA_Div_BitB.0;  
 Output:A.0 = $BitA_Div_BitB.1;  
 $BitA_Div_BitB.0 = MSB.0;  
 $BitA_Div_BitB.1 = Input:A.0;  
 MSB.0 = Input.0;  
}

Object ( Variant RndUp, Variant RndDn) BitADivBitB( NULL A
    , Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp",Documentation="NULL/Var"
{
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 37,20
 Object ( Variant B) Input:A;  //_GUI 37,23
 Object Output( Variant RndUp) ;  //_GUI 77,20
 Object Output:A( Variant RndDn) ;  //_GUI 77,23
 Object ( Variant RndUp, Variant RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, Variant B) ;  //_GUI 59,19
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 45,21

 //_ Behavior Topology
 Output.0 = $BitA_Div_BitB.0;  
 Output:A.0 = $BitA_Div_BitB.1;  
 $BitA_Div_BitB.0 = Input.0;  
 $BitA_Div_BitB.1 = MSB.0;  
 MSB.0 = Input:A.0;  
}

Object ( Variant RndUp, Variant RndDn) BitADivBitB( NULL A
    , NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp",Documentation="NULL/NULL"
{
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 37,20
 Object ( NULL B) Input:A;  //_GUI 37,23
 Object Output( Variant RndUp) ;  //_GUI 77,20
 Object Output:A( Variant RndDn) ;  //_GUI 77,23
 Object ( Variant RndUp, Variant RndDn, Bit E) $BitA_Div_BitB
    ( Variant A, Variant B) ;  //_GUI 59,19
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Div_BitB.0;  
 Output:A.0 = $BitA_Div_BitB.1;  
 $BitA_Div_BitB.0 = Input.0;  
 $BitA_Div_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) XOR-NInput( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\Async\\Advanced"
{
 // All bits are XORed together to produce a single bit output.  This is the same function as an even-parity generator; if the number of 1's is even, output is 0, otherwise 1. It works with any combination of variants, lists or bits.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of XORing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 8,31
 Object Output( Bit Out1) ;  //_GUI 71,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,29
 Object ( Variant Out1) $XOR-NInput( Variant In1, Variant In2) ;  //_GUI 41,29
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 14,29
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 58,29

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 VariantIn.0 = BIN.0;  
 $XOR-NInput.0 = VariantIn.1;  
 $XOR-NInput.1 = VariantIn.0;  
 BIN.0 = Input.0;  
 VouchBit.0 = $XOR-NInput.0;  
}

Object ( Bit Out1) XOR-NInput( Bit In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="bit"
{
 // All bits are XORed together to produce a single bit output.  This is the same function as an even-parity generator; if the number of 1's is even, output is 0, otherwise 1. It works with any combination of variants, lists or bits.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of XORing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) XOR-NInput( NULL In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="NULL"
{
 // All bits are XORed together to produce a single bit output.  This is the same function as an even-parity generator; if the number of 1's is even, output is 0, otherwise 1. It works with any combination of variants, lists or bits.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of XORing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 10,31
 Object Output( NULL Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5, Variant In6) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 31,20
 Object ( Variant In2) Input:A;  //_GUI 31,23
 Object ( Variant In3) Input:B;  //_GUI 31,26
 Object ( Variant In4) Input:C;  //_GUI 31,29
 Object ( Variant In5) Input:D;  //_GUI 31,32
 Object ( Variant In6) Input:E;  //_GUI 31,37
 Object Output( List Out1) ;  //_GUI 67,35
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5) ;  //_GUI 37,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 53,33

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
 PackLSB.3 = Input:C.0;  
 PackLSB.4 = Input:D.0;  
 ListOut.0 = Input:E.0;  
 ListOut.1 = PackLSB.0;  //_GUI 50,35, 50,22
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6) UnPackLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,25
 Object Output( Variant Out1) ;  //_GUI 68,23
 Object Output:A( Variant Out2) ;  //_GUI 68,26
 Object Output:B( Variant Out3) ;  //_GUI 68,29
 Object Output:C( Variant Out4) ;  //_GUI 68,32
 Object Output:D( Variant Out5) ;  //_GUI 68,35
 Object Output:E( Variant Out6) ;  //_GUI 68,39
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 32,23
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5) UnPackLSB:A( Variant In1) ;  //_GUI 53,22

 //_ Behavior Topology
 Output.0 = UnPackLSB:A.0;  
 Output:A.0 = UnPackLSB:A.1;  
 Output:B.0 = UnPackLSB:A.2;  
 Output:C.0 = UnPackLSB:A.3;  
 Output:D.0 = UnPackLSB:A.4;  
 Output:E.0 = UnPackLSB.1;  //_GUI 50,40, 50,28
 UnPackLSB.0 = Input.0;  
 UnPackLSB:A.0 = UnPackLSB.0;  
}

Object ( Variant N) $BitA_Mod_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 // This object produces  data set whose bitlength equals bitlength A %(modulus) bitlength B.  The numeric value of the output will be 0.
 //
 // Inputs:
 // A - bitlength is significant parameter
 // B - bitlength is significant parameter
 //
 // Outputs:
 // N - bitlength of N = bitlength of A % bitlength of B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,18
 Object ( Variant B) Input:A;  //_GUI 26,34
 Object Output( Variant N) ;  //_GUI 118,42
 Object ( MSB032 Constant) Input:B;  //_GUI 84,42
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), %)"
 Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) ;  //_GUI 98,40

 //_ Behavior Topology
 Output.0 = "Constant->N_Bits".0;  
 "Constant->N_Bits".0 = Input:B.0;  
}

Object ( NULL N) $BitA_Mod_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,19
 Object ( Variant B) Input:A;  //_GUI 24,27
 Object Output( NULL N) ;  //_GUI 64,19
 Object Text;  //_GUI 26,36,0 divided by anything is 0 remainder 0

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL N) $BitA_Mod_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,19
 Object ( NULL B) Input:A;  //_GUI 24,27
 Object Output( NULL N) ;  //_GUI 64,19
 Object Text;  //_GUI 26,36,0 divided by anything is 0 remainder 0
 Object ( Bit Constant) Input:B;  //_GUI 59,28
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 65,28
 //_ Attributes Trap="BitA_Mod_BitB - B is NULL - Divide by zero error"

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:B.0;  
}

Object ( NULL N) $BitA_Mod_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,18
 Object ( NULL B) Input:A;  //_GUI 26,34
 Object Output( NULL N) ;  //_GUI 60,34
 Object ( Bit Constant) Input:B;  //_GUI 52,43
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 58,43
 //_ Attributes Trap="BitA_Mod_BitB - B is NULL - Divide by zero error"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Le_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is less than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Le_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Le_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Le_BitB.0 = MSB.0;  
 $BitA_Le_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Le_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is less than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 8,24,( 0 <= 0 )
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Le_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is less than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 17,12
 Object ( Bit Out1) $BitA_Le_BitB( Variant A, Variant B) ;  //_GUI 31,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 12,25,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Le_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Le_BitB.0 = MSB.0;  
 $BitA_Le_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Le_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is less than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 17,15
 Object ( Bit Out1) $BitA_Le_BitB( Variant A, Variant B) ;  //_GUI 31,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 12,25,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Le_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Le_BitB.0 = Input.0;  
 $BitA_Le_BitB.1 = MSB.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28, Variant Out29) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object Output:Z( Variant Out27) ;  //_GUI 80,115
 Object Output:a( Variant Out28) ;  //_GUI 80,118
 Object Output:b( Variant Out29) ;  //_GUI 80,121
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 Output:Z.0 = ExposeMSB.25;  
 Output:a.0 = ExposeMSB.26;  
 Output:b.0 = ExposeMSB.27;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1) $XOR-NInput( Variant In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="var/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,24
 Object ( Bit In2) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,22
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $XOR-NInput( Variant In1, Variant In2) ;  //_GUI 42,22
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 VariantIn.0 = Input.0;  
 XOR.0 = $XOR-NInput.0;  
 XOR.1 = Input:A.0;  //_GUI 59,32
 $XOR-NInput.0 = VariantIn.1;  
 $XOR-NInput.1 = VariantIn.0;  
}

Object ( Bit Out1) $XOR-NInput( Bit In1, Bit In2) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,24
 Object ( Bit In2) Input:A;  //_GUI 11,27
 Object Output( Bit Out1) ;  //_GUI 31,25
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 18,23
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 XOR.0 = Input.0;  
 XOR.1 = Input:A.0;  
}

Object ( Variant Out1) $XOR-NInput( Bit In2, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In2) Input;  //_GUI 10,24
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $XOR-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 VariantIn.0 = Input:A.0;  
 XOR.0 = Input.0;  
 XOR.1 = $XOR-NInput.0;  //_GUI 59,32
 $XOR-NInput.0 = VariantIn.1;  
 $XOR-NInput.1 = VariantIn.0;  
}

Object ( Variant Out1) $XOR-NInput( Variant In1, Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,20
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $XOR-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 16,18
 Object ( Variant Out1) $XOR-NInput:A( Variant In1, Variant In2) ;  //_GUI 30,18
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 VariantIn.0 = Input:A.0;  
 XOR.0 = $XOR-NInput:A.0;  //_GUI 59,21
 XOR.1 = $XOR-NInput.0;  //_GUI 59,32
 $XOR-NInput.0 = VariantIn.1;  
 $XOR-NInput.1 = VariantIn.0;  
 VariantIn:A.0 = Input.0;  
 $XOR-NInput:A.0 = VariantIn:A.1;  
 $XOR-NInput:A.1 = VariantIn:A.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4, Variant In5) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 30,19
 Object ( Variant In2) Input:A;  //_GUI 30,22
 Object ( Variant In3) Input:B;  //_GUI 30,25
 Object ( Variant In4) Input:C;  //_GUI 30,28
 Object ( Variant In5) Input:D;  //_GUI 30,33
 Object Output( List Out1) ;  //_GUI 66,31
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 36,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,29

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
 PackLSB.3 = Input:C.0;  
 ListOut.0 = Input:D.0;  
 ListOut.1 = PackLSB.0;  //_GUI 49,31, 49,21
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5) UnPackLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 25,25
 Object Output( Variant Out1) ;  //_GUI 66,23
 Object Output:A( Variant Out2) ;  //_GUI 66,26
 Object Output:B( Variant Out3) ;  //_GUI 66,29
 Object Output:C( Variant Out4) ;  //_GUI 66,32
 Object Output:D( Variant Out5) ;  //_GUI 66,37
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 31,23
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackLSB:A( Variant In1) ;  //_GUI 51,22

 //_ Behavior Topology
 Output.0 = UnPackLSB:A.0;  
 Output:A.0 = UnPackLSB:A.1;  
 Output:B.0 = UnPackLSB:A.2;  
 Output:C.0 = UnPackLSB:A.3;  
 Output:D.0 = UnPackLSB.1;  //_GUI 48,38, 48,28
 UnPackLSB.0 = Input.0;  
 UnPackLSB:A.0 = UnPackLSB.0;  
}

Object ( Bit Out1) $BitA_Le_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object Text;  //_GUI 29,42,( 0 <= 0 )
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Le_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), >, !)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Le_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object Text;  //_GUI 29,42,( ( ! 0 ) <= 0 )
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Le_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object Text;  //_GUI 29,42,( 0 <= ( ! 0 ) )
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27
    , Variant Out28) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object Output:Z( Variant Out27) ;  //_GUI 80,115
 Object Output:a( Variant Out28) ;  //_GUI 80,118
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27) ExposeMSB
    ( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 Output:Z.0 = ExposeMSB.25;  
 Output:a.0 = ExposeMSB.26;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 30,21
 Object ( Variant In2) Input:A;  //_GUI 30,24
 Object ( Variant In3) Input:B;  //_GUI 30,27
 Object ( Variant In4) Input:C;  //_GUI 30,31
 Object Output( List Out1) ;  //_GUI 68,29
 Object ( List Out1) PackLSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 37,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 PackLSB.0 = Input.0;  
 PackLSB.1 = Input:A.0;  
 PackLSB.2 = Input:B.0;  
 ListOut.0 = Input:C.0;  
 ListOut.1 = PackLSB.0;  //_GUI 51,29, 51,23
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) UnPackLSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\LSB\\UnPackLSB",Icon="Exposer_In"
{
 // Unpacks an LSB-shaped List into its data elements.
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 24,24
 Object Output( Variant Out1) ;  //_GUI 65,22
 Object Output:A( Variant Out2) ;  //_GUI 65,25
 Object Output:B( Variant Out3) ;  //_GUI 65,28
 Object Output:C( Variant Out4) ;  //_GUI 65,32
 Object ( Variant Out1, Variant Out2) UnPackLSB( Variant In1) ;  //_GUI 30,22
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) UnPackLSB:A
    ( Variant In1) ;  //_GUI 49,21

 //_ Behavior Topology
 Output.0 = UnPackLSB:A.0;  
 Output:A.0 = UnPackLSB:A.1;  
 Output:B.0 = UnPackLSB:A.2;  
 Output:C.0 = UnPackLSB.1;  //_GUI 47,33, 47,27
 UnPackLSB.0 = Input.0;  
 UnPackLSB:A.0 = UnPackLSB.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26, Variant Out27) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object Output:Z( Variant Out27) ;  //_GUI 80,115
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 Output:Z.0 = ExposeMSB.25;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25, Variant Out26) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object Output:Y( Variant Out26) ;  //_GUI 80,112
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 Output:Y.0 = ExposeMSB.24;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24, Variant Out25) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object Output:X( Variant Out25) ;  //_GUI 80,109
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 Output:X.0 = ExposeMSB.23;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23
    , Variant Out24) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object Output:W( Variant Out24) ;  //_GUI 80,106
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23) ExposeMSB
    ( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 47,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 Output:W.0 = ExposeMSB.22;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22, Variant Out23) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object Output:V( Variant Out23) ;  //_GUI 80,103
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 46,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 Output:V.0 = ExposeMSB.21;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21, Variant Out22) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object Output:U( Variant Out22) ;  //_GUI 80,100
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 45,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 Output:U.0 = ExposeMSB.20;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20, Variant Out21) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object Output:T( Variant Out21) ;  //_GUI 80,97
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20) ExposeMSB( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 46,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 Output:T.0 = ExposeMSB.19;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,42, 60,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19
    , Variant Out20) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 41,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object Output:S( Variant Out20) ;  //_GUI 80,94
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19) ExposeMSB
    ( Variant In1) ;  //_GUI 63,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 48,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 Output:S.0 = ExposeMSB.18;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 63,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18, Variant Out19) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 41,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object Output:R( Variant Out19) ;  //_GUI 80,91
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18) ExposeMSB( Variant In1) ;  //_GUI 64,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 48,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 Output:R.0 = ExposeMSB.17;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 63,42, 63,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17, Variant Out18) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 41,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object Output:Q( Variant Out18) ;  //_GUI 80,88
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17) ExposeMSB( Variant In1) ;  //_GUI 64,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 49,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 Output:Q.0 = ExposeMSB.16;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 63,42, 63,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16, Variant Out17) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 41,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object Output:P( Variant Out17) ;  //_GUI 80,85
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16) ExposeMSB( Variant In1) ;  //_GUI 65,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 49,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 Output:P.0 = ExposeMSB.15;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 63,42, 63,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15
    , Variant Out16) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 41,36
 Object Output( Variant Out1) ;  //_GUI 80,35
 Object Output:A( Variant Out2) ;  //_GUI 80,40
 Object Output:B( Variant Out3) ;  //_GUI 80,43
 Object Output:C( Variant Out4) ;  //_GUI 80,46
 Object Output:D( Variant Out5) ;  //_GUI 80,49
 Object Output:E( Variant Out6) ;  //_GUI 80,52
 Object Output:F( Variant Out7) ;  //_GUI 80,55
 Object Output:G( Variant Out8) ;  //_GUI 80,58
 Object Output:H( Variant Out9) ;  //_GUI 80,61
 Object Output:I( Variant Out10) ;  //_GUI 80,64
 Object Output:J( Variant Out11) ;  //_GUI 80,67
 Object Output:K( Variant Out12) ;  //_GUI 80,70
 Object Output:L( Variant Out13) ;  //_GUI 80,73
 Object Output:M( Variant Out14) ;  //_GUI 80,76
 Object Output:N( Variant Out15) ;  //_GUI 80,79
 Object Output:O( Variant Out16) ;  //_GUI 80,82
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15) ExposeMSB
    ( Variant In1) ;  //_GUI 65,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 48,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 Output:O.0 = ExposeMSB.14;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 63,42, 63,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14, Variant Out15) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 40,36
 Object Output( Variant Out1) ;  //_GUI 79,35
 Object Output:A( Variant Out2) ;  //_GUI 79,40
 Object Output:B( Variant Out3) ;  //_GUI 79,43
 Object Output:C( Variant Out4) ;  //_GUI 79,46
 Object Output:D( Variant Out5) ;  //_GUI 79,49
 Object Output:E( Variant Out6) ;  //_GUI 79,52
 Object Output:F( Variant Out7) ;  //_GUI 79,55
 Object Output:G( Variant Out8) ;  //_GUI 79,58
 Object Output:H( Variant Out9) ;  //_GUI 79,61
 Object Output:I( Variant Out10) ;  //_GUI 79,64
 Object Output:J( Variant Out11) ;  //_GUI 79,67
 Object Output:K( Variant Out12) ;  //_GUI 79,70
 Object Output:L( Variant Out13) ;  //_GUI 79,73
 Object Output:M( Variant Out14) ;  //_GUI 79,76
 Object Output:N( Variant Out15) ;  //_GUI 79,79
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14) ExposeMSB( Variant In1) ;  //_GUI 64,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 48,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 Output:N.0 = ExposeMSB.13;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 62,42, 62,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13, Variant Out14) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 39,35
 Object Output( Variant Out1) ;  //_GUI 78,34
 Object Output:A( Variant Out2) ;  //_GUI 78,39
 Object Output:B( Variant Out3) ;  //_GUI 78,42
 Object Output:C( Variant Out4) ;  //_GUI 78,45
 Object Output:D( Variant Out5) ;  //_GUI 78,48
 Object Output:E( Variant Out6) ;  //_GUI 78,51
 Object Output:F( Variant Out7) ;  //_GUI 78,54
 Object Output:G( Variant Out8) ;  //_GUI 78,57
 Object Output:H( Variant Out9) ;  //_GUI 78,60
 Object Output:I( Variant Out10) ;  //_GUI 78,63
 Object Output:J( Variant Out11) ;  //_GUI 78,66
 Object Output:K( Variant Out12) ;  //_GUI 78,69
 Object Output:L( Variant Out13) ;  //_GUI 78,72
 Object Output:M( Variant Out14) ;  //_GUI 78,75
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13) ExposeMSB( Variant In1) ;  //_GUI 63,38
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 46,33

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 Output:M.0 = ExposeMSB.12;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 61,41, 61,38
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12, Variant Out13) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 40,38
 Object Output( Variant Out1) ;  //_GUI 79,37
 Object Output:A( Variant Out2) ;  //_GUI 79,42
 Object Output:B( Variant Out3) ;  //_GUI 79,45
 Object Output:C( Variant Out4) ;  //_GUI 79,48
 Object Output:D( Variant Out5) ;  //_GUI 79,51
 Object Output:E( Variant Out6) ;  //_GUI 79,54
 Object Output:F( Variant Out7) ;  //_GUI 79,57
 Object Output:G( Variant Out8) ;  //_GUI 79,60
 Object Output:H( Variant Out9) ;  //_GUI 79,63
 Object Output:I( Variant Out10) ;  //_GUI 79,66
 Object Output:J( Variant Out11) ;  //_GUI 79,69
 Object Output:K( Variant Out12) ;  //_GUI 79,72
 Object Output:L( Variant Out13) ;  //_GUI 79,75
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12) ExposeMSB( Variant In1) ;  //_GUI 64,41
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 47,36

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 Output:L.0 = ExposeMSB.11;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 62,44, 62,41
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11
    , Variant Out12) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 38,38
 Object Output( Variant Out1) ;  //_GUI 77,37
 Object Output:A( Variant Out2) ;  //_GUI 77,42
 Object Output:B( Variant Out3) ;  //_GUI 77,45
 Object Output:C( Variant Out4) ;  //_GUI 77,48
 Object Output:D( Variant Out5) ;  //_GUI 77,51
 Object Output:E( Variant Out6) ;  //_GUI 77,54
 Object Output:F( Variant Out7) ;  //_GUI 77,57
 Object Output:G( Variant Out8) ;  //_GUI 77,60
 Object Output:H( Variant Out9) ;  //_GUI 77,63
 Object Output:I( Variant Out10) ;  //_GUI 77,66
 Object Output:J( Variant Out11) ;  //_GUI 77,69
 Object Output:K( Variant Out12) ;  //_GUI 77,72
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11) ExposeMSB
    ( Variant In1) ;  //_GUI 62,41
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 46,36

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 Output:K.0 = ExposeMSB.10;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 60,44, 60,41
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10, Variant Out11) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 37,37
 Object Output( Variant Out1) ;  //_GUI 76,36
 Object Output:A( Variant Out2) ;  //_GUI 76,41
 Object Output:B( Variant Out3) ;  //_GUI 76,44
 Object Output:C( Variant Out4) ;  //_GUI 76,47
 Object Output:D( Variant Out5) ;  //_GUI 76,50
 Object Output:E( Variant Out6) ;  //_GUI 76,53
 Object Output:F( Variant Out7) ;  //_GUI 76,56
 Object Output:G( Variant Out8) ;  //_GUI 76,59
 Object Output:H( Variant Out9) ;  //_GUI 76,62
 Object Output:I( Variant Out10) ;  //_GUI 76,65
 Object Output:J( Variant Out11) ;  //_GUI 76,68
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10) ExposeMSB( Variant In1) ;  //_GUI 61,40
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 44,35

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 Output:J.0 = ExposeMSB.9;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 59,43, 59,40
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9, Variant Out10) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 34,36
 Object Output( Variant Out1) ;  //_GUI 73,35
 Object Output:A( Variant Out2) ;  //_GUI 73,40
 Object Output:B( Variant Out3) ;  //_GUI 73,43
 Object Output:C( Variant Out4) ;  //_GUI 73,46
 Object Output:D( Variant Out5) ;  //_GUI 73,49
 Object Output:E( Variant Out6) ;  //_GUI 73,52
 Object Output:F( Variant Out7) ;  //_GUI 73,55
 Object Output:G( Variant Out8) ;  //_GUI 73,58
 Object Output:H( Variant Out9) ;  //_GUI 73,61
 Object Output:I( Variant Out10) ;  //_GUI 73,64
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9) ExposeMSB( Variant In1) ;  //_GUI 58,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 41,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 Output:I.0 = ExposeMSB.8;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 56,42, 56,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8, Variant Out9) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,36
 Object Output( Variant Out1) ;  //_GUI 72,35
 Object Output:A( Variant Out2) ;  //_GUI 72,40
 Object Output:B( Variant Out3) ;  //_GUI 72,43
 Object Output:C( Variant Out4) ;  //_GUI 72,46
 Object Output:D( Variant Out5) ;  //_GUI 72,49
 Object Output:E( Variant Out6) ;  //_GUI 72,52
 Object Output:F( Variant Out7) ;  //_GUI 72,55
 Object Output:G( Variant Out8) ;  //_GUI 72,58
 Object Output:H( Variant Out9) ;  //_GUI 72,61
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8) ExposeMSB( Variant In1) ;  //_GUI 57,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 40,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 Output:H.0 = ExposeMSB.7;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 55,42, 55,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7
    , Variant Out8) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 31,36
 Object Output( Variant Out1) ;  //_GUI 70,35
 Object Output:A( Variant Out2) ;  //_GUI 70,40
 Object Output:B( Variant Out3) ;  //_GUI 70,43
 Object Output:C( Variant Out4) ;  //_GUI 70,46
 Object Output:D( Variant Out5) ;  //_GUI 70,49
 Object Output:E( Variant Out6) ;  //_GUI 70,52
 Object Output:F( Variant Out7) ;  //_GUI 70,55
 Object Output:G( Variant Out8) ;  //_GUI 70,58
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) ExposeMSB
    ( Variant In1) ;  //_GUI 55,39
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 38,34

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 Output:G.0 = ExposeMSB.6;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 53,42, 53,39
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6, Variant Out7) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 31,35
 Object Output( Variant Out1) ;  //_GUI 70,34
 Object Output:A( Variant Out2) ;  //_GUI 70,39
 Object Output:B( Variant Out3) ;  //_GUI 70,42
 Object Output:C( Variant Out4) ;  //_GUI 70,45
 Object Output:D( Variant Out5) ;  //_GUI 70,48
 Object Output:E( Variant Out6) ;  //_GUI 70,51
 Object Output:F( Variant Out7) ;  //_GUI 70,54
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6) ExposeMSB( Variant In1) ;  //_GUI 55,38
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 38,33

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 Output:F.0 = ExposeMSB.5;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 53,41, 53,38
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5, Variant Out6) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,35
 Object Output( Variant Out1) ;  //_GUI 72,34
 Object Output:A( Variant Out2) ;  //_GUI 72,39
 Object Output:B( Variant Out3) ;  //_GUI 72,42
 Object Output:C( Variant Out4) ;  //_GUI 72,45
 Object Output:D( Variant Out5) ;  //_GUI 72,48
 Object Output:E( Variant Out6) ;  //_GUI 72,51
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5) ExposeMSB( Variant In1) ;  //_GUI 57,38
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 40,33

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 Output:E.0 = ExposeMSB.4;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 55,41, 55,38
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4, Variant Out5) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 34,35
 Object Output( Variant Out1) ;  //_GUI 73,34
 Object Output:A( Variant Out2) ;  //_GUI 73,39
 Object Output:B( Variant Out3) ;  //_GUI 73,42
 Object Output:C( Variant Out4) ;  //_GUI 73,45
 Object Output:D( Variant Out5) ;  //_GUI 73,48
 Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) ExposeMSB( Variant In1) ;  //_GUI 58,38
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 41,33

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 Output:D.0 = ExposeMSB.3;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 56,41, 56,38
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3
    , Variant Out4) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 34,34
 Object Output( Variant Out1) ;  //_GUI 73,33
 Object Output:A( Variant Out2) ;  //_GUI 73,38
 Object Output:B( Variant Out3) ;  //_GUI 73,41
 Object Output:C( Variant Out4) ;  //_GUI 73,44
 Object ( Variant Out1, Variant Out2, Variant Out3) ExposeMSB
    ( Variant In1) ;  //_GUI 58,37
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 41,32

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 Output:C.0 = ExposeMSB.2;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 56,40, 56,37
 ExposeMSB:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2, Variant Out3) ExposeMSB
    ( Variant In1) 
//_ Attributes TreeGroup="CoreLib_James\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,33
 Object Output( Variant Out1) ;  //_GUI 68,32
 Object Output:A( Variant Out2) ;  //_GUI 68,37
 Object Output:B( Variant Out3) ;  //_GUI 68,40
 Object ( Variant Out1, Variant Out2) ExposeMSB( Variant In1) ;  //_GUI 49,36
 Object ( Variant Out1, Variant Out2) ExposeMSB:A( Variant In1) ;  //_GUI 34,31

 //_ Behavior Topology
 Output.0 = ExposeMSB:A.0;  
 Output:A.0 = ExposeMSB.0;  
 Output:B.0 = ExposeMSB.1;  
 ExposeMSB.0 = ExposeMSB:A.1;  //_GUI 48,39, 48,36
 ExposeMSB:A.0 = Input.0;  
}

