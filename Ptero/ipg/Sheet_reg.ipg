VIVA 3.03 Implementation Independent Algorithm Description Language
// Sheet   2020/7/9 16:57:03


DataSet Fix32 = ( Word , Word ); //_ Attributes 4,12632256,System\Static
DataSet Fix16 = ( Byte , Byte ); //_ Attributes 4,32896,System\Static
DataSet Complex = ( List ); //_ Attributes 1,8421504
DataSet Fixed = ( List ); //_ Attributes 1,4227327
DataSet Floating = ( List ); //_ Attributes 1,32896
DataSet Signed = ( Variant ); //_ Attributes 1,16776960
DataSet TBus = ( List ); //_ Attributes 1,0,User\General
DataSet IndexedEl = ( Variant , Variant ); //_ Attributes 1,13290239,User\Join
DataSet IndEl_Or_Wrap = ( Variant ); //_ Attributes 1,8421631,User\Join
DataSet IndEl_And_Wrap = ( Variant ); //_ Attributes 1,8421631,User\Join
DataSet IndEl_Unique_Wrap = ( Variant ); //_ Attributes 1,8421631,User\Join
DataSet "MSB032*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "IVivaString*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "IWaveDisplay*" = ( Word , Word ); //_ Attributes 1,11141375,WaveDisplayProj1,9
DataSet "IDispatch**" = ( Word , Word ); //_ Attributes 1,11141375,System\\Com
DataSet WFD_Enable = ( Bit ); //_ Attributes 1,8388863,User\\Join
DataSet WFD_Analyzer = ( List ); //_ Attributes 1,8388863,User\\Join
DataSet "ISBHC_LinkNV*" = ( Word , Word ); //_ Attributes 1,11141375,SBHC_LinkLib,9
DataSet "BIN512*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet NPI_DeRef = ( Variant ); //_ Attributes 1,4194432
DataSet S18 = ( MSB018 ); //_ Attributes 2,0
DataSet IXYGraph = ( Unsupported ); //_ Attributes 1,11141375,XYGraphProj1,1
DataSet "IXYGraph*" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphProj1,9
DataSet ITreeView = ( Unsupported ); //_ Attributes 1,11141375,ComctlLib,1
DataSet "ITreeView*" = ( Word , Word ); //_ Attributes 1,11141375,ComctlLib,9
DataSet "MSB112*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB020*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB064*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB040*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB160*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB044*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB208*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB046*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB232*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB047*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet s9 = ( MSB008 , Bit ); //_ Attributes 2,16744576
DataSet s13 = ( MSB012 , Bit ); //_ Attributes 2,0
DataSet "MSB039*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "Byte*" = ( Pointer ); //_ Attributes 1,11141375,System,16401
DataSet "DWord*" = ( Word , Word ); //_ Attributes 1,11141375,System\\Static,16403
DataSet "MSB053*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "IXYGraphForm*" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,9
DataSet 8BitSigned = ( MSB009 ); //_ Attributes 2,12632256,System
DataSet "MSB102*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet ZTerm = ( NULL ); //_ Attributes 1,13684991,Layer2\\ZTLib
DataSet ZTList = ( Variant , Variant ); //_ Attributes 1,8421631,Layer2\\ZTLib
DataSet "MSB184*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB103*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet MIGWrite_DeRef = ( Variant ); //_ Attributes 1,8453888
DataSet MIGRead_DeRef = ( Variant ); //_ Attributes 1,16744576
DataSet Fixed13p5 = ( MSB005 , MSB013 ); //_ Attributes 4,33023
DataSet Fixed13p16 = ( MSB016 , MSB013 ); //_ Attributes 4,33023
DataSet Fix18 = ( MSB009 , MSB009 ); //_ Attributes 4,32896,System\\Static
DataSet "LSB064*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$LSB,16385
DataSet "IMemory*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet ISBHC_LinkNV = ( Unsupported ); //_ Attributes 1,11141375,SBHC_LinkLib,1
DataSet DeviceIOControlConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceAccessConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceShareConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceCreateConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceAttributeConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "QWord*" = ( Word , Word ); //_ Attributes 1,11141375,System\\Static,16405
DataSet Pipelined = ( Bit ); //_ Attributes 1,0
DataSet Mul = ( Bit ); //_ Attributes 1,8421376,Operators
DataSet Add = ( Bit ); //_ Attributes 1,8404992,Operators
DataSet Sub = ( Bit ); //_ Attributes 1,8388863,Operators
DataSet AddSub = ( Bit ); //_ Attributes 1,65535,Operators
DataSet Div = ( Bit ); //_ Attributes 1,8454016,Operators
DataSet "Ix86Atoms*" = ( Word , Word ); //_ Attributes 1,11141375,VIVAATOMLib,9
DataSet FileModeConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "IFileObject*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "Variant*" = ( Pointer ); //_ Attributes 1,11141375,System\\$BIN
DataSet "ComUInt*" = ( Word , Word ); //_ Attributes 1,11141375,System\\Com
DataSet "MSB016*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet Fix64 = ( DWord , DWord ); //_ Attributes 4,10526880,System\\Static
DataSet Decimal = ( ZTList ); //_ Attributes 1,128
DataSet FloatSM = ( MSB013 , MSB007 ); //_ Attributes 8,33023
DataSet IDevice = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet "IDevice*" = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "DWord**" = ( Word , Word ); //_ Attributes 1,11141375,System\\Static,16403
DataSet IMemory = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet S32 = ( MSB032 ); //_ Attributes 2,16744448
DataSet Default = ( Variant ); //_ Attributes 1,16777215
DataSet RR = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\RWCR
DataSet ChEn = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChMode = ( LSB002 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChPrio = ( LSB008 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChFifoNum = ( LSB004 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChFifoMask = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChSize = ( LSB017 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet DmaAddrR = ( MSB064 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet DmaNxtR = ( MSB064 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet DmaSizeR = ( ChPrio , MSB , ChRunning , FifoRdy , ChEn , ChFifoNum , MSB006 , ChFifoMask , ChMode , MSB013 , ChSize ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChRunning = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet FifoRdy = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FpgaHalt = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet HostHalt = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet ClrFifo = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FifoRdyCnt = ( LSB004 ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet RDmaEnable = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet RDmaEnabled = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet RDmaDisable = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet WDmaDisable = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet WDmaEnable = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet WDmaEnabled = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet FpgaState = ( MSB002 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaStates = ( LSB020 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet HcCCR = ( MSB013 , RDmaEnabled , RDmaEnable , RDmaDisable , MSB013 , WDmaEnabled , WDmaEnable , WDmaDisable , MSB012 , FpgaStates ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet ChNum = ( LSB004 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet ChBits = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Channel
DataSet FifoErr = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FifoErrs = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FifoRdys = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FifoRdyR = ( MSB006 , FifoErrs , MSB006 , FifoRdys , MSB006 , FifoErrs , MSB006 , FifoRdys ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FifoCountR = ( MSB032 , FpgaHalt , HostHalt , ChMode , ClrFifo , MSB016 , FifoRdyCnt ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet DataBits = ( BIN064 ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet BarClk = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet BarCS = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet BarCSLR = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet BarCSHR = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet BarCSLW = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet BarCSHW = ( MSB ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet Bar0 = ( BarReg ); //_ Attributes 1,16711808,User\\PCIX\\Bar\\0
DataSet BarReg = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Bar\\Reg
DataSet BarCSList = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Bar
DataSet DmaEnabled = ( List ); //_ Attributes 1,16711808,User\\PCIX\\HcCCR
DataSet ActiveChInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\ChCtl
DataSet TBit = ( Bit , Bit ); //_ Attributes 1,0,User\\General
DataSet TBusOld = ( TBit , Variant ); //_ Attributes 1,0,User\\General
DataSet RWActiveChInfo = ( ActiveChInfo , ActiveChInfo ); //_ Attributes 1,16711808,User\\PCIX\\ChCtl
DataSet DmaIE = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\DmaIER
DataSet RWDmaIE = ( DmaIE , DmaIE ); //_ Attributes 1,16711808,User\\PCIX\\DmaIER
DataSet DmaC = ( Bit ); //_ Attributes 1,16711808,User\\PCIX\\DmaCR
DataSet RWDmaC = ( DmaC , DmaC ); //_ Attributes 1,16711808,User\\PCIX\\DmaCR
DataSet RWDmaCLatched = ( DmaC , DmaC ); //_ Attributes 1,16711808,User\\PCIX\\DmaCR
DataSet Bar2 = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Bar\\2
DataSet DmaNxtCtl = ( List ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet DmaAddrCtl = ( List ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet DmaSzCtl = ( List ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet DmaRegInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet RWDmaRegInfo = ( DmaRegInfo , DmaRegInfo ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet DmaRegCtl = ( List ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet RWDmaRegCtl = ( DmaRegCtl , DmaRegCtl ); //_ Attributes 1,16711808,User\\PCIX\\DmaRegs
DataSet FifoCmd = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FifoCmds = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FpgaModes = ( LSB020 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet Bar1 = ( BarReg ); //_ Attributes 1,16711808,User\\PCIX\\Bar\\1
DataSet ControlInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\RWCR
DataSet RWControlInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\RWCR
DataSet RWFifoRdys = ( FifoRdys , FifoRdys ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet RWFifoErrs = ( FifoErrs , FifoErrs ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet RWFifoRdyCnt = ( List , List ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet CFGDataSet = ( MSB512 ); //_ Attributes 1,4210816
DataSet RWFifoInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet FpgaProgModes = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaProgErrs = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaProgInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaProgBeg = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaProgEnd = ( LSB010 ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaProgCmd = ( FpgaProgEnd , FpgaProgBeg ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet FpgaToFifoInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Fpgas
DataSet BarCtl = ( List ); //_ Attributes 1,16711808,User\\PCIX\\Bar\\Reg
DataSet FifoRdyErrs = ( FifoErrs , FifoRdys ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet RWFifoRdyErrs = ( FifoRdyErrs , FifoRdyErrs ); //_ Attributes 1,16711808,User\\PCIX\\Fifos
DataSet BitBangInfo = ( List ); //_ Attributes 1,16711808,User\\PCIX\\BbPCR
DataSet XactReq = ( List ); //_ Attributes 1,16711808,User\\PCIX\\ChCtl
DataSet IFileObject = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet FileSeekConstants = ( Word , Word ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet Small_Int = ( Nibble , Nibble ); //_ Attributes 2,128,System\\Static
DataSet Ix86Atoms = ( Unsupported ); //_ Attributes 1,11141375,VIVAATOMLib,1
DataSet _DSBHC_Link = ( Unsupported ); //_ Attributes 1,11141375,SBHC_LinkLib,1
DataSet "_DSBHC_Link*" = ( Word , Word ); //_ Attributes 1,11141375,SBHC_LinkLib,9
DataSet 3Bit = ( DBit , Bit ); //_ Attributes 1,16777215,System\\$LowLevel
DataSet Signed_Int = ( Variant ); //_ Attributes 1,16776960
DataSet Unsigned_Int = ( Variant ); //_ Attributes 1,8453888
DataSet Fixed_Point = ( List ); //_ Attributes 1,4227327
DataSet Floating_Point = ( List ); //_ Attributes 1,32896
DataSet 6Bit = ( 3Bit , 3Bit ); //_ Attributes 1,8421631,System\\$LowLevel
DataSet 14BIT = ( Byte , 6Bit ); //_ Attributes 1,65535,System\\$LowLevel
DataSet BeginConv = ( Bit ); //_ Attributes 1,33023,System\\$LowLevel
DataSet "IVivaPort*" = ( Word , Word ); //_ Attributes 1,11141375,SBSPortIO,9
DataSet "MSB216*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB080*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet IWaveDisplay = ( Unsupported ); //_ Attributes 1,11141375,WaveDisplayProj1,1
DataSet IVivaString = ( Unsupported ); //_ Attributes 1,11141375,VIVASTANDARDOBJECTSLib,1
DataSet "MSB392*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB135*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB088*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB019*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB022*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB050*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB042*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB058*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB036*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "ICheckBoxX*" = ( Word , Word ); //_ Attributes 1,11141375,Buttons,9
DataSet "IProgressBar*" = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,9
DataSet MousePointerConstants = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,3
DataSet "MSB097*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet SMALLINT = ( MSB004 , MSB004 ); //_ Attributes 2,0
DataSet IProgressBar = ( Unsupported ); //_ Attributes 1,11141375,MSComctlLib,1
DataSet SmInt = ( Nibble , Nibble ); //_ Attributes 2,0
DataSet "List*" = ( Word , Word ); //_ Attributes 1,11141375
DataSet "BIN024*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet 1Q8 = ( MSB009 , Bit ); //_ Attributes 4,10623166,System\\Static
DataSet 2Q8 = ( MSB008 , DBit ); //_ Attributes 4,12262621,System\\Static
DataSet 1Q14 = ( MSB014 , MSB002 ); //_ Attributes 4,15501559
DataSet "MSB152*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB045*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "BIN256*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "BIN008*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "BIN064*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "BIN136*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet Picture = ( Unsupported ); //_ Attributes 1,11141375,MSComctlLib,1
DataSet "Picture*" = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,9
DataSet "Picture**" = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,16393
DataSet AppearanceConstants = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,3
DataSet BorderStyleConstants = ( Word , Word ); //_ Attributes 1,11141375,MSComctlLib,3
DataSet ICheckBoxX = ( Unsupported ); //_ Attributes 1,11141375,Buttons,1
DataSet IVivaPort = ( Unsupported ); //_ Attributes 1,11141375,SBSPortIO,1
DataSet "Word*" = ( Word , Word ); //_ Attributes 1,11141375,System\\Static,16402
DataSet "MSB144*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB048*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB066*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB034*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet 1Q16 = ( MSB014 , MSB002 ); //_ Attributes 4,14650608,System\\Static
DataSet 2Q16 = ( MSB013 , MSB003 ); //_ Attributes 4,8590490,System\\Static
DataSet My_Signed = ( MSB064 , Bit ); //_ Attributes 2,11156617,User\\Esmail
DataSet Float_6_14 = ( MSB014 , MSB006 ); //_ Attributes 8,4194368
DataSet Int_33 = ( MSB032 , Bit ); //_ Attributes 2,16744448,System\\Static
DataSet Int_17 = ( MSB016 , Bit ); //_ Attributes 2,16744448,System\\Static
DataSet 1Q9 = ( MSB007 , MSB002 ); //_ Attributes 4,14650608,System\\Static
DataSet 1Q16_UN = ( MSB015 , Bit ); //_ Attributes 4,14650608,System\\Static
DataSet 1Q9_UN = ( MSB008 , Bit ); //_ Attributes 4,14650608,System\\Static
DataSet 2Q10 = ( MSB007 , MSB003 ); //_ Attributes 4,12262621,System\\Static
DataSet 1Q10 = ( MSB008 , MSB002 ); //_ Attributes 4,14650608,System\\Static
DataSet IBitmapGraph = ( Unsupported ); //_ Attributes 1,11141375,BitmapGraphProj1,1
DataSet "IBitmapGraph*" = ( Word , Word ); //_ Attributes 1,11141375,BitmapGraphProj1,9
DataSet "DInt*" = ( Word , Word ); //_ Attributes 2,11141375,System\\Static,16387
DataSet "MSB018*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB026*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB027*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB304*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB075*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB054*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB057*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB107*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB167*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet 10Signed = ( MSB009 , Bit ); //_ Attributes 2,16711680
DataSet RotateStruct = ( Variant , Variant ); //_ Attributes 1,4227072
DataSet _DSBSDIMEIO = ( Unsupported ); //_ Attributes 1,11141375,SBSDIMEIOLib,1
DataSet "_DSBSDIMEIO*" = ( Word , Word ); //_ Attributes 1,11141375,SBSDIMEIOLib,9
DataSet "MSB128*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "BIN128*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "MSB056*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet IComm = ( Unsupported ); //_ Attributes 1,11141375,SBIJTAG,1
DataSet "IComm*" = ( Word , Word ); //_ Attributes 1,11141375,SBIJTAG,9
DataSet "MSB024*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "BIN1024*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "Byte**" = ( Word , Word ); //_ Attributes 1,11141375,System,16401
DataSet "BIN512**" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "MSB256*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB060*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB280*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB061*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB116*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB147*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB186*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB202*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB352*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB188*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB400*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB190*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB093*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB065*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB071*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB136*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB028*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB081*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB117*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB225*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB165*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB033*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB070*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB087*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "_DMouseControl2*" = ( Word , Word ); //_ Attributes 1,11141375,MouseControl2Lib,9
DataSet Fixed32point24 = ( MSB024 , MSB008 ); //_ Attributes 4,0
DataSet Fixed31by24 = ( MSB024 , MSB007 ); //_ Attributes 4,65280
DataSet "MSB031*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB038*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB192*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB108*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "BIN032*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$BIN,16385
DataSet "MSB095*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet int23 = ( MSB022 , Bit ); //_ Attributes 2,65280
DataSet int16 = ( MSB015 , Bit ); //_ Attributes 2,8421376
DataSet Fixec32 = ( Word , Word ); //_ Attributes 4,0
DataSet Fixed36 = ( MSB018 , MSB018 ); //_ Attributes 4,4227327
DataSet Fixed24X8 = ( MSB024 , MSB008 ); //_ Attributes 4,16744448
DataSet "MSB041*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB043*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB059*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet Mul_DeRef = ( Variant ); //_ Attributes 1,32768
DataSet JoinCount = ( Variant ); //_ Attributes 1,0
DataSet "MSB030*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB288*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB504*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB098*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB328*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB105*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB083*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB025*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB012*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB688*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB238*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB119*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "Signed Byte*" = ( Word , Word ); //_ Attributes 2,11141375,System\\Com
DataSet IXYGraphForm = ( Unsupported ); //_ Attributes 1,11141375,XYGraphFormProj1,1
DataSet "MSB078*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB051*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB062*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet Float24 = ( MSB016 , MSB006 ); //_ Attributes 8,32768
DataSet Vertex = ( Variant , Variant ); //_ Attributes 1,8421376
DataSet Int10 = ( MSB009 , Bit ); //_ Attributes 2,8421376
DataSet Int12 = ( MSB011 , Bit ); //_ Attributes 2,16776960
DataSet "MSB052*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet 9signed = ( MSB008 , Bit ); //_ Attributes 2,0
DataSet "MSB272*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB432*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB133*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB067*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB456*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB035*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB384*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB512*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB480*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB416*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB224*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB063*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB608*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB148*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB896*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB229*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet 9singed = ( MSB008 , Bit ); //_ Attributes 2,65535
DataSet "MSB068*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB069*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB072*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet Font = ( Unsupported ); //_ Attributes 1,11141375,XYGraphFormProj1,1
DataSet "Font*" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,9
DataSet "Font**" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,16393
DataSet "Font***" = ( Word , Word ); //_ Attributes 1,11141375,XYGraphFormProj1,16393
DataSet "MSB158*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB168*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB132*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB240*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB134*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB264*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB172*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB101*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB178*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB122*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB126*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB094*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB376*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB127*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB096*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet S13 = ( MSB012 , Bit ); //_ Attributes 2,12615808
DataSet Fix2x14 = ( MSB014 , MSB002 ); //_ Attributes 4,65280
DataSet Fix3x13 = ( MSB013 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix10x14 = ( MSB014 , MSB010 ); //_ Attributes 4,8421376
DataSet Fix12x14 = ( MSB014 , MSB012 ); //_ Attributes 4,8388863
DataSet Fixed18x14 = ( MSB018 , MSB014 ); //_ Attributes 4,16744448
DataSet s16 = ( MSB015 , Bit ); //_ Attributes 2,8453888
DataSet "MSB125*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet AXIWrite_DeRef = ( Variant ); //_ Attributes 1,4194432
DataSet AXIRead_DeRef = ( Variant ); //_ Attributes 1,16744448
DataSet "MSB106*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB210*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB212*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet MrgList = ( Variant ); //_ Attributes 1,0
DataSet AXIReadReg_DeRef = ( Variant ); //_ Attributes 1,0
DataSet S20 = ( MSB020 ); //_ Attributes 2,16744448
DataSet S19 = ( MSB019 ); //_ Attributes 2,12615808
DataSet Fixed2p36 = ( MSB036 , MSB002 ); //_ Attributes 4,0
DataSet "MSB408*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB226*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet "MSB230*" = ( Word , Word ); //_ Attributes 1,11141375,System\\$MSB,16385
DataSet Int_32 = ( MSB031 , Bit ); //_ Attributes 2,16744448
DataSet Int26 = ( MSB025 , Bit ); //_ Attributes 2,33023
DataSet Int11 = ( MSB010 , Bit ); //_ Attributes 2,33023
DataSet Int21 = ( MSB020 , Bit ); //_ Attributes 2,33023
DataSet Int9 = ( MSB008 , Bit ); //_ Attributes 2,33023
DataSet SignMSB008 = ( MSB009 ); //_ Attributes 2,16744448
DataSet SignMSB011 = ( MSB011 ); //_ Attributes 2,12615680
DataSet SignMSB017 = ( MSB017 ); //_ Attributes 2,15461355
DataSet Int41 = ( MSB040 , Bit ); //_ Attributes 2,33023
DataSet Int48 = ( MSB047 , Bit ); //_ Attributes 2,33023
DataSet Int25 = ( MSB024 , Bit ); //_ Attributes 2,33023
DataSet Multiplier_DeRef = ( Variant ); //_ Attributes 1,12632256
DataSet Multiplier1_DeRef = ( Variant ); //_ Attributes 1,8421504
DataSet Add_DeRef = ( Variant ); //_ Attributes 1,8421440
DataSet Fix1p15 = ( MSB015 , Bit ); //_ Attributes 4,65280
DataSet Fix15p1 = ( Bit , MSB015 ); //_ Attributes 4,16744576
DataSet Fix16p0 = ( NULL , MSB016 ); //_ Attributes 4,16744576
DataSet Float16 = ( MSB011 , MSB005 ); //_ Attributes 8,4227072
DataSet Fix2p15 = ( MSB015 , MSB002 ); //_ Attributes 4,65280
DataSet Fixed5p15 = ( MSB015 , MSB005 ); //_ Attributes 4,32768
DataSet Fixed2P15 = ( MSB015 , MSB002 ); //_ Attributes 4,65280
DataSet Fixed1P15 = ( MSB015 , Bit ); //_ Attributes 4,32768
DataSet Fixed5P15 = ( MSB015 , MSB005 ); //_ Attributes 4,32768
DataSet Fixed4P12 = ( MSB012 , MSB004 ); //_ Attributes 4,32768
DataSet Fixed5P11 = ( MSB011 , MSB005 ); //_ Attributes 4,32768
DataSet Fixed21P11 = ( MSB011 , MSB021 ); //_ Attributes 4,32768
DataSet Fixed7P11 = ( MSB011 , MSB007 ); //_ Attributes 4,32768
DataSet 16Signed = ( MSB015 , Bit ); //_ Attributes 2,64
DataSet 20Signed = ( MSB019 , Bit ); //_ Attributes 2,128
DataSet Fixed6P10 = ( MSB010 , MSB006 ); //_ Attributes 4,32768
DataSet Fixed7P9 = ( MSB009 , MSB007 ); //_ Attributes 4,32768
DataSet Fixed8P8 = ( MSB008 , MSB008 ); //_ Attributes 4,32768
DataSet Fixed9P7 = ( MSB007 , MSB009 ); //_ Attributes 4,32768
DataSet Fixed10P6 = ( MSB006 , MSB010 ); //_ Attributes 4,32768
DataSet 32Signed = ( MSB031 , Bit ); //_ Attributes 2,4210816
DataSet 18Signed = ( MSB017 , Bit ); //_ Attributes 2,4210816
DataSet 28Signed = ( MSB027 , Bit ); //_ Attributes 2,4210816
DataSet 27Signed = ( MSB026 , Bit ); //_ Attributes 2,4210816
DataSet 26Signed = ( MSB025 , Bit ); //_ Attributes 2,4210816
DataSet 19Signed = ( MSB018 , Bit ); //_ Attributes 2,4210816
DataSet 43Signed = ( MSB042 , Bit ); //_ Attributes 2,4210816
DataSet Fixed2P14 = ( MSB014 , MSB002 ); //_ Attributes 4,32768
DataSet 38Signed = ( MSB037 , Bit ); //_ Attributes 2,4210816
DataSet 33Signed = ( MSB032 , Bit ); //_ Attributes 2,4210816
DataSet Fixed3P13 = ( MSB013 , MSB003 ); //_ Attributes 4,32768
DataSet Fixed15P7 = ( MSB007 , MSB015 ); //_ Attributes 4,32768
DataSet Fix6p10 = ( MSB010 , MSB006 ); //_ Attributes 4,8453888
DataSet Fix10p6 = ( MSB006 , MSB010 ); //_ Attributes 4,8453888
DataSet Fix16p16 = ( MSB016 , MSB016 ); //_ Attributes 4,8453888
DataSet Fixed3P3 = ( MSB003 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix11p5 = ( MSB005 , MSB011 ); //_ Attributes 4,65280
DataSet Fix12p4 = ( MSB004 , MSB012 ); //_ Attributes 4,65280
DataSet Fix13p3 = ( MSB003 , MSB013 ); //_ Attributes 4,65280
DataSet Fix14p2 = ( MSB002 , MSB014 ); //_ Attributes 4,65280
DataSet Fixed11P5 = ( MSB005 , MSB011 ); //_ Attributes 4,32768
DataSet 5Singed = ( MSB005 ); //_ Attributes 2,64
DataSet Fixed12P4 = ( MSB004 , MSB012 ); //_ Attributes 4,32768
DataSet int8 = ( MSB008 ); //_ Attributes 2,0
DataSet FIxed9P23 = ( MSB023 , MSB009 ); //_ Attributes 4,255
DataSet IDispatch = ( Unsupported ); //_ Attributes 1,11141375,StdVCL,1
DataSet IMemoX = ( Unsupported ); //_ Attributes 1,11141375,Edits,1
DataSet "IMemoX*" = ( Word , Word ); //_ Attributes 1,11141375,Edits,9
DataSet IEditX = ( Unsupported ); //_ Attributes 1,11141375,Edits,1
DataSet "IEditX*" = ( Word , Word ); //_ Attributes 1,11141375,Edits,9
DataSet IMemObject = ( Unsupported ); //_ Attributes 1,11141375,PTEROUTILLib,1
DataSet "IMemObject*" = ( Word , Word ); //_ Attributes 1,11141375,PTEROUTILLib,9
DataSet "Bool*" = ( Word , Word ); //_ Attributes 1,11141375,System\\Com
DataSet "ComInt*" = ( Word , Word ); //_ Attributes 2,11141375,System\\Com
DataSet "Int*" = ( Word , Word ); //_ Attributes 2,11141375,System\\Static,16386
DataSet IDeviceRect = ( Unsupported ); //_ Attributes 1,11141375,IEXTagLib,1
DataSet "IDeviceRect*" = ( Word , Word ); //_ Attributes 1,11141375,IEXTagLib,9
DataSet 6P4 = ( MSB004 , MSB006 ); //_ Attributes 4,14116968,System\\$MSB
DataSet MSB98304 = ( MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 , MSB1536 ); //_ Attributes 1,0,System\\$MSB
DataSet Fix3P13 = ( MSB013 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix3P15 = ( MSB015 , MSB003 ); //_ Attributes 4,16744576
DataSet Fix12P15 = ( MSB015 , MSB012 ); //_ Attributes 4,16744576
DataSet Fixed17P15 = ( MSB015 , MSB017 ); //_ Attributes 4,32768
DataSet Fixed_1p15 = ( MSB015 , Bit ); //_ Attributes 4,64
DataSet Fixed_4p12 = ( MSB012 , MSB004 ); //_ Attributes 4,64
DataSet Fixed_5p11 = ( MSB011 , MSB005 ); //_ Attributes 4,64
DataSet Fixed_6p10 = ( MSB010 , MSB006 ); //_ Attributes 4,64
DataSet Fixed_7p9 = ( MSB009 , MSB007 ); //_ Attributes 4,64
DataSet Fixed_8p8 = ( MSB008 , MSB008 ); //_ Attributes 4,64
DataSet Fixed_9p7 = ( MSB007 , MSB009 ); //_ Attributes 4,64
DataSet Fixed_10p6 = ( MSB006 , MSB010 ); //_ Attributes 4,64
DataSet Fixed_11p5 = ( MSB005 , MSB011 ); //_ Attributes 4,64
DataSet Fixed_12p4 = ( MSB004 , MSB012 ); //_ Attributes 4,64
DataSet Fixed_2p14 = ( MSB014 , MSB002 ); //_ Attributes 4,0
DataSet Fixed_3p13 = ( MSB013 , MSB003 ); //_ Attributes 4,0
DataSet Fixed_13p3 = ( MSB003 , MSB013 ); //_ Attributes 4,0
DataSet Fixed3P15 = ( MSB015 , MSB003 ); //_ Attributes 4,32768
DataSet Fixed12P15 = ( MSB015 , MSB012 ); //_ Attributes 4,32768
DataSet Fixed8P24 = ( MSB024 , MSB008 ); //_ Attributes 4,0
DataSet Fixed5P13 = ( MSB013 , MSB005 ); //_ Attributes 4,0
DataSet Fix1p17 = ( MSB017 , Bit ); //_ Attributes 4,65280
DataSet Fix27p0 = ( NULL , MSB027 ); //_ Attributes 4,65280
DataSet Fix31p17 = ( MSB017 , MSB031 ); //_ Attributes 4,255
DataSet Fix13p32 = ( MSB032 , MSB013 ); //_ Attributes 4,255
DataSet Fix16p32 = ( MSB032 , MSB016 ); //_ Attributes 4,255
DataSet Fix9p0 = ( NULL , MSB009 ); //_ Attributes 4,255
DataSet Signed_MSB009 = ( MSB009 ); //_ Attributes 2,0
DataSet null1 = ( NULL , NULL ); //_ Attributes 1,15461355
DataSet BR = ( Variant , Variant ); //_ Attributes 1,0,Undefined
DataSet TR = ( Variant , Variant ); //_ Attributes 1,0,Undefined
DataSet Fixed1P10 = ( MSB010 , Bit ); //_ Attributes 4,16744703
DataSet 9p10 = ( MSB010 , MSB009 ); //_ Attributes 4,8421631
DataSet 1p12 = ( MSB012 , MSB ); //_ Attributes 4,16776960,numbers
DataSet Fix1p12 = ( MSB012 , Bit ); //_ Attributes 4,16776960,numbers
DataSet Fix14p12 = ( MSB012 , MSB014 ); //_ Attributes 4,16776960,numbers
DataSet Fix13p0 = ( NULL , MSB013 ); //_ Attributes 4,16776960,numbers
DataSet Fix14p15 = ( MSB015 , MSB014 ); //_ Attributes 4,16776960,numbers
DataSet Fix1p8 = ( MSB008 , Bit ); //_ Attributes 4,16776960,numbers
DataSet Fix17p8 = ( MSB008 , MSB017 ); //_ Attributes 4,16776960,numbers
DataSet Fix33p8 = ( MSB008 , MSB033 ); //_ Attributes 4,16776960
DataSet Fix20p12 = ( MSB012 , MSB020 ); //_ Attributes 8,16776960
DataSet Fix21p20 = ( MSB020 , MSB021 ); //_ Attributes 8,16776960
DataSet Fix9p16 = ( MSB016 , MSB009 ); //_ Attributes 4,12615680
DataSet Fix17p31 = ( MSB031 , MSB017 ); //_ Attributes 4,12615680
DataSet Fix12p20 = ( MSB020 , MSB012 ); //_ Attributes 4,4227327
DataSet Fix7p20 = ( MSB020 , MSB007 ); //_ Attributes 4,12615680
DataSet Fix16P36 = ( MSB036 , MSB016 ); //_ Attributes 4,12615680
DataSet 8P24 = ( MSB024 , MSB008 ); //_ Attributes 4,0
DataSet 6P26 = ( MSB026 , MSB006 ); //_ Attributes 4,0
DataSet 6P10 = ( MSB010 , MSB006 ); //_ Attributes 4,0
DataSet 12P15 = ( MSB015 , MSB012 ); //_ Attributes 4,0
DataSet Fix1p26 = ( MSB026 , Bit ); //_ Attributes 4,16744448
DataSet Fix1P26 = ( MSB026 , Bit ); //_ Attributes 4,0
DataSet Fix1p37 = ( MSB037 , Bit ); //_ Attributes 4,0
DataSet Fix2p36 = ( MSB036 , MSB002 ); //_ Attributes 4,0
DataSet Fix1p36 = ( MSB036 , Bit ); //_ Attributes 4,0
DataSet 8P0 = ( MSB008 ); //_ Attributes 4,16711680
DataSet Fixed_8p24 = ( MSB024 , MSB008 ); //_ Attributes 4,16776960,System\\Static
DataSet Fixed_12p15 = ( MSB015 , MSB012 ); //_ Attributes 4,10485760,System\\Static
DataSet Fixed_7p20 = ( MSB020 , MSB007 ); //_ Attributes 4,10485760,System\\Static
DataSet Fixed_1p24 = ( MSB024 , Bit ); //_ Attributes 4,14116968,System\\Static
DataSet 7p20 = ( MSB020 , MSB007 ); //_ Attributes 4,16776960
DataSet 8p24 = ( MSB024 , MSB008 ); //_ Attributes 4,16776960
DataSet Uint64 = ( MSB064 , MSB ); //_ Attributes 1,16711808,System\\$MSB

Object Sheet_reg
//_ Attributes WipSheet
{
 //_ Object Prototypes
 Object ( Bit Go) Input;  //_GUI 61,37
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite( Variant In1
    , Variant Index) ;  //_GUI 65,36

 Object ( MSB008 index) Input:A;  //_GUI 61,40
 //_ Attributes Constant="100"

 Object ( Variant NxtIndex) AXIReadReg( Variant Data, Variant Index) ;  //_GUI 65,44
 Object ( Variant NxtIndex) AXIReadReg:A( Variant Data, Variant Index) ;  //_GUI 65,56

 Object ( MSB008 Index) Input:B;  //_GUI 61,48
 //_ Attributes Constant="19"

 Object ( MSB008 Index) Input:C;  //_GUI 61,56
 //_ Attributes Constant="20"


 //_ Behavior Topology
 AXIRegWrite.0 = Input.0;  
 AXIRegWrite.1 = Input:A.0;  
 AXIReadReg.1 = Input:B.0;
 AXIReadReg:A.1= Input:C.0;

}

Object ( Variant Out1, Variant NxtIndex) AXIRegWrite( Variant In1
    , Variant Index) 
{
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 24,44
 //_ Attributes Constant="0"
 Object ( Variant Index) Input:A;  //_GUI 19,51
 //_ Attributes Constant="0"
 Object Output( Variant Out1) ;  //_GUI 96,31
 Object Output:A( Variant NxtIndex) ;  //_GUI 127,51
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 58,27
 Object ( Variant AXIRegWrite) Input:B;  //_GUI 25,18
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) Inc( Variant In1) ;  //_GUI 54,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,51
 Object ( Variant Data) List_Mux_Sel_vivado( Variant ListData, Variant Sel) ;  //_GUI 30,17

 //_ Behavior Topology
 Output.0 = Lo_N.1;  
 Output:A.0 = Inc.0;  
 Lo_N.0 = List_Mux_Sel_vivado.0;  //_GUI 50,29
 Lo_N.1 = Input.0;  //_GUI 58,45
 Inc.0 = Junction.1;  
 Junction.0 = Input:A.0;  
 List_Mux_Sel_vivado.0 = Input:B.0;  
 List_Mux_Sel_vivado.1 = Junction.0;  //_GUI 29,22
}

Object ( List Out1, Variant NxtIndex) AXIRegWrite( List In1
    , Variant Index) 
{
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 19,28
 //_ Attributes Constant="0"
 Object ( Variant Index) Input:A;  //_GUI 19,41
 //_ Attributes Constant="0"
 Object Output( List Out1) ;  //_GUI 125,28
 Object Output:A( Variant NxtIndex) ;  //_GUI 127,49
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 24,26
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 108,26
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite( Variant In1
    , Variant Index) ;  //_GUI 51,37
 Object ( Variant Out1, Variant NxtIndex) AXIRegWrite:A( Variant In1
    , Variant Index) ;  //_GUI 51,26

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = AXIRegWrite:A.1;  //_GUI 86,50, 86,31
 ListIn.0 = Input.0;  
 ListOut.0 = AXIRegWrite.0;  //_GUI 98,31, 98,39
 ListOut.1 = AXIRegWrite:A.0;  
 AXIRegWrite.0 = ListIn.0;  //_GUI 35,39
 AXIRegWrite.1 = Input:A.0;  
 AXIRegWrite:A.0 = ListIn.1;  
 AXIRegWrite:A.1 = AXIRegWrite.1;  //_GUI 47,31, 47,36, 72,36, 72,42
}

Object ( Variant NxtIndex) AXIReadReg( Variant Data, Variant Index) 
{
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 42,53
 Object ( Variant Index) Input:A;  //_GUI 105,72
 //_ Attributes Constant="3"
 Object Output( Variant NxtIndex) ;  //_GUI 144,82
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 58,49
 Object ( MSB032 In) Input:B;  //_GUI 54,42
 //_ Attributes Constant="0",PromoteToParentObject="False"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 102,53
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 113,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,53
 Object ( AXIReadReg_DeRef Out) AXIReadReg_DeRefOut( Variant In1) ;  //_GUI 137,68
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 123,68
 Object ( Variant Out1) Inc( Variant In1) ;  //_GUI 125,80
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 114,72
 Object Output:A( AXIReadReg_DeRef AXIReadRegG) ;  //_GUI 162,70
 //_ Attributes Resource="GlobalIncludeSystem",PromoteToParentObject="False"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 75,48
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 122,92
 //_ Attributes System="X86CPU"
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 141,93
 //_ Attributes System="X86CPU"
 Object ( MSB004 MSB004) Input:C;  //_GUI 136,97
 //_ Attributes System="X86CPU",Constant="8",PromoteToParentObject="False"
 Object ( Bit Out1) INVERT( Bit In1) ;  //_GUI 155,93
 //_ Attributes System="X86CPU"
 Object Output:B( Bit Out) ;  //_GUI 168,95
 //_ Attributes Trap="Index error.",PromoteToParentObject="False"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 117,82

 //_ Behavior Topology
 Output.0 = Inc.0;  
 Lo_N.0 = Input:B.0;  
 Lo_N.1 = Junction.1;  
 ListOut.0 = Junction.2;  //_GUI 102,65, 52,65
 ListOut.1 = Zero.0;  //_GUI 95,55, 95,51
 MSB.0 = ListOut.0;  
 Junction.0 = Input.0;  
 AXIReadReg_DeRefOut.0 = ListOut:A.0;  
 ListOut:A.0 = Junction:A.1;  
 ListOut:A.1 = MSB.0;  
 Inc.0 = Junction:B.1;  
 Junction:A.0 = Input:A.0;  
 Output:A.0 = AXIReadReg_DeRefOut.0;  
 Zero.0 = Lo_N.0;  
 BitLength.0 = Junction:B.2;  //_GUI 118,95
 Equal.0 = BitLength.0;  
 Equal.1 = Input:C.0;  
 INVERT.0 = Equal.0;  
 Output:B.0 = INVERT.0;  
 Junction:B.0 = Junction:A.2;  //_GUI 115,83
}

Object ( Variant NxtIndex) AXIReadReg( List Data, Variant Index) 
{
 //_ Object Prototypes
 Object ( List Data) Input;  //_GUI 33,30
 Object ( Variant Index) Input:A;  //_GUI 33,40
 //_ Attributes Constant="3"
 Object Output( Variant NxtIndex) ;  //_GUI 84,30
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 38,28
 Object ( Variant NxtIndex) AXIReadReg( Variant Data, Variant Index) ;  //_GUI 69,36
 Object ( Variant NxtIndex) AXIReadReg:A( Variant Data, Variant Index) ;  //_GUI 69,28

 //_ Behavior Topology
 Output.0 = AXIReadReg:A.0;  
 ListIn.0 = Input.0;  
 AXIReadReg.0 = ListIn.0;  //_GUI 57,38, 57,33
 AXIReadReg.1 = Input:A.0;  
 AXIReadReg:A.0 = ListIn.1;  
 AXIReadReg:A.1 = AXIReadReg.0;  //_GUI 69,36, 83,36
}

Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N least-significant bits and the bitlength - N most-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Lo_N - the bitlength of this parameter specifies N - the number of bits in the lo data set.
 //
 // Outputs:
 // Hi - the bitlength - N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,33
 Object ( Variant Lo_N) Input:A;  //_GUI 29,42
 Object Output( Variant Hi) ;  //_GUI 95,32
 Object Output:A( Variant Lo) ;  //_GUI 95,35
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 35,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 61,40
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 57,31
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 45,31
 Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Variant Lo_N) ;  //_GUI 83,31
 //_ Attributes Documentation="Variant/Variant"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 49,40

 //_ Behavior Topology
 Output.0 = $Lo_N.0;  
 Output:A.0 = $Lo_N.1;  
 LSB.0 = Input:A.0;  
 VariantIn.0 = Zero.0;  
 VariantIn:A.0 = LSB:A.0;  
 LSB:A.0 = Input.0;  
 $Lo_N.0 = VariantIn:A.1;  
 $Lo_N.1 = VariantIn:A.0;  
 $Lo_N.2 = VariantIn.1;  //_GUI 79,39, 79,42
 Zero.0 = LSB.0;  
}

Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Bit Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Bit"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( Bit Lo_N) Input:A;  //_GUI 40,47
 Object Output( Variant Hi) ;  //_GUI 75,26
 Object Output:A( Variant Lo) ;  //_GUI 82,36
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,25
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 46,25

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  //_GUI 72,37, 72,30
 VariantIn.0 = LSB.0;  
 LSB.0 = Input.0;  
}

Object ( NULL Hi, Bit Lo) Lo_N( Bit Data
    , Bit Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,27
 Object ( Bit Lo_N) Input:A;  //_GUI 40,47
 Object Output( NULL Hi) ;  //_GUI 90,25
 Object Output:A( Bit Lo) ;  //_GUI 82,36
 Object ( NULL Out1) NULL;  //_GUI 78,23

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  //_GUI 71,37, 71,28
}

Object ( NULL Hi, Variant Lo) Lo_N( Bit Data
    , Variant Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Var"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,28
 Object ( Variant Lo_N) Input:A;  //_GUI 40,44
 Object Output( NULL Hi) ;  //_GUI 102,25
 Object Output:A( Variant Lo) ;  //_GUI 94,47
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 48,42
 Object ( NULL Out1) NULL;  //_GUI 87,23
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 67,43
 //_ Attributes Documentation="ztlist"

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = UExtnd.1;  
 MSB.0 = Input:A.0;  
 UExtnd.0 = MSB.0;  
 UExtnd.1 = Input.0;  //_GUI 60,48, 60,29
}

Object ( Variant Hi, NULL Lo) Lo_N( Variant Data
    , NULL Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( NULL Lo_N) Input:A;  //_GUI 40,47
 Object Output( Variant Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 82,36
 Object ( NULL Out1) NULL;  //_GUI 70,34

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
}

Object ( NULL Hi, NULL Lo) Lo_N( NULL Data
    , NULL Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/NULL"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N least-significant bits and the bitlength - N most-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Lo_N - the bitlength of this parameter specifies N - the number of bits in the lo data set.
 //
 // Outputs:
 // Hi - the bitlength - N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 29,32
 Object ( NULL Lo_N) Input:A;  //_GUI 29,35
 Object Output( NULL Hi) ;  //_GUI 95,32
 Object Output:A( NULL Lo) ;  //_GUI 95,35
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 72,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 73,36
 Junction.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) Lo_N( NULL Data
    , Variant Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/Var"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N least-significant bits and the bitlength - N most-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Lo_N - the bitlength of this parameter specifies N - the number of bits in the lo data set.
 //
 // Outputs:
 // Hi - the bitlength - N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 29,32
 Object ( Variant Lo_N) Input:A;  //_GUI 29,35
 Object Output( NULL Hi) ;  //_GUI 95,32
 Object Output:A( NULL Lo) ;  //_GUI 95,35
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 72,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 73,36
 Junction.0 = Input.0;  
}

Object ( Variant Out1) Inc( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronously increments the input value.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant input: Number
 //
 // Outputs:
 //
 // output: Number + 1.  No indication of carry out or overflow is given.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed and List.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 16,19
 Object Output( Variant Out1) ;  //_GUI 91,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,19
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 42,23
 Object ( Variant S) Add( Variant A, Variant B) ;  //_GUI 71,21

 //_ Behavior Topology
 Output.0 = Add.0;  
 Junction.0 = Input.0;  
 One.0 = Junction.2;  //_GUI 31,26
 Add.0 = Junction.1;  //_GUI 59,23, 59,20
 Add.1 = One.0;  
}

Object ( Variant Data) List_Mux_Sel_vivado( Variant ListData, Variant Sel) 
//_ Attributes TreeGroup="CoreLib_James\\\\CoreLib\\\\Multiplexers\\\\Async"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 14,27
 //_ Attributes Constant="0"
 Object ( Variant Sel) Input:A;  //_GUI 15,41
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 150,36
 Object ( Variant Out1) "2^N_List"( Variant In1) ;  //_GUI 21,25
 Object Text;  //_GUI 18,14,Bring the number \x01of elements up to \x01a power of two.
 Object ( Variant Size) ListSize( Variant List) ;  //_GUI 54,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,27
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 66,32
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 85,33
 //_ Attributes Documentation="ztlist"
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 123,48
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 133,34
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 115,33
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 102,35
 Object ( Variant Out1) 2MinList( Variant In1) ;  //_GUI 39,25
 //_ Attributes Documentation="var"
 Object Text;  //_GUI 38,17,Make at least \x01two elements

 //_ Behavior Topology
 Output.0 = AND.0;  
 "2^N_List".0 = Input.0;  
 ListSize.0 = Junction.2;  //_GUI 52,35
 Junction.0 = 2MinList.0;  
 MaskToNum.0 = ListSize.0;  
 UExtnd.0 = MaskToNum.0;  
 UExtnd.1 = Input:A.0;  //_GUI 85,42
 INVERT.0 = UExtnd.0;  //_GUI 99,51, 99,35
 AND.0 = $List_Mux_Sel.0;  
 AND.1 = INVERT.0;  
 $List_Mux_Sel.0 = Junction.1;  //_GUI 115,28
 $List_Mux_Sel.1 = MSB.0;  
 MSB.0 = UExtnd.1;  
 2MinList.0 = "2^N_List".0;  
}

Object ( Variant Data) List_Mux_Sel_vivado( Variant ListData, NULL Sel) 
//_ Attributes TreeGroup="CoreLib_James\\\\CoreLib\\\\Multiplexers\\\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,11
 //_ Attributes Constant="0"
 Object ( NULL Sel) Input:A;  //_GUI 23,24
 //_ Attributes Constant="0"
 Object Output( Variant Data) ;  //_GUI 82,11
 Object Text;  //_GUI 25,6,The leaf for a 1-dimention mux where the Sel was not a ZTList.
 Object Text;  //_GUI 18,33,We are not selecting, so pass the data through.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) MSB( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="Bit"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 9,25
 Object Output( Bit Out1) ;  //_GUI 33,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) MSB( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="NULL"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 9,25
 Object Output( NULL Out1) ;  //_GUI 33,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) MSB( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a MSB pattern, producing a MSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 132,33
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 105,23
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 122,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,38
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,9
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 21,32
 Object ( Bit In2) Input:A;  //_GUI 27,60
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), 65535, >)"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 45,60
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 91,38
 Object ( Variant Out1) $Cast:A( Variant Data, MSB Type) ;  //_GUI 105,36
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 72,32
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 72,40
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Cast.0 = $Select:A.0;  //_GUI 93,28, 93,12
 $Select.0 = $Cast.0;  //_GUI 115,33
 $Select.1 = $Cast:A.0;  //_GUI 115,36
 $Select.2 = Junction:B.1;  //_GUI 122,61
 VariantIn.0 = $Select:B.0;  //_GUI 49,41
 $Select:A.0 = Junction.1;  
 $Select:A.2 = Junction:A.1;  //_GUI 22,17
 $Select:B.1 = Junction.2;  //_GUI 31,30
 $Select:B.2 = Junction:A.2;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,50, 46,50
 Junction:B.0 = Input:A.0;  
 VariantOut.0 = MSB:A.0;  
 VariantOut.1 = MSB.0;  //_GUI 87,40, 87,35
 $Cast:A.0 = VariantOut.0;  
 MSB.0 = VariantIn.1;  //_GUI 68,35, 68,40
 MSB:A.0 = VariantIn.0;  
}

Object ( Variant Out1) MSB( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="list"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a MSB pattern, producing a MSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 88,8
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 60,8
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 74,6
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 41,2
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 41,10
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 22,8

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantOut.0 = MSB:A.0;  
 VariantOut.1 = MSB.0;  //_GUI 56,10, 56,5
 $Cast.0 = VariantOut.0;  
 MSB.0 = ListIn.1;  //_GUI 37,5, 37,10
 MSB:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( Bit Out1) Zero( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Bit"
{
 // DDescription:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 37,30
 Object Output( Bit Out1) ;  //_GUI 57,41
 Object ( Bit In) Input:A;  //_GUI 38,41
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) Zero( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 106,23
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,22
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 51,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,25
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 90,21

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = Zero:A.0;  //_GUI 68,28, 68,35
 VariantOut.1 = Zero.0;  
 Zero.0 = VariantIn.1;  
 Zero:A.0 = VariantIn.0;  //_GUI 47,35, 47,28
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 89,23, 89,21, 27,21
 Cast.1 = VariantOut.0;  
}

Object ( Signed Out1) Zero( Signed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Signed"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 32,23
 Object Output( Signed Out1) ;  //_GUI 82,23
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 38,21
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 67,21
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 52,21

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = Zero.0;  
 Zero.0 = SignedIn.0;  
}

Object ( Floating Out1) Zero( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Floating"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 43,37
 Object Output( Floating Out1) ;  //_GUI 154,37
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 91,42
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 91,34
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 50,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 69,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 120,35
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 136,35

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 Zero.0 = ListIn.0;  //_GUI 86,45, 86,40
 Zero:A.0 = ListIn.1;  
 FloatingIn.0 = Input.0;  
 ListIn.0 = FloatingIn.0;  
 ListOut.0 = Zero.0;  //_GUI 108,40, 108,45
 ListOut.1 = Zero:A.0;  
 FloatingOut.0 = ListOut.0;  
}

Object ( Fixed Out1) Zero( Fixed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Fixed"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 31,31
 Object Output( Fixed Out1) ;  //_GUI 144,31
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 85,35
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 41,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 57,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 108,29
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 124,29
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 85,28

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 Zero.0 = ListIn.0;  //_GUI 77,38, 77,34
 FixedIn.0 = Input.0;  
 ListIn.0 = FixedIn.0;  
 ListOut.0 = Zero.0;  //_GUI 103,34, 103,38
 ListOut.1 = Zero:A.0;  
 FixedOut.0 = ListOut.0;  
 Zero:A.0 = ListIn.1;  
}

Object ( Complex Out1) Zero( Complex In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Complex"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 26,29
 Object Output( Complex Out1) ;  //_GUI 125,29
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 110,27
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 32,27
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 67,34
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 67,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 46,27
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 95,27

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 ComplexOut.0 = ListOut.0;  
 ComplexIn.0 = Input.0;  
 Zero.0 = ListIn.0;  //_GUI 62,37, 62,32
 Zero:A.0 = ListIn.1;  
 ListIn.0 = ComplexIn.0;  
 ListOut.0 = Zero.0;  //_GUI 84,32, 84,37
 ListOut.1 = Zero:A.0;  
}

Object ( List Out1) Zero( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="List"
{
 // Description:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 22,25
 Object Output( List Out1) ;  //_GUI 91,25
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 75,23
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,32
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 50,22

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Zero.0;  //_GUI 68,28, 68,35
 ListOut.1 = Zero:A.0;  
 Zero.0 = ListIn.0;  //_GUI 47,35, 47,28
 Zero:A.0 = ListIn.1;  
}

Object ( NULL Out1) Zero( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="NULL"
{
 // PDescription:
 // Polymorphic Constant Zero.  Sets the incoming data set to  a constant Zero.
 //
 // Inputs:
 // In1: Incoming data set
 //
 // Outputs:
 // incoming data set with Zero value.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,23
 Object Output( NULL Out1) ;  //_GUI 106,23

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) BitLength( Variant Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns the bitlength of the incoming data set as a numberic constant.  The output data set will have the smallest bitlength possible to represent the constant value.  This means the ouput will always have a leading 1.
 //
 // Inputs:
 //
 // Variant Type: The dataset for which a bit length will be computed.
 //
 // Outputs:
 //
 // Variant output: The bit length of Type as a numeric constant.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 18,20
 Object Output( Variant Out1) ;  //_GUI 57,20
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 26,18
 Object Text;  //_GUI 22,27,The Type input is filtered through an MSB in order to produce a simple data set out of Lists, Contextual data sets, etc.  The $BitLength object then returns the length of this data set.
 Object ( Variant Out1) $BitLength( Variant Type) ;  //_GUI 40,18

 //_ Behavior Topology
 Output.0 = $BitLength.0;  
 MSB.0 = Input.0;  
 $BitLength.0 = MSB.0;  
}

Object ( Bit Out1) BitLength( Bit Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 // Returns the bitlength of the incoming data set as a numberic constant.  The output data set will have the smallest bitlength possible to represent the constant value.  This means the ouput will always have a leading 1.
 //
 // Inputs:
 //
 // Variant Type: The dataset for which a bit length will be computed.
 //
 // Outputs:
 //
 // Variant output: The bit length of Type as a numeric constant.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 18,20
 Object Output( Bit Out1) ;  //_GUI 53,20
 Object ( Bit In) Input:A;  //_GUI 45,20
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) BitLength( NULL Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL"
{
 // Returns the bitlength of the incoming data set as a numberic constant.  The output data set will have the smallest bitlength possible to represent the constant value.  This means the ouput will always have a leading 1.
 //
 // Inputs:
 //
 // Variant Type: The dataset for which a bit length will be computed.
 //
 // Outputs:
 //
 // Variant output: The bit length of Type as a numeric constant.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 18,20
 Object Output( Bit Out1) ;  //_GUI 57,20
 Object ( Bit Type) Input:A;  //_GUI 48,20
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) Equal( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\Async"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,17
 Object ( Variant In2) Input:A;  //_GUI 13,20
 Object Output( Bit Out1) ;  //_GUI 73,18
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 42,16
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 60,16
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 26,16

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 NotZero.0 = XOR.0;  
 INVERT.0 = NotZero.0;  
 XOR.0 = Input.0;  
 XOR.1 = Input:A.0;  
}

Object ( Bit Out1) Equal( Floating In1, Floating In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="Floating"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 13,17
 Object ( Floating In2) Input:A;  //_GUI 13,58
 Object Output( Bit Out1) ;  //_GUI 124,38
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 81,30
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 103,36
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 67,38
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 41,56
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 41,15
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 93,31
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 67,45
 Object Text;  //_GUI 13,96,so -0 == +0 or all types of NaN == NaN or all the bits are equal
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating
    ( Floating In1) ;  //_GUI 20,56
 //_ Attributes Documentation="with NaN"
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating:A
    ( Floating In1) ;  //_GUI 20,15
 //_ Attributes Documentation="with NaN"

 //_ Behavior Topology
 Output.0 = OR.0;  
 AND.0 = ExposeFloating:A.5;  
 AND.1 = ExposeFloating.5;  //_GUI 81,73
 OR.0 = OR:A.0;  
 OR.1 = Equal.0;  
 Equal.0 = CollectBIN:A.0;  //_GUI 60,40, 60,18
 Equal.1 = CollectBIN.0;  //_GUI 60,43, 60,59
 CollectBIN.0 = ExposeFloating.0;  
 CollectBIN.1 = ExposeFloating.1;  
 CollectBIN.2 = ExposeFloating.3;  //_GUI 38,64, 38,67
 CollectBIN:A.0 = ExposeFloating:A.0;  
 CollectBIN:A.1 = ExposeFloating:A.1;  
 CollectBIN:A.2 = ExposeFloating:A.3;  //_GUI 38,23, 38,26
 OR:A.0 = AND.0;  
 OR:A.1 = AND:A.0;  //_GUI 93,48
 AND:A.0 = ExposeFloating:A.10;  
 AND:A.1 = ExposeFloating.10;  //_GUI 67,88
 ExposeFloating.0 = Input:A.0;  
 ExposeFloating:A.0 = Input.0;  
}

Object ( Bit Out1) Equal( NULL In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="NULL"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,17
 Object ( NULL In2) Input:A;  //_GUI 13,22
 Object Output( Bit Out1) ;  //_GUI 56,28
 Object ( Bit In) Input:B;  //_GUI 41,28
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) Equal( Variant In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="var/NULL"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,17
 Object ( NULL In2) Input:A;  //_GUI 13,22
 Object Output( Bit Out1) ;  //_GUI 56,28
 Object ( Bit In) Input:B;  //_GUI 41,28
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) Equal( NULL In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="NULL/var"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,17
 Object ( Variant In2) Input:A;  //_GUI 13,22
 Object Output( Bit Out1) ;  //_GUI 56,28
 Object ( Bit In) Input:B;  //_GUI 41,28
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) Equal( List In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="list"
{
 // Compares two numbers, A and B, and asserts output if equal.  This implementation is usually more efficient than the Equal output of the Compare object.
 //
 // Inputs:
 //
 // Variant input: A
 //
 // Variant input: B
 //
 // Outputs:
 //
 // Bit output: Result
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx, Signed, Floating (-0 == +0, any NAN == any NAN), Fixed, List (has list inputs and bit output), NULL (NULL == NULL) and Complex.  A and B can not have mixed datasets except with respect to size.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 13,17
 Object ( List In2) Input:A;  //_GUI 13,28
 Object Output( Bit Out1) ;  //_GUI 67,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,15
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 21,26
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 40,15
 Object ( Bit Out1) Equal:A( Variant In1, Variant In2) ;  //_GUI 40,26
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,20

 //_ Behavior Topology
 Output.0 = AND.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 Equal.0 = ListIn.1;  
 Equal.1 = ListIn:A.1;  //_GUI 36,20, 36,28
 Equal:A.0 = ListIn.0;  //_GUI 40,24, 32,24
 Equal:A.1 = ListIn:A.0;  
 AND.0 = Equal.0;  //_GUI 52,22, 52,18
 AND.1 = Equal:A.0;  //_GUI 52,25, 52,29
}

Object ( Variant Out1) INVERT( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async"
{
 // Description:
 // Inverts the input data.
 //
 // Inputs:
 // In1:  data
 //
 // Outputs:
 // Out1:  inverted data.
 //
 // Date:
 // March 9, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,22
 Object Output( Variant Out1) ;  //_GUI 109,20
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 70,20
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 29,20
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 49,16
 Object ( Variant Out1) INVERT:A( Variant In1) ;  //_GUI 54,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 24,22
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 92,18

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = INVERT:A.0;  
 VariantOut.1 = INVERT.0;  //_GUI 66,22, 66,19
 VariantIn.0 = Junction.1;  
 INVERT.0 = VariantIn.1;  //_GUI 45,19, 45,22
 INVERT:A.0 = VariantIn.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 86,20, 86,13, 25,13
 Cast.1 = VariantOut.0;  
}

Object ( NULL Out1) INVERT( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$INVERT",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,20
 Object Output( NULL Out1) ;  //_GUI 109,20

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) LSB( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="NULL"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 9,25
 Object Output( NULL Out1) ;  //_GUI 32,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) LSB( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="Bit"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 9,25
 Object Output( Bit Out1) ;  //_GUI 33,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) LSB( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a LSB pattern, producing a LSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 132,33
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 105,23
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 122,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,38
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,9
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 21,32
 Object ( Bit In2) Input:A;  //_GUI 27,60
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), 65535, >)"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 45,60
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 91,38
 Object ( Variant Out1) $Cast:A( Variant Data, LSB Type) ;  //_GUI 105,36
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 72,32
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 72,40
 //_ Attributes Documentation="NULL"

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Cast.0 = $Select:A.0;  //_GUI 93,28, 93,12
 $Select.0 = $Cast.0;  //_GUI 115,33
 $Select.1 = $Cast:A.0;  //_GUI 115,36
 $Select.2 = Junction:B.1;  //_GUI 122,61
 VariantIn.0 = $Select:B.0;  //_GUI 49,41
 $Select:A.0 = Junction.1;  
 $Select:A.2 = Junction:A.1;  //_GUI 22,17
 $Select:B.1 = Junction.2;  //_GUI 31,30
 $Select:B.2 = Junction:A.2;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,50, 46,50
 Junction:B.0 = Input:A.0;  
 VariantOut.0 = LSB:A.0;  
 VariantOut.1 = LSB.0;  //_GUI 87,40, 87,35
 $Cast:A.0 = VariantOut.0;  
 LSB.0 = VariantIn.1;  //_GUI 68,35, 68,40
 LSB:A.0 = VariantIn.0;  
}

Object ( Variant Out1) LSB( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="list"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a LSB pattern, producing a LSBxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 84,8
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 58,8
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 72,6
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 39,2
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 39,10
 //_ Attributes Documentation="NULL"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,8

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantOut.0 = LSB:A.0;  
 VariantOut.1 = LSB.0;  //_GUI 54,10, 54,5
 $Cast.0 = VariantOut.0;  
 LSB.0 = ListIn.1;  //_GUI 35,5, 35,10
 LSB:A.0 = ListIn.0;  
 ListIn.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Variant Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Variant"
{
 // Date:
 // 04 Oct 2002
 //
 //
 //
 // Recursive object that used in Lo_N implementation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 15,23
 Object ( Variant Lo) Input:A;  //_GUI 16,39
 Object ( Variant Lo_N) Input:B;  //_GUI 47,48
 Object Output( Variant Hi) ;  //_GUI 109,25
 Object Output:A( Variant Lo) ;  //_GUI 109,28
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 56,46
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 44,29
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 57,27
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 23,21
 Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Variant Lo_N) ;  //_GUI 90,24
 //_ Attributes Documentation="Variant/Variant"

 //_ Behavior Topology
 Output.0 = $Lo_N.0;  
 Output:A.0 = $Lo_N.1;  
 VariantIn.0 = Input:B.0;  
 VariantOut.0 = Input:A.0;  //_GUI 40,34, 40,40
 VariantOut.1 = VariantIn:A.0;  //_GUI 37,31, 37,26
 $Cast.0 = VariantOut.0;  
 VariantIn:A.0 = Input.0;  
 $Lo_N.0 = VariantIn:A.1;  //_GUI 72,26, 72,23
 $Lo_N.1 = $Cast.0;  //_GUI 80,29, 80,30
 $Lo_N.2 = VariantIn.1;  //_GUI 70,32, 70,48
}

Object ( Variant Hi, Variant Lo) $Lo_N( Variant Hi
    , Variant Lo, Bit Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant Leaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 38,27
 Object ( Variant Lo) Input:A;  //_GUI 40,40
 Object ( Bit Lo_N) Input:B;  //_GUI 45,52
 Object Output( Variant Hi) ;  //_GUI 63,26
 Object Output:A( Variant Lo) ;  //_GUI 96,36
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,36
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 46,25
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 81,34

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = $Cast.0;  
 VariantOut.0 = Input:A.0;  
 VariantOut.1 = VariantIn.0;  //_GUI 60,38, 60,30
 VariantIn.0 = Input.0;  
 $Cast.0 = VariantOut.0;  
}

Object ( NULL Hi, Variant Lo) $Lo_N( Bit Hi
    , Variant Lo, Bit Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit Leaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Hi) Input;  //_GUI 38,29
 Object ( Variant Lo) Input:A;  //_GUI 40,40
 Object ( Bit Lo_N) Input:B;  //_GUI 45,52
 Object Output( NULL Hi) ;  //_GUI 86,26
 Object Output:A( Variant Lo) ;  //_GUI 96,36
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,36
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 81,34
 Object ( NULL Out1) NULL;  //_GUI 69,24

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = $Cast.0;  
 VariantOut.0 = Input:A.0;  
 VariantOut.1 = Input.0;  //_GUI 60,38, 60,30
 $Cast.0 = VariantOut.0;  
}

Object ( NULL Hi, Variant Lo) $Lo_N( Bit Hi
    , Variant Lo, Variant Lo_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="ErrorLeaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Hi) Input;  //_GUI 38,28
 Object ( Variant Lo) Input:A;  //_GUI 40,40
 Object ( Variant Lo_N) Input:B;  //_GUI 45,52
 Object Output( NULL Hi) ;  //_GUI 86,26
 Object Output:A( Variant Lo) ;  //_GUI 127,34
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,36
 Object ( Variant Out1) $Cast( Variant Data, MSB Type) ;  //_GUI 81,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 99,32
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 113,32
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 51,50
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 70,49
 Object ( NULL Out1) NULL;  //_GUI 69,24

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = MSB.0;  
 VariantOut.0 = Input:A.0;  
 VariantOut.1 = Input.0;  //_GUI 59,38, 59,29
 $Cast.0 = VariantOut.0;  
 ListOut.0 = $Cast.0;  
 ListOut.1 = Zero.0;  //_GUI 93,34, 93,52
 MSB.0 = ListOut.0;  
 VariantIn.0 = Input:B.0;  
 Zero.0 = VariantIn.1;  
}

Object ( NULL Out1) NULL
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object creates a NULL dataset (transport) instance.  The only supported way to instantiate a NULL dataset is to drop this object on your sheet.  Any other way is potentially erroneous.
 //
 // Inputs:
 //
 // None
 //
 // Outputs:
 //
 // NULL output: Outputs a NULL dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object Output( NULL Out1) ;  //_GUI 77,31
 Object ( NULL NULL_Remove) Input;  //_GUI 47,31
 //_ Attributes Resource="Global",PromoteToParentObject="False",WarnOnRemoval="False"

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced",Documentation="PadLeft"
{
 // This does an unsigned extend of the data when converting to a larger dataset size.  If shrinking the dataset, the OFL will go high if any of the discarded bits were high.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to unsign extend
 //
 // Outputs:
 //
 // Bit/List OFL: 1 if any removed bits were high.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,38
 Object ( Variant Data) Input:A;  //_GUI 7,51
 Object Output( Bit OFL) ;  //_GUI 215,29
 Object Output:A( Variant Out1) ;  //_GUI 204,37
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 104,50
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 169,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 38,64
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 120,49
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 94,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 34,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 38,67
 Object Text;  //_GUI 77,73,So if the data is shorter then the type, we need to tack on some zero fill on the top.
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 169,27
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 104,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 163,51
 Object Text;  //_GUI 41,10,If we lose non-zero data on the high end, that's an overflow.
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 117,33
 //_ Attributes Documentation="Bit"
 Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) ;  //_GUI 136,34
 //_ Attributes Documentation="Variant"
 Object ( Bit In) Input:B;  //_GUI 132,38
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 122,10,If the UExtend inputs Type and Data are the same sizes, the Hi output of Lo_N will be NULL.  In this case there is no overflow, so change it to a bit of value zero with ZeroNulls.
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 203,27
 Object ( Bit In) Input:C;  //_GUI 163,31
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 19,65
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 18,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 14,51
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 134,50
 //_ Attributes Documentation="ztl/var"
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 187,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In0) ;  //_GUI 51,47
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,46
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 55,64
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 51,25
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 55,42
 Object ( Variant Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 64,35

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 Lo_N.0 = $Select:E.0;  //_GUI 93,52, 93,38
 Lo_N.1 = Junction:A.1;  
 $Select.0 = Lo_N:A.1;  //_GUI 114,46
 $Select.1 = PushLsb.0;  //_GUI 161,49, 161,53
 $Select.2 = Junction:D.2;  
 Junction.0 = Junction:C.0;  
 Zero.0 = Lo_N.0;  
 Junction:A.0 = $Select:C.0;  //_GUI 84,55, 84,60
 Junction:B.0 = Junction:E.1;  
 Junction:C.0 = BitA_Ge_BitB.0;  
 $Select:A.0 = ZeroNulls.0;  //_GUI 149,29, 149,37
 $Select:A.1 = Input:C.0;  
 $Select:A.2 = Junction:D.1;  //_GUI 164,35
 Lo_N:A.0 = $Select:B.0;  //_GUI 87,36, 87,49
 Lo_N:A.1 = $Select:D.0;  //_GUI 98,39, 98,27
 Junction:D.0 = Junction:C.1;  //_GUI 164,68
 NotZero.0 = Lo_N:A.0;  
 ZeroNulls.0 = NotZero.0;  
 ZeroNulls.1 = Input:B.0;  
 VouchBit.0 = $Select:A.0;  
 BitA_Ge_BitB.0 = Junction:E.2;  
 BitA_Ge_BitB.1 = Junction:F.2;  //_GUI 15,70
 Junction:E.0 = Input.0;  
 Junction:F.0 = Input:A.0;  
 PushLsb.0 = Zero.0;  
 PushLsb.1 = Junction:A.2;  //_GUI 134,64, 95,64
 Context.0 = Junction:B.0;  //_GUI 187,8, 35,8
 Context.1 = $Select.0;  //_GUI 183,40, 183,47
 Junction:G.0 = Junction:F.1;  //_GUI 31,48, 31,52
 $Select:B.0 = Junction:G.1;  
 $Select:B.2 = Junction:H.0;  //_GUI 56,54
 Junction:H.0 = Junction.2;  
 $Select:C.1 = Junction:G.2;  //_GUI 52,62
 $Select:C.2 = Junction:H.1;  
 Junction:I.0 = Junction:B.1;  //_GUI 43,26, 43,39
 $Select:D.0 = Junction:I.1;  
 $Select:D.2 = Junction:J.0;  //_GUI 56,32
 Junction:J.0 = Junction.1;  //_GUI 39,43
 $Select:E.1 = Junction:I.2;  //_GUI 52,40
 $Select:E.2 = Junction:J.1;  
}

Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Bit Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Var/Bit"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 46,46
 Object ( Bit Data) Input:A;  //_GUI 48,56
 Object Output( Bit OFL) ;  //_GUI 89,46
 Object Output:A( Variant Out1) ;  //_GUI 97,49
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 54,44
 Object ( Bit C, Variant Out2) SHL( Variant In1
    , Bit C) ;  //_GUI 74,45
 //_ Attributes Documentation="Variant"
 Object Text;  //_GUI 42,65,This is an optimization for when the Data input is a Bit.  An Unsigned Extension can simply be done by by using a Rotate-Carry-Left into an zeroed-out data set.

 //_ Behavior Topology
 Output.0 = SHL.0;  
 Output:A.0 = SHL.1;  
 Zero.0 = Input.0;  
 SHL.0 = Zero.0;  
 SHL.1 = Input:A.0;  //_GUI 68,50, 68,57
}

Object ( List OFL, List Out1) UExtnd( Variant Type
    , List Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="var/List"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 54,29
 Object ( List Data) Input:A;  //_GUI 54,33
 Object Output( List OFL) ;  //_GUI 128,23
 Object Output:A( List Out1) ;  //_GUI 123,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 75,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 60,31
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 108,31
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 111,21
 Object ( Variant OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 79,43
 //_ Attributes Documentation="PadLeft"
 Object ( Variant OFL, Variant Out1) UExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 79,28
 //_ Attributes Documentation="PadLeft"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = UExtnd.1;  //_GUI 102,36, 102,48
 ListOut.1 = UExtnd:A.1;  
 ListOut:A.0 = UExtnd.0;  //_GUI 95,26, 95,45
 ListOut:A.1 = UExtnd:A.0;  //_GUI 89,23
 UExtnd.0 = Junction.2;  //_GUI 76,45
 UExtnd.1 = ListIn.0;  //_GUI 71,48
 UExtnd:A.0 = Junction.1;  
 UExtnd:A.1 = ListIn.1;  
}

Object ( Bit OFL, NULL Out1) UExtnd( NULL Type
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="NULL/var"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( Variant Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,12
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 23,21

 //_ Behavior Topology
 Output.0 = NotZero.0;  //_GUI 35,13
 Output:A.0 = Input.0;  
 NotZero.0 = Input:A.0;  
}

Object ( Bit OFL, NULL Out1) UExtnd( NULL Type
    , NULL Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="NULL/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , NULL Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="var/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( Variant Out1) ;  //_GUI 53,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,15

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( List OFL, List Out1) UExtnd( List Type
    , List Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced",Documentation="list"
{
 // This does an unsigned extend of the data when converting to a larger dataset size.  If shrinking the dataset, the OFL will go high if any of the discarded bits were high.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to unsign extend
 //
 // Outputs:
 //
 // Bit/List OFL: 1 if any removed bits were high.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 6,15
 Object ( List Data) Input:A;  //_GUI 6,24
 Object Output( List OFL) ;  //_GUI 55,22
 Object Output:A( List Out1) ;  //_GUI 55,31
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 12,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 42,20
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 12,22
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 42,29
 Object ( Variant OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 26,29
 //_ Attributes Documentation="PadLeft"
 Object ( Variant OFL, Variant Out1) UExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 29,13
 //_ Attributes Documentation="PadLeft"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = UExtnd.0;  //_GUI 36,25
 ListOut.1 = UExtnd:A.0;  //_GUI 42,15
 ListIn:A.0 = Input:A.0;  
 ListOut:A.0 = UExtnd.1;  
 ListOut:A.1 = UExtnd:A.1;  //_GUI 39,31
 UExtnd.0 = ListIn.0;  //_GUI 26,18
 UExtnd.1 = ListIn:A.0;  //_GUI 23,34
 UExtnd:A.0 = ListIn.1;  
 UExtnd:A.1 = ListIn:A.1;  //_GUI 29,24
}

Object ( Bit Out1) One( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Bit"
{
 // One - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 47,30
 Object Output( Bit Out1) ;  //_GUI 64,37
 Object ( Bit In) Input:A;  //_GUI 47,37
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Floating Out1) One( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Floating"
{
 // One - Variant Select Case
 //
 // Date:
 // 11 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 9,29
 Object Output( Floating Out1) ;  //_GUI 104,29
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 45,32
 Object ( Variant Out1) Zero:A( Variant In1) ;  //_GUI 41,14
 Object Text;  //_GUI 41,40,Mantissa is set to Zero.
 Object Text;  //_GUI 51,20,Exponent is bit pattern 01111...
 Object Text;  //_GUI 42,9,Sign is Zero
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 16,27
 Object ( Floating Out1) CollectFloating( Bit Sign, Variant BExp
    , Variant Mant) ;  //_GUI 87,27
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 55,24

 //_ Behavior Topology
 Output.0 = CollectFloating.0;  
 Zero.0 = ExposeFloating.2;  
 Zero:A.0 = ExposeFloating.0;  //_GUI 36,17, 36,29
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = Zero:A.0;  //_GUI 83,29, 83,17
 CollectFloating.1 = MakeBias.0;  //_GUI 80,32, 80,27
 CollectFloating.2 = Zero.0;  
 MakeBias.0 = ExposeFloating.1;  //_GUI 39,27, 39,32
}

Object ( Fixed Out1) One( Fixed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Fixed"
{
 // One - Variant Select Case
 //
 // Date:
 // 11 Nov  2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 12,19
 Object Output( Fixed Out1) ;  //_GUI 69,19
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 37,23
 Object Text;  //_GUI 38,34,Fraction portion is Zero.
 Object Text;  //_GUI 38,10,Whole portion is One
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 37,16
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 18,17
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 53,17

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 34,26, 34,22
 One.0 = ExposeFixed.0;  
 ExposeFixed.0 = Input.0;  
 CollectFixed.0 = One.0;  
 CollectFixed.1 = Zero.0;  //_GUI 50,22, 50,26
}

Object ( Signed Out1) One( Signed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Signed"
{
 // One - Signed case
 //
 // Date:
 // Added trap May 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 13,22
 Object Output( Signed Out1) ;  //_GUI 72,22
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 19,20
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 57,20
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 43,20
 Object ( Bit Out1) IsBit( Variant Type) ;  //_GUI 38,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,22
 Object Output:A( Bit Trap) ;  //_GUI 54,34
 //_ Attributes Trap="Signed dataset has sign bit only."

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = One.0;  
 One.0 = Junction.1;  
 IsBit.0 = Junction.2;  //_GUI 35,35
 Junction.0 = SignedIn.0;  
 Output:A.0 = IsBit.0;  
}

Object ( List Out1) One( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="List"
{
 // One - Variant Select Case
 //
 // Sets all Values in Vector to One.
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 10,20
 Object Output( List Out1) ;  //_GUI 64,20
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 17,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 50,18
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 34,24
 Object ( Variant Out1) One:A( Variant In1) ;  //_GUI 34,17

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = One.0;  //_GUI 47,23, 47,27
 ListOut.1 = One:A.0;  
 One.0 = ListIn.0;  //_GUI 31,27, 31,23
 One:A.0 = ListIn.1;  
}

Object ( Variant Out1) One( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps"
{
 // Polymorphic Constant One - will prodoce a logically correct one for any data set given on the input.
 //
 // Date:
 // 17 May 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 27,30
 Object Output( Variant Out1) ;  //_GUI 122,28
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 65,27
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 88,28
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 38,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 33,30
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 109,26
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 64,38

 //_ Behavior Topology
 Output.0 = Cast.0;  
 Zero.0 = VariantIn.1;  
 VariantOut.0 = One.0;  //_GUI 83,33, 83,41
 VariantOut.1 = Zero.0;  
 VariantIn.0 = Junction.1;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 105,28, 105,25, 34,25
 Cast.1 = VariantOut.0;  
 One.0 = VariantIn.0;  //_GUI 57,41, 57,33
}

Object ( Complex Out1) One( Complex In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="Complex"
{
 // One - Variant Select Case
 //
 // Sets all Values in Vector to One.
 //
 // Date:
 // 11 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 13,16
 Object Output( Complex Out1) ;  //_GUI 75,16
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 40,13
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 40,22
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 19,14
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 56,14

 //_ Behavior Topology
 Output.0 = CollectComplex.0;  
 One.0 = ExposeComplex.0;  
 Zero.0 = ExposeComplex.1;  //_GUI 37,25, 37,19
 ExposeComplex.0 = Input.0;  
 CollectComplex.0 = One.0;  
 CollectComplex.1 = Zero.0;  //_GUI 54,19, 54,25
}

Object ( NULL Out1) One( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal\\ZeroOne",Documentation="NULL"
{
 // One - Variant Select Case
 //
 // Date:
 // 11 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,22
 Object Output( NULL Out1) ;  //_GUI 24,22

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant S) Add( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronous addition.
 //
 // Because this is an asynchronou
 // s object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Number
 //
 // Variant B: Number
 //
 // Outputs:
 //
 // Variant S: The Sum of A and B.  If the dataset of A and B are the same, then the dataset of S will also be the same.  If the dataset of A and B are different, the dataset of S will be the result of a Symmetrize of the two inputs.  In this case a compile-time warning is generated indicating the input datasets were different.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed, Complex and List. If one input is a list and the other is not, the other is duplicated into an equivalent list of the one.  A and B can not have mixed datasets except with respect to size or for the cases of MSB, LSB and BIN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 15,15
 Object ( Variant B) Input:A;  //_GUI 15,18
 Object Output( Variant S) ;  //_GUI 48,18
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 26,14
 //_ Attributes Documentation="List"

 //_ Behavior Topology
 Output.0 = Add.1;  
 Add.0 = Input.0;  
 Add.1 = Input:A.0;  
}

Object ( Variant Out1) "2^N_List"( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Takes in a list of any order and adds zeroed MSB elements on the MSB end until there are two to the power of N elements.  The list is output in LSB order.  If the input is a single element list (a variant) then the output is the same.  This is because 1 = 2^N where N = 0.
 //
 // Inputs:
 //
 // Variant input: The input list.
 //
 // Outputs:
 //
 // Variant output: The output list where the number of elements is rounded up to the nearest two to the N elements by adding zeroed elements of the MSB element of the input list onto the MSB end of the output list which is put into LSB order.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 10,14
 Object Output( Variant Out1) ;  //_GUI 39,14
 Object ( Variant Out1) "2^N_LSBList"( List In1) ;  //_GUI 21,12
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = "2^N_LSBList".0;  
 "2^N_LSBList".0 = Input.0;  
}

Object ( Variant Out1) "2^N_List"( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // Takes in a list of any order and adds zeroed MSB elements on the MSB end until there are two to the power of N elements.  The list is output in LSB order.  If the input is a single element list (a variant) then the output is the same.  This is because 1 = 2^N where N = 0.
 //
 // Inputs:
 //
 // Variant input: The input list.
 //
 // Outputs:
 //
 // Variant output: The output list where the number of elements is rounded up to the nearest two to the N elements by adding zeroed elements of the MSB element of the input list onto the MSB end of the output list which is put into LSB order.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 12,24
 Object Output( Variant Out1) ;  //_GUI 41,24
 Object Text;  //_GUI 13,7,A Variant input means this is a single element list.  A single element list has 2^N elements where N is 0. Therefore just pass the single element list through.  If you want at least 2 elements, call 2MinList afterwords.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Size) ListSize( Variant List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object returns the number of elements in the list as the number of bits in the output dataset.
 //
 // Note:  Lists can have elements of NULL, which will be counted the same as any other element.  There is an ambiguity between an empty list (NULL) and a single element list where the element is NULL. Both cases will be counted as having 0 elements.
 //
 // Inputs:
 //
 // Variant List: The list to size.
 //
 // Outputs:
 //
 // Variant Size: The number of bits in this LSBxxx dataset represents the number of elements in the input List.  This output could also be a Bit if the input is a single element list (a Variant).  This output could also be a NULL (zero bits) if the input is an empty list (a NULL).  This output has the value of zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 11,16
 Object Output( Variant Size) ;  //_GUI 35,16
 Object ( Bit In) Input:A;  //_GUI 27,16
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Size) ListSize( List List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="List"
{
 // This object returns the number of elements in the list as the number of bits in the output dataset.
 //
 // Note:  Lists can have elements of NULL, which will be counted the same as any other element.  There is an ambiguity between an empty list (NULL) and a single element list where the element is NULL. Both cases will be counted as having 0 elements.
 //
 // Inputs:
 //
 // Variant List: The list to size.
 //
 // Outputs:
 //
 // Variant Size: The number of bits in this LSBxxx dataset represents the number of elements in the input List.  This output could also be a Bit if the input is a single element list (a Variant).  This output could also be a NULL (zero bits) if the input is an empty list (a NULL).  This output has the value of zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 18,24
 Object Output( Variant Size) ;  //_GUI 89,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 62,22
 Object Text;  //_GUI 27,37,This object returns a data set with as many bits as the List has elements.
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 76,22
 Object ( Variant Size) $ListSize( Variant List) ;  //_GUI 47,16
 //_ Attributes Documentation="List"
 Object ( Variant Size) $ListSize:A( Variant List) ;  //_GUI 46,24
 //_ Attributes Documentation="List"
 Object Text;  //_GUI 27,45,We have the $ListSize layer so we can distinguish empty elements (and count them) from empty lists (and not count them).

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $ListSize:A.0;  
 ListOut.1 = $ListSize.0;  //_GUI 57,24
 LSB.0 = ListOut.0;  
 $ListSize.0 = ListIn.1;  //_GUI 44,19, 44,24
 $ListSize:A.0 = ListIn.0;  
}

Object ( NULL Size) ListSize( NULL List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object returns the number of elements in the list as the number of bits in the output dataset.
 //
 // Note:  Lists can have elements of NULL, which will be counted the same as any other element.  There is an ambiguity between an empty list (NULL) and a single element list where the element is NULL. Both cases will be counted as having 0 elements.
 //
 // Inputs:
 //
 // Variant List: The list to size.
 //
 // Outputs:
 //
 // Variant Size: The number of bits in this LSBxxx dataset represents the number of elements in the input List.  This output could also be a Bit if the input is a single element list (a Variant).  This output could also be a NULL (zero bits) if the input is an empty list (a NULL).  This output has the value of zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL List) Input;  //_GUI 13,21
 Object Output( NULL Size) ;  //_GUI 40,21
 Object Text;  //_GUI 14,27,Assume this is an empty list.  In doing so we won't detect a single emenemt list where the element is a NULL

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Num) MaskToNum( Variant Mask) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Encoders/Decoders\\$Internal"
{
 // This object replaces the traditional EncodeRev object.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Mask) Input;  //_GUI 45,20
 Object Output( Variant Num) ;  //_GUI 168,21
 Object Text;  //_GUI 11,71,uint32_t HcGetPeNumFromMask(uint32_t peMask){      int x;      for(x = 0; x < sizeof(peMask)*8; x++)                 if ( (1<<x) & peMask) return(x);      return(NO_PE);}
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 76,18
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 152,19
 Object Text;  //_GUI 44,4,We begin by converting our bits to a BIN type, whose bitlength is an exact power of 2.
 Object Text;  //_GUI 102,51,At each step of the recursion, we break the BIN type in half and determine  one bit at a time of our output data set beginning with the most-significant.  At each stage of the recursion, the top bit will be set to 1 if the top-half of the BIN data set contains the 1 we are searching for.
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 108,23
 Object ( Bit In) Input:A;  //_GUI 114,35
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 107,19
 Object ( Variant Out1) $MaskToNum( Variant Data, Variant Lower) ;  //_GUI 128,18
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $MaskToNum:A( Variant Data, Variant Lower) ;  //_GUI 125,31
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) "Pad2^N"( Variant In1) ;  //_GUI 52,18

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = "Pad2^N".0;  
 OR.0 = $MaskToNum.0;  
 OR.1 = $MaskToNum:A.0;  //_GUI 145,24, 145,34
 NotZero.0 = Junction.2;  
 Junction.0 = VariantIn.1;  
 $MaskToNum.0 = Junction.1;  
 $MaskToNum.1 = NotZero.0;  //_GUI 125,23, 125,26
 $MaskToNum:A.0 = VariantIn.0;  //_GUI 99,33, 99,23
 $MaskToNum:A.1 = Input:A.0;  
 "Pad2^N".0 = Input.0;  
}

Object ( NULL Num) MaskToNum( Bit Mask) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Mask) Input;  //_GUI 45,20
 Object Output( NULL Num) ;  //_GUI 82,23
 Object Text;  //_GUI 49,31,If the Encode receives only one input bit, the value can only be zero. This is NULL to give symmetry to the numToMask operation.
 Object ( NULL Out1) NULL;  //_GUI 64,21

 //_ Behavior Topology
 Output.0 = NULL.0;  
}

Object ( Variant Out1) AND( Variant In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,16
 Object ( NULL In2) Input:A;  //_GUI 27,22
 Object Output( Variant Out1) ;  //_GUI 44,16
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,14
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( Variant Out1) AND( NULL In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="NULL/Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 26,9
 Object ( Variant In1) Input:A;  //_GUI 26,16
 Object Output( Variant Out1) ;  //_GUI 44,16
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,14
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input:A.0;  
}

Object ( Variant Out1) AND( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async\\AND"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 12,24
 Object ( Variant In2) Input:A;  //_GUI 12,27
 Object Output( Variant Out1) ;  //_GUI 57,25
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 42,23
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 28,23
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $AND.0;  
 $AND.0 = Symmetrize.0;  
 $AND.1 = Symmetrize.1;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( Variant Out1) AND( Bit In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Bit\\Variant"
{
 // AND - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,26
 Object Output( Variant Out1) ;  //_GUI 120,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 73,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,24
 Object ( Variant Out1) AND( Bit In1, Variant In2) ;  //_GUI 57,24
 Object ( Variant Out1) AND:A( Bit In1, Variant In2) ;  //_GUI 57,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 24,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 95,15

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = AND.0;  //_GUI 71,22, 71,27
 VariantOut.1 = AND:A.0;  
 VariantIn.0 = Junction:A.1;  
 AND.0 = Junction.2;  //_GUI 52,26, 52,23, 43,23
 AND.1 = VariantIn.0;  
 AND:A.0 = Junction.1;  
 AND:A.1 = VariantIn.1;  //_GUI 49,21, 49,26
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction:A.2;  //_GUI 92,17, 92,33, 25,33
 Cast.1 = VariantOut.0;  
}

Object ( Variant Out1) AND( Variant In2, Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Variant\\Bit"
{
 // AND - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,18
 Object ( Bit In1) Input:A;  //_GUI 12,28
 Object Output( Variant Out1) ;  //_GUI 98,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 20,16
 Object ( Variant Out1) AND( Variant In2, Bit In1) ;  //_GUI 48,16
 Object ( Variant Out1) AND:A( Variant In2, Bit In1) ;  //_GUI 48,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 43,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 17,18
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 81,15

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = AND:A.0;  //_GUI 63,22, 63,27
 VariantOut.1 = AND.0;  
 VariantIn.0 = Junction:A.1;  
 AND.0 = VariantIn.1;  
 AND.1 = Junction.0;  //_GUI 44,21
 AND:A.0 = VariantIn.0;  //_GUI 39,26, 39,21
 AND:A.1 = Junction.1;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 79,17, 79,12, 18,12
 Cast.1 = VariantOut.0;  
}

Object ( List Out1) AND( List In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = AND.0;  //_GUI 65,29, 65,32
 ListOut.1 = AND:A.0;  //_GUI 66,26, 66,23
 AND.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 AND.1 = Junction.1;  
 AND:A.0 = ListIn.1;  
 AND:A.1 = Junction.0;  //_GUI 46,25
}

Object ( List Out1) AND( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var\\List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = AND:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = AND.0;  
 AND.0 = Junction.1;  
 AND.1 = ListIn.1;  //_GUI 41,21, 41,26
 AND:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 AND:A.1 = ListIn.0;  
}

Object ( NULL Out1) AND( NULL In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 26,16
 Object ( NULL In2) Input:A;  //_GUI 27,22
 Object Output( NULL Out1) ;  //_GUI 44,16

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) AND( List In2, Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Bit In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = AND.0;  //_GUI 65,29, 65,32
 ListOut.1 = AND:A.0;  //_GUI 66,26, 66,23
 AND.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 AND.1 = Junction.1;  
 AND:A.0 = ListIn.1;  
 AND:A.1 = Junction.0;  //_GUI 46,25
}

Object ( List Out1) AND( Bit In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Bit\\List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Bit\\Variant"
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Bit\\Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = AND:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = AND.0;  
 AND.0 = Junction.1;  
 AND.1 = ListIn.1;  //_GUI 41,21, 41,26
 AND:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 AND:A.1 = ListIn.0;  
}

Object ( Variant Out1) AND( List In2, List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\List"
{
 // updated Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 11,25
 Object Output( Variant Out1) ;  //_GUI 44,23
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 19,21
 //_ Attributes Documentation="List\\List"
 Object Text;  //_GUI 11,31,Will warn if lists are different sizes.

 //_ Behavior Topology
 Output.0 = $AND_SameLists.0;  
 $AND_SameLists.0 = Input.0;  
 $AND_SameLists.1 = Input:A.0;  
}

Object ( Bit Out1) AND( Bit In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Bit/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Bit Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) AND( NULL In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Null/Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Bit In2) Input:A;  //_GUI 21,22
 Object Output( Bit Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,25
 Object ( Variant Sel) Input:A;  //_GUI 15,41
 Object Output( Variant Data) ;  //_GUI 132,32
 Object ( Variant Hi, Variant Lo) Bisect( Variant In1) ;  //_GUI 47,23
 //_ Attributes Documentation="zterm"
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 86,29
 Object ( Variant MSB, Variant Out1) PopMsb( Variant In1) ;  //_GUI 62,39
 //_ Attributes Documentation="zterm"
 Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 104,30
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $List_Mux_Sel.0;  
 Bisect.0 = Input.0;  
 Mux.0 = Bisect.1;  //_GUI 86,28
 Mux.1 = Bisect.0;  //_GUI 66,34, 66,25
 Mux.2 = PopMsb.0;  //_GUI 86,41
 PopMsb.0 = Input:A.0;  
 $List_Mux_Sel.0 = Mux.0;  
 $List_Mux_Sel.1 = PopMsb.1;  //_GUI 104,44
}

Object ( Variant Data) $List_Mux_Sel( Variant ListData, NULL Sel) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,25
 Object ( NULL Sel) Input:A;  //_GUI 15,41
 Object Output( Variant Data) ;  //_GUI 131,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) 2MinList( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 // Makes the list at least 2 elements long.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 25,25
 Object Output( List Out1) ;  //_GUI 60,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 47,21
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 35,20
 //_ Attributes Documentation="ztlist"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 31,25
 Object Text;  //_GUI 23,7,A variant is a single element list.  Make it a 2 element list by adding an element (of the same dataset) on the most significant end with a value of zero

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Junction.1;  
 ListOut.1 = Zero.0;  
 Zero.0 = Junction.0;  //_GUI 32,23
 Junction.0 = Input.0;  
}

Object ( List Out1) 2MinList( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Makes the list at least 2 elements long.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 25,25
 Object Output( List Out1) ;  //_GUI 60,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 47,21
 Object Text;  //_GUI 23,7,A NULL is a 0 element list.  We don't know the original dataset of the list, so just pick a bit. Make it a 2 element list by adding two elements.
 Object ( Bit In) Input:A;  //_GUI 37,22
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 43,22

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Junction.2;  //_GUI 44,26
 ListOut.1 = Junction.1;  
 Junction.0 = Input:A.0;  
}

Object ( List Out1) 2MinList( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Makes the list at least 2 elements long.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 27,23
 Object Output( List Out1) ;  //_GUI 60,23
 Object Text;  //_GUI 26,10,A list dataset is guaranteed to have at least two elements, so, do nothing to it.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) Cast( Variant Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters"
{
 // The Cast operator is used to provide type information in the synthesizor when ambiguities exist, or when the type information could not be known any other way.  There are only two places where Cast should be used. ($Cast should never be used.)
 //
 // Feedback:
 // In a feedback situation, the input type cannot possibly be known until the output type has been propogated.  The Cast object before the input provides type information in this loop.  It is safest to place a Convert object (2-1 footprint) before the Cast since the Cast object cannot do any conversions - not even LSB -> MSB.  As the pattern of your data sets may change in an operator, using the Convert object before a Cast is always the safest bet.  See Count as an example.
 //
 // Ambiguous Collection:
 // In a recursive object that utilizes Variant Exposers and Collectors, you may encouter a situation where the two child data sets may be collected into several parent data sets.  The use of a Cast object (taking its Type from the original data set before the Exposer) after a Variant Collector guarantees collection into the correct data set.  This is seen in countless library objects.  It is actually recommended that a Cast always follow a Variant Collector.
 //
 // Inputs:
 //
 // Variant Type: The resulting dataset
 //
 // Variant Data: The input data and dataset (always the same dataset as Type)
 //
 // Outputs:
 //
 // Variant output: Data with dataset Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 26,19
 Object ( Variant Data) Input:A;  //_GUI 26,22
 Object Output( Variant Out1) ;  //_GUI 44,20
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 32,18

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 $Cast.0 = Input:A.0;  
 $Cast.1 = Input.0;  
}

Object ( Floating Out1) Cast( Floating Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Floating"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 17,22
 Object ( Variant Data) Input:A;  //_GUI 16,36
 Object Output( Floating Out1) ;  //_GUI 142,28
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 80,25
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 80,36
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 28,20
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 127,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 45,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 111,26
 Object Text;  //_GUI 86,10,We break up the Floating data set until we get to the Nums inside.  These are then casted using the primitive $Cast.
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 25,34
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 46,36
 Object Text;  //_GUI 21,47,contextual followed by a list: the null on the top of the first variant splitter is how the contextual works

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 $Cast.0 = VariantIn:A.1;  //_GUI 67,30, 67,38
 $Cast.1 = ListIn.1;  //_GUI 76,27, 76,22
 $Cast:A.0 = VariantIn:A.0;  
 $Cast:A.1 = ListIn.0;  //_GUI 74,38, 74,25
 FloatingIn.0 = Input.0;  
 FloatingOut.0 = ListOut.0;  
 ListIn.0 = FloatingIn.0;  
 ListOut.0 = $Cast:A.0;  //_GUI 104,31, 104,39
 ListOut.1 = $Cast.0;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = VariantIn.0;  
}

Object ( Fixed Out1) Cast( Fixed Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Fixed"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Type) Input;  //_GUI 7,20
 Object ( Variant Data) Input:A;  //_GUI 8,34
 Object Output( Fixed Out1) ;  //_GUI 121,26
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 70,23
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 70,34
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 19,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 88,24
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 105,24
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 39,34
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 20,32

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 $Cast.0 = VariantIn.1;  //_GUI 57,28, 57,36
 $Cast.1 = ListIn.1;  //_GUI 66,25, 66,20
 $Cast:A.0 = VariantIn.0;  
 $Cast:A.1 = ListIn.0;  //_GUI 64,36, 64,23
 FixedIn.0 = Input.0;  
 ListIn.0 = FixedIn.0;  
 ListOut.0 = $Cast:A.0;  //_GUI 85,29, 85,37
 ListOut.1 = $Cast.0;  
 FixedOut.0 = ListOut.0;  
 VariantIn.0 = VariantIn:A.0;  
 VariantIn:A.0 = Input:A.0;  
}

Object ( Complex Out1) Cast( Complex Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Complex"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex Type) Input;  //_GUI 7,20
 Object ( Variant Data) Input:A;  //_GUI 8,34
 Object Output( Complex Out1) ;  //_GUI 132,26
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 70,23
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 70,34
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 19,18
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 116,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 41,18
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 102,24
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 41,34
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 20,32

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 $Cast.0 = VariantIn.1;  //_GUI 57,28, 57,36
 $Cast.1 = ListIn.1;  //_GUI 66,25, 66,20
 $Cast:A.0 = VariantIn.0;  
 $Cast:A.1 = ListIn.0;  //_GUI 64,36, 64,23
 ComplexIn.0 = Input.0;  
 ComplexOut.0 = ListOut.0;  
 ListIn.0 = ComplexIn.0;  
 ListOut.0 = $Cast:A.0;  //_GUI 94,29, 94,37
 ListOut.1 = $Cast.0;  
 VariantIn.0 = VariantIn:A.0;  
 VariantIn:A.0 = Input:A.0;  
}

Object ( List Out1) Cast( List Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="List"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // If given Static Data Sets, this object will perform a $Cast.
 //
 // Date:
 // 17 May 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 24,19
 Object ( Variant Data) Input:A;  //_GUI 25,31
 Object Output( List Out1) ;  //_GUI 88,20
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 59,29
 Object ( Variant Out1) Cast:A( Variant Type, Variant Data) ;  //_GUI 59,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 32,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 31,17
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 75,18

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Cast.0 = ListIn.0;  //_GUI 53,31, 53,22
 Cast.1 = VariantIn.0;  
 Cast:A.0 = ListIn.1;  
 Cast:A.1 = VariantIn.1;  //_GUI 48,22, 48,31
 VariantIn.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Cast.0;  //_GUI 72,23, 72,32
 ListOut.1 = Cast:A.0;  
}

Object ( Signed Out1) Cast( Signed Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="Signed"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Type) Input;  //_GUI 17,22
 Object ( Variant Data) Input:A;  //_GUI 18,37
 Object Output( Signed Out1) ;  //_GUI 100,37
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 70,35
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 28,20
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,35
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 85,35

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 $Cast.0 = VariantIn.0;  
 $Cast.1 = SignedIn.0;  //_GUI 60,37, 60,23
 SignedIn.0 = Input.0;  
 VariantIn.0 = Input:A.0;  
 SignedOut.0 = $Cast.0;  
}

Object ( NULL Out1) Cast( NULL Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="NULL"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 18,26
 Object ( Variant Data) Input:A;  //_GUI 18,33
 Object Output( NULL Out1) ;  //_GUI 174,26

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) Cast( NULL Type, NULL Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal\\Cast",Documentation="NULL/NULL"
{
 // Performs a behavioral Cast for feedback loops.  A $Cast is insufficient for Dynamic Data Sets.
 //
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 18,26
 Object ( NULL Data) Input:A;  //_GUI 18,33
 Object Output( NULL Out1) ;  //_GUI 174,26

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) $BitLength( Variant Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 23,16
 Object Output( Variant Out1) ;  //_GUI 57,23
 Object ( MSB032 In) Input:A;  //_GUI 24,23
 //_ Attributes PromoteToParentObject="False",Constant="$(NodeInfo:0:BitLen)"
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 37,21
 Object Text;  //_GUI 25,30,The Macro ##N2.B returns the bitlength of the Type input.  This is then filtered through a Min_Rep to trim the data set while removing leading 0s.

 //_ Behavior Topology
 Output.0 = Min_Rep.0;  
 Min_Rep.0 = Input:A.0;  
}

Object ( Bit Out1) $BitLength( Bit Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 23,16
 Object Output( Bit Out1) ;  //_GUI 44,22
 Object ( Bit In) Input:A;  //_GUI 36,22
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) NotZero( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\Async"
{
 // Returns 1 if input data does not equal zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,20
 Object Output( Bit Out1) ;  //_GUI 53,20
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 26,18
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 40,18

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 OR-NInput.0 = Input.0;  
 VouchBit.0 = OR-NInput.0;  
}

Object ( NULL Out1) NotZero( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="NULL"
{
 // NotZero - Variant Select Case
 //
 // Returns 1 if input data does not equal zero.
 //
 // Date Last Modified:
 // 13 May 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 14,17
 Object Output( NULL Out1) ;  //_GUI 33,17

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) NotZero( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="Bit"
{
 // NotZero - Variant Select Case
 //
 // Returns 1 if input data does not equal zero.
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 14,17
 Object Output( Bit Out1) ;  //_GUI 33,17

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) NotZero( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="Floating"
{
 // Returns 1 if input data does not equal zero.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 13,20
 Object Output( Bit Out1) ;  //_GUI 83,23
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 55,21
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 21,18
 Object Text;  //_GUI 31,11,-0 == 0
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 40,21
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 70,21

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 OR-NInput.0 = CollectLSB.0;  
 ExposeFloating.0 = Input.0;  
 CollectLSB.0 = ExposeFloating.1;  
 CollectLSB.1 = ExposeFloating.2;  
 VouchBit.0 = OR-NInput.0;  
}

Object ( Bit Out1) XOR( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit/Bit"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 19,17
 Object ( Bit In2) Input:A;  //_GUI 19,28
 Object Output( Bit Out1) ;  //_GUI 86,19
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 37,16
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 74,17
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 37,24
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 49,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 28,17
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 31,28

 //_ Behavior Topology
 Output.0 = AND.0;  
 OR.0 = Junction.1;  
 OR.1 = Junction:A.0;  //_GUI 32,21
 AND.0 = OR.0;  
 AND.1 = INVERT.0;  //_GUI 65,22, 65,27
 AND:A.0 = Junction.2;  //_GUI 29,26
 AND:A.1 = Junction:A.1;  
 INVERT.0 = AND:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
}

Object ( Variant Out1) XOR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Note that there is a subtle difference between the behavior of XOR with a Var/NULL input and the InvertEn object with a NULL on Data and Bit on En.  An XOR with Var/NULL will pass through the Var where the InvertEn with a NULL Data and a Bit En will pass through the NULL.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,30
 Object ( Variant In2) Input:A;  //_GUI 13,33
 Object Output( Variant Out1) ;  //_GUI 64,31
 Object ( Variant Out1) $XOR( Variant In1, Variant In2) ;  //_GUI 44,29
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 23,29
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $XOR.0;  
 $XOR.0 = Symmetrize.0;  
 $XOR.1 = Symmetrize.1;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( List Out1) XOR( List In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List/List"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 31,28
 Object ( List In2) Input:A;  //_GUI 31,37
 Object Output( List Out1) ;  //_GUI 105,29
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,26
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 40,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 87,27
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 64,26
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 64,35
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListIn:A.0 = Input:A.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 84,32, 84,38
 ListOut.1 = $XOR_SameLists.0;  
 $XOR_SameLists.0 = ListIn.1;  
 $XOR_SameLists.1 = ListIn:A.1;  //_GUI 62,31, 62,34, 55,34, 55,37
 $XOR_SameLists:A.0 = ListIn.0;  //_GUI 58,37, 58,31
 $XOR_SameLists:A.1 = ListIn:A.0;  
}

Object ( List Out1) XOR( List In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List/Variant"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 31,28
 Object ( Variant In2) Input:A;  //_GUI 31,39
 Object Output( List Out1) ;  //_GUI 101,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 64,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,26
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 83,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,39

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 XOR.0 = ListIn.1;  
 XOR.1 = Junction.0;  //_GUI 61,31
 XOR:A.0 = ListIn.0;  //_GUI 58,37, 58,31
 XOR:A.1 = Junction.1;  
 ListIn.0 = Input.0;  
 ListOut.0 = XOR:A.0;  //_GUI 80,32, 80,38
 ListOut.1 = XOR.0;  
 Junction.0 = Input:A.0;  
}

Object ( List Out1) XOR( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Variant/List"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 31,27
 Object ( List In2) Input:A;  //_GUI 31,37
 Object Output( List Out1) ;  //_GUI 101,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 64,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 40,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 83,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 57,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 XOR.0 = Junction.1;  
 XOR.1 = ListIn.1;  //_GUI 62,31, 62,34, 55,34, 55,37
 XOR:A.0 = Junction.2;  //_GUI 58,37
 XOR:A.1 = ListIn.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = XOR:A.0;  //_GUI 80,32, 80,38
 ListOut.1 = XOR.0;  
 Junction.0 = Input.0;  
}

Object ( Variant Out1) XOR( Bit In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="bit/var"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,28
 Object ( Variant In2) Input:A;  //_GUI 12,35
 Object Output( Variant Out1) ;  //_GUI 83,31
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 46,27
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 24,33
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 58,31
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 71,29
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 46,33
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 19,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 40,28

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 XOR.0 = Junction:A.1;  
 XOR.1 = VariantIn.1;  //_GUI 37,32, 37,35
 VariantIn.0 = Junction.1;  
 VariantOut.0 = XOR:A.0;  
 VariantOut.1 = XOR.0;  //_GUI 58,32, 56,32
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction.0;  //_GUI 71,23, 20,23
 XOR:A.0 = Junction:A.2;  //_GUI 41,35
 XOR:A.1 = VariantIn.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
}

Object ( Variant Out1) XOR( Variant In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="var/bit"
{
 // Descriptioni:
 // XOR
 //
 // Inputs:
 // In1: Input data set
 // In2: Input data set
 //
 // Outputs:
 // Out1: Variant result
 //
 // Date:
 // May 13, 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,30
 Object ( Bit In2) Input:A;  //_GUI 12,35
 Object Output( Variant Out1) ;  //_GUI 91,29
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 54,25
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 24,28
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 66,29
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 54,31
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 47,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 19,30
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 79,27

 //_ Behavior Topology
 Output.0 = Cast.0;  
 XOR.0 = VariantIn.1;  //_GUI 42,27, 42,30
 XOR.1 = Junction.0;  //_GUI 48,30
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = XOR:A.0;  
 VariantOut.1 = XOR.0;  //_GUI 66,30, 64,30
 XOR:A.0 = VariantIn.0;  
 XOR:A.1 = Junction.1;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 79,19, 20,19
 Cast.1 = VariantOut.0;  
}

Object ( Variant Out1) XOR( Variant In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Var/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) XOR( NULL In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Null/Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Variant In2) Input:A;  //_GUI 21,22
 Object Output( Variant Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( NULL Out1) XOR( NULL In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Null/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( NULL Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) XOR( List In2, Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List\\Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Bit In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = XOR:A.0;  //_GUI 65,29, 65,32
 ListOut.1 = XOR.0;  //_GUI 66,26, 66,23
 XOR.0 = ListIn.1;  
 XOR.1 = Junction.0;  //_GUI 46,25
 XOR:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 XOR:A.1 = Junction.1;  
}

Object ( List Out1) XOR( Bit In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = XOR:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = XOR.0;  
 XOR.0 = Junction.1;  
 XOR.1 = ListIn.1;  //_GUI 41,21, 41,26
 XOR:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 XOR:A.1 = ListIn.0;  
}

Object ( Bit Out1) XOR( Bit In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Bit Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) XOR( NULL In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Null/Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Bit In2) Input:A;  //_GUI 21,22
 Object Output( Bit Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) CollectBIN( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out"
{
 // Collects inputs into a BIN data set
 //
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,34
 Object ( Variant In2) Input:A;  //_GUI 26,38
 Object ( Variant In3) Input:B;  //_GUI 26,41
 Object Output( Variant Out1) ;  //_GUI 71,35
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) ;  //_GUI 34,37
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2) ;  //_GUI 48,33

 //_ Behavior Topology
 Output.0 = CollectBIN:A.0;  
 CollectBIN.0 = Input:A.0;  
 CollectBIN.1 = Input:B.0;  
 CollectBIN:A.0 = Input.0;  
 CollectBIN:A.1 = CollectBIN.0;  //_GUI 47,38, 47,40
}

Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating
    ( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Async\\Advanced",Documentation="with NaN"
{
 // This object exposes the Sign portion, the Biased Exponent portion and the Mantissa (high bit implied) portion of a value from a Floating dataset.
 //
 // Inputs:
 //
 // Floating Floating: The Floating value to expose.
 //
 // Outputs:
 //
 // Variant Sign: The sign bit.
 //
 // Variant BExp: The biased exponent.
 //
 // Variant Exp: The unbiased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Variant IMant: The mantissa (or significand) with the most significant bit (the implied bit).
 //
 // Bit Zero: The input value is a zero (positive or negative)
 //
 // Bit Denormalized: The input value is denormalized (BExp = 0 & Mant != 0)
 //
 // Bit Infinity: The input value is positive or negative infinity (BExp = AllHigh & Mant = 0)
 //
 // Bit QNaN: Quiet Not a Number (BExp = AllHigh & MSB(Mant) = 1)
 //
 // Bit SNaN: Signaled Not a Number (BExp = AllHigh & MSB(Mant) = 0 & Mant != 0)
 //
 // Bit NaN: Either QNaN or SnaN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 11,20
 Object Output( Bit Sign) ;  //_GUI 116,6
 Object Output:A( Variant BExp) ;  //_GUI 116,11
 Object Output:B( Variant Exp) ;  //_GUI 144,18
 Object Output:C( Variant Mant) ;  //_GUI 146,22
 Object Output:D( Variant IMant) ;  //_GUI 140,29
 Object Output:E( Bit Zero) ;  //_GUI 129,39
 Object Output:F( Bit Denormalized) ;  //_GUI 118,57
 Object Output:G( Bit Infinity) ;  //_GUI 118,63
 Object Output:H( Bit QNaN) ;  //_GUI 134,79
 Object Output:I( Bit SNaN) ;  //_GUI 135,91
 Object Output:J( Bit NaN) ;  //_GUI 135,99
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 35,18
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 49,11
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out11) ExposeMSB:A( Variant In1) ;  //_GUI 55,80
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 66,15
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 125,97
 Object Text;  //_GUI 131,10,(Biased exponent)
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 111,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 97,38
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 93,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 66,38
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 67,69
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 75,90
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 71,36
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 75,47
 Object Text;  //_GUI 15,110,Infinity = all the exponent bits high and the significand bits lowNaN = QNaN or SNaNQNaN = all the exponent bits high and the MSB significand bit highSNaN = all the exponent bits high and the MSB significand bit low (other significand bits high)Zero = all bits low, not counting the sign bit
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 92,49
 Object ( Bit Out1) EqualZero:B( Variant In1) ;  //_GUI 77,69
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 90,71
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In1) ;  //_GUI 51,49
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 95,77
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 117,79
 Object ( Bit Out) AND:C( Bit In1, Bit In2) ;  //_GUI 91,88
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In1) ;  //_GUI 90,78
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In0) ;  //_GUI 120,91
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 74,81
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In1) ;  //_GUI 92,56
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 104,89
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 75,97
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 17,18
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 67,4
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 127,27
 Object ( Bit OFL, Variant Out1) RemoveBias( Variant In1) ;  //_GUI 100,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 91,15
 Object ( Bit Out) INVERT:C( Bit In1) ;  //_GUI 98,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:M
    ( Variant In1) ;  //_GUI 51,31
 Object ( Variant Out1) AND:E( Variant In1, Variant In2) ;  //_GUI 132,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In0) ;  //_GUI 118,28

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = Junction:L.0;  //_GUI 92,12
 Output:B.0 = AND:E.0;  
 Output:C.0 = Junction.1;  
 Output:D.0 = PushMsb.0;  
 Output:E.0 = AND.0;  
 Output:F.0 = Junction:B.2;  //_GUI 98,58
 Output:G.0 = AND:A.0;  
 Output:H.0 = Junction:G.1;  
 Output:I.0 = Junction:I.1;  
 Output:J.0 = OR.0;  
 ListIn.0 = FloatingIn.0;  
 ExposeMSB.0 = ListIn.1;  //_GUI 46,14
 ExposeMSB:A.0 = Junction:F.2;  //_GUI 52,83
 Junction.0 = ListIn.0;  
 Junction:A.0 = ExposeMSB.1;  
 OR.0 = Junction:I.2;  //_GUI 121,99
 OR.1 = Junction:G.2;  //_GUI 118,102
 AND.0 = Junction:B.1;  
 AND.1 = Junction:D.1;  //_GUI 111,50
 Junction:B.0 = EqualZero.0;  
 AND:A.0 = Junction:K.2;  
 AND:A.1 = Junction:E.0;  //_GUI 91,66
 Junction:C.0 = Junction:A.2;  
 INVERT.0 = Junction:C.2;  
 INVERT:A.0 = Junction:J.2;  
 EqualZero.0 = Junction:C.1;  
 EqualZero:A.0 = Junction:F.1;  
 Junction:D.0 = EqualZero:A.0;  
 EqualZero:B.0 = INVERT.0;  
 Junction:E.0 = EqualZero:B.0;  
 Junction:F.0 = Junction:M.2;  
 AND:B.0 = Junction:H.1;  
 AND:B.1 = Junction:J.1;  
 Junction:G.0 = AND:B.0;  
 AND:C.0 = Junction:H.2;  
 AND:C.1 = INVERT:A.0;  
 Junction:H.0 = Junction:E.2;  
 Junction:I.0 = AND:D.0;  
 Junction:J.0 = ExposeMSB:A.0;  
 Junction:K.0 = Junction:D.2;  
 AND:D.0 = AND:C.0;  
 AND:D.1 = INVERT:B.0;  //_GUI 104,100
 INVERT:B.0 = Junction:K.0;  //_GUI 46,100, 46,57
 FloatingIn.0 = Input.0;  
 $Cast.0 = ExposeMSB.0;  //_GUI 63,9, 63,13
 PushMsb.0 = Junction:N.1;  
 PushMsb.1 = Junction:M.1;  
 RemoveBias.0 = Junction:L.1;  
 Junction:L.0 = Junction:A.1;  
 INVERT:C.0 = Junction:B.0;  
 Junction:M.0 = Junction.2;  
 AND:E.0 = RemoveBias.1;  
 AND:E.1 = Junction:N.0;  //_GUI 119,21
 Junction:N.0 = INVERT:C.0;  
}

Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Replaces a NULL with a zero value of the dataset of Type.  Otherwise, passes the input through unchanged.
 //
 // Inputs:
 //
 // Variant Data:  Data passed through, as is, unless it is a NULL input.
 //
 // Variant Type:  The dataset that a NULL input dataset is replaced with in the output.
 //
 // Outputs:
 //
 // Variant Data: Input Data or replaced NULL.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 26,25
 Object ( Variant Type) Input:A;  //_GUI 26,31
 Object Output( Variant Data) ;  //_GUI 53,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data) ZeroNulls( NULL Data, Variant Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Null"
{
 // Replaces a NULL with a zero value of the dataset of Type.  Otherwise, passes the input through unchanged.
 //
 // Inputs:
 //
 // Variant Data:  Data passed through, as is, unless it is a NULL input.
 //
 // Variant Type:  The dataset that a NULL input dataset is replaced with in the output.
 //
 // Outputs:
 //
 // Variant Data: Input Data or replaced NULL.
 //
 // Date:
 // March 4, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 26,25
 Object ( Variant Type) Input:A;  //_GUI 26,31
 Object Output( Variant Data) ;  //_GUI 53,25
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 41,23

 //_ Behavior Topology
 Output.0 = Zero.0;  
 Zero.0 = Input:A.0;  //_GUI 35,26, 35,32
}

Object ( Bit Out1) VouchBit( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // The purpose of this object is to vouch for a transport that it will resolve to a Bit.  This is done by (1) forcing the output dataset to a Bit and (2) producing a compile time error if the variant input transport becomes anything other than a bit.  Can be used in feedback loops and in front of Bit output horns.
 //
 // If an output dataset of an object is a bit, but internally the bit output horn connects to a variant transport, often, when this object is resolved, the bit output dataset is lost and becomes a variant, then is later resolved back to a bit.  Most of the time, this works fine, but sometimes in feedback situations the transport is unsuccessful at resolving back into a bit.  The VouchBit object is used to clear up this problem.
 //
 // This object is better than a $Cast, which, if the variant input becomes something other than a bit, the $Cast will force it to be a bit, whereas with the VouchBit, if the variant input becomes anything other than a bit, an error is produced.
 //
 // Inputs:
 //
 // Bit input: Transport to be vouched for as a Bit.
 //
 // Outputs:
 //
 // Bit output: The Bit output.
 //
 // Revision 1
 // Revision 2 - 07/20/06 Just a pass through with the input changed to a Bit. Let the more recent Viva type checking produce the errors.  Will behave correctly if an old overload with a Var input is referenced, you will just get a slightly different error message, but an error, none the less.  The new implementation should compile significantly faster.
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 17,29
 Object Output( Bit Out1) ;  //_GUI 42,29

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) VouchBit( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // This object tells anything downstream that the transport is a bit.  If the variant input becomes anything other than a bit, a user trap is generated.
 //
 // Basically you are vouching that the variant transport will become a bit.
 //
 // If an output dataset of an object is a bit, but internally the bit output horn connects to a variant transport, often, when this object is resolved, the bit output dataset is lost and becomes a variant, then is later resolved back to a bit.  Most of the time, this works fine, but sometimes in feedback situations the transport is unsuccessfull at resolving back into a bit.  The VouchBit object is used to clear up this problem.
 //
 // Place this object between a variant transport and its bit output horn.
 //
 // This object is better than a $Cast, which, if the variant input becomes something other than a bit, the $Cast will force it to be a bit.  Whereas with the VouchBit, if the variant input becomes anything other than a bit, a user trap is produced.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 17,28
 Object Output( Bit Out1) ;  //_GUI 61,27
 Object Output:A( Bit Trap) ;  //_GUI 61,14
 //_ Attributes Trap="Input did not resolve to a Bit"
 Object ( Bit In) Input:A;  //_GUI 55,27
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit In) Input:B;  //_GUI 55,14
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Ge_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Ge_BitB.0 = MSB.0;  
 $BitA_Ge_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Ge_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Ge_BitB.0 = Input.0;  
 $BitA_Ge_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 17,12
 Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Ge_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Ge_BitB.0 = MSB.0;  
 $BitA_Ge_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Ge_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is greater than or equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 9,27,( 0 >= 0 )
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant Out1) PushLsb( NULL In1, Variant LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,14
 Object ( Variant LSB) Input:A;  //_GUI 19,17
 Object Output( Variant Out1) ;  //_GUI 38,15

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 31,16, 31,18
}

Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,14
 Object ( Variant LSB) Input:A;  //_GUI 19,17
 Object Output( Variant Out1) ;  //_GUI 57,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 29,13
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 43,13
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 LSB.0 = ListOut.0;  
}

Object ( NULL Out1) PushLsb( NULL In1, NULL LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,14
 Object ( NULL LSB) Input:A;  //_GUI 19,17
 Object Output( NULL Out1) ;  //_GUI 38,15

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 31,16, 31,18
}

Object ( Variant Out1) PushLsb( Variant In1, NULL LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,15
 Object ( NULL LSB) Input:A;  //_GUI 19,18
 Object Output( Variant Out1) ;  //_GUI 38,15

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) PushLsb( List In1, Variant LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="list/var"
{
 // This object adds, or pushes the item from the lower input onto the least significant end of the upper input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the upper input is a variant, the bottom input is appended to it and the output dataset is LSBxxx.  To append multiple bits, it is recommended that you use CollectLSB.
 //
 // * If the upper input is a list, this input is first converted to an LSB ordered list and then the bottom input is appended as a single element onto the LSB end of the list.  To concatenate two lists, it is recommended that you use the two-input LsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input LsbList object instead.
 //
 // Inputs:
 //
 // Variant input: An item will be pushed onto this input's least significant end.
 //
 // Variant LSB: The item to push.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 27,27
 Object ( Variant LSB) Input:A;  //_GUI 27,30
 Object Output( List Out1) ;  //_GUI 84,28
 Object Text;  //_GUI 30,42,If LSB input is a list, this will put that as the most signficant element of the AnyList. This object always outputs an LSB ordered list on the top level. If you want this to concatenate two lists and give a single list output, call Lsb_List instead. For doing multiddimensionial lists, use the ZTList operators instead.
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 65,26
 Object ( List LsbList) LsbList( List AnyList) ;  //_GUI 38,25
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = LsbList.0;  
 LsbList.0 = Input.0;  
}

Object ( Variant Out1) Context( Variant Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters"
{
 // Changes the context, or meaning, of a set of bits.  Not to be used to change the size of a dataset (use Convert for this).  An example use of Context would be to change a dataset of MSB008 into a 4 element LSB ordered list of BIN002 elements.
 //
 // Inputs:
 //
 // Variant Type: The resulting dataset
 //
 // Variant Data: The input data and dataset
 //
 // Outputs:
 //
 // Variant output: Data with dataset Type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 20,9
 Object ( Variant Data) Input:A;  //_GUI 20,34
 Object Output( Variant Out1) ;  //_GUI 153,44
 Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) ;  //_GUI 97,35
 //_ Attributes Documentation="Bit"
 Object Output:A( Bit Trap) ;  //_GUI 148,36
 //_ Attributes Trap="Data larger than context"
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 124,34
 //_ Attributes Documentation="NULL"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 136,34
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 134,42
 Object ( Bit "Type and B fixed length") Input:B;  //_GUI 27,63
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), M, 65535, <)"
 Object ( Bit "Bitlen(A) same as Bitlen(B)") Input:C;  //_GUI 27,66
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), =)"
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 31,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 40,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 40,57
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 97,44
 Object Text;  //_GUI 37,73,We bypass teh $Context operator in the case where we already have the correct dataset.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 47,9
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 67,8
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 55,28
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 67,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 50,34
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 63,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 54,53
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 63,46

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Context.0 = $Select:A.0;  //_GUI 81,37, 81,11
 $Context.1 = $Select:C.0;  //_GUI 73,40
 Output:A.0 = INVERT.0;  
 IsNULL.0 = $Context.0;  
 INVERT.0 = IsNULL.0;  
 $Select.0 = $Context.1;  //_GUI 121,44, 121,40
 $Select.1 = $Cast.0;  
 $Select.2 = Junction:A.2;  //_GUI 134,58
 AND.0 = Input:B.0;  
 AND.1 = Input:C.0;  
 Junction.0 = Junction:A.1;  
 Junction:A.0 = AND.0;  
 $Cast.0 = $Select:D.0;  
 $Cast.1 = $Select:B.0;  //_GUI 77,46
 Junction:B.0 = Input.0;  
 $Select:A.0 = Junction:B.1;  
 $Select:A.2 = Junction:C.0;  //_GUI 56,16
 Junction:C.0 = Junction.1;  //_GUI 41,29
 $Select:B.1 = Junction:B.2;  //_GUI 48,26
 $Select:B.2 = Junction:C.1;  
 Junction:D.0 = Input:A.0;  
 $Select:C.0 = Junction:D.1;  
 $Select:C.2 = Junction:E.0;  //_GUI 55,41
 Junction:E.0 = Junction.2;  
 $Select:D.1 = Junction:D.2;  //_GUI 51,51
 $Select:D.2 = Junction:E.1;  
}

Object ( Bit C, Bit Out2) SHL( Bit In1
    , Bit C) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal",Documentation="Bit"
{
 // Bit case for SHL
 //
 // Date Last Modified:
 // 26 June 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,14
 Object ( Bit C) Input:A;  //_GUI 12,27
 //_ Attributes Constant="0"
 Object Output( Bit C) ;  //_GUI 51,14
 Object Output:A( Bit Out2) ;  //_GUI 50,27

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit C, Variant Out2) SHL( Variant In1
    , Bit C) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters",Documentation="Bit_Carry"
{
 // Shift Left with Carry
 //
 // This object simply realigns bits and does not consume any physical resources.
 //
 // Inputs:
 // In1- Input Data
 // C- Carry-In Bit
 //
 // Outputs:
 // C- Carry-Out Bit
 // Out2- Output Data
 //
 // Date Last Modified:
 // Mar/2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,33
 Object ( Bit C) Input:A;  //_GUI 15,42
 //_ Attributes Constant="0"
 Object Output( Bit C) ;  //_GUI 108,23
 Object Output:A( Variant Out2) ;  //_GUI 109,38
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 77,21
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 40,32
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 65,38
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 78,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 29,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 60,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 24,33
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 94,36

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = Context.0;  
 $Cast.0 = Hi_N.0;  //_GUI 50,26
 $Cast.1 = Junction:A.0;  //_GUI 61,23
 Hi_N.0 = Junction:B.1;  
 Hi_N.1 = Junction.0;  //_GUI 30,37
 ListOut.0 = Junction:A.1;  
 ListOut.1 = Hi_N.1;  //_GUI 58,40, 58,37
 LSB.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Junction.1;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:B.0;  //_GUI 94,11, 25,11
 Context.1 = LSB.0;  
}

Object ( Variant C, Variant Out2) SHL( Variant In1
    , Variant C) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters",Documentation="Var_Carry"
{
 // Shift Left with Carry
 //
 // This object simply realigns bits and does not consume any physical resources.  The input data will be shifted one bit for every bit in the C dataset.
 //
 // Inputs:
 // In1- Input Data
 // C- Carry-In Bits
 //
 // Outputs:
 // C- Carry-Out Bits
 // Out2- Output Data
 //
 // Date Last Modified:
 // Mar/2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 39,48
 Object ( Variant C) Input:A;  //_GUI 39,57
 Object Output( Variant C) ;  //_GUI 132,38
 Object Output:A( Variant Out2) ;  //_GUI 133,53
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 64,47
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 89,53
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 102,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 84,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 48,48
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 101,36
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 118,51

 //_ Behavior Topology
 Output.0 = Context.0;  
 Output:A.0 = Context:A.0;  
 Hi_N.0 = Junction:B.1;  
 Hi_N.1 = Junction.0;  //_GUI 54,52
 ListOut.0 = Junction:A.1;  
 ListOut.1 = Hi_N.1;  //_GUI 82,55, 82,52
 LSB.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Junction.1;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:A.0;  //_GUI 85,38
 Context.1 = Hi_N.0;  //_GUI 74,41
 Context:A.0 = Junction:B.0;  //_GUI 118,26, 49,26
 Context:A.1 = LSB.0;  
}

Object ( NULL C, Variant Out2) SHL( Variant In1
    , NULL C) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 39,48
 Object ( NULL C) Input:A;  //_GUI 39,57
 Object Output( NULL C) ;  //_GUI 132,36
 Object Output:A( Variant Out2) ;  //_GUI 133,53

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 63,37, 63,58
 Output:A.0 = Input.0;  //_GUI 86,54, 86,49
}

Object ( Bit C, Floating Out2) SHL( Floating In1
    , Variant C) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 10,17
 Object ( Variant C) Input:A;  //_GUI 16,38
 Object Output( Bit C) ;  //_GUI 143,19
 Object Output:A( Floating Out2) ;  //_GUI 156,29
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 78,18
 Object ( Variant Out1) BitLength( Variant In1) ;  //_GUI 26,36
 //_ Attributes Documentation="zterm"
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 22,15
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 122,27
 Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) ;  //_GUI 49,18

 //_ Behavior Topology
 Output.0 = ADSU.0;  
 Output:A.0 = CollectFloating.0;  
 ADSU.0 = SymmetrizeNW.0;  
 ADSU.1 = SymmetrizeNW.1;  
 BitLength.0 = Input:A.0;  
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 106,29, 106,17
 CollectFloating.1 = ADSU.2;  //_GUI 96,32
 CollectFloating.2 = ExposeFloating.2;  //_GUI 38,35
 SymmetrizeNW.0 = ExposeFloating.1;  
 SymmetrizeNW.1 = BitLength.0;  //_GUI 44,23, 44,39
}

Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the Sign portion, the Biased Exponent portion and the Mantissa (high bit implied) portion of a value from a Floating dataset.
 //
 // Inputs:
 //
 // Variant input: The Floating value to expose.
 //
 // Outputs:
 //
 // Variant Sign: The sign bit.
 //
 // Variant BExp: The biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 11,20
 Object Output( Bit Sign) ;  //_GUI 80,8
 Object Output:A( Variant BExp) ;  //_GUI 80,15
 Object Output:B( Variant Mant) ;  //_GUI 80,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,18
 Object Text;  //_GUI 92,14,(Biased exponent)
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 49,11
 //_ Attributes Documentation="Error"
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 17,18
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 67,6

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = ExposeMSB.1;  
 Output:B.0 = ListIn.0;  
 ListIn.0 = FloatingIn.0;  
 ExposeMSB.0 = ListIn.1;  //_GUI 46,14, 46,20
 FloatingIn.0 = Input.0;  
 VouchBit.0 = ExposeMSB.0;  //_GUI 63,9, 63,13
}

Object ( Floating Out1) CollectFloating( Bit Sign, Variant BExp
    , Variant Mant) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the Sign, the Biased Exponent and the Mantissa (high bit implied) portions of a value into a Floating dataset.
 //
 // Inputs:
 //
 // Bit Sign: The sign bit.
 //
 // Variant SBExp: The biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded Floating value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Sign) Input;  //_GUI 21,17
 Object ( Variant BExp) Input:A;  //_GUI 21,20
 Object ( Variant Mant) Input:B;  //_GUI 21,26
 Object Output( Floating Out1) ;  //_GUI 71,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 44,20
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 27,16
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 57,20
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 28,24

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 ListOut.0 = MSB.0;  //_GUI 43,25, 43,27
 ListOut.1 = CollectMSB.0;  //_GUI 43,22, 43,19
 CollectMSB.0 = Input.0;  
 CollectMSB.1 = Input:A.0;  
 FloatingOut.0 = ListOut.0;  
 MSB.0 = Input:B.0;  
}

Object ( Variant Out1) MakeBias( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Determines the bias constant value for the size of exponent input.
 //
 // Inputs:
 //
 // Variant input: The exponent dataset for which a bias constant value will be generated..
 //
 // Outputs:
 //
 // Variant output: The bias constant value for the input exponent dataset.  The constant value is a most significant bit of zero and all other bits one.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 34,29
 Object Output( Variant Out1) ;  //_GUI 82,29
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 67,27
 Object Text;  //_GUI 67,24,Build our bias.
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 52,27
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 40,27

 //_ Behavior Topology
 Output.0 = ReverseBits.0;  
 ReverseBits.0 = INVERT.0;  
 INVERT.0 = One.0;  
 One.0 = Input.0;  
}

Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the whole and fractional portions of a value from a Fixed dataset.  SWhole and Fract combined are a two's complement number.  Care must be taken when using these portions of the Fixed dataset.  It is not recommended that you work with them as separate numbers, but if really want to, you can think of them like this: SWhole is a two's complement truncated whole number (rounded towards negative infinity) and Fract is the positive portion that is added to get the resulting fixed value.
 //
 // Example:
 //
 // Decimal	Binary	Interpretation
 // 2.25	010.01	2 + .25
 // -2.25	101.11	-3 + .75 = -2.25
 //
 // Note that two's complement of 9 (01001) is -9 (10111)
 //
 // Inputs:
 //
 // Variant input: The Fixed value to be exposed.
 //
 // Outputs:
 //
 // Variant SWhole: The signed whole portion of the Fixed dataset as a two's complement interpretation of the MSBxxx dataset.  Note that this is not a dataset of the name Signed.
 //
 // Variant Fract: The fractional portion of the Fixed dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 20,26
 Object Output( Variant SWhole) ;  //_GUI 52,25
 Object Output:A( Variant Fract) ;  //_GUI 52,28
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 26,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,24

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 FixedIn.0 = Input.0;  
 ListIn.0 = FixedIn.0;  
}

Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the whole and fractional portions of a value into a Fixed dataset.  SWhole and Fract combined are a two's complement number.  Care must be taken when using these portions of the Fixed dataset.  It is not recommended that you work with them as separate numbers, but if really want to, you can think of them like this: SWhole is a two's complement truncated whole number (rounded towards negative infinity) and Fract is the positive portion that is added to get the resulting fixed value.
 //
 // Example:
 //
 // Decimal	Binary	Interpretation
 // 2.25	010.01	2 + .25
 // -2.25	101.11	-3 + .75 = -2.25
 //
 // Note that two's complement of 9 (01001) is -9 (10111)
 //
 // Inputs:
 //
 // Variant SWhole: The signed whole portion of the Fixed dataset as a two's complement interpretation of the MSBxxx dataset.  Note that this is not a dataset of the name Signed.
 //
 // Variant Fract: The fractional portion of the Fixed dataset.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded complex value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant SWhole) Input;  //_GUI 20,38
 Object ( Variant Fract) Input:A;  //_GUI 20,41
 Object Output( Fixed Out1) ;  //_GUI 64,39
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 51,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 26,36
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 26,39

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 FixedOut.0 = ListOut.0;  
 ListOut.0 = MSB:A.0;  
 ListOut.1 = MSB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
}

Object ( Fixed Out1) CollectFixed( Variant SWhole, NULL Fract) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant SWhole) Input;  //_GUI 32,38
 Object ( NULL Fract) Input:A;  //_GUI 32,41
 Object Output( Fixed Out1) ;  //_GUI 64,39
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 51,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37

 //_ Behavior Topology
 Output.0 = FixedOut.0;  
 FixedOut.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( Bit Out1) IsBit( Variant Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is Bit.  Returns false in all other cases including contextual datasets of a single bit.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a Bit dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Bit, 0 otherwise.
 //
 // Date:
 // January 16, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 48,20
 Object Output( Bit Out1) ;  //_GUI 87,30
 Object ( Bit In) Input:A;  //_GUI 48,30
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 40,38,Everything besides a Bit matches this overload, so output a 0.  Note that single bit contextual datasets will match this overload and return a 0.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsBit( Bit Type) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal"
{
 // Returns true if the input dataset is Bit.  Returns false in all other cases including contextual datasets of a single bit.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a Bit dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Bit, 0 otherwise.
 //
 // Date:
 // January 16, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Type) Input;  //_GUI 48,20
 Object Output( Bit Out1) ;  //_GUI 87,30
 Object ( Bit In) Input:A;  //_GUI 48,30
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 40,38,Everything besides a Bit matches the other overload, so output a 1.  Note that single bit contextual datasets will not match this overload and get a 0.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the real and imaginary portions of a complex value from a Complex dataset.  The real and imaginary datasets will both be either Fixed, Floating, or Signed.
 //
 // Inputs:
 //
 // Variant input: The complex value to expose.
 //
 // Outputs:
 //
 // Variant Real: The real portion of a complex dataset.
 //
 // Variant Imag: The imaginary portion of a complex dataset.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 16,26
 Object Output( Variant Real) ;  //_GUI 52,25
 Object Output:A( Variant Imag) ;  //_GUI 52,28
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,24
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 25,24

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 ListIn.0 = ComplexIn.0;  
 ComplexIn.0 = Input.0;  
}

Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the real and imaginary portions of a complex value into a Complex dataset.  The real and imaginary datasets must both be Fixed, Floating, or Signed.
 //
 // Inputs:
 //
 // Variant Real: The real portion of a complex dataset.
 //
 // Variant Imag: The imaginary portion of a complex dataset.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded complex value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Real) Input;  //_GUI 32,38
 Object ( Variant Imag) Input:A;  //_GUI 32,41
 Object Output( Complex Out1) ;  //_GUI 68,39
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 51,37

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ComplexOut.0 = ListOut.0;  
}

Object ( Complex Out1) CollectComplex( Variant Real, NULL Imag) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Real) Input;  //_GUI 32,38
 Object ( NULL Imag) Input:A;  //_GUI 32,41
 Object Output( Complex Out1) ;  //_GUI 69,39
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 38,37
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 51,37

 //_ Behavior Topology
 Output.0 = ComplexOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 ComplexOut.0 = ListOut.0;  
}

Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async"
{
 // Same as Add (2,1) except has an extra OFL output.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Value
 //
 // Variant B: Value
 //
 // Outputs:
 //
 // Bit OFL: Overflow used to detect an overflow error
 //
 // Variant S: The sum of A and B.
 //
 // Dataset Coverage:
 //
 // Unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating and Complex (OFL is OR of both real and imaginary portions) and lists of these (S and OFL are lists).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx and BINxxx).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx, and BINxxx) or undefinded behavior will occur.  If different sizes then the inputs are symmetrized with a warning.  If one of A or B is a list and the other is not, the other is duplicated into a list matching the one then the respective list elements are added.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 14,14
 Object ( Variant B) Input:A;  //_GUI 14,17
 Object Output( Variant OFL) ;  //_GUI 64,14
 Object Output:A( Variant S) ;  //_GUI 64,17
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 46,13
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 25,13

 //_ Behavior Topology
 Output.0 = $ResolveError.0;  
 Output:A.0 = $ResolveError.1;  
 $ResolveError.0 = ADSU.0;  
 $ResolveError.1 = ADSU.1;  
 $ResolveError.2 = ADSU.2;  
 ADSU.0 = Input.0;  
 ADSU.1 = Input:A.0;  
}

Object ( List OFL, List S) Add( List A
    , Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 21,18
 Object ( Variant B) Input:A;  //_GUI 21,29
 Object Output( List OFL) ;  //_GUI 97,18
 Object Output:A( List S) ;  //_GUI 97,27
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 34,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 46,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 82,16
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 82,25
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 57,16
 Object ( Variant OFL, Variant S) Add:A( Variant A
    , Variant B) ;  //_GUI 57,25

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 Junction.0 = Input:A.0;  
 ListOut.0 = Add:A.0;  //_GUI 78,21, 78,27
 ListOut.1 = Add.0;  
 ListOut:A.0 = Add:A.1;  
 ListOut:A.1 = Add.1;  //_GUI 82,24, 74,24
 Add.0 = ListIn.1;  
 Add.1 = Junction.0;  //_GUI 51,21, 51,27, 47,27
 Add:A.0 = ListIn.0;  //_GUI 54,27, 54,24, 48,24, 48,21
 Add:A.1 = Junction.1;  
}

Object ( List OFL, List S) Add( Variant A
    , List B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="Variant/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 25,17
 Object ( List B) Input:A;  //_GUI 25,27
 Object Output( List OFL) ;  //_GUI 97,18
 Object Output:A( List S) ;  //_GUI 97,27
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 33,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,17
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 82,16
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 82,25
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 57,16
 Object ( Variant OFL, Variant S) Add:A( Variant A
    , Variant B) ;  //_GUI 57,25

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
 ListOut.0 = Add:A.0;  //_GUI 78,21, 78,27
 ListOut.1 = Add.0;  
 ListOut:A.0 = Add:A.1;  
 ListOut:A.1 = Add.1;  //_GUI 82,24, 74,24
 Add.0 = Junction.1;  
 Add.1 = ListIn.1;  //_GUI 51,21, 51,27
 Add:A.0 = Junction.2;  //_GUI 54,27, 54,24, 48,24
 Add:A.1 = ListIn.0;  
}

Object ( List OFL, List S) Add( List A
    , List B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 10,13
 Object ( List B) Input:A;  //_GUI 10,22
 Object Output( List OFL) ;  //_GUI 86,13
 Object Output:A( List S) ;  //_GUI 86,22
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 22,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,11
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 22,11
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 71,20
 Object ( Variant OFL, Variant S) Add( Variant A
    , Variant B) ;  //_GUI 46,11
 Object ( Variant OFL, Variant S) Add:A( Variant A
    , Variant B) ;  //_GUI 46,20

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = Add:A.0;  //_GUI 67,16, 67,22
 ListOut.1 = Add.0;  
 ListIn:A.0 = Input.0;  
 ListOut:A.0 = Add:A.1;  
 ListOut:A.1 = Add.1;  //_GUI 71,19, 63,19
 Add.0 = ListIn:A.1;  
 Add.1 = ListIn.1;  //_GUI 40,16, 40,22
 Add:A.0 = ListIn:A.0;  //_GUI 43,22, 43,19, 37,19, 37,16
 Add:A.1 = ListIn.0;  
}

Object ( Variant Out1) "2^N_LSBList"( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 4,43
 Object Output( Variant Out1) ;  //_GUI 221,30
 Object ( Variant Size) ListSize( Variant List) ;  //_GUI 51,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,43
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 77,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 63,26
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 76,10
 //_ Attributes Documentation="list"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In3) ;  //_GUI 47,26
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 89,12
 //_ Attributes Documentation="NULL"
 Object Text;  //_GUI 51,33,Subtract (using Lo_N) our list size (in bits) from the power of 2 size.
 Object Text;  //_GUI 89,31,Make a list with one element per bit
 Object Text;  //_GUI 114,28,Replace each element with a zeroed one from the origonal list.
 Object Text;  //_GUI 75,4,Get an element and zero it.
 Object Text;  //_GUI 166,11,Add the zeroed elements to the top (Most sig) end.
 Object ( Variant Out1) Bit_List( Variant In1) ;  //_GUI 100,21
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 12,41
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 203,28
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 134,35
 //_ Attributes Documentation="NULL"
 Object Text;  //_GUI 142,50,we're performing a manual CAT operation here: the NULL list represents the empty list
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 176,20
 //_ Attributes Documentation="var/list"
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 151,20
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 151,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 133,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 147,37
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 147,32
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 90,21
 //_ Attributes Documentation="zterm"
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 115,19
 Object ( Variant Out1) "Pad2^N"( Variant In1) ;  //_GUI 65,19

 //_ Behavior Topology
 Output.0 = $Select.0;  
 ListSize.0 = Junction:B.2;  
 Junction.0 = LsbList.0;  
 Lo_N.0 = "Pad2^N".0;  //_GUI 76,24, 76,22
 Lo_N.1 = Junction:A.1;  
 Junction:A.0 = ListSize.0;  
 PopLsb.0 = Junction:B.1;  //_GUI 48,13
 Junction:B.0 = Junction.0;  
 Zero.0 = PopLsb.1;  
 Bit_List.0 = LSB.0;  
 LsbList.0 = Input.0;  
 $Select.0 = AppendLsbList.0;  //_GUI 203,23
 $Select.1 = $SelectOut:A.1;  
 $Select.2 = Junction:D.1;  //_GUI 173,36, 173,38
 IsNULL.0 = Junction:C.2;  
 AppendLsbList.0 = $SelectOut.0;  
 AppendLsbList.1 = $SelectOut:A.0;  //_GUI 176,30
 $SelectOut.0 = Junction:C.1;  
 $SelectOut.1 = Junction:E.1;  //_GUI 148,25
 $SelectOut:A.0 = Junction.1;  //_GUI 130,30, 130,44
 $SelectOut:A.1 = Junction:E.2;  
 Junction:C.0 = ListFill.0;  
 Junction:D.0 = IsNULL.0;  
 Junction:E.0 = Junction:D.0;  
 LSB.0 = Lo_N.0;  
 ListFill.0 = Zero.0;  //_GUI 112,21, 112,15
 ListFill.1 = Bit_List.0;  
 "Pad2^N".0 = Junction:A.0;  //_GUI 64,22
}

Object ( Variant Size) $ListSize( List List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 18,24
 Object Output( Variant Size) ;  //_GUI 89,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 62,22
 Object Text;  //_GUI 27,37,This object returns a data set with as many bits as the List has elements.
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 76,22
 Object ( Variant Size) $ListSize( Variant List) ;  //_GUI 46,16
 //_ Attributes Documentation="List"
 Object ( Variant Size) $ListSize:A( Variant List) ;  //_GUI 46,24
 //_ Attributes Documentation="List"

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $ListSize:A.0;  
 ListOut.1 = $ListSize.0;  //_GUI 59,24, 59,19
 LSB.0 = ListOut.0;  
 $ListSize.0 = ListIn.1;  //_GUI 44,19, 44,24
 $ListSize:A.0 = ListIn.0;  
}

Object ( Variant Size) $ListSize( NULL List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL List) Input;  //_GUI 13,21
 Object Output( Variant Size) ;  //_GUI 39,21
 Object Text;  //_GUI 16,27,This is an empty list element, which is still counted.
 Object ( Bit In) Input:A;  //_GUI 31,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Size) $ListSize( Variant List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 23,18
 Object Output( Variant Size) ;  //_GUI 47,18
 Object ( Bit In) Input:A;  //_GUI 39,18
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) OR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async\\OR"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 17,35
 Object ( Variant In2) Input:A;  //_GUI 17,38
 Object Output( Variant Out1) ;  //_GUI 66,36
 Object ( Variant Out1) $OR( Variant In1, Variant In2) ;  //_GUI 46,34
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 29,34
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $OR.0;  
 $OR.0 = Symmetrize.0;  
 $OR.1 = Symmetrize.1;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( List Out1) OR( List In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List/List"
{
 // OR - Variant Select Case
 //
 // Date:
 // 13 May 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 21,15
 Object ( List In2) Input:A;  //_GUI 21,25
 Object Output( List Out1) ;  //_GUI 93,19
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 76,17
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,23
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,13
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,23
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 70,22, 70,26
 ListOut.1 = $OR_SameLists.0;  //_GUI 72,19, 72,16
 ListIn:A.0 = Input:A.0;  
 $OR_SameLists.0 = ListIn.1;  
 $OR_SameLists.1 = ListIn:A.1;  //_GUI 49,18, 49,22, 44,22, 44,25
 $OR_SameLists:A.0 = ListIn.0;  //_GUI 47,25, 47,18
 $OR_SameLists:A.1 = ListIn:A.0;  
}

Object ( List Out1) OR( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var/List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,14
 Object ( List In2) Input:A;  //_GUI 21,25
 Object Output( List Out1) ;  //_GUI 93,19
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 56,23
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 57,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 76,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 46,14

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 OR.0 = Junction.2;  //_GUI 47,25
 OR.1 = ListIn.0;  
 OR:A.0 = Junction.1;  
 OR:A.1 = ListIn.1;  //_GUI 52,18, 52,22, 43,22, 43,25
 ListOut.0 = OR.0;  //_GUI 70,22, 70,26
 ListOut.1 = OR:A.0;  //_GUI 72,19, 72,16
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
}

Object ( List Out1) OR( List In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List/Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 21,15
 Object ( Variant In2) Input:A;  //_GUI 26,27
 Object Output( List Out1) ;  //_GUI 94,16
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 56,23
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 57,13
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 77,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 50,27

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 OR.0 = ListIn.0;  //_GUI 45,25, 45,18
 OR.1 = Junction.1;  
 OR:A.0 = ListIn.1;  
 OR:A.1 = Junction.0;  //_GUI 51,18
 ListIn.0 = Input.0;  
 ListOut.0 = OR.0;  //_GUI 70,19, 70,26
 ListOut.1 = OR:A.0;  
 Junction.0 = Input:A.0;  
}

Object ( Variant Out1) OR( Variant In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) OR( NULL In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Null/Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Variant In2) Input:A;  //_GUI 21,22
 Object Output( Variant Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( NULL Out1) OR( NULL In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Null/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( NULL Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) OR( List In2, Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List\\Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Bit In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 51,20
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 51,29

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = OR:A.0;  //_GUI 65,29, 65,32
 ListOut.1 = OR.0;  //_GUI 66,26, 66,23
 OR.0 = ListIn.1;  
 OR.1 = Junction.0;  //_GUI 46,25
 OR:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 OR:A.1 = Junction.1;  
}

Object ( List Out1) OR( Bit In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Bit\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 48,16
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 48,24

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = OR:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = OR.0;  
 OR.0 = Junction.1;  
 OR.1 = ListIn.1;  //_GUI 41,21, 41,26
 OR:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 OR:A.1 = ListIn.0;  
}

Object ( Variant Out1) OR( Bit In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Bit\\Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,26
 Object Output( Variant Out1) ;  //_GUI 120,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 73,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 24,26
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 95,15
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 57,16
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 57,24

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = OR:A.0;  //_GUI 71,22, 71,27
 VariantOut.1 = OR.0;  
 VariantIn.0 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Cast.0 = Junction:A.2;  //_GUI 92,17, 92,33, 25,33
 Cast.1 = VariantOut.0;  
 OR.0 = Junction.1;  
 OR.1 = VariantIn.1;  //_GUI 49,21, 49,26
 OR:A.0 = Junction.2;  //_GUI 52,26, 52,23, 43,23
 OR:A.1 = VariantIn.0;  
}

Object ( Variant Out1) OR( Variant In2, Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Variant\\Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,18
 Object ( Bit In1) Input:A;  //_GUI 12,28
 Object Output( Variant Out1) ;  //_GUI 98,17
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 20,16
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 43,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 17,18
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 81,15
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 48,16
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 48,24

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = OR:A.0;  //_GUI 63,22, 63,27
 VariantOut.1 = OR.0;  
 VariantIn.0 = Junction:A.1;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 79,17, 79,12, 18,12
 Cast.1 = VariantOut.0;  
 OR.0 = VariantIn.1;  
 OR.1 = Junction.0;  //_GUI 44,21
 OR:A.0 = VariantIn.0;  //_GUI 39,26, 39,21
 OR:A.1 = Junction.1;  
}

Object ( Bit Out1) OR( Bit In1, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Bit/Null"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 21,14
 Object ( NULL In2) Input:A;  //_GUI 21,25
 Object Output( Bit Out1) ;  //_GUI 92,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) OR( NULL In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Null/Bit"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 21,14
 Object ( Bit In2) Input:A;  //_GUI 21,22
 Object Output( Bit Out1) ;  //_GUI 89,22

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) $MaskToNum( Variant Data, Variant Lower) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="Variant"
{
 // Date Last Modifed:
 // 12 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 36,23
 Object ( Variant Lower) Input:A;  //_GUI 41,49
 Object Output( Variant Out1) ;  //_GUI 161,34
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 46,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 60,49
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 67,28
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 147,32
 Object Text;  //_GUI 66,73,At each step of the recursion we are setting the next bit (starting from the most-significant).  In this manner we build up an LSB data set containing the binary value.  The $Cast objects are here to enforce the type of our first collection of two Bits into an LSB002.
 Object ( Bit In) Input:B;  //_GUI 61,62
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 73,48
 Object ( Variant Out1) CollectLSB:A( Variant In2, Variant In3) ;  //_GUI 72,58
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 66,22
 Object ( Variant Out1) $MaskToNum( Variant Data, Variant Lower) ;  //_GUI 124,31
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $MaskToNum:A( Variant Data, Variant Lower) ;  //_GUI 123,56
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input.0;  
 Junction.0 = Input:A.0;  
 NotZero.0 = Junction:A.2;  
 OR.0 = $MaskToNum.0;  
 OR.1 = $MaskToNum:A.0;  //_GUI 144,37, 144,59
 CollectLSB.0 = Junction.1;  
 CollectLSB.1 = NotZero.0;  //_GUI 64,53, 64,39, 82,39, 82,31
 CollectLSB:A.0 = Junction.2;  //_GUI 61,60
 CollectLSB:A.1 = Input:B.0;  
 Junction:A.0 = VariantIn.1;  
 $MaskToNum.0 = Junction:A.1;  //_GUI 120,33, 120,23
 $MaskToNum.1 = CollectLSB.0;  //_GUI 106,36, 106,51
 $MaskToNum:A.0 = VariantIn.0;  //_GUI 117,58, 117,26
 $MaskToNum:A.1 = CollectLSB:A.0;  
}

Object ( Variant Out1) $MaskToNum( Bit Data, Variant Lower) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Encoders/Decoders\\$Internal",Documentation="leaf"
{
 // Date Last Modifed:
 // 12 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 36,31
 Object ( Variant Lower) Input:A;  //_GUI 37,42
 Object Output( Variant Out1) ;  //_GUI 94,42

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) "Pad2^N"( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Filters incoming data producing a BIN data set where the bitlength is a power of 2.  Leading 0s will be added if necessary.
 //
 // Inputs:
 //
 // Variant input: A value that may be zero extended to have a length equal to a power of two.
 //
 // Outputs:
 //
 // Variant output: The value that may have been zero extended to have a length equal to a power of two.
 //
 // Example:
 //
 // Input	Output
 // Bit (1)	Bit (1)
 // MSB002	BIN002
 // LSB003	BIN004
 // LSB004	BIN004
 // BIN005	BIN008
 // MSB008	BIN008
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 6,28
 Object Output( Variant Out1) ;  //_GUI 166,29
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 43,43
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 59,43
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 114,51
 Object Text;  //_GUI 44,54,We want the bitlength to be an even power of two.  If anything besides the most-signiicant bit is 1, we must increase the size of the input data set to an even power of 2.
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 138,27
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 151,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 22,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 55,45
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 77,33
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 60,35
 Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) ;  //_GUI 92,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 112,28
 Object ( Variant Out1) BitLength( Variant Type) ;  //_GUI 30,43
 Object ( Bit In) Input:A;  //_GUI 69,31
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 115,60,If the output of NotZero is asserted, we will alter the incoming data set.
 Object Text;  //_GUI 84,19,In this case, the output of Constant->N_Bits is a data set whose bitlength is an exact power of 2.
 Object Text;  //_GUI 175,23,We are guaranteed that the output is a BIN type whose bitlength is an exact power of 2.  This property may be very desirable in certain recursive situations.  See the Encode object as an example.
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 117,34

 //_ Behavior Topology
 Output.0 = BIN.0;  
 MSB.0 = BitLength.0;  
 VariantIn.0 = Junction:A.1;  
 NotZero.0 = VariantIn.0;  //_GUI 109,54, 109,48
 $Select.0 = Junction:B.1;  
 $Select.1 = UExtnd.1;  //_GUI 133,32, 133,39
 $Select.2 = NotZero.0;  //_GUI 135,35, 135,54
 BIN.0 = $Select.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = MSB.0;  
 VariantOut.0 = Zero.0;  
 VariantOut.1 = Input:A.0;  //_GUI 75,35, 75,32
 Zero.0 = Junction:A.0;  //_GUI 56,38
 "Constant->N_Bits".0 = VariantOut.0;  
 Junction:B.0 = Junction.1;  
 BitLength.0 = Junction.2;  //_GUI 23,46
 UExtnd.0 = "Constant->N_Bits".0;  
 UExtnd.1 = Junction:B.2;  //_GUI 113,39
}

Object ( Bit Out1) "Pad2^N"( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit"
{
 // Filters incoming data producing a BIN data set where the bitlength is a power of 2.  Leading 0s will be added if necessary.
 //
 // Inputs:
 //
 // Variant input: A value that may be zero extended to have a length equal to a power of two.
 //
 // Outputs:
 //
 // Variant output: The value that may have been zero extended to have a length equal to a power of two.
 //
 // Example:
 //
 // Input	Output
 // Bit (1)	Bit (1)
 // MSB002	BIN002
 // LSB003	BIN004
 // LSB004	BIN004
 // BIN005	BIN008
 // MSB008	BIN008
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 34,27
 Object Output( Bit Out1) ;  //_GUI 54,27
 Object Text;  //_GUI 40,35,If the input type is Bit, nothing needs to be done.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) $AND( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="Variant"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,15
 Object ( Variant In2) Input:A;  //_GUI 15,25
 Object Output( Variant Out1) ;  //_GUI 110,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 28,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,17
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 28,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 22,15
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 93,15
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 55,13
 Object ( Variant Out1) $AND:A( Variant In1, Variant In2) ;  //_GUI 55,23

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Input:A.0;  
 VariantOut.0 = $AND:A.0;  //_GUI 68,22, 68,26
 VariantOut.1 = $AND.0;  //_GUI 68,19, 68,16
 VariantIn:A.0 = Junction.1;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 89,17, 89,9, 23,9
 Cast.1 = VariantOut.0;  
 $AND.0 = VariantIn:A.1;  
 $AND.1 = VariantIn.1;  //_GUI 49,18, 49,22, 44,22, 44,25
 $AND:A.0 = VariantIn:A.0;  //_GUI 47,25, 47,18
 $AND:A.1 = VariantIn.0;  
}

Object ( Bit Out1) $AND( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="Leaf"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 28,15
 Object ( Bit In2) Input:A;  //_GUI 28,18
 Object Output( Bit Out1) ;  //_GUI 54,16
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 37,14

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
}

Object ( List Out1) $AND( List In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="List\\Var"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 89,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,24
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 51,20
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $AND:A( Variant In1, Variant In2) ;  //_GUI 51,29
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $AND:A.0;  //_GUI 65,29, 65,32
 ListOut.1 = $AND.0;  //_GUI 66,26, 66,23
 $AND.0 = ListIn.1;  
 $AND.1 = Junction.0;  //_GUI 46,25
 $AND:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $AND:A.1 = Junction.1;  
}

Object ( List Out1) $AND( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Icon="AND",Documentation="Var\\List"
{
 // Added July 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 90,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 72,17
 Object ( Variant Out1) $AND( Variant In1, Variant In2) ;  //_GUI 48,16
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) $AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $AND:A.0;  //_GUI 63,22, 63,27
 ListOut.1 = $AND.0;  
 $AND.0 = Junction.1;  
 $AND.1 = ListIn.1;  //_GUI 41,21, 41,26
 $AND:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $AND:A.1 = ListIn.0;  
}

Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires and possibly inverters.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,21
 Object ( Variant In2) Input:A;  //_GUI 10,24
 Object Output( Variant Out1) ;  //_GUI 41,21
 Object Output:A( Variant Out2) ;  //_GUI 41,24
 Object Text;  //_GUI 25,41,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Bit In) Input:B;  //_GUI 20,27
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 26,20
 Object Text;  //_GUI 17,33,Warn by default.

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 $Symmetrize.0 = Input.0;  
 $Symmetrize.1 = Input:A.0;  
 $Symmetrize.2 = Input:B.0;  
}

Object ( List Out1) $AND_SameLists( List In2, List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\List"
{
 // Added Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 19,31
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $AND_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $AND_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $AND_SameLists.0;  //_GUI 74,26, 74,23
 ListIn:A.0 = Input:A.0;  
 $AND_SameLists.0 = ListIn.1;  
 $AND_SameLists.1 = ListIn:A.1;  //_GUI 43,25, 43,33
 $AND_SameLists:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $AND_SameLists:A.1 = ListIn:A.0;  //_GUI 51,36
}

Object ( List Out1) $AND_SameLists( List In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="List\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Bit In) Input:B;  //_GUI 22,39
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 28,39
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $AND_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $AND_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $AND_SameLists.0;  //_GUI 74,26, 74,23
 Output:A.0 = Input:B.0;  
 $AND_SameLists.0 = ListIn.1;  
 $AND_SameLists.1 = Junction.0;  //_GUI 46,25
 $AND_SameLists:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 $AND_SameLists:A.1 = Junction.1;  
}

Object ( List Out1) $AND_SameLists( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,17
 Object ( Bit In) Input:B;  //_GUI 30,34
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 36,34
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $AND_SameLists( Variant In2, Variant In1) ;  //_GUI 48,16
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $AND_SameLists:A( Variant In2, Variant In1) ;  //_GUI 48,24
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $AND_SameLists:A.0;  //_GUI 71,22, 71,27
 ListOut.1 = $AND_SameLists.0;  
 Output:A.0 = Input:B.0;  
 $AND_SameLists.0 = Junction.1;  
 $AND_SameLists.1 = ListIn.1;  //_GUI 41,21, 41,26
 $AND_SameLists:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $AND_SameLists:A.1 = ListIn.0;  
}

Object ( Variant Out1) $AND_SameLists( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="Var\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,20
 Object Output( Variant Out1) ;  //_GUI 30,18
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 18,16
 //_ Attributes Documentation="Var/NULL"

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
}

Object ( NULL Hi, NULL Lo) Bisect( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,33
 Object Output( NULL Hi) ;  //_GUI 52,20
 Object Output:A( NULL Lo) ;  //_GUI 52,33
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 43,33

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 44,21
 Output:A.0 = Junction.1;  
 Junction.0 = Input.0;  
}

Object ( NULL Hi, Bit Lo) Bisect( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="bit"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 19,33
 Object Output( NULL Hi) ;  //_GUI 52,20
 Object Output:A( Bit Lo) ;  //_GUI 52,33
 Object ( NULL Out1) NULL;  //_GUI 34,18
 Object Text;  //_GUI 26,39,Odd elements go out Lo

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) Bisect( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,37
 Object Output( Variant Hi) ;  //_GUI 105,31
 Object Output:A( Variant Lo) ;  //_GUI 105,37
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 26,35
 //_ Attributes Documentation="list"
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 45,30
 //_ Attributes Documentation="list"
 Object ( Variant Hi, Variant Lo) Bisect( Variant In1) ;  //_GUI 59,32
 //_ Attributes Documentation="zterm"
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 75,29
 //_ Attributes Documentation="ztl/var"
 Object ( Variant Out1) PushLsb:A( Variant In1, Variant LSB) ;  //_GUI 88,35
 //_ Attributes Documentation="ztl/var"

 //_ Behavior Topology
 Output.0 = PushLsb.0;  
 Output:A.0 = PushLsb:A.0;  
 PopLsb.0 = Input.0;  
 PopMsb.0 = PopLsb.0;  //_GUI 40,33, 40,37
 Bisect.0 = PopMsb.1;  
 PushLsb.0 = PopMsb.0;  //_GUI 58,31, 58,32
 PushLsb.1 = Bisect.0;  
 PushLsb:A.0 = Bisect.1;  
 PushLsb:A.1 = PopLsb.1;  
}

Object ( Variant Hi, Variant Lo) Bisect( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Bisects the dataset into high (Hi) and low (Lo) sections.  If the input is a list, the list is bisected.  For odd numbered inputs, the extra Bit/element is put with the low (Lo) section.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use BisectList instead.
 //
 // Inputs:
 //
 // Variant input: The variant or list that will be bisected.
 //
 // Outputs:
 //
 // Variant Hi: The high (MSB) half of the bisected variant or list.
 //
 // Variant Lo: The low (LSB) half of the bisected variant or list.  This half will contain any odd bit or element.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,18
 Object Output( Variant Hi) ;  //_GUI 41,17
 Object Output:A( Variant Lo) ;  //_GUI 40,20
 Object ( Variant Hi, Variant Lo) BisectList( Variant In1) ;  //_GUI 23,16
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = BisectList.0;  
 Output:A.0 = BisectList.1;  
 BisectList.0 = Input.0;  
}

Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\Async"
{
 // Multiplexer
 //
 // INPUTS:
 //
 // Variant A: The first input to select between.
 //
 // Variant B: The second input to select between.  A and B must have the same dataset.
 //
 // Variant Sel: A number to select which input to output.  0 for A and 1 for B.
 //
 // OUTPUTS:
 //
 // Variant O:	The multiplexed output.  Has the same dataset as input A.
 //
 // August 25, 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,28
 Object ( Variant B) Input:A;  //_GUI 22,31
 Object ( Bit S) Input:B;  //_GUI 22,34
 Object Output( Variant O) ;  //_GUI 71,29
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 52,27
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 33,27
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 $Mux.0 = Symmetrize.0;  
 $Mux.1 = Symmetrize.1;  
 $Mux.2 = Input:B.0;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
}

Object ( Variant O) Mux( Variant A, NULL B
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,13
 Object ( NULL B) Input:A;  //_GUI 22,23
 Object ( Bit S) Input:B;  //_GUI 22,31
 Object Output( Variant O) ;  //_GUI 61,14
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 49,12
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 30,29

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = INVERT.0;  //_GUI 43,17, 43,32
 INVERT.0 = Input:B.0;  
}

Object ( Variant O) Mux( NULL A, Variant B
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 19,18
 Object ( Variant B) Input:A;  //_GUI 19,21
 Object ( Bit S) Input:B;  //_GUI 19,24
 Object Output( Variant O) ;  //_GUI 43,22
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 31,20

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input:A.0;  
 AND.1 = Input:B.0;  
}

Object ( Variant MSB, Variant Out2) PopMsb( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="list"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 36,18
 Object Output:A( Variant Out2) ;  //_GUI 36,21
 Object ( Variant MSB, Variant Out2) ListPopMsb( Variant In1) ;  //_GUI 21,17
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListPopMsb.0;  
 Output:A.0 = ListPopMsb.1;  
 ListPopMsb.0 = Input.0;  
}

Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 48,18
 Object Output:A( Variant Out2) ;  //_GUI 48,21
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 23,17
 //_ Attributes Documentation="Error"

 //_ Behavior Topology
 Output.0 = ExposeMSB.0;  
 Output:A.0 = ExposeMSB.1;  
 ExposeMSB.0 = Input.0;  
}

Object ( Bit MSB, NULL Out1) PopMsb( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="bit"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 15,19
 Object Output( Bit MSB) ;  //_GUI 39,10
 Object Output:A( NULL Out1) ;  //_GUI 39,17
 Object ( NULL Out1) NULL;  //_GUI 27,15

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 23,11, 23,20
 Output:A.0 = NULL.0;  
}

Object ( NULL MSB, NULL Out1) PopMsb( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL"
{
 // This object removes, or pops the most significant input item from the input and outputs the popped item out the top output and the remnant of the input out the bottom output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the bottom output dataset is MSBxxx (or Bit) and the MSB output is a Bit.
 //
 // * For a bit input, the bottom output dataset is NULL and the MSB output is a Bit.
 //
 // * For any non-empty list, the MSB output is the most significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the bottom output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the bottom output is the remnant of the BIN ordered input list, which had the most significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the bottom output is the remnant of the input list, which had the most significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopMSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the most significant item will be popped.
 //
 // Outputs:
 //
 // Variant MSB: The popped item.
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,17
 Object Output( NULL MSB) ;  //_GUI 39,10
 Object Output:A( NULL Out1) ;  //_GUI 39,17
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 22,17

 //_ Behavior Topology
 Output.0 = Junction.0;  //_GUI 23,11
 Output:A.0 = Junction.1;  
 Junction.0 = Input.0;  
}

Object ( Variant Out1) Min_Rep( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Date:
 // 11/11/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,40
 Object Output( Variant Out1) ;  //_GUI 100,37
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 24,38
 //_ Attributes Documentation="bit"
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 86,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 20,40
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 69,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 47,42
 Object Text;  //_GUI 37,6,Remove all leading zeros then output as LSB.
 Object Text;  //_GUI 43,15,If MSB is a zero, remove it then recurse.
 Object Text;  //_GUI 46,103,If MSB is a one, LSB the original input and output it.
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 71,34
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 55,49
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 55,32

 //_ Behavior Topology
 Output.0 = $Select.0;  
 ExposeMSB.0 = Junction:A.1;  
 $Select.0 = Min_Rep.0;  
 $Select.1 = LSB.0;  //_GUI 82,40, 82,52
 $Select.2 = Junction:B.1;  
 Junction.0 = ExposeMSB.0;  
 Junction:A.0 = Input.0;  
 LSB.0 = $Select:A.0;  
 Junction:B.0 = Junction.2;  
 Min_Rep.0 = $Select:B.0;  //_GUI 71,35
 $Select:A.1 = Junction:A.2;  //_GUI 21,54
 $Select:A.2 = Junction:B.2;  //_GUI 48,57
 $Select:B.0 = ExposeMSB.1;  //_GUI 40,34, 40,43
 $Select:B.2 = Junction.1;  
}

Object ( NULL Out1) Min_Rep( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 16,24
 Object Output( NULL Out1) ;  //_GUI 29,24
 Object Text;  //_GUI 12,10,The minimum representation of NULL is NULL

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Signed Out1) Min_Rep( Signed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Signed"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 16,24
 Object Output( Signed Out1) ;  //_GUI 78,24
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 65,22
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 53,22
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 22,22
 Object ( Variant Out1) Min_Rep_Twos( Variant In1) ;  //_GUI 35,22

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 SignedOut.0 = MSB.0;  
 MSB.0 = Min_Rep_Twos.0;  
 SignedIn.0 = Input.0;  
 Min_Rep_Twos.0 = SignedIn.0;  
}

Object ( Fixed Out1) Min_Rep( Fixed In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Fixed"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 16,30
 Object Output( Fixed Out1) ;  //_GUI 101,30
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 22,28
 Object ( Variant Out1) Min_Rep_Twos( Variant In1) ;  //_GUI 52,27
 Object Text;  //_GUI 45,19,Reduce whole part to smalles two's complement representation.
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 38,35
 //_ Attributes Documentation="Leaf"
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 53,35
 Object ( Variant Out1) ReverseBits:A( Variant In1) ;  //_GUI 65,35
 //_ Attributes Documentation="Leaf"
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 86,28
 Object Text;  //_GUI 43,44,Remove all trailing zeros of fraction

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 ExposeFixed.0 = Input.0;  
 Min_Rep_Twos.0 = ExposeFixed.0;  
 ReverseBits.0 = ExposeFixed.1;  //_GUI 36,38, 36,33
 Min_Rep.0 = ReverseBits.0;  
 ReverseBits:A.0 = Min_Rep.0;  
 CollectFixed.0 = Min_Rep_Twos.0;  
 CollectFixed.1 = ReverseBits:A.0;  //_GUI 82,33, 82,38
}

Object ( Bit Out1) Min_Rep( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 16,24
 Object Output( Bit Out1) ;  //_GUI 29,24
 Object Text;  //_GUI 12,10,A constant of 1 is represented by a single bit with a value of one.A constant of 0 is represented by a single bit with a value of zero.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Floating Out1) Min_Rep( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Floating"
{
 // This takes in a constant, and converts it to the smallest dataset capable of representing the constant.  (Removes leading zeros for unsigned datasets.)  It is very often seen taking input from a BitLength object, which proces a 32-bit constant.  Supports datasets of unsigned (MSBxxx, LSBxxx and BINxxx), Signed, Fixed, Floating, Bit and NULL)
 //
 // A zero value input returns a bit with a value of zero.
 //
 // Inputs:
 //
 // Variant input: Constant data.
 //
 // Outputs:
 //
 // Variant output: A minimal dataset that can still represent the constant input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 6,35
 Object Output( Floating Out1) ;  //_GUI 264,24
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 177,41
 //_ Attributes Documentation="Leaf"
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 192,41
 Object ( Variant Out1) ReverseBits:A( Variant In1) ;  //_GUI 204,41
 //_ Attributes Documentation="Leaf"
 Object Text;  //_GUI 181,38,Remove all trailing zeros of mant
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 22,33
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 246,22
 Object ( Variant Out1) Min_Rep_Twos( Variant In1) ;  //_GUI 137,29
 Object ( Bit OFL, Variant Out2) AddBias( Variant In1) ;  //_GUI 155,29
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 215,23
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 175,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 171,30
 Object Text;  //_GUI 177,13,Only overflows if trying to AddBias to MaxNeg, so in this case, sign extend one bit.
 Object Text;  //_GUI 62,25,two's complement bias
 Object ( Bit OFL, Variant Out1) RemoveBias( Variant In1) ;  //_GUI 60,35
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 84,29
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 125,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 77,36
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 107,29
 Object ( Bit In) Input:A;  //_GUI 101,30
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 197,23
 Object ( Bit In) Input:B;  //_GUI 191,24
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 87,18,Only overflows if trying to RemoveBias to MaxPos, so in this case, sign extend one bit.
 Object ( Variant Out1) EqualZero( Variant In1) ;  //_GUI 30,46
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:B
    ( Floating In0) ;  //_GUI 12,35
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 234,24
 Object ( MSB002 In) Input:C;  //_GUI 228,28
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant D
    , Bit S) ;  //_GUI 44,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 43,48
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 15,44
 //_ Attributes Documentation="bit"
 Object Text;  //_GUI 19,54,Detect negative zero also by removing the sign bit
 Object Text;  //_GUI 233,51,If zero, exp is 2 bits of zero

 //_ Behavior Topology
 Output.0 = CollectFloating.0;  
 ReverseBits.0 = ExposeFloating.2;  //_GUI 38,44
 Min_Rep.0 = ReverseBits.0;  
 ReverseBits:A.0 = Min_Rep.0;  
 ExposeFloating.0 = Junction:B.1;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 246,10, 38,10
 CollectFloating.1 = $Select:B.0;  
 CollectFloating.2 = ReverseBits:A.0;  //_GUI 246,44
 Min_Rep_Twos.0 = $Select:A.0;  
 AddBias.0 = Min_Rep_Twos.0;  
 $Select.0 = $SelectOut.0;  //_GUI 215,20, 187,20
 $Select.1 = CollectMSB:A.0;  //_GUI 212,28, 212,26
 $Select.2 = Junction.1;  
 $SelectOut.0 = AddBias.1;  //_GUI 168,25, 168,34
 $SelectOut.1 = Junction.0;  //_GUI 172,28
 Junction.0 = AddBias.0;  
 RemoveBias.0 = $SelectOut:B.0;  
 $SelectOut:A.0 = RemoveBias.1;  //_GUI 81,31, 81,40
 $SelectOut:A.1 = Junction:A.0;  //_GUI 78,34
 $Select:A.0 = $SelectOut:A.0;  //_GUI 125,27, 96,27
 $Select:A.1 = CollectMSB.0;  //_GUI 122,34, 122,32
 $Select:A.2 = Junction:A.1;  
 Junction:A.0 = RemoveBias.0;  
 CollectMSB.0 = Input:A.0;  
 CollectMSB.1 = $SelectOut:A.1;  
 CollectMSB:A.0 = Input:B.0;  
 CollectMSB:A.1 = $SelectOut.1;  
 EqualZero.0 = ExposeMSB.1;  
 Junction:B.0 = Input.0;  
 $Select:B.0 = $Select.0;  
 $Select:B.1 = Input:C.0;  
 $Select:B.2 = Junction:C.1;  //_GUI 234,49
 $SelectOut:B.0 = ExposeFloating.1;  
 $SelectOut:B.1 = Junction:C.0;  
 Junction:C.0 = EqualZero.0;  
 ExposeMSB.0 = Junction:B.2;  //_GUI 13,47
}

Object ( Bit Out1) OR-NInput( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="bit"
{
 // All bits are ORed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ORing all input bits.
 //
 // Revision 2 - 11/08/05 documentation AND to OR
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) OR-NInput( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async\\Advanced"
{
 // All bits are ORed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ORing all input bits.
 //
 // Revision 2 - 11/08/05 documentation AND to OR
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 59,31
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 32,29
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 17,29
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 47,29

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 $OR-NInput.0 = ExposeBIN.0;  
 $OR-NInput.1 = ExposeBIN.1;  
 ExposeBIN.0 = Input.0;  
 VouchBit.0 = $OR-NInput.0;  
}

Object ( NULL Out1) OR-NInput( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="NULL"
{
 // All bits are ORed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ORing all input bits.
 //
 // Revision 2 - 11/08/05 documentation AND to OR
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 10,31
 Object Output( NULL Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out"
{
 // Date:
 // 12 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 26,22
 Object ( Variant In3) Input:A;  //_GUI 26,25
 Object Output( Variant Out1) ;  //_GUI 62,23
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 35,21
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 50,21
 Object Text;  //_GUI 31,33,The data sets of the inputs are arbitrary.  The LSB  operator will arrange all bits in the list into an LSB data set.

 //_ Behavior Topology
 Output.0 = LSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 LSB.0 = ListOut.0;  
}

Object ( Variant mLSBOut) CollectLSB( Variant Hi, NULL Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out",Documentation="Var/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( Variant mLSBOut) ;  //_GUI 41,14
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 28,12

 //_ Behavior Topology
 Output.0 = LSB.0;  
 LSB.0 = Input.0;  //_GUI 20,15, 20,14
}

Object ( Variant mLSBOut) CollectLSB( NULL Hi, Variant Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out",Documentation="Null/Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( Variant Lo) Input:A;  //_GUI 7,16
 Object Output( Variant mLSBOut) ;  //_GUI 41,14
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 28,12

 //_ Behavior Topology
 Output.0 = LSB.0;  
 LSB.0 = Input:A.0;  //_GUI 20,15, 20,17
}

Object ( NULL mLSBOut) CollectLSB( NULL Hi, NULL Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\CollectLSB",Icon="Exposer_Out",Documentation="Null/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( NULL mLSBOut) ;  //_GUI 41,14

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 26,15, 26,14
}

Object ( Variant Out1) $XOR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Variant"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 9,17
 Object ( Variant In2) Input:A;  //_GUI 9,25
 Object Output( Variant Out1) ;  //_GUI 99,16
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 19,15
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 19,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 63,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 15,17
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 81,14
 Object ( Variant Out1) $XOR( Variant In1, Variant In2) ;  //_GUI 46,15
 Object ( Variant Out1) $XOR:A( Variant In1, Variant In2) ;  //_GUI 46,23

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantIn:A.0 = Input:A.0;  
 VariantOut.0 = $XOR:A.0;  //_GUI 60,21, 60,26
 VariantOut.1 = $XOR.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 76,16, 76,11, 16,11
 Cast.1 = VariantOut.0;  
 $XOR.0 = VariantIn.1;  
 $XOR.1 = VariantIn:A.1;  //_GUI 42,20, 42,23, 35,23, 35,25
 $XOR:A.0 = VariantIn.0;  //_GUI 40,25, 40,20
 $XOR:A.1 = VariantIn:A.0;  
}

Object ( Bit Out1) $XOR( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Bit"
{
 // XOR - Variant Select Case
 //
 // Date:
 // 09 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 19,17
 Object ( Bit In2) Input:A;  //_GUI 19,28
 Object Output( Bit Out1) ;  //_GUI 86,19
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 37,16
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 74,17
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 37,24
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 49,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 28,17
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 31,28

 //_ Behavior Topology
 Output.0 = AND.0;  
 OR.0 = Junction.1;  
 OR.1 = Junction:A.0;  //_GUI 32,21
 AND.0 = OR.0;  
 AND.1 = INVERT.0;  //_GUI 65,22, 65,27
 AND:A.0 = Junction.2;  //_GUI 29,26
 AND:A.1 = Junction:A.1;  
 INVERT.0 = AND:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
}

Object ( List Out1) $XOR_SameLists( List In2, List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List\\List"
{
 // Added Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 19,31
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $XOR_SameLists.0;  //_GUI 74,26, 74,23
 ListIn:A.0 = Input:A.0;  
 $XOR_SameLists.0 = ListIn.1;  
 $XOR_SameLists.1 = ListIn:A.1;  //_GUI 43,25, 43,33
 $XOR_SameLists:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $XOR_SameLists:A.1 = ListIn:A.0;  //_GUI 51,36
}

Object ( List Out1) $XOR_SameLists( List In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="List\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Bit In) Input:B;  //_GUI 22,39
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 28,39
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $XOR_SameLists.0;  //_GUI 74,26, 74,23
 Output:A.0 = Input:B.0;  
 $XOR_SameLists.0 = ListIn.1;  
 $XOR_SameLists.1 = Junction.0;  //_GUI 46,25
 $XOR_SameLists:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 $XOR_SameLists:A.1 = Junction.1;  
}

Object ( List Out1) $XOR_SameLists( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Var\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,17
 Object ( Bit In) Input:B;  //_GUI 30,34
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 36,34
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $XOR_SameLists( Variant In2, Variant In1) ;  //_GUI 48,16
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $XOR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 48,24
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $XOR_SameLists:A.0;  //_GUI 71,22, 71,27
 ListOut.1 = $XOR_SameLists.0;  
 Output:A.0 = Input:B.0;  
 $XOR_SameLists.0 = Junction.1;  
 $XOR_SameLists.1 = ListIn.1;  //_GUI 41,21, 41,26
 $XOR_SameLists:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $XOR_SameLists:A.1 = ListIn.0;  
}

Object ( Variant Out1) $XOR_SameLists( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$XOR",Documentation="Var\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,20
 Object Output( Variant Out1) ;  //_GUI 30,18
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 18,16
 //_ Attributes Documentation="Bit/Bit"

 //_ Behavior Topology
 Output.0 = XOR.0;  
 XOR.0 = Input.0;  
 XOR.1 = Input:A.0;  
}

Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out"
{
 // Collects inputs into a BIN data set
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,16
 Object ( Variant In2) Input:A;  //_GUI 14,19
 Object Output( Variant Out1) ;  //_GUI 51,17
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 36,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 22,15

 //_ Behavior Topology
 Output.0 = BIN.0;  
 BIN.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( NULL mMSBOut) CollectBIN( NULL Hi, NULL Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out",Documentation="Null/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( NULL mMSBOut) ;  //_GUI 41,14

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 26,15, 26,14
}

Object ( Variant Out1) CollectBIN( NULL In3, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out",Documentation="null/var"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In3) Input;  //_GUI 22,22
 Object ( Variant In2) Input:A;  //_GUI 22,25
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 39,23

 //_ Behavior Topology
 Output.0 = BIN.0;  
 BIN.0 = Input:A.0;  
}

Object ( Variant Out1) CollectBIN( Variant In2, NULL In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\CollectBIN",Icon="Exposer_Out",Documentation="var/null"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,25
 Object ( NULL In3) Input:A;  //_GUI 22,27
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 41,23

 //_ Behavior Topology
 Output.0 = BIN.0;  
 BIN.0 = Input.0;  
}

Object ( Bit Out1, NULL Out1) ExposeMSB( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In",Documentation="bit"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 36,32
 Object Output( Bit Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1) NULL;  //_GUI 53,36

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
}

Object ( Variant Out1, Variant Out2) ExposeMSB( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,33
 Object Output( Variant Out1) ;  //_GUI 68,32
 Object Output:A( Variant Out2) ;  //_GUI 68,35
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 36,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  
 MSB.0 = Input.0;  
 VariantIn.0 = MSB.0;  
}

Object ( NULL Out1, NULL Out1) ExposeMSB( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\ExposeMSB",Icon="Exposer_In",Documentation="NULL"
{
 // Date:
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 36,32
 Object Output( NULL Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,39
 Junction.0 = Input.0;  
}

Object ( Bit Out1) EqualZero( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\Async"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 4,20
 Object Output( Bit Out1) ;  //_GUI 46,20
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 30,18
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 14,18

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 INVERT.0 = NotZero.0;  
 NotZero.0 = Input.0;  
}

Object ( Bit Out1) EqualZero( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="NULL"
{
 // Date:
 // 11 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 25,16
 Object Output( Bit Out1) ;  //_GUI 47,16
 Object ( Bit In) Input:A;  //_GUI 41,16
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 16,27,Treat a NULL input as a constant zero value.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) EqualZero( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\$Internal",Documentation="Bit"
{
 // Date:
 // 11 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 68,37
 Object Output( Bit Out1) ;  //_GUI 90,37
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 75,35

 //_ Behavior Topology
 Output.0 = INVERT.0;  
 INVERT.0 = Input.0;  
}

Object ( Variant Out1) PushMsb( Variant MSB, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 25,24
 Object ( NULL In2) Input:A;  //_GUI 25,31
 Object Output( Variant Out1) ;  //_GUI 82,24

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 17,12
 Object ( Variant In2) Input:A;  //_GUI 17,15
 Object Output( Variant Out1) ;  //_GUI 54,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 27,11
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 41,11

 //_ Behavior Topology
 Output.0 = MSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 MSB.0 = ListOut.0;  
}

Object ( List Out1) PushMsb( Variant MSB, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/list"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 27,24
 Object ( List In2) Input:A;  //_GUI 27,27
 Object Output( List Out1) ;  //_GUI 83,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 66,23
 Object ( List MsbList) MsbList( List AnyList) ;  //_GUI 37,25
 //_ Attributes Documentation="list"
 Object Text;  //_GUI 28,36,If MSB input is a list, this will put that as the most signficant element of the AnyList. This object always outputs an MSB ordered list on the top level. If you want this to concatenate two lists and give a single list output, call Msb_List instead. For doing multiddimensionial lists, use the ZTList operators instead.

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = MsbList.0;  
 ListOut.1 = Input.0;  
 MsbList.0 = Input:A.0;  
}

Object ( Variant Out1) PushMsb( NULL MSB, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL MSB) Input;  //_GUI 25,24
 Object ( Variant In2) Input:A;  //_GUI 25,31
 Object Output( Variant Out1) ;  //_GUI 82,24
 Object Text;  //_GUI 28,41,Adding no MSB bits to, say, an MSB005 will result in no change to the original data set.

 //_ Behavior Topology
 Output.0 = Input:A.0;  //_GUI 56,25, 56,32
}

Object ( NULL Out1) PushMsb( NULL MSB, NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // This object adds, or pushes the item from the upper input onto the most significant end of the lower input.  Input items should be either a Bit for a Variant or an element for a List.
 //
 // * If the lower input is a variant, the top input is prepended to it and the output dataset is MSBxxx.  To append multiple bits, it is recommended that you use CollectMSB.
 //
 // * If the lower input is a list, this input is first converted to an MSB ordered list and then the top input is prepended as a single element onto the MSB end of the list.  To concatenate two lists, it is recommended that you use the two-input MsbList object.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use the two-input MsbList object instead.
 //
 // Inputs:
 //
 // Variant MSB: The item to push.
 //
 // Variant input: An item will be pushed onto this input's most significant end.
 //
 // Outputs:
 //
 // Variant output: The result of the push.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL MSB) Input;  //_GUI 25,24
 Object ( NULL In2) Input:A;  //_GUI 25,31
 Object Output( NULL Out1) ;  //_GUI 82,24

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) RemoveBias( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Takes in a biased exponent and removes the bias from it and outputs a twos complement exponent. This object does not detect special IEEE floating-point cases for the exponent.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Variant input: A biased exponent
 //
 // Outputs:
 //
 // Bit OFL: The Overflow bit.  Goes high if the input is the maximum positive unsigned value (all bits high), which can't be represented in a twos complement manner.
 //
 // Variant output: The exponent with the bias offset removed and now in twos complement form.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 37,26
 Object Output( Bit OFL) ;  //_GUI 78,17
 Object Output:A( Variant Out1) ;  //_GUI 78,27
 Object ( Variant S) Sub( Variant A, Variant B) ;  //_GUI 64,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,26
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 47,31
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 64,15
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 47,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 59,26
 Object Text;  //_GUI 36,45,A Biased exponant of MaxUInt can't be represented as an unbiased 2's complement value of the same size.  For example a 3 bit biased exponent has a MaxUInt value of 7.  The Bias is 3.  7-3=4. 4 Can't be represented as a 2's complement value in 3 bits (100 is actually -4) and 4 must be represented in 4 bits (0100).Note that IEEE is not supported here.  A biased exponent of all zeros has the special meaning of denormalized mantissa.  A biased exponent of all ones has the special meaning of various NaNs.

 //_ Behavior Topology
 Output.0 = Equal.0;  
 Output:A.0 = Sub.0;  
 Sub.0 = Junction:A.1;  
 Sub.1 = MakeBias.0;  //_GUI 61,30, 61,34
 Junction.0 = Input.0;  
 MakeBias.0 = Junction.2;  //_GUI 44,34
 Equal.0 = AllOnes.0;  
 Equal.1 = Junction:A.0;  //_GUI 60,20
 AllOnes.0 = Junction.0;  //_GUI 44,17
 Junction:A.0 = Junction.1;  
}

Object ( Bit Out1) $BitA_Ge_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 25,44,( 0 >= 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), <, !)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 25,44,( ( ! 0 ) >= 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ge_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 25,44,( 0 >= ( ! 0 ) )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant LsbList) LsbList( Variant AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts a list of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant LsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element MSB ordered list converted to a four-element LSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (list (list (W, X), Y), Z)
 // 2. LsbList(list (W, list (X, list (Y, Z))))	= list (list (list (W, X), Y), Z)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList) Input;  //_GUI 20,33
 Object Output( Variant LsbList) ;  //_GUI 31,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List LsbList) LsbList( List AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // This object converts a list of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant LsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element MSB ordered list converted to a four-element LSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (list (list (W, X), Y), Z)
 // 2. LsbList(list (W, list (X, list (Y, Z))))	= list (list (list (W, X), Y), Z)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList) Input;  //_GUI 20,33
 Object Output( List LsbList) ;  //_GUI 62,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,31
 Object ( List LsbList) LsbList( Variant AnyList_Hi, Variant AnyList_Lo) ;  //_GUI 41,31

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 ListIn.0 = Input.0;  
 LsbList.0 = ListIn.1;  
 LsbList.1 = ListIn.0;  
}

Object ( NULL LsbList) LsbList( NULL AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object converts a list of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant LsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element MSB ordered list converted to a four-element LSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (list (list (W, X), Y), Z)
 // 2. LsbList(list (W, list (X, list (Y, Z))))	= list (list (list (W, X), Y), Z)
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList) Input;  //_GUI 20,33
 Object Output( NULL LsbList) ;  //_GUI 29,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Var"
{
 // Date:
 // 8/9/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Context) Input;  //_GUI 32,21
 Object ( Variant Data) Input:A;  //_GUI 32,33
 Object Output( Variant Data) ;  //_GUI 142,20
 Object Output:A( Variant Context) ;  //_GUI 142,29
 Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) ;  //_GUI 93,19
 //_ Attributes Documentation="Leaf"
 Object ( Variant Data, Variant Context) $Context:A( Variant Context
    , Variant Data) ;  //_GUI 61,29
 //_ Attributes Documentation="Leaf"
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 42,19
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 112,29
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 127,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 38,21

 //_ Behavior Topology
 Output.0 = $Context.0;  
 Output:A.0 = Cast.0;  
 $Context.0 = VariantIn.1;  
 $Context.1 = $Context:A.0;  //_GUI 81,24, 81,31
 $Context:A.0 = VariantIn.0;  //_GUI 56,31, 56,24
 $Context:A.1 = Input:A.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = $Context:A.1;  
 VariantOut.1 = $Context.1;  //_GUI 110,31, 110,24
 Cast.0 = Junction.0;  //_GUI 127,15, 39,15
 Cast.1 = VariantOut.0;  
 Junction.0 = Input.0;  
}

Object ( Variant Data, List Context) $Context( List Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="List"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Context) Input;  //_GUI 34,21
 Object ( Variant Data) Input:A;  //_GUI 34,33
 Object Output( Variant Data) ;  //_GUI 127,20
 Object Output:A( List Context) ;  //_GUI 128,31
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 42,19
 Object ( Variant Data, Variant Context) $Context( Variant Context
    , Variant Data) ;  //_GUI 93,19
 //_ Attributes Documentation="Leaf"
 Object ( Variant Data, Variant Context) $Context:A( Variant Context
    , Variant Data) ;  //_GUI 61,29
 //_ Attributes Documentation="Leaf"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 112,29

 //_ Behavior Topology
 Output.0 = $Context.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 $Context.0 = ListIn.1;  
 $Context.1 = $Context:A.0;  //_GUI 81,24, 81,31
 $Context:A.0 = ListIn.0;  //_GUI 56,31, 56,24
 $Context:A.1 = Input:A.0;  
 ListOut.0 = $Context:A.1;  
 ListOut.1 = $Context.1;  //_GUI 110,31, 110,24
}

Object ( Variant Data, Variant Context) $Context( Bit Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Bit"
{
 // Date:
 // 08/09/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Context) Input;  //_GUI 28,24
 Object ( Variant Data) Input:A;  //_GUI 28,29
 Object Output( Variant Data) ;  //_GUI 68,21
 Object Output:A( Variant Context) ;  //_GUI 68,24
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 43,20

 //_ Behavior Topology
 Output.0 = Lo_N.0;  
 Output:A.0 = Lo_N.1;  
 Lo_N.0 = Input:A.0;  //_GUI 40,22, 40,30
 Lo_N.1 = Input.0;  
}

Object ( Variant Data, Floating Context) $Context( Floating Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Context) Input;  //_GUI 39,20
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 157,16
 Object Output:A( Floating Context) ;  //_GUI 157,20
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 63,18
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 106,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 128,18
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 142,18
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Floating Number.  Our goal is to recreate a Contextual Floating out of these bits.  We begin by taking off the bottom N bits, where N is the bitlength of our Mantissa.  We then take off the next M bits, where M is the bitlength of the Characteristic.  This step is necessary just in case any leading 0s were added the context-free data set.Arial,9,0,0
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 48,18

 //_ Behavior Topology
 Output.0 = Lo_N:A.0;  
 Output:A.0 = FloatingOut.0;  
 ListIn.0 = FloatingIn.0;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = ListIn.0;  //_GUI 79,37, 79,23
 Lo_N:A.0 = Lo_N.0;  //_GUI 102,17, 102,34
 Lo_N:A.1 = ListIn.1;  
 ListOut.0 = Lo_N.1;  //_GUI 118,23, 118,37
 ListOut.1 = Lo_N:A.1;  
 FloatingOut.0 = ListOut.0;  
 FloatingIn.0 = Input.0;  
}

Object ( Variant Data, Fixed Context) $Context( Fixed Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Fixed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed Context) Input;  //_GUI 39,20
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 157,16
 Object Output:A( Fixed Context) ;  //_GUI 157,20
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 106,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 128,18
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Fixed Number.  Our goal is to recreate a Contextual Fixed out of these bits.  We begin by taking off the bottom N bits, where N is the bitlength of our fractional portion.  We then take off the next M bits, where M is the bitlength of the whole portion.  This step is necessary just in case any leading 0s were added the context-free data set.Arial,9,0,0
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 48,18
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 143,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 63,18

 //_ Behavior Topology
 Output.0 = Lo_N:A.0;  
 Output:A.0 = FixedOut.0;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = ListIn.0;  //_GUI 79,37, 79,23
 Lo_N:A.0 = Lo_N.0;  //_GUI 102,17, 102,34
 Lo_N:A.1 = ListIn.1;  
 ListOut.0 = Lo_N.1;  //_GUI 118,23, 118,37
 ListOut.1 = Lo_N:A.1;  
 FixedIn.0 = Input.0;  
 FixedOut.0 = ListOut.0;  
 ListIn.0 = FixedIn.0;  
}

Object ( Variant Data, Complex Context) $Context( Complex Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex Context) Input;  //_GUI 39,20
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 181,16
 Object Output:A( Complex Context) ;  //_GUI 181,20
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 106,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 145,18
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Complex Number.  Our goal is to recreate a Contextual Complex out of these bits.  We begin by taking off the bottom N bits, where N is the bitlength of our imaginary portion.  We then take off the next M bits, where M is the bitlength of the real portion.  This step is necessary just in case any leading 0s were added the context-free data set.Arial,9,0,0
 Object ( List Out1) ComplexIn( Complex In) ;  //_GUI 48,18
 Object ( Complex Out) ComplexOut( List In1) ;  //_GUI 161,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 63,18
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 128,32
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 78,29
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 122,22
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 90,19

 //_ Behavior Topology
 Output.0 = Lo_N:A.0;  
 Output:A.0 = ComplexOut.0;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = Junction.2;  //_GUI 79,37
 Lo_N:A.0 = Lo_N.0;  //_GUI 102,17, 102,34
 Lo_N:A.1 = Junction:A.1;  
 ListOut.0 = Context.0;  //_GUI 138,23
 ListOut.1 = Context:A.0;  //_GUI 132,20
 ComplexIn.0 = Input.0;  
 ComplexOut.0 = ListOut.0;  
 ListIn.0 = ComplexIn.0;  
 Context.0 = Junction.1;  //_GUI 128,30
 Context.1 = Lo_N.1;  
 Junction.0 = ListIn.0;  //_GUI 79,23
 Context:A.0 = Junction:A.2;  //_GUI 91,24
 Context:A.1 = Lo_N:A.1;  //_GUI 116,27
 Junction:A.0 = ListIn.1;  
}

Object ( Variant Data, Signed Context) $Context( Signed Context
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Signed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed Context) Input;  //_GUI 39,24
 Object ( Variant Data) Input:A;  //_GUI 39,33
 Object Output( Variant Data) ;  //_GUI 119,33
 Object Output:A( Signed Context) ;  //_GUI 119,36
 Object Text;  //_GUI 36,45,In this case, the Data input is a context-free collection of bits, which at one point were the bits of a Signed Number.  Our goal is to recreate a Contextual Signed out of these bits.  We only take as many bits out of the Data data set as our Signed Type specifies.  This is done to strip any leading 0s that may have been added to the context-free number, thus maintaing the 2's complement nature of the Signed number.Arial,9,0,0
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 48,22
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 104,34
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 84,32

 //_ Behavior Topology
 Output.0 = Lo_N.0;  
 Output:A.0 = SignedOut.0;  
 SignedIn.0 = Input.0;  
 SignedOut.0 = Lo_N.1;  
 Lo_N.0 = Input:A.0;  
 Lo_N.1 = SignedIn.0;  //_GUI 79,37, 79,25
}

Object ( Variant Data, Variant Context) $Context( Variant Context
    , NULL Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="NULL"
{
 // Date:
 // 8/10/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Context) Input;  //_GUI 32,21
 Object ( NULL Data) Input:A;  //_GUI 32,33
 Object Output( Variant Data) ;  //_GUI 52,23
 Object Output:A( Variant Context) ;  //_GUI 52,32
 Object ( Bit In) Input:B;  //_GUI 44,43
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:B( Bit Trap) ;  //_GUI 50,43
 //_ Attributes Trap="Data ran out before context was filled"

 //_ Behavior Topology
 Output:B.0 = Input:B.0;  
}

Object ( Bit Out1) IsNULL( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL"
{
 // Returns true if the input dataset is a NULL dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be NULL.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is NULL, 0 otherwise.
 //
 // Date:
 // February 5, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 46,30
 Object Output( Bit Out1) ;  //_GUI 84,40
 Object ( Bit In) Input:A;  //_GUI 47,40
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsNULL( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a NULL dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be NULL.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is NULL, 0 otherwise.
 //
 // Date:  February 5, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 43,27
 Object Output( Bit Out1) ;  //_GUI 81,37
 Object ( Bit In) Input:A;  //_GUI 44,37
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps"
{
 // This object is essentially a parameterizable Exposer.
 //
 // Splits a data set into the N most-significant bits and the bitlength - N least-significant bits.  This recursive object changes data representation in the synthesizer and does not produce any additional circuitry.
 //
 // Inputs:
 // Data - any data set to be split
 //
 // Hi_N - the bitlength of this parameter specifies N - the number of bits in the hi data set.
 //
 // Outputs:
 // Hi - the N- most-significant bits of the data input
 // (represented as LSB)
 //
 // Lo - the bitlength - N least-significant bits of the data input. (represented as MSB)
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 30,23
 Object ( Variant Hi_N) Input:A;  //_GUI 32,37
 Object Output( Variant Hi) ;  //_GUI 88,22
 Object Output:A( Variant Lo) ;  //_GUI 88,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 38,21
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 40,35
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 52,35
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 50,21
 Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Variant Hi_N) ;  //_GUI 76,21
 //_ Attributes Documentation="Variant/Variant"

 //_ Behavior Topology
 Output.0 = $Hi_N.0;  
 Output:A.0 = $Hi_N.1;  
 MSB.0 = Input.0;  
 LSB.0 = Input:A.0;  
 VariantIn.0 = LSB.0;  
 VariantIn:A.0 = MSB.0;  
 $Hi_N.0 = VariantIn:A.1;  
 $Hi_N.1 = VariantIn:A.0;  
 $Hi_N.2 = VariantIn.1;  //_GUI 73,29, 73,37
}

Object ( Bit Hi, NULL Lo) Hi_N( Bit Data
    , Bit Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,27
 Object ( Bit Hi_N) Input:A;  //_GUI 40,47
 Object Output( Bit Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 90,35
 Object ( NULL Out1) NULL;  //_GUI 72,33

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = NULL.0;  
}

Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Bit Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Bit"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( Bit Hi_N) Input:A;  //_GUI 40,47
 Object Output( Variant Hi) ;  //_GUI 82,26
 Object Output:A( Variant Lo) ;  //_GUI 82,36
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 58,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 46,25

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  //_GUI 72,37, 72,30
 VariantIn.0 = MSB.0;  
 MSB.0 = Input.0;  
}

Object ( Variant Hi, NULL Lo) Hi_N( Bit Data
    , Variant Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit/Var"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 38,28
 Object ( Variant Hi_N) Input:A;  //_GUI 35,44
 Object Output( Variant Hi) ;  //_GUI 97,15
 Object Output:A( NULL Lo) ;  //_GUI 98,60
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 47,42
 Object ( NULL Out1) NULL;  //_GUI 83,58
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 66,43
 //_ Attributes Documentation="ztlist"

 //_ Behavior Topology
 Output.0 = UExtnd.1;  //_GUI 85,16, 85,48
 Output:A.0 = NULL.0;  
 LSB.0 = Input:A.0;  
 UExtnd.0 = LSB.0;  
 UExtnd.1 = Input.0;  //_GUI 60,48, 60,29
}

Object ( NULL Hi, Variant Lo) Hi_N( Variant Data
    , NULL Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 38,27
 Object ( NULL Hi_N) Input:A;  //_GUI 40,47
 Object Output( NULL Hi) ;  //_GUI 90,27
 Object Output:A( Variant Lo) ;  //_GUI 90,35
 Object ( NULL Out1) NULL;  //_GUI 78,25

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  //_GUI 67,36, 67,28
}

Object ( NULL Hi, NULL Lo) Hi_N( NULL Data
    , NULL Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 38,27
 Object ( NULL Hi_N) Input:A;  //_GUI 39,36
 Object Output( NULL Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 90,33
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,27

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,34
 Junction.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) Hi_N( NULL Data
    , Variant Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL/Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Data) Input;  //_GUI 38,27
 Object ( Variant Hi_N) Input:A;  //_GUI 39,36
 Object Output( NULL Hi) ;  //_GUI 90,27
 Object Output:A( NULL Lo) ;  //_GUI 90,33
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,27

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,34
 Junction.0 = Input.0;  
}

Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\Advanced\\Twos",Icon="Add"
{
 // Performs an add or a subtract function with Carry In, Carry Out and Overflow.
 //
 // This object has input and output behaviors that are dataset dependent.  It is not recommended that you use this object to implement dataset independent algorithms.  Use Add, Sub and AddSub to implement dataset independent algorithms.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Value A.
 //
 // Variant B: Value B.
 //
 // Bit Add: Add command.  1 for add, 0 for subtract.  If disconnected, defaults to 1.
 //
 // Bit CI: Carry In value.  Normally set this to low when adding and high when subtracting.  To Carry In, set to 1 (asserted high) when adding and set to 0 (asserted low) when subtracting.  If disconnected, defaults to 0.
 //
 // Outputs:
 //
 // Bit CO: Carry Out value.  Indicates high bit rolled over.  Can be used in a carry chain or can be used to indicate an error condition when using unsigned numbers. When adding, Carry Out is signaled with a 1 (asserted high).  When subtracting, Carry Out is signaled with a 0 (asserted low).
 //
 // Bit OFL: Overflow value.  Indicates half rollover point crossed.  Can be used to indicate an error condition when using twos complement numbers.
 //
 // Variant S: The result of the operation.  The sum or the difference of A and B.
 //
 // Dataset Coverage:
 //
 // Unsigned (MSBxxx, LSBxxx and BINxxx use CO), Twos Complement (MSBxxx, LSBxxx and BINxxx use OFL), Signed (use OFL), Fixed (CI is LSB of fraction portion, use OFL), Floating (CI, CO ignored), Complex (the inputs Add and CI both get sent to the Real and Imaginary portions, CO and OFL are the OR of CO and OFL of both portions).  A and B must be the same dataset (with the exception of MSBxxx, LSBxxx, and BINxxx) and same size.  If different sizes then the inputs are symmetrized and a warning is produced.
 //
 // Examples: (widen dialog box to columate examples)
 //
 // A (Uns, 2's)	B (Uns, 2's)	Add	CI	CO	OFL	S (Uns, 2's)	Function
 // 000 (0,0)		000 (0,0)		1	0	0	0	000 (0,0)		A+B
 // 001 (1,1)		001 (1,1)		1	0	0	0	010 (2,2)		A+B
 // 001 (1,1)		010 (2,2)		1	0	0	0	011 (3,3)		A+B
 // 010 (2,2)		010 (2,2)		1	0	0	1	100 (4,-4)		A+B
 // 100 (4,-4)		100 (4,-4)		1	0	1	1	000 (0,0)		A+B
 // 110 (6,-2)		110 (6,-2)		1	0	1	0	100 (4,-4)		A+B
 // 111 (7,-1)		111 (7,-1)		1	0	1	0	110 (6,-2)		A+B
 // 000 (0,0)		000 (0,0)		1	1	0	0	001 (1,1)		A+B+1
 // 001 (1,1)		001 (1,1)		1	1	0	0	011 (3,3)		A+B+1
 // 001 (1,1)		010 (2,2)		1	1	0	1	100 (4,-4)		A+B+1
 // 010 (2,2)		010 (2,2)		1	1	0	1	101 (5,-3)		A+B+1
 // 100 (4,-4)		100 (4,-4)		1	1	1	1	001 (1,1)		A+B+1
 // 110 (6,-2)		110 (6,-2)		1	1	1	0	101 (5,-3)		A+B+1
 // 111 (7,-1)		111 (7,-1)		1	1	1	0	111 (7,-1)		A+B+1
 // 000 (0,0)		000 (0,0)		0	0	0	0	111 (7,-1)		A-B-1
 // 000 (0,0)		001 (1,1)		0	0	0	0	110 (6,-2)		A-B-1
 // 001 (1,1)		000 (0,0)		0	0	0	0	000 (0,0)		A-B-1
 // 100 (4,-4)		011 (3,3)		0	0	1	1	000 (0,0)		A-B-1
 // 100 (4,-4)		100 (4,-4)		0	0	0	0	111 (7,-1)		A-B-1
 // 110 (6,-2)		100 (4,-4)		0	0	1	0	001 (1,1)		A-B-1
 // 001 (1,1)		100 (4,-4)		0	0	0	1	100 (4,-4)		A-B-1
 // 000 (0,0)		000 (0,0)		0	1	0	0	000 (0,0)		A-B
 // 000 (0,0)		001 (1,1)		0	1	0	0	111 (7,-1)		A-B
 // 001 (1,1)		000 (0,0)		0	1	1	0	001 (1,1)		A-B
 // 100 (4,-4)		011 (3,3)		0	1	1	1	001 (1,1)		A-B
 // 100 (4,-4)		100 (4,-4)		0	1	1	0	000 (1,1)		A-B
 // 110 (6,-2)		100 (4,-4)		0	1	1	0	010 (2,2)		A-B
 // 001 (1,1)		100 (4,-4)		0	1	0	1	101 (5,-3)		A-B
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 9,16
 Object ( Variant B) Input:A;  //_GUI 9,19
 Object ( Bit ADD) Input:B;  //_GUI 41,22
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 41,25
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 58,16
 Object Output:A( Bit OFL) ;  //_GUI 58,19
 Object Output:B( Variant S) ;  //_GUI 82,20
 Object ( Bit CO, Bit OFL, Variant S) $ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 46,15
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 15,15
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 32,14
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 32,17
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 70,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,16
 Object Text;  //_GUI 25,40,So the OFL is for the Twos compliment rollover on the last bit

 //_ Behavior Topology
 Output.0 = $ADSU.0;  
 Output:A.0 = $ADSU.1;  
 Output:B.0 = Context.0;  
 $ADSU.0 = MSB.0;  
 $ADSU.1 = MSB:A.0;  
 $ADSU.2 = Input:B.0;  
 $ADSU.3 = Input:C.0;  
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
 MSB.0 = Junction.1;  
 MSB:A.0 = Symmetrize.1;  
 Context.0 = Junction.0;  //_GUI 70,9, 29,9
 Context.1 = $ADSU.2;  
 Junction.0 = Symmetrize.0;  
}

Object ( Bit CO, Bit OFL, Floating S) ADSU
    ( Floating A, Floating B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal",Icon="Add",Documentation="Floating"
{
 // Instructions inside....
 //
 // Updated:
 // Oct 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating A) Input;  //_GUI 24,62
 Object ( Floating B) Input:A;  //_GUI 24,65
 Object ( Bit ADD) Input:B;  //_GUI 67,131
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 50,140
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 68,4
 Object Output:A( Bit OFL) ;  //_GUI 540,30
 Object Output:B( Floating S) ;  //_GUI 614,81
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 259,113
 Object ( LSB002 Twos) Input:D;  //_GUI 255,108
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 335,105
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 140,63
 Object ( Variant Out1) PushMsb:A( Variant MSB, Variant In2) ;  //_GUI 258,96
 Object ( LSB002 Twos) Input:E;  //_GUI 254,95
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 425,114
 Object Text;  //_GUI 425,108,Implicit toss
 Object Text;  //_GUI 272,43,this line changes depending on which one we chose
 Object Text;  //_GUI 264,140,we add two bits here: one for the co on the adsu and one to hold our sign bit
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 135,66
 Object Text;  //_GUI 366,125,if we're high in the top data bit, which is likely, we need to increment the exponent
 Object ( Variant MSB, Variant Out2) PopMsb:B( Variant In1) ;  //_GUI 380,112
 Object Text;  //_GUI 507,152,So if our top bit is high (this was the extra bit we added to catch the co on the mantissa add) then we need to add one to the exponent and use the rest of the bits without the lsb as the mantissa resultotherwise we toss the top bitand we shift the thing so that the top bit is setand we subtract from the exponent that number of shiftsand we toss the top bit for our result
 Object Text;  //_GUI 364,35,yikes: if the mantissa ADSU resulted in a zero we need to zero the exponent; one of our top two data bits (after shift) has to be high or we ended up with zero; we subtract off the whole exponent to make it that way if necessary
 Object Text;  //_GUI 134,132,This is a compare: we could do the FromTwos on the S (which would make more sense), but that would lengthen the already long logic path; instead we just Subtract the other direction in parallel.
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 423,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 422,37
 Object ( Variant Out1, Variant Out2) Symmetrize( Variant In1
    , Variant In2) ;  //_GUI 30,61
 //_ Attributes Documentation="Bit/Variant"
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 200,53
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 479,140
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 390,135
 Object Text;  //_GUI 2,81,Special Operations (not all of these are implemented)Operations on special numbers are well-defined by IEEE. In the simplest case, any operation with a NaN yields a NaN result. Other operations are as follows:Operation	 	Resultn / �Infinity 	0�Infinity x �Infinity 	�Infinity�nonzero / 0 	�InfinityInfinity + Infinity 	Infinity�0 / �0 		NaNInfinity - Infinity 	NaN�Infinity / �Infinity 	NaN�Infinity x 0 	NaNfromhttp://stevehollasch.com/cgindex/coding/ieeefloat.html
 Object Text;  //_GUI 100,3,Infinity = all the exponent bits high and the significand bits lowNaN = QNaN or SNaNQNaN = all the exponent bits high and the MSB significand bit highSNaN = all the exponent bits high and the MSB significand bit low (other significand bits high)Zero = all bits low, not including the sign bit
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 486,68
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 203,26
 Object Text;  //_GUI 214,43,either being NaN triggers OFL
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 229,27
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 265,28
 Object Text;  //_GUI 260,25,subtraction of infinity triggers OFL
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 245,45
 Object Text;  //_GUI 559,22,Infinity + Infinity = Infinity, or so the IEEE saysThat means if we're adding and we CO then we fill the exp data high. If we're subtracting and we OFL then we fill the exponent high as well.
 Object Text;  //_GUI 228,7,possibilities (subraction handled by sign negation):adding and both negativeadding and both positiveadding and the top negative (OFL)adding and the bottom negative (OFL)
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 79,129
 Object Text;  //_GUI 59,121,if we're subtracting then we negate the sign on the lower input
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 219,32
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 127,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 115,76
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 200,111
 //_ Attributes Documentation="Bit"
 Object ( Variant O) $Mux:B( Variant A, Variant B
    , Bit S) ;  //_GUI 200,132
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 194,118
 Object ( Variant O) $Mux:C( Variant A, Variant B
    , Bit S) ;  //_GUI 200,100
 //_ Attributes Documentation="Bit"
 Object ( Variant O) $Mux:D( Variant A, Variant B
    , Bit S) ;  //_GUI 200,89
 //_ Attributes Documentation="Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In1) ;  //_GUI 194,107
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In1) ;  //_GUI 194,96
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 169,104
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 164,115
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In0) ;  //_GUI 191,123
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 188,126
 Object Text;  //_GUI 185,146,We put these muxs in here to avoid having to have two Barrel Shifters and rounders
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:L
    ( Bit In0) ;  //_GUI 194,63
 Object ( Bit Out1) EqualAllOnes( Variant In1) ;  //_GUI 474,87
 Object Text;  //_GUI 4,12,So the plan here is this:1. Figure out which one has the larger exponent2. Scale the smaller one to have the same exponent as the larger one3. Add a bit and convert the numbers to twos compliment depending upon the sign bit4. Perform the add'5. If there's a CO, dec/inc the exponent6. Scale the result to fit the implicit bit model
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 599,79
 Object ( Bit OFL, Bit ERNG_Data, Bit ERNG_FallOff
    , Bit Round, Variant FallOff, Variant Data) ShiftRightBy( Variant Data
    , Variant ShiftBy, Bit IsTwos) ;  //_GUI 222,112
 //_ Attributes Documentation="barrel with ranges"
 Object ( Variant O) $Mux:E( Variant A, Variant B
    , Bit S) ;  //_GUI 200,76
 //_ Attributes Documentation="Variant"
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 310,100
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 271,132
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 148,62
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In1) ;  //_GUI 194,83
 Object ( Bit SUB) Input:F;  //_GUI 142,69
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CI) Input:G;  //_GUI 142,72
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 297,121
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:N
    ( Bit In3) ;  //_GUI 280,125
 Object Text;  //_GUI 393,4,If OFL triggers, that's technically a NaN. You should OR the OFL bit with the high bit of the mantissa and the exponent bits in the case where you care about NaNs.Arial,20,255,1
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:O
    ( Variant In1) ;  //_GUI 389,120
 Object ( Bit CO, Bit OFL, Variant S) ADSU:B
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 148,78
 Object ( Bit SUB) Input:H;  //_GUI 142,85
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit CI) Input:I;  //_GUI 142,88
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Variant O) $Mux:F( Variant A, Variant B
    , Bit S) ;  //_GUI 283,84
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT:C( Variant In1) ;  //_GUI 273,86
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:P
    ( Variant In3) ;  //_GUI 268,88
 Object ( Variant O) $Mux:G( Variant A, Variant B
    , Bit S) ;  //_GUI 368,93
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT:D( Variant In1) ;  //_GUI 355,95
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Q
    ( Variant In3) ;  //_GUI 367,103
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:R
    ( Variant In3) ;  //_GUI 349,97
 Object Text;  //_GUI 316,116,So because we're doing an ADSU and because we have sufficient accuracy for the lone sign bit as well as the carry out, we can get away with One's complement instead of Twos.
 Object ( Variant O) $Mux:H( Variant A, Variant B
    , Bit S) ;  //_GUI 561,117
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 583,101
 Object Text;  //_GUI 504,38,!UFL
 Object Text;  //_GUI 488,63,!OFL
 Object Text;  //_GUI 445,57,!=0
 Object Text;  //_GUI 340,60,The OFL on the extend means that the encoded mantissa is larger than the exponent dataset. This is likely an error in the design of the dataset, but we will try to handle the case anyway. It is unlikely that BitLen(MaskToNum(mantissa)) - BitLen(Exponent) > BitsPerStageSG so we won't worry about the timing on the NotZero for it.
 Object ( Bit CO, Bit OFL, Variant S) ADSU:C
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 463,43
 Object ( Bit SUB) Input:J;  //_GUI 459,50
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:S
    ( Variant In0) ;  //_GUI 415,55
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In0) ;  //_GUI 408,136
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 409,137
 Object ( Variant O) $Mux:I( Variant A, Variant B
    , Bit S) ;  //_GUI 498,129
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant LSB) PopLsb:A( Variant In1) ;  //_GUI 458,128
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In0) ;  //_GUI 457,142
 Object ( Variant Out1) PushMsb:B( Variant MSB, Variant In2) ;  //_GUI 477,125
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:V
    ( Bit In0) ;  //_GUI 474,136
 Object ( Bit CI) Input:K;  //_GUI 459,53
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In0) ;  //_GUI 446,136
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 425,67
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:X
    ( Variant In1) ;  //_GUI 424,66
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Y
    ( Variant In0) ;  //_GUI 507,83
 Object ( Variant O) $Mux:J( Variant A, Variant B
    , Bit S) ;  //_GUI 560,49
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) AND:C( Variant In1, Variant In2) ;  //_GUI 504,43
 Object ( Bit Out) AND:D( Bit In1, Bit In2) ;  //_GUI 487,40
 Object ( Bit Out) INVERT:E( Bit In1) ;  //_GUI 472,39
 Object ( Variant O) $Mux:K( Variant A, Variant B
    , Bit S) ;  //_GUI 442,45
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Z
    ( Variant In0) ;  //_GUI 441,37
 Object ( Variant O) $Mux:L( Variant A, Variant B
    , Bit S) ;  //_GUI 561,100
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:a
    ( Variant In1) ;  //_GUI 507,107
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 481,101
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:b
    ( Variant In3) ;  //_GUI 418,103
 Object ( Bit Out) AND:E( Bit In1, Bit In2) ;  //_GUI 522,99
 Object ( Bit Out) INVERT:F( Bit In1) ;  //_GUI 573,100
 Object ( Variant Out1, Variant LSB) PopLsb:B( Variant In1) ;  //_GUI 450,95
 Object ( Variant Out1, Variant LSB) PopLsb:C( Variant In1) ;  //_GUI 460,88
 Object ( Bit Out) AND:F( Bit In1, Bit In2) ;  //_GUI 470,95
 Object ( Bit Out) AND:G( Bit In1, Bit In2) ;  //_GUI 512,88
 Object ( Variant Out1, Variant LSB) PopLsb:D( Variant In1) ;  //_GUI 515,68
 Object ( Variant Out1, Variant LSB) PopLsb:E( Variant In1) ;  //_GUI 525,61
 Object ( Bit Out) AND:H( Bit In1, Bit In2) ;  //_GUI 535,68
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:c
    ( Variant In0) ;  //_GUI 504,70
 Object ( Bit Out) AND:I( Bit In1, Bit In2) ;  //_GUI 545,91
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:d
    ( Bit In0) ;  //_GUI 502,89
 Object Text;  //_GUI 221,73,So A has the larger exponent; that means we shift B
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating
    ( Floating In1) ;  //_GUI 80,32
 //_ Attributes Documentation="with NaN"
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating:A
    ( Floating In1) ;  //_GUI 66,83
 //_ Attributes Documentation="with NaN"
 Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) LeftJustify( Variant Data) ;  //_GUI 398,118
 Object ( Variant Out1) XOR:A( Variant In1, Variant In2) ;  //_GUI 285,121
 Object ( Variant Out1) XOR:B( Variant In1, Variant In2) ;  //_GUI 92,74
 Object Text;  //_GUI 90,68,(Negate or invert sign)
 Object Text;  //_GUI 284,115,(Negate or invert sign)
 Object ( Bit CO, Bit OFL, Variant S) ADSU:D
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 419,135
 Object ( Bit CO, Bit OFL, Variant S) ADSU:E
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 463,65

 //_ Behavior Topology
 Output.0 = Input:C.0;  //_GUI 58,5, 58,141
 Output:A.0 = OR:A.0;  
 Output:B.0 = CollectFloating.0;  
 PushMsb.0 = Input:D.0;  
 PushMsb.1 = ShiftRightBy.5;  //_GUI 259,129
 PopMsb.0 = ADSU.2;  
 Junction.0 = ExposeFloating.1;  //_GUI 131,64, 131,37
 PushMsb:A.0 = Input:E.0;  
 PushMsb:A.1 = $Mux:C.0;  //_GUI 245,101, 245,103
 PopMsb:A.0 = LeftJustify.0;  //_GUI 414,117
 Junction:A.0 = ExposeFloating:A.1;  //_GUI 131,67, 131,88
 PopMsb:B.0 = $Mux:G.0;  //_GUI 378,115
 UExtnd.0 = Junction:B.2;  
 UExtnd.1 = Junction:b.1;  //_GUI 419,50
 Junction:B.0 = Junction:S.0;  //_GUI 416,38
 Symmetrize.0 = Input.0;  
 Symmetrize.1 = Input:A.0;  
 $Mux.0 = Junction:A.0;  //_GUI 136,55
 $Mux.1 = Junction.0;  //_GUI 141,58
 $Mux.2 = Junction:L.0;  //_GUI 195,61
 MSB.0 = Junction:U.1;  
 PopLsb.0 = Junction:O.2;  
 OR.0 = ADSU:E.0;  //_GUI 486,67
 OR.1 = ADSU:E.2;  
 AND.0 = ExposeFloating.7;  //_GUI 110,28, 110,55
 AND.1 = ExposeFloating:A.7;  //_GUI 113,31, 113,106
 AND:A.0 = AND.0;  
 AND:A.1 = XOR.0;  
 OR:A.0 = AND:A.0;  
 OR:A.1 = OR:B.0;  //_GUI 255,33
 OR:B.0 = ExposeFloating.10;  //_GUI 120,47, 120,64
 OR:B.1 = ExposeFloating:A.10;  //_GUI 122,50, 122,115
 INVERT.0 = Input:B.0;  
 XOR.0 = Junction:C.1;  
 XOR.1 = Junction:D.0;  //_GUI 139,37, 139,43, 116,43
 Junction:C.0 = ExposeFloating.0;  
 Junction:D.0 = XOR:B.0;  
 $Mux:A.0 = Junction:H.2;  //_GUI 170,113
 $Mux:A.1 = Junction:I.1;  
 $Mux:A.2 = Junction:E.1;  
 $Mux:B.0 = Junction:J.1;  //_GUI 200,124
 $Mux:B.1 = Junction:K.1;  //_GUI 192,137, 192,127
 $Mux:B.2 = Junction:E.2;  //_GUI 195,140
 Junction:E.0 = Junction:F.2;  
 $Mux:C.0 = Junction:I.0;  //_GUI 165,102
 $Mux:C.1 = Junction:H.1;  
 $Mux:C.2 = Junction:F.1;  
 $Mux:D.0 = Junction:K.0;  //_GUI 189,91
 $Mux:D.1 = Junction:J.0;  //_GUI 192,94
 $Mux:D.2 = Junction:G.1;  
 Junction:F.0 = Junction:G.2;  
 Junction:G.0 = Junction:M.2;  
 Junction:H.0 = ExposeFloating.4;  //_GUI 106,105, 106,46
 Junction:I.0 = ExposeFloating:A.4;  //_GUI 143,116, 143,97
 Junction:J.0 = Junction:C.2;  //_GUI 128,124
 Junction:K.0 = Junction:D.2;  //_GUI 116,127
 Junction:L.0 = ADSU:A.0;  
 EqualAllOnes.0 = PopLsb:C.0;  
 CollectFloating.0 = Junction:Q.2;  //_GUI 385,81, 385,104
 CollectFloating.1 = $Mux:J.0;  //_GUI 570,84
 CollectFloating.2 = AND:B.0;  //_GUI 599,104
 ShiftRightBy.0 = $Mux:A.0;  
 ShiftRightBy.1 = $Mux:E.0;  //_GUI 216,117, 216,79
 $Mux:E.0 = ADSU:B.2;  //_GUI 179,78, 179,86
 $Mux:E.1 = ADSU:A.2;  //_GUI 172,81, 172,70
 $Mux:E.2 = Junction:M.1;  
 ADSU.0 = $Mux:F.0;  //_GUI 297,102, 297,87
 ADSU.1 = PushMsb.0;  //_GUI 270,105
 ADSU.2 = Junction:N.1;  //_GUI 281,108
 ADSU.3 = INVERT:B.0;  //_GUI 307,111
 INVERT:A.0 = $Mux:B.0;  
 ADSU:A.0 = Junction.1;  
 ADSU:A.1 = Junction:A.1;  
 ADSU:A.2 = Input:F.0;  
 ADSU:A.3 = Input:G.0;  
 Junction:M.0 = Junction:L.2;  
 INVERT:B.0 = XOR:A.0;  
 Junction:N.0 = INVERT:A.0;  
 Junction:O.0 = PopMsb:B.1;  
 ADSU:B.0 = Junction:A.2;  //_GUI 136,80
 ADSU:B.1 = Junction.2;  //_GUI 141,83
 ADSU:B.2 = Input:H.0;  
 ADSU:B.3 = Input:I.0;  
 $Mux:F.0 = Junction:P.1;  //_GUI 269,86
 $Mux:F.1 = INVERT:C.0;  
 $Mux:F.2 = $Mux:D.0;  
 INVERT:C.0 = Junction:P.2;  
 Junction:P.0 = PushMsb:A.0;  
 $Mux:G.0 = Junction:R.1;  //_GUI 350,95
 $Mux:G.1 = INVERT:D.0;  
 $Mux:G.2 = Junction:Q.1;  
 INVERT:D.0 = Junction:R.2;  
 Junction:Q.0 = PopMsb.0;  //_GUI 368,107
 Junction:R.0 = PopMsb.1;  //_GUI 350,110
 $Mux:H.0 = PopMsb:A.1;  
 $Mux:H.1 = $Mux:I.0;  //_GUI 512,122, 512,132
 $Mux:H.2 = Junction:a.2;  //_GUI 508,125
 AND:B.0 = INVERT:F.0;  
 AND:B.1 = $Mux:H.0;  //_GUI 579,106, 579,120
 ADSU:C.0 = Junction:Z.1;  //_GUI 463,38
 ADSU:C.1 = $Mux:K.0;  
 ADSU:C.2 = Input:J.0;  
 ADSU:C.3 = Input:K.0;  
 Junction:S.0 = $Mux.0;  
 Junction:T.0 = PopLsb.0;  
 Zero.0 = Junction:T.2;  
 $Mux:I.0 = MSB.0;  //_GUI 493,131, 493,143
 $Mux:I.1 = PushMsb:B.0;  //_GUI 488,134
 $Mux:I.2 = Junction:V.1;  
 PopLsb:A.0 = Junction:U.0;  
 Junction:U.0 = ADSU:D.2;  
 PushMsb:B.0 = Junction:V.0;  //_GUI 475,127
 PushMsb:B.1 = PopLsb:A.0;  
 Junction:V.0 = Junction:W.1;  
 Junction:W.0 = ADSU:D.0;  
 One.0 = Junction:X.2;  
 Junction:X.0 = Junction:S.1;  //_GUI 425,56
 Junction:Y.0 = PopMsb:B.0;  //_GUI 390,84
 $Mux:J.0 = AND:C.0;  //_GUI 560,46
 $Mux:J.1 = Junction:c.0;  //_GUI 505,54
 $Mux:J.2 = Junction:Y.0;  //_GUI 508,57
 AND:C.0 = AND:D.0;  //_GUI 500,45, 500,43
 AND:C.1 = ADSU:C.2;  //_GUI 490,48, 490,51
 AND:D.0 = INVERT:E.0;  
 AND:D.1 = ADSU:C.0;  
 INVERT:E.0 = UExtnd.0;  //_GUI 433,42
 $Mux:K.0 = Junction:Z.2;  
 $Mux:K.1 = UExtnd.1;  
 $Mux:K.2 = PopMsb:A.0;  //_GUI 442,116
 Junction:Z.0 = Junction:B.1;  
 $Mux:L.0 = AND:E.0;  
 $Mux:L.1 = AND:I.0;  //_GUI 555,105
 $Mux:L.2 = Junction:a.1;  
 Junction:a.0 = Junction:Y.2;  
 EqualZero.0 = Junction:b.2;  
 Junction:b.0 = LeftJustify.2;  //_GUI 419,126
 AND:E.0 = AND:G.0;  
 AND:E.1 = EqualZero.0;  
 INVERT:F.0 = $Mux:L.0;  
 PopLsb:B.0 = Junction:S.2;  //_GUI 416,98
 PopLsb:C.0 = PopLsb:B.0;  
 AND:F.0 = PopLsb:C.1;  
 AND:F.1 = PopLsb:B.1;  
 AND:G.0 = Junction:d.1;  
 AND:G.1 = AND:F.0;  //_GUI 512,98
 PopLsb:D.0 = Junction:c.1;  
 PopLsb:E.0 = PopLsb:D.0;  
 AND:H.0 = PopLsb:E.1;  
 AND:H.1 = PopLsb:D.1;  
 Junction:c.0 = OR.0;  
 AND:I.0 = AND:H.0;  
 AND:I.1 = Junction:d.2;  //_GUI 503,96
 Junction:d.0 = EqualAllOnes.0;  
 ExposeFloating.0 = Symmetrize.0;  //_GUI 42,35
 ExposeFloating:A.0 = Symmetrize.1;  //_GUI 66,78, 42,78
 LeftJustify.0 = Junction:O.1;  
 XOR:A.0 = ShiftRightBy.3;  
 XOR:A.1 = Junction:N.2;  
 XOR:B.0 = ExposeFloating:A.0;  //_GUI 82,76
 XOR:B.1 = INVERT.0;  //_GUI 92,132
 ADSU:D.0 = Junction:T.1;  
 ADSU:D.1 = Zero.0;  
 ADSU:D.3 = PopLsb.1;  //_GUI 400,146
 ADSU:E.0 = Junction:X.1;  
 ADSU:E.1 = One.0;  
 ADSU:E.3 = Junction:W.0;  //_GUI 447,76
}

Object ( Bit CO, Bit OFL, Complex S) ADSU
    ( Complex A, Complex B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal",Icon="Add",Documentation="Complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex A) Input;  //_GUI 9,12
 Object ( Complex B) Input:A;  //_GUI 10,27
 Object ( Bit ADD) Input:B;  //_GUI 10,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 10,35
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 97,12
 Object Output:A( Bit OFL) ;  //_GUI 97,21
 Object Output:B( Complex S) ;  //_GUI 97,30
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 50,10
 Object ( Bit CO, Bit OFL, Variant S) ADSU:A
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 50,25
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 79,28
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 16,25
 Object ( Variant Real, Variant Imag) ExposeComplex:A( Complex In1) ;  //_GUI 15,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 41,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 44,35
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 84,19
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 84,10
 Object Text;  //_GUI 34,41,For Complex, the CI is used by both the real and the comples.  Usually it will be the invers of ADD.The CO is used to see if either Real or Imag carried out, not to chain ADSUs together.The OFL is used to see if either Real or Imag overflowed, not to cain ADSUs together.

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 Output:A.0 = OR.0;  
 Output:B.0 = CollectComplex.0;  
 ADSU.0 = ExposeComplex:A.0;  
 ADSU.1 = ExposeComplex.0;  //_GUI 38,15, 38,21, 32,21
 ADSU.2 = Junction.0;  //_GUI 42,18
 ADSU.3 = Junction:A.0;  //_GUI 45,21
 ADSU:A.0 = ExposeComplex:A.1;  //_GUI 35,27, 35,15
 ADSU:A.1 = ExposeComplex.1;  
 ADSU:A.2 = Junction.1;  
 ADSU:A.3 = Junction:A.1;  
 CollectComplex.0 = ADSU.2;  //_GUI 79,18
 CollectComplex.1 = ADSU:A.2;  
 ExposeComplex.0 = Input:A.0;  
 ExposeComplex:A.0 = Input.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input:C.0;  
 OR.0 = ADSU.1;  //_GUI 71,21, 71,15
 OR.1 = ADSU:A.1;  //_GUI 71,24, 71,30
 OR:A.0 = ADSU.0;  
 OR:A.1 = ADSU:A.0;  //_GUI 75,15, 75,27
}

Object ( Variant Out1, Variant Out2) SymmetrizeNW( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Advanced"
{
 // Same behavior as Symmetrize except no warnings are produced.  Unsupported combinations of datasets still produce an error message.  See the Symmetrize object documentation for more information.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Variant input: One of the input datasets to symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,21
 Object ( Variant In2) Input:A;  //_GUI 10,24
 Object Output( Variant Out1) ;  //_GUI 41,21
 Object Output:A( Variant Out2) ;  //_GUI 41,24
 Object Text;  //_GUI 25,41,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Bit In) Input:B;  //_GUI 20,27
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 26,20
 //_ Attributes Documentation="Variant"
 Object Text;  //_GUI 17,33,Don't warn.

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 $Symmetrize.0 = Input.0;  
 $Symmetrize.1 = Input:A.0;  
 $Symmetrize.2 = Input:B.0;  
}

Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,24
 Object ( Variant In3) Input:A;  //_GUI 22,27
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 30,23
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 44,23

 //_ Behavior Topology
 Output.0 = MSB.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
 MSB.0 = ListOut.0;  
}

Object ( NULL mMSBOut) CollectMSB( NULL Hi, NULL Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out",Documentation="Null/Null"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Hi) Input;  //_GUI 7,13
 Object ( NULL Lo) Input:A;  //_GUI 7,16
 Object Output( NULL mMSBOut) ;  //_GUI 41,14

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 26,15, 26,14
}

Object ( Variant Out1) CollectMSB( NULL In3, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out",Documentation="null/var"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In3) Input;  //_GUI 22,22
 Object ( Variant In2) Input:A;  //_GUI 22,25
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 44,23

 //_ Behavior Topology
 Output.0 = MSB.0;  
 MSB.0 = Input:A.0;  
}

Object ( Variant Out1) CollectMSB( Variant In2, NULL In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out",Documentation="var/null"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 22,25
 Object ( NULL In3) Input:A;  //_GUI 22,27
 Object Output( Variant Out1) ;  //_GUI 56,25
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 44,23

 //_ Behavior Topology
 Output.0 = MSB.0;  
 MSB.0 = Input.0;  
}

Object ( Bit Out1) ReverseBits( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Icon="Swap",Documentation="Leaf"
{
 // Date:
 // 10 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 27,20
 Object Output( Bit Out1) ;  //_GUI 40,20

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) ReverseBits( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps",Icon="Swap"
{
 // Swaps all the bits in a data set, so the most-significant bit becomes the least-significant and so on.  This object essentially changes the endian representatin of the input data set.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 22,20
 Object Output( Variant Out1) ;  //_GUI 98,18
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 49,18
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 37,18
 Object ( Variant Out1) $ReverseBits( Variant Build, Variant Orig) ;  //_GUI 66,18
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,20
 Object Text;  //_GUI 46,4,I guess we should make some attempt to convert this back to its original dataset.
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 84,16

 //_ Behavior Topology
 Output.0 = Context.0;  
 VariantIn.0 = MSB.0;  
 MSB.0 = Junction.1;  
 $ReverseBits.0 = VariantIn.1;  
 $ReverseBits.1 = VariantIn.0;  
 Junction.0 = Input.0;  
 Context.0 = Junction.0;  //_GUI 84,11, 31,11
 Context.1 = $ReverseBits.0;  
}

Object ( Bit OFL, Variant S) $ResolveError( Bit CO
    , Bit OFL, Variant S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Variant S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,21
 Object Output:A( Variant S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For unsigned datasets, CO is the error condition

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit OFL, Signed S) $ResolveError( Bit CO
    , Bit OFL, Signed S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\$Internal",Documentation="signed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Signed S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,24
 Object Output:A( Signed S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For signed datasets, OFL is the error condition

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit OFL, Fixed S) $ResolveError( Bit CO
    , Bit OFL, Fixed S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\$Internal",Documentation="fixed"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Fixed S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,24
 Object Output:A( Fixed S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For fixed datasets, OFL is the error condition

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Bit OFL, Floating S) $ResolveError( Bit CO
    , Bit OFL, Floating S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\$Internal",Documentation="floating"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 21,21
 Object ( Bit OFL) Input:A;  //_GUI 21,24
 Object ( Floating S) Input:B;  //_GUI 21,27
 Object Output( Bit OFL) ;  //_GUI 47,24
 Object Output:A( Floating S) ;  //_GUI 47,27
 Object Text;  //_GUI 15,34,For fixed datasets, OFL is the error condition

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( List OFL, List S) $ResolveError( List CO
    , List OFL, List S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List CO) Input;  //_GUI 22,33
 Object ( List OFL) Input:A;  //_GUI 22,42
 Object ( List S) Input:B;  //_GUI 22,51
 Object Output( List OFL) ;  //_GUI 79,35
 Object Output:A( List S) ;  //_GUI 79,44
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 28,31
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 66,33
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 28,40
 Object ( Variant Out1, Variant Out2) ListIn:B( List In) ;  //_GUI 28,49
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 66,42
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 48,18
 Object ( Variant OFL, Variant S) $ResolveError:A( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 45,60

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $ResolveError:A.0;  //_GUI 60,38
 ListOut.1 = $ResolveError.0;  //_GUI 66,20
 ListIn:A.0 = Input:A.0;  
 ListIn:B.0 = Input:B.0;  
 ListOut:A.0 = $ResolveError:A.1;  //_GUI 66,65
 ListOut:A.1 = $ResolveError.1;  //_GUI 63,44
 $ResolveError.0 = ListIn.1;  //_GUI 39,20
 $ResolveError.1 = ListIn:A.1;  //_GUI 42,23, 42,42
 $ResolveError.2 = ListIn:B.1;  //_GUI 48,51
 $ResolveError:A.0 = ListIn.0;  //_GUI 45,36
 $ResolveError:A.1 = ListIn:A.0;  //_GUI 42,65, 42,45
 $ResolveError:A.2 = ListIn:B.0;  //_GUI 39,68
}

Object ( Variant OFL, Complex S) $ResolveError( Bit CO
    , Bit OFL, Complex S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\$Internal",Documentation="complex"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit CO) Input;  //_GUI 6,16
 Object ( Bit OFL) Input:A;  //_GUI 6,19
 Object ( Complex S) Input:B;  //_GUI 6,23
 Object Output( Variant OFL) ;  //_GUI 59,16
 Object Output:A( Complex S) ;  //_GUI 59,29
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 16,21
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 36,15
 Object ( Complex Out1, Complex Out2, Complex Out3) Junction
    ( Complex In0) ;  //_GUI 12,23
 Object Text;  //_GUI 18,33,Both the real and imaginary portions have the same dataset so just use one of them to resolve the error.

 //_ Behavior Topology
 Output.0 = $ResolveError.0;  
 Output:A.0 = Junction.2;  //_GUI 13,30
 ExposeComplex.0 = Junction.1;  
 $ResolveError.0 = Input.0;  
 $ResolveError.1 = Input:A.0;  
 $ResolveError.2 = ExposeComplex.0;  
 Junction.0 = Input:B.0;  
}

Object ( Variant Out1, Variant LSB) PopLsb( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="list"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant Out1) ;  //_GUI 35,18
 Object Output:A( Variant LSB) ;  //_GUI 35,21
 Object ( Variant Remnant, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 21,17
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListPopLsb.0;  
 Output:A.0 = ListPopLsb.1;  
 ListPopLsb.0 = Input.0;  
}

Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant Out1) ;  //_GUI 46,18
 Object Output:A( Variant LSB) ;  //_GUI 46,21
 Object ( Variant Out1, Variant Out11) ExposeLSB( Variant In1) ;  //_GUI 26,17
 //_ Attributes Documentation="Error"

 //_ Behavior Topology
 Output.0 = ExposeLSB.0;  
 Output:A.0 = ExposeLSB.1;  
 ExposeLSB.0 = Input.0;  
}

Object ( NULL Out1, Bit LSB) PopLsb( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="bit"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 14,27
 Object Output( NULL Out1) ;  //_GUI 39,17
 Object Output:A( Bit LSB) ;  //_GUI 39,27
 Object ( NULL Out1) NULL;  //_GUI 19,38
 Object Text;  //_GUI 22,50,Putting this on the bottom is a workaround for a bug to be fixed very soon.

 //_ Behavior Topology
 Output.0 = NULL.0;  //_GUI 35,18, 35,41
 Output:A.0 = Input.0;  
}

Object ( NULL Out1, NULL LSB) PopLsb( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL"
{
 // This object removes, or pops the least significant input item from the input and outputs the popped item out the bottom output and the remnant of the input out the top output.  Input items can either be bits of a Variant or elements of a List.
 //
 // * For variant inputs, the top output dataset is LSBxxx (or Bit) and the LSB output is a Bit.
 //
 // * For a bit input, the top output dataset is NULL and the LSB output is a Bit.
 //
 // * For any non-empty list, the LSB output is the least significant element of the list.
 //
 // * For a linier list (an MSB or LSB ordered list) the top output is the remnant of the list maintaining the original order.
 //
 // * For a BIN ordered list the top output is the remnant of the BIN ordered list, which had the least significant element clipped, making it an arbitrary list structure instead of a true BIN ordered list.
 //
 // * For arbitrary list structures the top output is the remnant of the list, which has the least significant element clipped.
 //
 // Note: This object doesn't support single element lists.  If single element lists need to be supported, use ListPopLSB instead.
 //
 // Inputs:
 //
 // Variant input: The input from which the least significant item will be popped.
 //
 // Outputs:
 //
 // Variant output: The remnant of the input after the pop.
 //
 // Variant LSB: The popped item.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,17
 Object Output( NULL Out1) ;  //_GUI 45,17
 Object Output:A( NULL LSB) ;  //_GUI 45,21
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 39,17
 Object Text;  //_GUI 17,30,Generally you should arrange your ZTList recursion such that this function is not called with the ZTerm dataset.  (It can be ambiguous with the case of null data in a list.)  But if you do, here are some NULLs that will get ripped out eventually.

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 40,22
 Junction.0 = Input.0;  
}

Object ( List Out1) Bit_List( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,14
 Object Output( List Out1) ;  //_GUI 62,14
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 48,12
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 20,12
 Object ( Variant Out1) Bit_List( Variant In1) ;  //_GUI 35,9
 Object ( Variant Out1) Bit_List:A( Variant In1) ;  //_GUI 35,16

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Bit_List:A.0;  //_GUI 47,17, 47,19
 ListOut.1 = Bit_List.0;  //_GUI 47,14, 47,12
 VariantIn.0 = Input.0;  
 Bit_List.0 = VariantIn.1;  //_GUI 34,12, 34,14
 Bit_List:A.0 = VariantIn.0;  //_GUI 34,19, 34,17
}

Object ( Bit Data) Bit_List( Bit Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="bit"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 14,14
 Object Output( Bit Data) ;  //_GUI 62,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) Bit_List( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 14,14
 Object Output( NULL Out1) ;  //_GUI 25,14

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1) Bit_List( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // Takes the input and maps it into a list of bits of the same order as the variant breakdown of the input dataset.
 //
 // Inputs:
 //
 // Variant input: The input bits as dataset of MSBxxx, LSBxxx or BINxxx.
 //
 // Outputs:
 //
 // Variant output: The output bits as a list of bits in the same order as the input's variant breakdown.
 //
 // Examples:
 //
 // Bit_List (MSB003)	= list (Bit, list (Bit, Bit))
 // Bit_List (LSB005)	= list (list (list (list (Bit, Bit), Bit), Bit), Bit)
 // Bit_List (BIN004)	= list (list (Bit, Bit), list (Bit, Bit))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 14,14
 Object Output( List Out1) ;  //_GUI 62,14
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 48,12
 Object ( Variant Out1) Bit_List( Variant In1) ;  //_GUI 35,9
 Object ( Variant Out1) Bit_List:A( Variant In1) ;  //_GUI 35,16
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,12

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Bit_List:A.0;  //_GUI 47,17, 47,19
 ListOut.1 = Bit_List.0;  //_GUI 47,14, 47,12
 Bit_List.0 = ListIn.1;  //_GUI 34,12, 34,14
 Bit_List:A.0 = ListIn.0;  //_GUI 34,19, 34,17
 ListIn.0 = Input.0;  
}

Object ( List LsbList) AppendLsbList( Variant LsbList, List AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 // Works for the var/list and the list/list case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant LsbList) Input;  //_GUI 20,38
 Object ( List AnyList) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 76,42
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 42,37
 Object ( List LsbList) AppendLsbList:A( Variant LsbList, Variant AnyList) ;  //_GUI 59,40

 //_ Behavior Topology
 Output.0 = AppendLsbList:A.0;  
 ListIn.0 = Input:A.0;  
 AppendLsbList.0 = Input.0;  
 AppendLsbList.1 = ListIn.1;  
 AppendLsbList:A.0 = AppendLsbList.0;  //_GUI 58,42, 58,40
 AppendLsbList:A.1 = ListIn.0;  
}

Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal"
{
 // Works for the var/var and the list/var case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant LsbList) Input;  //_GUI 20,33
 Object ( Variant AnyList) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 69,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 39,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 35,35
 Object ( Bit S) Input:A;  //_GUI 36,54
 //_ Attributes Constant="0"
 Object Output( Variant "#0") ;  //_GUI 68,36
 Object Output:A( Variant "#1") ;  //_GUI 67,49
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,35
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 47,54
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,47

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Junction.0 = Input.0;  
 $Select.0 = Junction.1;  
 $Select.2 = Junction:A.0;  //_GUI 48,42
 Junction:A.0 = Input:A.0;  
 $Select:A.1 = Junction.2;  //_GUI 44,52
 $Select:A.2 = Junction:A.1;  
}

Object ( NULL "#0", NULL "#1") $SelectOut( NULL D
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL D) Input;  //_GUI 35,35
 Object ( Bit S) Input:A;  //_GUI 36,54
 Object Output( NULL "#0") ;  //_GUI 68,36
 Object Output:A( NULL "#1") ;  //_GUI 67,49
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 43,35
 Object ( NULL Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 47,54
 Object ( NULL Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,47

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Junction.0 = Input.0;  
 $Select.0 = Junction.1;  
 $Select.2 = Junction:A.0;  //_GUI 48,42
 Junction:A.0 = Input:A.0;  
 $Select:A.1 = Junction.2;  //_GUI 44,52
 $Select:A.2 = Junction:A.1;  
}

Object ( Variant DataList) ListFill( Variant Data, Variant List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // Replaces each element of the input List with the input Data.
 //
 // Inputs:
 //
 // Variant Data: The value that will be copied N times, where N is the size of the List on the List input
 //
 // Variant List: This is an instantiation of a List.  It is only here to provide the pattern of the output List.  The data sets internal to this List do not matter, as they will be replaced with instances of the Data input.
 //
 // Ouputs:
 //
 // Variant DataList: A List in the Shape of the List input where every element is a copy of the Data input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 23,9
 Object ( Variant List) Input:A;  //_GUI 23,14
 Object Output( Variant DataList) ;  //_GUI 48,9
 Object Text;  //_GUI 14,22,When the input List is a variant, this means that the list was a single element list.  In this case we output a single elemet list (a variant) that is the Data passed in.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List DataList) ListFill( Variant Data, List List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="List"
{
 // Replaces each element of the input List with the input Data.
 //
 // Inputs:
 //
 // Variant Data: The value that will be copied N times, where N is the size of the List on the List input
 //
 // Variant List: This is an instantiation of a List.  It is only here to provide the pattern of the output List.  The data sets internal to this List do not matter, as they will be replaced with instances of the Data input.
 //
 // Ouputs:
 //
 // Variant DataList: A List in the Shape of the List input where every element is a copy of the Data input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 33,33
 Object ( List List) Input:A;  //_GUI 33,44
 Object Output( List DataList) ;  //_GUI 108,42
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 39,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 58,33
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 91,40
 Object ( Variant DataList) ListFill( Variant Data, Variant List) ;  //_GUI 65,32
 Object ( Variant DataList) ListFill:A( Variant Data, Variant List) ;  //_GUI 66,42

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
 ListOut.0 = ListFill:A.0;  
 ListOut.1 = ListFill.0;  //_GUI 86,42, 86,35
 ListFill.0 = Junction.1;  
 ListFill.1 = ListIn.1;  //_GUI 54,37, 54,44
 ListFill:A.0 = Junction.2;  //_GUI 59,44
 ListFill:A.1 = ListIn.0;  
}

Object ( NULL DataList) ListFill( Variant Data, NULL List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // Replaces each element of the input List with the input Data.
 //
 // Inputs:
 //
 // Variant Data: The value that will be copied N times, where N is the size of the List on the List input
 //
 // Variant List: This is an instantiation of a List.  It is only here to provide the pattern of the output List.  The data sets internal to this List do not matter, as they will be replaced with instances of the Data input.
 //
 // Ouputs:
 //
 // Variant DataList: A List in the Shape of the List input where every element is a copy of the Data input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 21,12
 Object ( NULL List) Input:A;  //_GUI 21,17
 Object Output( NULL DataList) ;  //_GUI 47,17
 Object Text;  //_GUI 14,27,A NULL list is an empty list.  So replacing all list nodes (none) with Data produces an empty list (NULL).

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Out1) $OR( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Icon="OR",Documentation="Variant"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,15
 Object ( Variant In2) Input:A;  //_GUI 16,25
 Object Output( Variant Out1) ;  //_GUI 116,17
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 28,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,17
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 28,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 22,15
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 98,15
 Object ( Variant Out1) $OR( Variant In1, Variant In2) ;  //_GUI 57,13
 Object ( Variant Out1) $OR:A( Variant In1, Variant In2) ;  //_GUI 58,23

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Input:A.0;  
 VariantOut.0 = $OR:A.0;  //_GUI 72,22, 72,26
 VariantOut.1 = $OR.0;  //_GUI 70,19, 70,16
 VariantIn:A.0 = Junction.1;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 92,17, 92,8, 23,8
 Cast.1 = VariantOut.0;  
 $OR.0 = VariantIn:A.1;  
 $OR.1 = VariantIn.1;  //_GUI 49,18, 49,22, 44,22, 44,25
 $OR:A.0 = VariantIn:A.0;  //_GUI 47,25, 47,18
 $OR:A.1 = VariantIn.0;  
}

Object ( Bit Out1) $OR( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Icon="OR",Documentation="Leaf"
{
 // Date:
 // 09 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 15,15
 Object ( Bit In2) Input:A;  //_GUI 15,18
 Object Output( Bit Out1) ;  //_GUI 38,16
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 22,14

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
}

Object ( List Out1) $OR_SameLists( List In2, List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List\\List"
{
 // Added Sept 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( List In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 19,31
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $OR_SameLists.0;  //_GUI 74,26, 74,23
 ListIn:A.0 = Input:A.0;  
 $OR_SameLists.0 = ListIn.1;  
 $OR_SameLists.1 = ListIn:A.1;  //_GUI 43,25, 43,33
 $OR_SameLists:A.0 = ListIn.0;  //_GUI 39,31, 39,25
 $OR_SameLists:A.1 = ListIn:A.0;  //_GUI 51,36
}

Object ( List Out1) $OR_SameLists( List In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="List\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 11,22
 Object ( Variant In1) Input:A;  //_GUI 10,33
 Object Output( List Out1) ;  //_GUI 97,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 45,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 79,24
 Object ( Bit In) Input:B;  //_GUI 22,39
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 28,39
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 51,20
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 51,29
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input:A.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 73,29, 73,32
 ListOut.1 = $OR_SameLists.0;  //_GUI 74,26, 74,23
 Output:A.0 = Input:B.0;  
 $OR_SameLists.0 = ListIn.1;  
 $OR_SameLists.1 = Junction.0;  //_GUI 46,25
 $OR_SameLists:A.0 = ListIn.0;  //_GUI 51,30, 39,30, 39,25
 $OR_SameLists:A.1 = Junction.1;  
}

Object ( List Out1) $OR_SameLists( Variant In1, List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var\\List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( List In2) Input:A;  //_GUI 11,26
 Object Output( List Out1) ;  //_GUI 98,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 19,24
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 80,17
 Object ( Bit In) Input:B;  //_GUI 30,34
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 36,34
 //_ Attributes Trap="Warning: Lists not same size so duplicating end element of smaller list."
 Object ( Variant Out1) $OR_SameLists( Variant In2, Variant In1) ;  //_GUI 48,16
 //_ Attributes Documentation="List\\List"
 Object ( Variant Out1) $OR_SameLists:A( Variant In2, Variant In1) ;  //_GUI 48,24
 //_ Attributes Documentation="List\\List"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $OR_SameLists:A.0;  //_GUI 71,22, 71,27
 ListOut.1 = $OR_SameLists.0;  
 Output:A.0 = Input:B.0;  
 $OR_SameLists.0 = Junction.1;  
 $OR_SameLists.1 = ListIn.1;  //_GUI 41,21, 41,26
 $OR_SameLists:A.0 = Junction.2;  //_GUI 44,26, 44,23, 35,23
 $OR_SameLists:A.1 = ListIn.0;  
}

Object ( Variant Out1) $OR_SameLists( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="Var\\Var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,17
 Object ( Variant In2) Input:A;  //_GUI 11,20
 Object Output( Variant Out1) ;  //_GUI 30,18
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 18,16

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
}

Object ( NULL Out1) BIN( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="NULL"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 13,25
 Object Output( NULL Out1) ;  //_GUI 31,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Bit Out1) BIN( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="Bit"
{
 // This object will take an arbitrary data set and rearrange its bits into a BIN pattern, procucing a BINx data set with same bitlength as the incoming data set.  The data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will  be lost.  The context may be reapplied via the Context operator.
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 13,25
 Object Output( Bit Out1) ;  //_GUI 31,25

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN002 Out1) BIN( BIN002 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN002"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN002 In1) Input;  //_GUI 42,38
 Object Output( BIN002 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN004 Out1) BIN( BIN004 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN004"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN004 In1) Input;  //_GUI 42,38
 Object Output( BIN004 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN008 Out1) BIN( BIN008 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN008"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN008 In1) Input;  //_GUI 42,38
 Object Output( BIN008 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN016 Out1) BIN( BIN016 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN016"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN016 In1) Input;  //_GUI 42,38
 Object Output( BIN016 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN032 Out1) BIN( BIN032 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN032"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN032 In1) Input;  //_GUI 42,38
 Object Output( BIN032 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN064 Out1) BIN( BIN064 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN064"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN064 In1) Input;  //_GUI 42,38
 Object Output( BIN064 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( BIN128 Out1) BIN( BIN128 In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="BIN128"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( BIN128 In1) Input;  //_GUI 42,38
 Object Output( BIN128 Out1) ;  //_GUI 56,38

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) BIN( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a BIN pattern, producing a BINxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 132,33
 Object ( Variant Out1) $Cast( Variant Data, BIN Type) ;  //_GUI 105,23
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 122,31
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 53,38
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 72,40
 Object ( Variant Out1) BIN:A( Variant In1) ;  //_GUI 72,32
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,9
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 39,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 30,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In3) ;  //_GUI 21,32
 Object ( Bit In2) Input:A;  //_GUI 27,60
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), 65535, >)"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 45,60
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 91,38
 Object ( Variant Out1) $Cast:A( Variant Data, BIN Type) ;  //_GUI 105,36

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Cast.0 = $Select:A.0;  //_GUI 93,28, 93,12
 $Select.0 = $Cast.0;  //_GUI 115,33
 $Select.1 = $Cast:A.0;  //_GUI 115,36
 $Select.2 = Junction:B.1;  //_GUI 122,61
 VariantIn.0 = $Select:B.0;  //_GUI 49,41
 BIN.0 = VariantIn.0;  
 BIN:A.0 = VariantIn.1;  //_GUI 68,35, 68,40
 $Select:A.0 = Junction.1;  
 $Select:A.2 = Junction:A.1;  //_GUI 22,17
 $Select:B.1 = Junction.2;  //_GUI 31,30
 $Select:B.2 = Junction:A.2;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction:B.0;  //_GUI 22,50, 46,50
 Junction:B.0 = Input:A.0;  
 VariantOut.0 = BIN.0;  
 VariantOut.1 = BIN:A.0;  //_GUI 87,40, 87,35
 $Cast:A.0 = VariantOut.0;  
}

Object ( Variant Out1) BIN( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal\\MSB-LSB-BIN",Documentation="list"
{
 // This object will take an arbitrary data set and rearrange the construction of its bits into a BIN pattern, producing a BINxxx data set with same bit length as the incoming data set.  The order and value of the data bits are maintained.  If a Contextual Data Set is passed through this operator, the state of all the Bits will be maintained, but the context of the data set will be lost.  The context may be reapplied via the Context operator.
 //
 // For an input with a single bit, the output will be Bit.
 // For an input with no bits, the output will be NULL.
 //
 // Date:
 // April 2005
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 11,10
 Object Output( Variant Out1) ;  //_GUI 84,8
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 39,10
 Object ( Variant Out1) BIN:A( Variant In1) ;  //_GUI 39,2
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 58,8
 Object ( Variant Out1) $Cast( Variant Data, BIN Type) ;  //_GUI 72,6
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,8

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 BIN.0 = ListIn.0;  
 BIN:A.0 = ListIn.1;  //_GUI 35,5, 35,10
 VariantOut.0 = BIN.0;  
 VariantOut.1 = BIN:A.0;  //_GUI 54,10, 54,5
 $Cast.0 = VariantOut.0;  
 ListIn.0 = Input.0;  
}

Object ( Variant N_Bits) "Constant->N_Bits"( Variant Constant) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Takes in a constant value and returns an MSB data set whose bitlength is equal to the numeric value of the constant.  The MSB data set will contain all 0s.
 //
 // Date:
 // 12 Nov 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Constant) Input;  //_GUI 10,37
 Object Output( Variant N_Bits) ;  //_GUI 50,35
 Object ( Variant Out1) Min_Rep( Variant In1) ;  //_GUI 16,35
 Object ( Bit In) Input:A;  //_GUI 21,29
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 34,2,This object produces an N-bit data set (MSB) where N is defined by a constant unsigned integer on the input Constant.  The output data set will contain all 0s.Arial,8,0,1
 Object Text;  //_GUI 7,15,First the constant is filtered through a Min_Rep object.  This object removes all leading 0s, giving us our constant represented in the smallest data set possiblet.
 Object Text;  //_GUI 10,44,We then start our recursion which doubles the size of Append and strips an LSB from Constant for every recurse.
 Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Variant Constant) ;  //_GUI 28,33
 //_ Attributes Documentation="var"

 //_ Behavior Topology
 Output.0 = "$Constant->N_Bits".0;  
 Min_Rep.0 = Input.0;  
 "$Constant->N_Bits".0 = Input:A.0;  //_GUI 28,30
 "$Constant->N_Bits".1 = Min_Rep.0;  
}

Object ( NULL N_Bits) "Constant->N_Bits"( NULL Constant) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Constant) Input;  //_GUI 12,19
 Object Output( NULL N_Bits) ;  //_GUI 25,19

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( List Out1, List Out2) $Symmetrize( List In1
    , List In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="List"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 13,15
 Object ( List In2) Input:A;  //_GUI 13,28
 Object ( Bit Warn) Input:B;  //_GUI 13,33
 Object Output( List Out1) ;  //_GUI 85,15
 Object Output:A( List Out2) ;  //_GUI 85,28
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,26
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 20,13
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 71,26
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 71,13
 Object Text;  //_GUI 25,39,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 46,13
 Object ( Variant Out1, Variant Out2) $Symmetrize:A( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 46,26
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 42,33

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 ListIn:A.0 = Input.0;  
 ListOut.0 = $Symmetrize:A.1;  
 ListOut.1 = $Symmetrize.1;  //_GUI 64,28, 64,18
 ListOut:A.0 = $Symmetrize:A.0;  //_GUI 67,18, 67,23, 61,23, 61,28
 ListOut:A.1 = $Symmetrize.0;  
 $Symmetrize.0 = ListIn:A.1;  
 $Symmetrize.1 = ListIn.1;  //_GUI 37,18, 37,28
 $Symmetrize.2 = Junction.0;  //_GUI 43,21
 $Symmetrize:A.0 = ListIn:A.0;  //_GUI 40,28, 40,23, 34,23, 34,18
 $Symmetrize:A.1 = ListIn.0;  
 $Symmetrize:A.2 = Junction.1;  
 Junction.0 = Input:B.0;  
}

Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Signed In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Signed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 16,21
 Object ( Signed In2) Input:A;  //_GUI 16,37
 Object ( Bit Warn) Input:B;  //_GUI 16,43
 Object Output( Signed Out1) ;  //_GUI 100,21
 Object Output:A( Signed Out2) ;  //_GUI 100,37
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 22,35
 Object ( Variant Out1) SignedIn:A( Signed In) ;  //_GUI 22,19
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 86,19
 Object Text;  //_GUI 63,83,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 72,33
 Object ( Variant OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 72,17
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 36,19
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 36,35
 Object ( Signed Out) SignedOut:A( Variant In1) ;  //_GUI 86,35
 Object ( Variant Max) $MaxSigned( Variant A, Variant B
    , Bit Warn) ;  //_GUI 53,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 49,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 68,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 49,37

 //_ Behavior Topology
 Output.0 = SignedOut.0;  
 Output:A.0 = SignedOut:A.0;  
 SignedIn.0 = Input:A.0;  
 SignedIn:A.0 = Input.0;  
 SignedOut.0 = TwosExtnd:A.1;  
 TwosExtnd.0 = Junction:A.2;  //_GUI 69,35
 TwosExtnd.1 = Junction:B.1;  
 TwosExtnd:A.0 = Junction:A.0;  //_GUI 69,19
 TwosExtnd:A.1 = Junction.1;  
 MSB.0 = SignedIn:A.0;  
 MSB:A.0 = SignedIn.0;  
 SignedOut:A.0 = TwosExtnd.1;  
 $MaxSigned.0 = Junction.2;  //_GUI 50,27
 $MaxSigned.1 = Junction:B.0;  //_GUI 50,30
 $MaxSigned.2 = Input:B.0;  //_GUI 53,44
 Junction.0 = MSB.0;  
 Junction:A.0 = $MaxSigned.0;  
 Junction:B.0 = MSB:A.0;  
}

Object ( Complex Out1, Complex Out2) $Symmetrize( Complex In1
    , Complex In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Complex"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 9,14
 Object ( Complex In2) Input:A;  //_GUI 9,27
 Object ( Bit Warn) Input:B;  //_GUI 9,32
 Object Output( Complex Out1) ;  //_GUI 90,14
 Object Output:A( Complex Out2) ;  //_GUI 90,27
 Object Text;  //_GUI 12,41,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 44,12
 Object ( Variant Out1, Variant Out2) $Symmetrize:A( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 44,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 40,32
 Object ( Variant Real, Variant Imag) ExposeComplex( Complex In1) ;  //_GUI 16,12
 Object ( Variant Real, Variant Imag) ExposeComplex:A( Complex In1) ;  //_GUI 16,25
 Object ( Complex Out1) CollectComplex( Variant Real, Variant Imag) ;  //_GUI 70,12
 Object ( Complex Out1) CollectComplex:A( Variant Real, Variant Imag) ;  //_GUI 70,25

 //_ Behavior Topology
 Output.0 = CollectComplex.0;  
 Output:A.0 = CollectComplex:A.0;  
 $Symmetrize.0 = ExposeComplex.0;  
 $Symmetrize.1 = ExposeComplex:A.0;  //_GUI 35,17, 35,27
 $Symmetrize.2 = Junction.0;  //_GUI 41,20
 $Symmetrize:A.0 = ExposeComplex.1;  //_GUI 38,27, 38,22, 32,22
 $Symmetrize:A.1 = ExposeComplex:A.1;  
 $Symmetrize:A.2 = Junction.1;  
 Junction.0 = Input:B.0;  
 ExposeComplex.0 = Input.0;  
 ExposeComplex:A.0 = Input:A.0;  
 CollectComplex.0 = $Symmetrize.0;  
 CollectComplex.1 = $Symmetrize:A.0;  //_GUI 66,17, 66,22, 60,22, 60,27
 CollectComplex:A.0 = $Symmetrize.1;  //_GUI 63,27, 63,17
 CollectComplex:A.1 = $Symmetrize:A.1;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Fixed In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Fixed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 10,25
 Object ( Fixed In2) Input:A;  //_GUI 10,40
 Object ( Bit Warn) Input:B;  //_GUI 10,52
 Object Output( Fixed Out1) ;  //_GUI 108,21
 Object Output:A( Fixed Out2) ;  //_GUI 108,35
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 87,19
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 18,23
 Object ( Variant SWhole, Variant Fract) ExposeFixed:A( Fixed In1) ;  //_GUI 18,38
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 65,45
 Object ( Variant OFL, Variant Out1) PadRight:A( Variant Type
    , Variant Data) ;  //_GUI 65,54
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 66,16
 Object ( Bit OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 66,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 36,24
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In1) ;  //_GUI 36,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 33,42
 Object ( Fixed Out1) CollectFixed:A( Variant SWhole, Variant Fract) ;  //_GUI 92,33
 Object Text;  //_GUI 15,64,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Max) $MaxFract( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 60,46
 Object ( Variant Max) $MaxSWhole( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 42,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 39,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 61,25

 //_ Behavior Topology
 Output.0 = CollectFixed.0;  
 Output:A.0 = CollectFixed:A.0;  
 CollectFixed.0 = TwosExtnd.1;  
 CollectFixed.1 = PadRight.1;  //_GUI 87,50
 ExposeFixed.0 = Input.0;  
 ExposeFixed:A.0 = Input:A.0;  
 PadRight.0 = Junction:C.1;  
 PadRight.1 = Junction:A.2;  //_GUI 37,50
 PadRight:A.0 = Junction:C.2;  //_GUI 61,56
 PadRight:A.1 = Junction:B.2;  //_GUI 34,59
 TwosExtnd.0 = Junction:F.0;  //_GUI 62,18
 TwosExtnd.1 = Junction.0;  //_GUI 37,21
 TwosExtnd:A.0 = Junction:F.2;  //_GUI 62,32
 TwosExtnd:A.1 = Junction:D.1;  
 Junction.0 = ExposeFixed.0;  
 Junction:A.0 = ExposeFixed.1;  //_GUI 37,28
 Junction:B.0 = ExposeFixed:A.1;  
 CollectFixed:A.0 = TwosExtnd:A.1;  
 CollectFixed:A.1 = PadRight:A.1;  //_GUI 92,59
 $MaxFract.0 = Junction:A.1;  
 $MaxFract.1 = Junction:B.1;  
 $MaxFract.2 = Junction:E.2;  
 Junction:C.0 = $MaxFract.0;  //_GUI 61,41
 $MaxSWhole.0 = Junction.1;  
 $MaxSWhole.1 = Junction:D.0;  //_GUI 43,28
 $MaxSWhole.2 = Junction:E.1;  //_GUI 40,31
 Junction:D.0 = ExposeFixed:A.0;  //_GUI 31,35
 Junction:E.0 = Input:B.0;  //_GUI 40,53
 Junction:F.0 = $MaxSWhole.0;  
}

Object ( Floating Out1, Floating Out2) $Symmetrize( Floating In1
    , Floating In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Floating"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 6,33
 Object ( Floating In2) Input:A;  //_GUI 6,47
 Object ( Bit Warn) Input:B;  //_GUI 6,62
 Object Output( Floating Out1) ;  //_GUI 99,28
 Object Output:A( Floating Out2) ;  //_GUI 99,56
 Object ( Variant SBExp, Variant Mant) ExposeFloating( Floating In1) ;  //_GUI 20,31
 Object ( Variant SBExp, Variant Mant) ExposeFloating:A( Floating In1) ;  //_GUI 20,45
 Object ( Floating Out1) CollectFloating( Variant SBExp, Variant Mant) ;  //_GUI 64,32
 Object ( Bit OFL, Floating Out2) FloatExtnd( Floating Type
    , Floating Data) ;  //_GUI 85,24
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction
    ( Floating In0) ;  //_GUI 13,33
 Object ( Bit OFL, Floating Out2) FloatExtnd:A( Floating Type
    , Floating Data) ;  //_GUI 85,52
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:A
    ( Floating In0) ;  //_GUI 81,34
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:B
    ( Floating In0) ;  //_GUI 13,47
 Object Text;  //_GUI 34,16,Construct a Floating dataset with the larger of the two exponents and the larger of the two mantissas then convert both inputs to this dataset.
 Object Text;  //_GUI 20,65,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Max) $MaxMant( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,45
 Object ( Variant Max) $MaxSBExp( Variant A, Variant B
    , Bit Warn) ;  //_GUI 45,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 41,52

 //_ Behavior Topology
 Output.0 = FloatExtnd.1;  
 Output:A.0 = FloatExtnd:A.1;  
 ExposeFloating.0 = Junction.1;  
 ExposeFloating:A.0 = Junction:B.1;  
 CollectFloating.0 = $MaxSBExp.0;  
 CollectFloating.1 = $MaxMant.0;  //_GUI 62,37, 62,48
 FloatExtnd.0 = Junction:A.0;  //_GUI 82,26
 FloatExtnd.1 = Junction.0;  //_GUI 14,29
 Junction.0 = Input.0;  
 FloatExtnd:A.0 = Junction:A.2;  //_GUI 82,54
 FloatExtnd:A.1 = Junction:B.2;  //_GUI 14,57
 Junction:A.0 = CollectFloating.0;  
 Junction:B.0 = Input:A.0;  
 $MaxMant.0 = ExposeFloating.1;  //_GUI 45,43, 36,43
 $MaxMant.1 = ExposeFloating:A.1;  
 $MaxMant.2 = Junction:C.2;  
 $MaxSBExp.0 = ExposeFloating.0;  
 $MaxSBExp.1 = ExposeFloating:A.0;  //_GUI 39,36, 39,47
 $MaxSBExp.2 = Junction:C.1;  //_GUI 42,39
 Junction:C.0 = Input:B.0;  //_GUI 42,63
}

Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Variant In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Signed/var"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In1) Input;  //_GUI 10,11
 Object ( Variant In2) Input:A;  //_GUI 10,19
 Object ( Bit Warn) Input:B;  //_GUI 10,23
 Object Output( Signed Out1) ;  //_GUI 65,14
 Object Output:A( Signed Out2) ;  //_GUI 65,17
 Object Text;  //_GUI 20,57,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 22,15
 Object ( Bit In) Input:C;  //_GUI 16,16
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 23,25,Convert the unsigned dataset into a twos complement dataset by adding a zero MSB then wrap as Signed.
 Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Signed In2, Bit Warn) ;  //_GUI 50,13
 //_ Attributes Documentation="Signed"
 Object ( Signed Out) SignedOut( Variant In1) ;  //_GUI 37,15
 Object ( Bit Out1) $SymmInvalidDS( Variant In1) ;  //_GUI 20,42
 Object Output:B( Bit Error) ;  //_GUI 66,44
 //_ Attributes Trap="Error: Can not symmetrize these inputs.  Behavior is undefined."
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 16,19
 Object Output:C( Bit Warning) ;  //_GUI 66,38
 //_ Attributes Trap="Warning: Converting Unsigned input to Signed dataset by adding a zero most significant bit."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 19,23
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,36
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 42,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 39,44

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 CollectMSB.0 = Input:C.0;  
 CollectMSB.1 = Junction.1;  
 $Symmetrize.0 = Input.0;  //_GUI 49,15, 49,12
 $Symmetrize.1 = SignedOut.0;  
 $Symmetrize.2 = Junction:A.1;  //_GUI 50,24
 SignedOut.0 = CollectMSB.0;  
 $SymmInvalidDS.0 = Junction.2;  //_GUI 17,45
 Output:B.0 = Junction:B.1;  
 Junction.0 = Input:A.0;  
 Output:C.0 = AND.0;  
 Junction:A.0 = Input:B.0;  
 AND.0 = Junction:A.2;  //_GUI 20,38
 AND.1 = INVERT.0;  
 INVERT.0 = Junction:B.0;  //_GUI 40,41
 Junction:B.0 = $SymmInvalidDS.0;  
}

Object ( Signed Out1, Signed Out2) $Symmetrize( Variant In2
    , Signed In1, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="var/Signed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,10
 Object ( Signed In1) Input:A;  //_GUI 10,13
 Object ( Bit Warn) Input:B;  //_GUI 10,19
 Object Output( Signed Out1) ;  //_GUI 58,10
 Object Output:A( Signed Out2) ;  //_GUI 58,13
 Object Text;  //_GUI 6,27,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Signed Out1, Signed Out2) $Symmetrize( Signed In1
    , Variant In2, Bit Warn) ;  //_GUI 34,12
 //_ Attributes Documentation="Signed/var"

 //_ Behavior Topology
 Output.0 = $Symmetrize.1;  //_GUI 52,11, 52,17
 Output:A.0 = $Symmetrize.0;  
 $Symmetrize.0 = Input:A.0;  
 $Symmetrize.1 = Input.0;  //_GUI 23,17, 23,11
 $Symmetrize.2 = Input:B.0;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Signed In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Fixed/Signed"
{
 // Description:
 // Takes any two input data sets and outputs equivalent symmetrical data sets.  Symmetrical data sets are data sets that have not only the same context, but also the same bit patterns.  This object is capable of symmetrizing different integer types, ie Fixed, Signed and Nums (unsigned integers).  It can also symmetrize Floating values, but it cannot do integer type to Floating conversions.  A warning message will be produced if the object is used in this way.  (The Floating type will be treated as an integer.)
 //
 // Inputs:
 // In1:  input data set
 // In2:  input data set
 //
 // Outputs:
 // Out1:  symmetrized output data set from In1
 // Out2:  symmetrized output data set from In1
 //
 // Date:
 // Nov 16, 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 11,12
 Object ( Signed In2) Input:A;  //_GUI 11,25
 Object ( Bit Warn) Input:B;  //_GUI 11,35
 Object Output( Fixed Out1) ;  //_GUI 80,25
 Object Output:A( Fixed Out2) ;  //_GUI 80,28
 Object Text;  //_GUI 14,54,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1) SignedIn( Signed In) ;  //_GUI 21,23
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 50,26
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Fixed In2, Bit Warn) ;  //_GUI 65,24
 //_ Attributes Documentation="Fixed"
 Object Text;  //_GUI 14,44,Convert the signed value into a twos complement value then into a Fixed with zeroed fraction bits, then symmetrize it with the other Fixed input.
 Object Output:B( Bit Warning) ;  //_GUI 21,38
 //_ Attributes Trap="Warning: Converting Signed input to a fixed dataset by adding zeroed fraction bits."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 17,35
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 21,14
 Object ( Fixed Out1, Fixed Out2, Fixed Out3) Junction:A
    ( Fixed In0) ;  //_GUI 18,12
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 37,28
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 SignedIn.0 = Input:A.0;  
 CollectFixed.0 = SignedIn.0;  //_GUI 50,26
 CollectFixed.1 = Zero.0;  
 $Symmetrize.0 = Junction:A.1;  //_GUI 65,13
 $Symmetrize.1 = CollectFixed.0;  
 $Symmetrize.2 = Junction.1;  //_GUI 65,36
 Output:B.0 = Junction.2;  //_GUI 18,39
 Junction.0 = Input:B.0;  
 ExposeFixed.0 = Junction:A.2;  //_GUI 19,17
 Junction:A.0 = Input.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 35,31, 35,19
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Signed In2
    , Fixed In1, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Signed/Fixed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Signed In2) Input;  //_GUI 10,14
 Object ( Fixed In1) Input:A;  //_GUI 10,17
 Object ( Bit Warn) Input:B;  //_GUI 10,23
 Object Output( Fixed Out1) ;  //_GUI 41,14
 Object Output:A( Fixed Out2) ;  //_GUI 41,17
 Object Text;  //_GUI 9,31,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Signed In2, Bit Warn) ;  //_GUI 21,16
 //_ Attributes Documentation="Fixed/Signed"

 //_ Behavior Topology
 Output.0 = $Symmetrize.1;  //_GUI 38,15, 38,21
 Output:A.0 = $Symmetrize.0;  
 $Symmetrize.0 = Input:A.0;  
 $Symmetrize.1 = Input.0;  //_GUI 18,21, 18,15
 $Symmetrize.2 = Input:B.0;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Variant In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="Fixed/var"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Fixed In1) Input;  //_GUI 10,5
 Object ( Variant In2) Input:A;  //_GUI 10,22
 Object ( Bit Warn) Input:B;  //_GUI 10,33
 Object Output( Fixed Out1) ;  //_GUI 81,18
 Object Output:A( Fixed Out2) ;  //_GUI 81,21
 Object Text;  //_GUI 16,68,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 22,18
 Object ( Bit In) Input:C;  //_GUI 16,19
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 23,36,Convert the unsigned dataset into a twos complement dataset by adding a zero MSB then collect into a Fixed with zeroed fraction bits.
 Object ( Bit Out1) $SymmInvalidDS( Variant In1) ;  //_GUI 25,55
 Object Output:B( Bit Error) ;  //_GUI 71,57
 //_ Attributes Trap="Error: Can not symmetrize these inputs.  Behavior is undefined."
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 16,22
 Object Output:C( Bit Warning) ;  //_GUI 71,51
 //_ Attributes Trap="Warning: Converting Unsigned input to Fixed dataset by adding a zero most significant bit to the signed whole and zeroed bits to the Fract portions."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 59,49
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 47,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 44,57
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 19,33
 Object ( Variant SWhole, Variant Fract) ExposeFixed( Fixed In1) ;  //_GUI 22,9
 Object ( Fixed Out1) CollectFixed( Variant SWhole, Variant Fract) ;  //_GUI 50,19
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 38,21
 //_ Attributes Documentation="Bit"
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Fixed In2, Bit Warn) ;  //_GUI 66,17
 //_ Attributes Documentation="Fixed"
 Object ( Fixed Out1, Fixed Out2, Fixed Out3) Junction:C
    ( Fixed In0) ;  //_GUI 17,5

 //_ Behavior Topology
 Output.0 = $Symmetrize.0;  
 Output:A.0 = $Symmetrize.1;  
 CollectMSB.0 = Input:C.0;  
 CollectMSB.1 = Junction.1;  
 $SymmInvalidDS.0 = Junction.2;  //_GUI 17,58
 Output:B.0 = Junction:A.1;  
 Junction.0 = Input:A.0;  
 Output:C.0 = AND.0;  
 AND.0 = Junction:B.2;  //_GUI 20,51
 AND.1 = INVERT.0;  
 INVERT.0 = Junction:A.0;  //_GUI 45,54
 Junction:A.0 = $SymmInvalidDS.0;  
 Junction:B.0 = Input:B.0;  
 ExposeFixed.0 = Junction:C.2;  //_GUI 18,12
 CollectFixed.0 = CollectMSB.0;  
 CollectFixed.1 = Zero.0;  
 Zero.0 = ExposeFixed.1;  //_GUI 37,24, 37,14
 $Symmetrize.0 = Junction:C.1;  //_GUI 66,6
 $Symmetrize.1 = CollectFixed.0;  
 $Symmetrize.2 = Junction:B.1;  //_GUI 66,34
 Junction:C.0 = Input.0;  
}

Object ( Fixed Out1, Fixed Out2) $Symmetrize( Variant In2
    , Fixed In1, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="var/Fixed"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 10,14
 Object ( Fixed In1) Input:A;  //_GUI 10,17
 Object ( Bit Warn) Input:B;  //_GUI 10,23
 Object Output( Fixed Out1) ;  //_GUI 40,14
 Object Output:A( Fixed Out2) ;  //_GUI 40,17
 Object Text;  //_GUI 10,31,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Fixed Out1, Fixed Out2) $Symmetrize( Fixed In1
    , Variant In2, Bit Warn) ;  //_GUI 20,16
 //_ Attributes Documentation="Fixed/var"

 //_ Behavior Topology
 Output.0 = $Symmetrize.1;  //_GUI 37,15, 37,21
 Output:A.0 = $Symmetrize.0;  
 $Symmetrize.0 = Input:A.0;  
 $Symmetrize.1 = Input.0;  //_GUI 17,21, 17,15
 $Symmetrize.2 = Input:B.0;  
}

Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 // Converts two input datasets into the most general common dataset.  Produces a warning if there were any dataset or dataset size changes.  This object generates no logic other than wires.  Unsupported combinations of datasets produce an error message.
 //
 // Inputs:
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Variant input: One of the input datasets to Symmetrize.
 //
 // Outputs:
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Variant output: The symmetrized dataset with the respective output value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 9,120
 Object ( Variant In2) Input:A;  //_GUI 9,132
 Object ( Bit Warn) Input:B;  //_GUI 9,173
 Object Output( Variant Out1) ;  //_GUI 212,122
 Object Output:A( Variant Out2) ;  //_GUI 212,134
 Object ( Bit Out1) SameDataSets( Variant In1, Variant In2) ;  //_GUI 22,146
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 18,120
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 46,148
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 46,135
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 50,180
 Object Output:B( Variant Trap) ;  //_GUI 74,180
 //_ Attributes Trap="Warning: Converting smaller dataset size to larger size."
 Object Text;  //_GUI 21,80,The purpose of this object is to take two arbitrary inputs and make them symmetrical.  This means that both outputs will have the same bitlength and pattern representation.Arial,8,0,1
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 15,132
 Object ( Bit Out1) BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 22,156
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In1) ;  //_GUI 18,147
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 15,150
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 187,139
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 168,141
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 96,158
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 72,138
 Object ( Variant Out1, Variant Out2) $Symmetrize( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 114,99
 Object ( Variant Out1, Variant Out2) $Symmetrize:A( Variant In1
    , Variant In2, Bit Warn) ;  //_GUI 114,87
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 92,99
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 138,99
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 93,87
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 110,106
 Object ( Variant Out) VariantOut:A( Variant In1, Variant In2) ;  //_GUI 138,87
 Object ( Variant Out) $Cast( Variant Data, Variant Type) ;  //_GUI 154,85
 Object ( Variant Out) $Cast:A( Variant Data, Variant Type) ;  //_GUI 154,97
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In3) ;  //_GUI 88,89
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In1) ;  //_GUI 150,86
 Object ( Variant OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 135,29
 //_ Attributes Documentation="PadLeft"
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 91,34
 //_ Attributes Documentation="NULL/NULL"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In3) ;  //_GUI 108,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 128,22
 Object ( Variant OFL, Variant Out1) UExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 135,15
 //_ Attributes Documentation="PadLeft"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In0) ;  //_GUI 108,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:P
    ( Bit In0) ;  //_GUI 150,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Q
    ( Variant In3) ;  //_GUI 125,26
 Object Text;  //_GUI 109,39,If different datasets and different lengths, unsign extend the smaller one to match the bigger one.
 Object Text;  //_GUI 113,110,If the same datasets but different sizes, do a variant split and recurse on $Symmetrize.  This could occur on contextual or user-defined datasets without a $Symmetrize overload.
 Object Text;  //_GUI 113,130,If the same datasets and same sizes, then already symmetrized so just pass through.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:R
    ( Bit In0) ;  //_GUI 58,173
 Object Text;  //_GUI 41,198,If different datasets and different bitlengths and not invalid inputs and Warn and then signal a warning trapIf invalid inputs then signal an error trap.We are not warning in the case of different datasets but same lengths.  Usually this is a case of MSBxxx,  LSBxxx and BINxxx and not a concern so we silently convert the lower to the upper context.We are not warning here for same datasets but different lengths because the recursive calls to $Symmetrize will warn if necessary.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:S
    ( Bit In3) ;  //_GUI 69,67
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 130,63
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:T
    ( Variant In0) ;  //_GUI 126,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:U
    ( Variant In3) ;  //_GUI 87,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:V
    ( Variant In3) ;  //_GUI 84,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:W
    ( Bit In3) ;  //_GUI 168,68
 Object Text;  //_GUI 97,57,If different datasets and same lengths, apply the upper context to the lower.
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 50,183
 Object ( Bit Out1) $SymmInvalidDS( Variant In1, Variant In2) ;  //_GUI 22,165
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:X
    ( Variant In1) ;  //_GUI 18,157
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:Y
    ( Variant In1) ;  //_GUI 15,160
 Object ( Variant Out1) AND( Variant In1, Variant In2
    , Variant In3, Variant In4) ;  //_GUI 62,178
 Object ( Bit Out) INVERT:B( Bit In1) ;  //_GUI 50,186
 Object Output:C( Bit Error) ;  //_GUI 74,191
 //_ Attributes Trap="Error: Can not symmetrize these inputs.  Behavior is undefined."
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:Z
    ( Bit In1) ;  //_GUI 40,188
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 51,119
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant In1
    , Bit S) ;  //_GUI 51,131
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant In1
    , Bit S) ;  //_GUI 73,50
 Object ( Variant "#0", Variant "#1") $SelectOut:C( Variant In1
    , Bit S) ;  //_GUI 73,63
 Object ( Variant "#0", Variant "#1") $SelectOut:D( Variant In1
    , Bit S) ;  //_GUI 76,122
 Object ( Variant "#0", Variant "#1") $SelectOut:E( Variant In1
    , Bit S) ;  //_GUI 76,134
 Object ( Variant "#0", Variant "#1") $SelectOut:F( Variant In1
    , Bit S) ;  //_GUI 112,18
 Object ( Variant "#0", Variant "#1") $SelectOut:G( Variant In1
    , Bit S) ;  //_GUI 112,29
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 154,18
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 154,29
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,50
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,61
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,122
 Object ( Variant Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 175,134
 Object ( Variant Out) $Select:F( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 196,120
 Object ( Variant Out) $Select:G( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 196,132
 Object ( Bit Out1) BitA_Eq_BitB:A( Variant A, Variant B) ;  //_GUI 70,156
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:a
    ( Variant In0) ;  //_GUI 65,135
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:b
    ( Variant In0) ;  //_GUI 69,123
 Object ( Bit Out1) BitA_Eq_BitB:B( Variant A, Variant B) ;  //_GUI 69,104
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:c
    ( Variant In3) ;  //_GUI 62,105
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:d
    ( Variant In3) ;  //_GUI 65,108
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:e
    ( Bit In3) ;  //_GUI 69,76

 //_ Behavior Topology
 Output.0 = $Select:F.0;  
 Output:A.0 = $Select:G.0;  
 SameDataSets.0 = Junction:D.1;  
 SameDataSets.1 = Junction:E.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = SameDataSets.0;  
 Junction:B.0 = Junction:A.0;  
 INVERT.0 = Junction:A.2;  //_GUI 47,183
 Output:B.0 = AND.0;  
 Junction:C.0 = Input:A.0;  
 BitA_Eq_BitB.0 = Junction:X.1;  
 BitA_Eq_BitB.1 = Junction:Y.1;  
 Junction:D.0 = Junction.2;  
 Junction:E.0 = Junction:C.2;  
 Junction:F.0 = Junction:A.1;  //_GUI 188,149
 Junction:G.0 = Junction:H.1;  //_GUI 169,159
 Junction:H.0 = BitA_Eq_BitB:A.0;  
 Junction:I.0 = Junction:H.0;  //_GUI 73,153, 97,153
 $Symmetrize.0 = VariantIn:A.0;  //_GUI 106,101, 106,92
 $Symmetrize.1 = VariantIn.0;  
 $Symmetrize.2 = Junction:J.2;  
 $Symmetrize:A.0 = VariantIn:A.1;  
 $Symmetrize:A.1 = VariantIn.1;  //_GUI 109,92, 109,97, 103,97
 $Symmetrize:A.2 = Junction:J.1;  //_GUI 111,95
 VariantIn.0 = $SelectOut:E.0;  //_GUI 92,136
 VariantOut.0 = $Symmetrize.1;  
 VariantOut.1 = $Symmetrize:A.1;  //_GUI 135,101, 135,92
 VariantIn:A.0 = Junction:K.2;  
 Junction:J.0 = Junction:R.1;  //_GUI 111,174
 VariantOut:A.0 = $Symmetrize.0;  //_GUI 138,98, 127,98
 VariantOut:A.1 = $Symmetrize:A.0;  
 $Cast.0 = VariantOut:A.0;  
 $Cast.1 = Junction:L.1;  
 $Cast:A.0 = VariantOut.0;  
 $Cast:A.1 = Junction:L.2;  //_GUI 151,99
 Junction:K.0 = $SelectOut:D.0;  //_GUI 89,124
 Junction:L.0 = Junction:K.1;  //_GUI 151,85, 89,85
 UExtnd.0 = Junction:N.2;  //_GUI 129,31
 UExtnd.1 = $SelectOut:G.1;  
 $BitA_Gt_BitB.0 = Junction:V.2;  
 $BitA_Gt_BitB.1 = Junction:U.2;  
 Junction:M.0 = Junction:O.0;  
 Junction:N.0 = $SelectOut:F.1;  
 UExtnd:A.0 = Junction:Q.1;  //_GUI 126,17
 UExtnd:A.1 = $SelectOut:F.0;  
 Junction:O.0 = $BitA_Gt_BitB.0;  
 Junction:P.0 = Junction:O.1;  
 Junction:Q.0 = $SelectOut:G.0;  //_GUI 126,31
 Junction:R.0 = Input:B.0;  
 Junction:S.0 = Junction:e.1;  
 Context.0 = Junction:T.2;  //_GUI 127,65
 Context.1 = $SelectOut:C.1;  
 Junction:T.0 = $SelectOut:B.1;  
 Junction:U.0 = $SelectOut:C.0;  //_GUI 88,65
 Junction:V.0 = $SelectOut:B.0;  
 Junction:W.0 = Junction:e.2;  //_GUI 169,77
 INVERT:A.0 = BitA_Eq_BitB.0;  //_GUI 44,186, 44,159
 $SymmInvalidDS.0 = Junction:X.2;  //_GUI 19,167
 $SymmInvalidDS.1 = Junction:Y.2;  //_GUI 16,170
 Junction:X.0 = Junction:D.2;  
 Junction:Y.0 = Junction:E.2;  
 AND.0 = Junction:R.2;  //_GUI 59,180
 AND.1 = INVERT.0;  
 AND.2 = INVERT:A.0;  
 AND.3 = INVERT:B.0;  
 INVERT:B.0 = Junction:Z.1;  
 Output:C.0 = Junction:Z.2;  //_GUI 41,192
 Junction:Z.0 = $SymmInvalidDS.0;  //_GUI 41,168
 $SelectOut.0 = Junction.1;  
 $SelectOut.1 = Junction:B.1;  //_GUI 47,124
 $SelectOut:A.0 = Junction:C.1;  
 $SelectOut:A.1 = Junction:B.2;  
 $SelectOut:B.0 = Junction:c.1;  //_GUI 63,52
 $SelectOut:B.1 = Junction:S.1;  //_GUI 70,55
 $SelectOut:C.0 = Junction:d.1;  //_GUI 66,65
 $SelectOut:C.1 = Junction:S.2;  
 $SelectOut:D.0 = Junction:b.1;  
 $SelectOut:D.1 = Junction:I.1;  //_GUI 73,127
 $SelectOut:E.0 = Junction:a.1;  
 $SelectOut:E.1 = Junction:I.2;  
 $SelectOut:F.0 = Junction:V.1;  //_GUI 85,20
 $SelectOut:F.1 = Junction:M.1;  //_GUI 109,23
 $SelectOut:G.0 = Junction:U.1;  //_GUI 88,31
 $SelectOut:G.1 = Junction:M.2;  
 $Select.0 = UExtnd:A.1;  
 $Select.1 = Junction:N.1;  
 $Select.2 = Junction:P.0;  //_GUI 151,26
 $Select:A.0 = Junction:Q.2;  //_GUI 148,31, 148,27
 $Select:A.1 = UExtnd.1;  
 $Select:A.2 = Junction:P.1;  
 $Select:B.0 = $Select.0;  //_GUI 175,21
 $Select:B.1 = Junction:T.1;  
 $Select:B.2 = Junction:W.1;  //_GUI 169,58
 $Select:C.0 = $Select:A.0;  //_GUI 172,63, 172,32
 $Select:C.1 = Context.0;  
 $Select:C.2 = Junction:W.2;  
 $Select:D.0 = $Cast.0;  //_GUI 175,88
 $Select:D.1 = $SelectOut:D.1;  
 $Select:D.2 = Junction:G.1;  //_GUI 169,130
 $Select:E.0 = $Cast:A.0;  //_GUI 172,136, 172,100
 $Select:E.1 = $SelectOut:E.1;  
 $Select:E.2 = Junction:G.2;  
 $Select:F.0 = $Select:B.0;  //_GUI 196,53
 $Select:F.1 = $Select:D.0;  
 $Select:F.2 = Junction:F.1;  //_GUI 188,128
 $Select:G.0 = $Select:C.0;  //_GUI 193,134, 193,64
 $Select:G.1 = $Select:E.0;  
 $Select:G.2 = Junction:F.2;  
 BitA_Eq_BitB:A.0 = Junction:b.2;  
 BitA_Eq_BitB:A.1 = Junction:a.2;  //_GUI 66,161
 Junction:a.0 = $SelectOut:A.1;  
 Junction:b.0 = $SelectOut.1;  
 BitA_Eq_BitB:B.0 = Junction:c.2;  
 BitA_Eq_BitB:B.1 = Junction:d.2;  
 Junction:c.0 = $SelectOut.0;  
 Junction:d.0 = $SelectOut:A.0;  //_GUI 66,133
 Junction:e.0 = BitA_Eq_BitB:B.0;  //_GUI 70,97, 83,97
}

Object ( Variant Hi, Variant Lo) BisectList( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 19,37
 Object Output( Variant Hi) ;  //_GUI 107,36
 Object Output:A( Variant Lo) ;  //_GUI 72,39
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( Variant Hi, Variant Lo) $BisectList_Low( Variant List
    , Variant LSB) ;  //_GUI 49,35
 //_ Attributes Documentation="list"
 Object ( Variant Out1, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 28,35
 //_ Attributes Documentation="ztlist"
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 86,34

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 Output:A.0 = $BisectList_Low.1;  
 $BisectList_Low.0 = ListPopLsb.0;  
 $BisectList_Low.1 = ListPopLsb.1;  
 ListPopLsb.0 = Input.0;  
 LsbList.0 = $BisectList_Low.0;  
}

Object ( NULL Hi, Variant Lo) BisectList( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 19,37
 Object Output( NULL Hi) ;  //_GUI 105,31
 Object Output:A( Variant Lo) ;  //_GUI 105,37
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( NULL Out1) NULL;  //_GUI 75,29

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( NULL Hi, NULL Lo) BisectList( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 19,37
 Object Output( NULL Hi) ;  //_GUI 105,31
 Object Output:A( NULL Lo) ;  //_GUI 105,37
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( NULL Out1) NULL;  //_GUI 75,29

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Bit O) $Mux( Bit A, Bit B
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="Bit"
{
 // Mux - Variant Select Case
 //
 // Date:
 // 07 Nov 2002
 //
 //
 //
 // SBS Inc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 9,12
 Object ( Bit B) Input:A;  //_GUI 9,21
 Object ( Bit S) Input:B;  //_GUI 9,24
 Object Output( Bit O) ;  //_GUI 78,14
 Object ( Bit Out1) INVERT( Bit In1) ;  //_GUI 22,15
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 45,11
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 46,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 19,24
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 61,12

 //_ Behavior Topology
 Output.0 = OR.0;  
 INVERT.0 = Junction.0;  //_GUI 20,18
 AND.0 = Input.0;  
 AND.1 = INVERT.0;  //_GUI 40,16, 40,18
 AND:A.0 = Input:A.0;  
 AND:A.1 = Junction.1;  
 Junction.0 = Input:B.0;  
 OR.0 = AND.0;  
 OR.1 = AND:A.0;  //_GUI 61,20, 56,20
}

Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="Variant"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 22,23
 Object ( Variant B) Input:A;  //_GUI 22,31
 Object ( Bit S) Input:B;  //_GUI 22,39
 Object Output( Variant O) ;  //_GUI 120,22
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 34,21
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 88,22
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 34,29
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 61,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 106,20
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 66,21
 //_ Attributes Documentation="Variant"
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 66,32
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $Mux:A.0;  //_GUI 82,27, 82,35
 VariantOut.1 = $Mux.0;  
 VariantIn:A.0 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 Cast.0 = Junction:A.0;  //_GUI 103,22, 103,19, 30,19
 Cast.1 = VariantOut.0;  
 $Mux.0 = VariantIn.1;  
 $Mux.1 = VariantIn:A.1;  //_GUI 57,26, 57,31
 $Mux.2 = Junction.0;  //_GUI 62,29
 $Mux:A.0 = VariantIn.0;  //_GUI 54,34, 54,26
 $Mux:A.1 = VariantIn:A.0;  //_GUI 50,37, 50,34
 $Mux:A.2 = Junction.1;  
}

Object ( NULL O) $Mux( NULL A, NULL B
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="NULL"
{
 // Date:
 // 07 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 22,22
 Object ( NULL B) Input:A;  //_GUI 22,31
 Object ( Bit S) Input:B;  //_GUI 22,39
 Object Output( NULL O) ;  //_GUI 120,22

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant MSB, Variant Remnant) ListPopMsb( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // This object removes the most significant element from a list.
 //
 // Inputs:
 //
 // Variant input:  The list data.
 //
 // Outputs:
 //
 // Variant MSB: The most significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant Remnant: The remnant of the list after the most significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the least significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 51,18
 Object Output:A( Variant Remnant) ;  //_GUI 51,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,17
 Object ( Variant MSB, Variant Out1) $ListPopMsb( Variant In2
    , Variant In1) ;  //_GUI 35,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $ListPopMsb.0;  
 Output:A.0 = $ListPopMsb.1;  
 ListIn.0 = Input.0;  
 $ListPopMsb.0 = ListIn.1;  
 $ListPopMsb.1 = ListIn.0;  
}

Object ( Variant MSB, NULL Remnant) ListPopMsb( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object removes the most significant element from a list.
 //
 // Inputs:
 //
 // Variant input:  The list data.
 //
 // Outputs:
 //
 // Variant MSB: The most significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant Remnant: The remnant of the list after the most significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the least significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,19
 Object Output( Variant MSB) ;  //_GUI 39,9
 Object Output:A( NULL Remnant) ;  //_GUI 39,17
 Object ( NULL Out1) NULL;  //_GUI 27,15

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 23,10, 23,20
 Output:A.0 = NULL.0;  
}

Object ( NULL MSB, NULL Remnant) ListPopMsb( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object removes the most significant element from a list.
 //
 // Inputs:
 //
 // Variant input:  The list data.
 //
 // Outputs:
 //
 // Variant MSB: The most significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant Remnant: The remnant of the list after the most significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the least significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,19
 Object Output( NULL MSB) ;  //_GUI 39,9
 Object Output:A( NULL Remnant) ;  //_GUI 39,17
 Object ( NULL Out1) NULL;  //_GUI 27,15

 //_ Behavior Topology
 Output.0 = Input.0;  //_GUI 23,10, 23,20
 Output:A.0 = NULL.0;  
}

Object ( Variant Out1) Min_Rep_Twos( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // This takes in a constant, interpreting it as a twos complement number, and converts it to the smallest dataset capable of representing the constant.  (Removes duplicate leading bits.)  Supports datasets of MSBxxx, LSBxxx, and BINxxx.  A zero value input returns two bits with a value of zero.
 //
 // Inputs:
 //
 // Variant input:	Constant value interpreted as twos complement data.
 //
 // Outputs:
 //
 // Variant output:	A minimal dataset that can still represent the constant twos complement input.
 //
 // Date:
 // 11/11/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 18,18
 Object Output( Variant Out1) ;  //_GUI 58,18
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 24,16
 //_ Attributes Documentation="bit"
 Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Variant In1) ;  //_GUI 39,16
 //_ Attributes Documentation="bit/var"

 //_ Behavior Topology
 Output.0 = $Min_Rep_Twos.0;  
 ExposeMSB.0 = Input.0;  
 $Min_Rep_Twos.0 = ExposeMSB.0;  
 $Min_Rep_Twos.1 = ExposeMSB.1;  
}

Object ( NULL Out1) Min_Rep_Twos( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // This takes in a constant, interpreting it as a twos complement number, and converts it to the smallest dataset capable of representing the constant.  (Removes duplicate leading bits.)  Supports datasets of MSBxxx, LSBxxx, and BINxxx.  A zero value input returns two bits with a value of zero.
 //
 // Inputs:
 //
 // Variant input:	Constant value interpreted as twos complement data.
 //
 // Outputs:
 //
 // Variant output:	A minimal dataset that can still represent the constant twos complement input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 18,18
 Object Output( NULL Out1) ;  //_GUI 42,18
 Object ( NULL Out1) NULL;  //_GUI 30,16
 Object ( Bit In) Input:A;  //_GUI 31,25
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 37,25
 //_ Attributes Trap="A two's complement number can't be represented with a single bit."

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit OFL, Variant Out2) AddBias( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Takes in a twos complement exponent and adds the bias onto it and outputs a biased exponent.
 //
 // Inputs:
 //
 // Variant input: A twos complement unbiased exponent
 //
 // Outputs:
 //
 // Bit OFL: The Overflow bit.  Goes high if the input is the maximum negative value (only the high bit set), which can't be represented in a biased manner.
 //
 // Variant output: The exponent with the bias offset added.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 27,37
 Object Output( Bit OFL) ;  //_GUI 80,29
 Object Output:A( Variant Out2) ;  //_GUI 83,38
 Object ( Variant Out1) MakeBias( Variant In1) ;  //_GUI 40,44
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,37
 Object ( Variant Out1) One( Variant In1) ;  //_GUI 40,26
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 52,26
 //_ Attributes Documentation="Leaf"
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 68,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 65,37
 Object Text;  //_GUI 33,16,Can't represent a biased exponent of MaxNeg
 Object ( Variant S) Add_CI( Variant A, Variant B
    , Bit CI) ;  //_GUI 70,36
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = Equal.0;  
 Output:A.0 = Add_CI.0;  
 MakeBias.0 = Junction.2;  //_GUI 35,47
 Junction.0 = Input.0;  
 One.0 = Junction.0;  //_GUI 35,29
 ReverseBits.0 = One.0;  
 Equal.0 = ReverseBits.0;  
 Equal.1 = Junction:A.0;  //_GUI 66,32
 Junction:A.0 = Junction.1;  
 Add_CI.0 = Junction:A.1;  
 Add_CI.1 = MakeBias.0;  //_GUI 66,41, 66,47
}

Object ( Variant Out1) $OR-NInput( Variant In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="var/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,24
 Object ( Bit In2) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,22
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 43,22
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input.0;  
 OR.0 = $OR-NInput.0;  
 OR.1 = Input:A.0;  //_GUI 59,32
 $OR-NInput.0 = VariantIn.1;  
 $OR-NInput.1 = VariantIn.0;  
}

Object ( Bit Out1) $OR-NInput( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,24
 Object ( Bit In2) Input:A;  //_GUI 11,27
 Object Output( Bit Out1) ;  //_GUI 31,25
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 18,23

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = Input.0;  
 OR.1 = Input:A.0;  
}

Object ( Variant Out1) $OR-NInput( Bit In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In2) Input;  //_GUI 10,24
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input:A.0;  
 OR.0 = Input.0;  
 OR.1 = $OR-NInput.0;  //_GUI 59,32
 $OR-NInput.0 = VariantIn.1;  
 $OR-NInput.1 = VariantIn.0;  
}

Object ( Variant Out1) $OR-NInput( Variant In1, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$OR",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,20
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 16,18
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $OR-NInput( Variant In1, Variant In2) ;  //_GUI 30,18
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1) $OR-NInput:A( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = OR.0;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = Input.0;  
 OR.0 = $OR-NInput.0;  //_GUI 59,21
 OR.1 = $OR-NInput:A.0;  //_GUI 59,32
 $OR-NInput.0 = VariantIn:A.1;  
 $OR-NInput.1 = VariantIn:A.0;  
 $OR-NInput:A.0 = VariantIn.1;  
 $OR-NInput:A.1 = VariantIn.0;  
}

Object ( NULL Out1, Bit Out1) ExposeBIN( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\ExposeBIN",Icon="Exposer_In",Documentation="Bit"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 38,34
 Object Output( NULL Out1) ;  //_GUI 63,26
 Object Output:A( Bit Out1) ;  //_GUI 58,34
 Object ( NULL Out1) NULL;  //_GUI 50,24

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2) ExposeBIN( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\ExposeBIN",Icon="Exposer_In"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 16,21
 Object Output( Variant Out1) ;  //_GUI 52,20
 Object Output:A( Variant Out2) ;  //_GUI 52,23
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 25,19
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 38,19

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  
 BIN.0 = Input.0;  
 VariantIn.0 = BIN.0;  
}

Object ( NULL Out1, NULL Out1) ExposeBIN( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\BIN\\ExposeBIN",Icon="Exposer_In",Documentation="NULL"
{
 // Date:
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 36,32
 Object Output( NULL Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,39
 Junction.0 = Input.0;  
}

Object ( List MsbList) MsbList( List AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 // This object converts a list of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant MsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element LSB ordered list converted to a four-element MSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (W, list (X, list (Y, Z)))
 // 2. LsbList(list (list (list (W, X), Y), Z))	= list (W, list (X, list (Y, Z)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList) Input;  //_GUI 20,33
 Object Output( List MsbList) ;  //_GUI 62,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,31
 Object ( List MsbList) MsbList( Variant AnyList_Hi, Variant AnyList_Lo) ;  //_GUI 41,31
 //_ Attributes Documentation="list/list"

 //_ Behavior Topology
 Output.0 = MsbList.0;  
 ListIn.0 = Input.0;  
 MsbList.0 = ListIn.1;  
 MsbList.1 = ListIn.0;  
}

Object ( Variant MsbList) MsbList( Variant AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts a list of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant MsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element LSB ordered list converted to a four-element MSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (W, list (X, list (Y, Z)))
 // 2. LsbList(list (list (list (W, X), Y), Z))	= list (W, list (X, list (Y, Z)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList) Input;  //_GUI 20,33
 Object Output( Variant MsbList) ;  //_GUI 31,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL MsbList) MsbList( NULL AnyList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL"
{
 // This object converts a list of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList: The list to reshape.
 //
 // Outputs:
 //
 // Variant MsbList: The list in the same significance order but a different construction order (a different shape).
 //
 // Examples:
 //
 // These examples show (1) a four element BIN ordered list and (2) a four element LSB ordered list converted to a four-element MSB ordered list.
 //
 // 1. LsbList(list (list (W, X), list (Y, Z)))	= list (W, list (X, list (Y, Z)))
 // 2. LsbList(list (list (list (W, X), Y), Z))	= list (W, list (X, list (Y, Z)))
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList) Input;  //_GUI 20,33
 Object Output( NULL MsbList) ;  //_GUI 29,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant S) Sub( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async"
{
 // Asynchronous subtraction
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Number
 //
 // Variant B: Number
 //
 // Outputs:
 //
 // S: The result of A minus B.  If the dataset of A and B are the same, then the dataset of S will also be the same.  If the dataset of A and B are different, the dataset of S will be the result of a Symmetrize of the two inputs.  In this case a compile-time warning is generated indicating the input datasets were different.
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (Works for unsigned or 2's complement), Signed, Floating, Fixed, Complex and List. If one input is a list and the other is not, the other is duplicated into an equivalent list of the one.  A and B can not have mixed datasets except with respect to size or for the cases of MSB, LSB and BIN.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 16,14
 Object ( Variant B) Input:A;  //_GUI 16,17
 Object Output( Variant S) ;  //_GUI 42,17
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 23,13
 //_ Attributes Documentation="List/List"

 //_ Behavior Topology
 Output.0 = Sub.1;  
 Sub.0 = Input.0;  
 Sub.1 = Input:A.0;  
}

Object ( Variant Out1) AllOnes( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,25
 Object Output( Variant Out1) ;  //_GUI 106,23
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 30,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 75,23
 //_ Attributes System="X86UI",Resource="TIMESLICE"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 26,25
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 90,21
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 52,22
 Object ( Variant Out1) AllOnes:A( Variant In1) ;  //_GUI 52,32

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantIn.0 = Junction.1;  
 VariantOut.0 = AllOnes:A.0;  //_GUI 68,28, 68,35
 VariantOut.1 = AllOnes.0;  
 Junction.0 = Input.0;  
 Cast.0 = Junction.0;  //_GUI 89,23, 89,21, 27,21
 Cast.1 = VariantOut.0;  
 AllOnes.0 = VariantIn.1;  
 AllOnes:A.0 = VariantIn.0;  //_GUI 47,35, 47,28
}

Object ( Bit Out1) AllOnes( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Bit"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 37,30
 Object Output( Bit Out1) ;  //_GUI 57,41
 Object ( Bit In) Input:A;  //_GUI 38,41
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( NULL Out1) AllOnes( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 37,30
 Object Output( NULL Out1) ;  //_GUI 48,30

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Floating Out1) AllOnes( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Floating"
{
 // Sets all bits in the dataset to 1.  There is a special overload for Floating that sets the dataset to infinity retaining the sign.
 //
 // Inputs:
 //
 // Variant input: The input dataset that will be set to all binary ones.
 //
 // Outputs:
 //
 // Variant output: The output dataset that was set to all binary ones.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 37,30
 Object Output( Floating Out1) ;  //_GUI 111,30
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 48,28
 Object ( Floating Out1) CollectFloating( Bit Sign, Variant BExp
    , Variant Mant) ;  //_GUI 96,28
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 72,39
 Object ( Variant Out1) AllOnes( Variant In1) ;  //_GUI 71,30
 Object Text;  //_GUI 47,16,we'll tie it to Infinity and leave the sign bit at whatever it came in as

 //_ Behavior Topology
 Output.0 = CollectFloating.0;  
 ExposeFloating.0 = Input.0;  
 CollectFloating.0 = ExposeFloating.0;  //_GUI 96,26, 64,26
 CollectFloating.1 = AllOnes.0;  
 CollectFloating.2 = Zero.0;  //_GUI 87,36, 87,42
 Zero.0 = ExposeFloating.2;  //_GUI 66,42, 66,36
 AllOnes.0 = ExposeFloating.1;  
}

Object ( List LsbList) LsbList( Variant AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 54,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 33,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( List LsbList) LsbList( List AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/list"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 94,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 60,32
 Object ( List LsbList) AppendLsbList:A( Variant LsbList, Variant AnyList) ;  //_GUI 77,33
 Object ( List LsbList) LsbList( List AnyList) ;  //_GUI 34,31
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = AppendLsbList:A.0;  
 ListIn.0 = Input:A.0;  
 AppendLsbList.0 = LsbList.0;  
 AppendLsbList.1 = ListIn.1;  //_GUI 60,42
 AppendLsbList:A.0 = AppendLsbList.0;  
 AppendLsbList:A.1 = ListIn.0;  //_GUI 77,45
 LsbList.0 = Input.0;  
}

Object ( List LsbList) LsbList( List AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 94,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 60,32
 Object ( List LsbList) LsbList( List AnyList) ;  //_GUI 33,31
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 60,43
 ListOut.1 = LsbList.0;  
 LsbList.0 = Input.0;  
}

Object ( List LsbList) LsbList( Variant AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List LsbList) ;  //_GUI 94,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List LsbList) AppendLsbList( Variant LsbList, Variant AnyList) ;  //_GUI 60,32
 Object ( List LsbList) AppendLsbList:A( Variant LsbList, Variant AnyList) ;  //_GUI 77,33

 //_ Behavior Topology
 Output.0 = AppendLsbList:A.0;  
 ListIn.0 = Input:A.0;  
 AppendLsbList.0 = Input.0;  
 AppendLsbList.1 = ListIn.1;  //_GUI 60,42
 AppendLsbList:A.0 = AppendLsbList.0;  
 AppendLsbList:A.1 = ListIn.0;  //_GUI 77,45
}

Object ( Variant LsbList) LsbList( Variant AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant LsbList) ;  //_GUI 81,33
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 33,31

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 LsbList.0 = Input.0;  
}

Object ( Variant LsbList) LsbList( NULL AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant LsbList) ;  //_GUI 74,42
 Object ( Variant LsbList) LsbList( Variant AnyList) ;  //_GUI 26,40

 //_ Behavior Topology
 Output.0 = LsbList.0;  
 LsbList.0 = Input:A.0;  
}

Object ( NULL LsbList) LsbList( NULL AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 // This object converts and combines the two list inputs of any shape to an LSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( NULL LsbList) ;  //_GUI 34,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Variant Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Variant/Variant"
{
 // Date:
 // 02 Jan 2003
 //
 //
 //
 // Recursive object that used in Hi_N implementation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 52,27
 Object ( Variant Lo) Input:A;  //_GUI 38,38
 Object ( Variant Hi_N) Input:B;  //_GUI 53,51
 Object Output( Variant Hi) ;  //_GUI 110,37
 Object Output:A( Variant Lo) ;  //_GUI 110,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 44,36
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 60,49
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 77,24
 Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Variant Hi_N) ;  //_GUI 93,36
 //_ Attributes Documentation="Variant"

 //_ Behavior Topology
 Output.0 = $Hi_N.0;  
 Output:A.0 = $Hi_N.1;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = Input:B.0;  
 VariantOut.0 = VariantIn.1;  //_GUI 60,31, 60,38
 VariantOut.1 = Input.0;  
 $Cast.0 = VariantOut.0;  
 $Hi_N.0 = $Cast.0;  //_GUI 87,38
 $Hi_N.1 = VariantIn.0;  
 $Hi_N.2 = VariantIn:A.1;  //_GUI 76,44, 76,51
}

Object ( Variant Hi, Variant Lo) $Hi_N( Variant Hi
    , Variant Lo, Bit Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="VariantLeaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 52,27
 Object ( Variant Lo) Input:A;  //_GUI 38,38
 Object ( Bit Hi_N) Input:B;  //_GUI 65,50
 Object Output( Variant Hi) ;  //_GUI 110,35
 Object Output:A( Variant Lo) ;  //_GUI 110,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 44,36
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 64,26
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 78,24

 //_ Behavior Topology
 Output.0 = $Cast.0;  //_GUI 98,36, 98,27
 Output:A.0 = VariantIn.0;  
 VariantIn.0 = Input:A.0;  
 VariantOut.0 = VariantIn.1;  //_GUI 60,31, 60,38
 VariantOut.1 = Input.0;  
 $Cast.0 = VariantOut.0;  
}

Object ( Variant Hi, NULL Lo) $Hi_N( Variant Hi
    , Bit Lo, Bit Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="Bit Leaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 40,26
 Object ( Bit Lo) Input:A;  //_GUI 40,41
 Object ( Bit Hi_N) Input:B;  //_GUI 45,52
 Object Output( Variant Hi) ;  //_GUI 89,25
 Object Output:A( NULL Lo) ;  //_GUI 93,38
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 74,23
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 56,25
 Object ( NULL Out1) NULL;  //_GUI 76,36

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 Output:A.0 = NULL.0;  
 $Cast.0 = VariantOut.0;  
 VariantOut.0 = Input:A.0;  //_GUI 50,30, 50,42
 VariantOut.1 = Input.0;  
}

Object ( Variant Hi, NULL Lo) $Hi_N( Variant Hi
    , Bit Lo, Variant Hi_N) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="ErrorLeaf"
{
 // Date:
 // 04 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Hi) Input;  //_GUI 44,12
 Object ( Bit Lo) Input:A;  //_GUI 40,39
 Object ( Variant Hi_N) Input:B;  //_GUI 45,52
 Object Output( Variant Hi) ;  //_GUI 126,24
 Object Output:A( NULL Lo) ;  //_GUI 114,38
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 98,22
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 112,22
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 51,50
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 60,11
 Object ( Variant Out1) $Cast( Variant Data, LSB Type) ;  //_GUI 76,9
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 67,49
 Object ( NULL Out1) NULL;  //_GUI 98,36

 //_ Behavior Topology
 Output.0 = MSB.0;  
 Output:A.0 = NULL.0;  
 ListOut.0 = Zero.0;  //_GUI 90,27, 90,52
 ListOut.1 = $Cast.0;  //_GUI 90,24, 90,12
 MSB.0 = ListOut.0;  
 VariantIn.0 = Input:B.0;  
 VariantOut.0 = Input:A.0;  //_GUI 55,16, 55,40
 VariantOut.1 = Input.0;  
 $Cast.0 = VariantOut.0;  
 Zero.0 = VariantIn.1;  
}

Object ( Bit CO, Bit OFL, Variant S) $ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Icon="Add",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 19,12
 Object ( Variant B) Input:A;  //_GUI 19,36
 Object ( Bit ADD) Input:B;  //_GUI 27,48
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 27,51
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 120,21
 Object Output:A( Bit OFL) ;  //_GUI 120,27
 Object Output:B( Variant S) ;  //_GUI 125,41
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 24,34
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 33,10
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 53,48
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 27,12
 Object ( Variant Out1) PushMsb( Variant MSB, Variant In2) ;  //_GUI 94,41
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 111,39
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 110,25
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 83,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 109,21
 Object ( Variant CO, Variant S) $$ADSU( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 62,41
 //_ Attributes Documentation="bit"
 Object ( Variant CO, Variant S) $$ADSU:A( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 84,20
 //_ Attributes Documentation="bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 74,40
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 96,19

 //_ Behavior Topology
 Output.0 = Junction:C.1;  
 Output:A.0 = XOR.0;  
 Output:B.0 = Cast.0;  
 PopMsb.0 = Input:A.0;  
 PopMsb:A.0 = Junction:A.1;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 PushMsb.0 = $$ADSU:A.1;  
 PushMsb.1 = $$ADSU.1;  
 Cast.0 = Junction:A.0;  //_GUI 107,41, 107,6, 28,6
 Cast.1 = PushMsb.0;  
 XOR.0 = Junction:C.2;  
 XOR.1 = Junction:B.2;  //_GUI 110,36
 Junction:B.0 = VouchBit.0;  
 Junction:C.0 = VouchBit:A.0;  
 $$ADSU.0 = PopMsb:A.1;  //_GUI 59,43, 59,15
 $$ADSU.1 = PopMsb.1;  //_GUI 48,46, 48,39
 $$ADSU.2 = Junction.1;  
 $$ADSU.3 = Input:C.0;  
 $$ADSU:A.0 = PopMsb:A.0;  //_GUI 84,12
 $$ADSU:A.1 = PopMsb.0;  //_GUI 34,25
 $$ADSU:A.2 = Junction.0;  //_GUI 54,28
 $$ADSU:A.3 = Junction:B.1;  
 VouchBit.0 = $$ADSU.0;  
 VouchBit:A.0 = $$ADSU:A.0;  
}

Object ( Bit CO, Bit OFL, Bit S) $ADSU
    ( Bit A, Bit B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Icon="Add",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 14,20
 Object ( Bit B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,35
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 113,17
 Object Output:A( Bit OFL) ;  //_GUI 113,23
 Object Output:B( Bit S) ;  //_GUI 115,29
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 20,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 36,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 86,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 82,31
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 92,27
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:A( Bit In1, Bit In2) ;  //_GUI 64,20
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:B( Bit In1, Bit In2) ;  //_GUI 48,19
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit In) Input:D;  //_GUI 107,23
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit O) $Mux( Bit A, Bit B
    , Bit S) ;  //_GUI 95,15
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 Output:A.0 = Input:D.0;  
 Output:B.0 = XOR.0;  
 INVERT.0 = Input:B.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = XOR:A.0;  
 Junction:B.0 = Input:C.0;  //_GUI 83,41
 XOR.0 = Junction:A.2;  //_GUI 87,29
 XOR.1 = Junction:B.2;  
 XOR:A.0 = XOR:B.0;  
 XOR:A.1 = INVERT.0;  //_GUI 64,36
 XOR:B.0 = Junction.1;  
 XOR:B.1 = Input:A.0;  
 $Mux.0 = Junction.0;  //_GUI 37,17
 $Mux.1 = Junction:B.1;  //_GUI 83,20
 $Mux.2 = Junction:A.1;  
}

Object ( Bit Out1) EqualAllOnes( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Comparators\\Async\\Advanced"
{
 // Takes in a value of any dataset and returns a high value if all bits of the dataset are high.
 //
 // Inputs:
 //
 // Variant input: The input value
 //
 // Outputs:
 //
 // Bit output: Asserted if all bits of the input are high.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 4,20
 Object Output( Bit Out1) ;  //_GUI 50,20
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 25,18
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 37,18
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 12,18
 Object Text;  //_GUI 11,26,remove any contexts

 //_ Behavior Topology
 Output.0 = EqualZero.0;  
 INVERT.0 = LSB.0;  
 EqualZero.0 = INVERT.0;  
 LSB.0 = Input.0;  
}

Object ( Bit OFL, Bit ERNG_Data, Bit ERNG_FallOff
    , Bit Round, Variant FallOff, Variant Data) ShiftRightBy( Variant Data
    , Variant ShiftBy, Bit IsTwos) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\Async\\Advanced",Documentation="barrel with ranges"
{
 // ShiftLeftBy instantiates a barrelshifter.  Data is shifted right (towards the least significant end) by ShiftBy amount.  This object is the same as a simpler object of the same name except that this object has some additional outputs and a Two's complement selector input.
 //
 // Since barrel shifters use large amounts of physical resources, the ShiftBy input is preprocessed, converting it into the smallest data set possible of representing the bit length of Data.  This ensures that an optimal structure is created.
 // If the ShiftBy input is constant, this object simply becomes a series of SHRs, which are free.
 //
 // Inputs:
 //
 // Variant Data: The input data that will be shifted at runtime (as apposed to SHR which shifts at compile time).
 //
 // Variant ShiftBy: The amount to shift data by.
 //
 // Bit IsTwos: If this input is a 1 the number to be right shifted should be interpreted as a two's complement number.  The most significant bit will be duplicated for the bit shifted in on the left.
 //
 // Outputs:
 //
 // Bit OFL: Overflow (OFL) goes high when any bits shifted off the end have a high value or ERNG_Data.
 //
 // Bit ERNG_Data: This indicates an error in the ShiftBy range.  This bit goes high if the ShiftBy value exceeds (Data size rounded up to the nearest power of two).
 //
 // Bit ERNG_FallOff: This indicates an error in the ShiftBy range.  This bit goes high if the ShiftBy value exceeds ( 2 * (Data size rounded up to the nearest power of two)).
 //
 // Bit Round: A bit used for rounding in some applications.  This is the MSB of FallOff.
 //
 // Variant FallOff: Data is shifted right out of Data into FallOff.  The dataset is the same as Data.
 //
 // Variant Data: The result of Data shifted right by ShiftBy.
 //
 // Date:
 // 07/30/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 7,35
 Object ( Variant ShiftBy) Input:A;  //_GUI 8,48
 Object ( Bit IsTwos) Input:B;  //_GUI 13,61
 //_ Attributes Constant="0"
 Object Output( Bit OFL) ;  //_GUI 217,6
 Object Output:A( Bit ERNG_Data) ;  //_GUI 215,15
 Object Output:B( Bit ERNG_FallOff) ;  //_GUI 215,23
 Object Output:C( Bit Round) ;  //_GUI 216,30
 Object Output:D( Variant FallOff) ;  //_GUI 214,37
 Object Output:E( Variant Data) ;  //_GUI 214,52
 Object ( Variant Data) List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 90,34
 //_ Attributes Documentation="var/ztlist"
 Object ( Variant Data) List_Mux_Sel:A( Variant ListData, Variant Sel) ;  //_GUI 86,22
 //_ Attributes Documentation="var/ztlist"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In3) ;  //_GUI 85,38
 Object ( Variant Out1) OR-NInput( Variant In1) ;  //_GUI 166,6
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 20,33
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 182,6
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 159,23
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 177,13
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 15,35
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 145,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In3) ;  //_GUI 139,34
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 123,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 112,36
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 126,35
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Variant Out1, Variant ZeroTheResult) ShiftByFilter( Variant Data
    , Variant ShiftBy) ;  //_GUI 36,44
 Object ( Bit Out1) EqualZero( Variant In1) ;  //_GUI 111,59
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 109,41
 //_ Attributes Documentation="ztlist"
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 202,4
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In0) ;  //_GUI 125,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 105,48
 Object ( Bit Out1) EqualZero:A( Variant In1) ;  //_GUI 169,40
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 202,35
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 193,39
 Object ( Bit Out) AND:B( Bit In1, Bit In2) ;  //_GUI 201,28
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 133,59
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 32,35
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 205,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 193,32
 Object Text;  //_GUI 143,74,So ERNG_FallOff triggers as soon as the Round and FallOff outputs are no longer validOFL triggers when data has fallen off of Data or the shift goes out of range for the Data input.
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 145,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 196,15
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 163,14
 Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Bit IsTwos) ;  //_GUI 60,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 107,24

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = Junction:J.2;  
 Output:B.0 = INVERT:A.0;  
 Output:C.0 = AND:B.0;  
 Output:D.0 = AND:A.0;  
 Output:E.0 = Context:A.0;  //_GUI 158,53, 158,36
 List_Mux_Sel.0 = PossibleRightShifts.0;  //_GUI 90,31
 List_Mux_Sel.1 = Junction.2;  
 List_Mux_Sel:A.0 = PossibleRightShifts.1;  //_GUI 83,24, 83,34
 List_Mux_Sel:A.1 = Junction.1;  
 Junction.0 = ShiftByFilter.0;  //_GUI 86,46
 OR-NInput.0 = Junction:K.0;  //_GUI 108,9
 MSB.0 = Junction:B.1;  
 VouchBit.0 = OR-NInput.0;  
 Junction:A.0 = Context.0;  
 VouchBit:A.0 = PopMsb.0;  
 Junction:B.0 = Input.0;  
 Context.0 = Junction:C.1;  //_GUI 140,23
 Context.1 = Mux.0;  
 Junction:C.0 = Junction:B.2;  //_GUI 140,54, 16,54
 Mux.0 = Junction:K.1;  
 Mux.1 = Junction:D.0;  //_GUI 113,28
 Mux.2 = PopLsb.1;  //_GUI 123,46
 Junction:D.0 = List_Mux_Sel.0;  
 AND.0 = Junction:D.1;  
 AND.1 = Junction:E.0;  
 ShiftByFilter.0 = Junction:H.2;  //_GUI 33,46
 ShiftByFilter.1 = Input:A.0;  
 EqualZero.0 = Junction:F.2;  //_GUI 106,62
 PopLsb.0 = Junction:F.0;  //_GUI 106,44
 OR.0 = Junction:J.1;  //_GUI 197,6
 OR.1 = VouchBit.0;  
 Junction:E.0 = EqualZero.0;  
 Junction:F.0 = ShiftByFilter.1;  
 EqualZero:A.0 = PopLsb.0;  
 AND:A.0 = Junction:A.1;  //_GUI 166,37, 166,24
 AND:A.1 = Junction:G.2;  
 Junction:G.0 = EqualZero:A.0;  //_GUI 194,43
 AND:B.0 = VouchBit:A.0;  //_GUI 190,30, 190,16
 AND:B.1 = Junction:I.2;  
 INVERT.0 = Junction:E.1;  
 Junction:H.0 = MSB.0;  
 INVERT:A.0 = Junction:I.1;  //_GUI 194,24
 Junction:I.0 = Junction:G.1;  
 Context:A.0 = Junction:C.2;  
 Context:A.1 = AND.0;  
 Junction:J.0 = INVERT.0;  //_GUI 197,62
 PopMsb.0 = Junction:A.0;  //_GUI 160,17
 PossibleRightShifts.0 = Junction:H.1;  //_GUI 52,31, 52,36
 PossibleRightShifts.1 = Input:B.0;  //_GUI 60,62
 Junction:K.0 = List_Mux_Sel:A.0;  
}

Object ( Variant ShiftedData, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) LeftJustify( Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\Async\\Advanced"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 37,29
 Object Output( Variant ShiftedData) ;  //_GUI 176,27
 Object Output:A( Variant ShiftMask) ;  //_GUI 176,39
 Object Output:B( Variant ShiftNum) ;  //_GUI 176,47
 Object Output:C( Bit Zero) ;  //_GUI 176,52
 Object Text;  //_GUI 49,6,round up to the nearest power of two.
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 93,25
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 47,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 89,18
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 148,28
 Object ( Variant Out1) "2^N_Bits"( Variant In1) ;  //_GUI 75,16
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 93,16
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 51,16
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 148,37
 Object ( Variant Val) Encoder( Variant Mask) ;  //_GUI 63,16
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 154,45
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 134,52
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 139,47
 Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, Variant ShBy) ;  //_GUI 111,28
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 164,25
 Object ( Variant Out1) Context:A( Variant Type, Variant Data) ;  //_GUI 164,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 160,26
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In3) ;  //_GUI 47,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 144,11
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In1) ;  //_GUI 144,32

 //_ Behavior Topology
 Output.0 = Context.0;  
 Output:A.0 = Context:A.0;  
 Output:B.0 = AND.0;  
 Output:C.0 = Junction:B.1;  
 PadRight.0 = Junction:A.2;  //_GUI 90,27
 PadRight.1 = Junction.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = "2^N_Bits".0;  
 Hi_N.0 = $LeftJustify.0;  
 Hi_N.1 = Junction:F.1;  
 "2^N_Bits".0 = Encoder.0;  
 ExposeBIN.0 = Junction:A.1;  
 Zero.0 = Junction:D.2;  
 Lo_N.0 = $LeftJustify.1;  //_GUI 141,39, 141,33
 Lo_N.1 = Junction:F.2;  //_GUI 145,42
 Encoder.0 = Zero.0;  
 AND.0 = $LeftJustify.2;  //_GUI 135,47, 135,36
 AND.1 = INVERT.0;  
 Junction:B.0 = $LeftJustify.3;  //_GUI 131,53, 131,39
 INVERT.0 = Junction:B.0;  //_GUI 135,50
 $LeftJustify.0 = PadRight.1;  
 $LeftJustify.1 = ExposeBIN.1;  //_GUI 107,33, 107,21
 Context.0 = Junction:C.1;  
 Context.1 = Hi_N.0;  
 Context:A.0 = Junction:C.2;  //_GUI 161,39
 Context:A.1 = Lo_N.1;  
 Junction:C.0 = Junction:E.1;  //_GUI 161,12
 Junction:D.0 = Junction.0;  
 Junction:E.0 = Junction:D.1;  //_GUI 48,12
 Junction:F.0 = Junction:E.2;  
}

Object ( Variant Out1) $ReverseBits( Variant Build, Variant Orig) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Variant"
{
 // Date:
 // 10 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Build) Input;  //_GUI 18,21
 Object ( Variant Orig) Input:A;  //_GUI 18,26
 Object Output( Variant Out1) ;  //_GUI 91,26
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 25,24
 Object ( Variant Out1) $ReverseBits( Variant Build, Variant Orig) ;  //_GUI 73,24
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 42,17

 //_ Behavior Topology
 Output.0 = $ReverseBits.0;  
 VariantIn.0 = Input:A.0;  
 $ReverseBits.0 = CollectMSB.0;  //_GUI 58,26, 58,20
 $ReverseBits.1 = VariantIn.0;  
 CollectMSB.0 = VariantIn.1;  //_GUI 39,19, 39,26
 CollectMSB.1 = Input.0;  
}

Object ( Variant Out1) $ReverseBits( Variant Build, Bit Orig) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Leaf"
{
 // Date:
 // 10 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Build) Input;  //_GUI 18,21
 Object ( Bit Orig) Input:A;  //_GUI 18,25
 Object Output( Variant Out1) ;  //_GUI 63,19
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 43,17

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Input:A.0;  //_GUI 37,19, 37,26
 CollectMSB.1 = Input.0;  
}

Object ( Variant Remnant, Variant LSB) ListPopLsb( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="list"
{
 // This object removes the least significant element from a list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: The remnant of the list after the least significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the most significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 15,19
 Object Output( Variant Remnant) ;  //_GUI 50,18
 Object Output:A( Variant LSB) ;  //_GUI 50,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,17
 Object ( Variant Out1, Variant LSB) $ListPopLsb( Variant In1
    , Variant In2) ;  //_GUI 35,17
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $ListPopLsb.0;  
 Output:A.0 = $ListPopLsb.1;  
 ListIn.0 = Input.0;  
 $ListPopLsb.0 = ListIn.1;  
 $ListPopLsb.1 = ListIn.0;  
}

Object ( NULL Remnant, Variant LSB) ListPopLsb( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="var"
{
 // This object removes the least significant element from a list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: The remnant of the list after the least significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the most significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 14,27
 Object Output( NULL Remnant) ;  //_GUI 39,18
 Object Output:A( Variant LSB) ;  //_GUI 39,27
 Object ( NULL Out1) NULL;  //_GUI 16,37

 //_ Behavior Topology
 Output.0 = NULL.0;  //_GUI 26,19
 Output:A.0 = Input.0;  
}

Object ( NULL Remnant, NULL LSB) ListPopLsb( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\ListPopLsb",Documentation="NULL"
{
 // This object removes the least significant element from a list.
 //
 // Inputs:
 //
 // Variant input: The list data.
 //
 // Outputs:
 //
 // Variant Remnant: The remnant of the list after the least significant element has been removed.  If a three or more element list was passed in, a list will be passed out.  If a two-element list was passed in, the most significant element will be passed out.  If a single-element list (Variant) was passed in, a NULL will be passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Variant LSB: The least significant element of the list.  If a single-element list (Variant) was passed in, then that variant is passed out.  If a zero-element list (NULL) was passed in, a NULL will be passed out.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,19
 Object Output( NULL Remnant) ;  //_GUI 39,19
 Object Output:A( NULL LSB) ;  //_GUI 39,27
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 22,19

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 23,28
 Junction.0 = Input.0;  
}

Object ( NULL Out1, Bit Out1) ExposeLSB( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\ExposeLSB",Icon="Exposer_In",Documentation="bit"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 41,29
 Object Output( NULL Out1) ;  //_GUI 69,21
 Object Output:A( Bit Out1) ;  //_GUI 68,29
 Object ( NULL Out1) NULL;  //_GUI 49,19

 //_ Behavior Topology
 Output.0 = NULL.0;  
 Output:A.0 = Input.0;  
}

Object ( Variant Out1, Variant Out2) ExposeLSB( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\ExposeLSB",Icon="Exposer_In"
{
 // Date:
 // 13 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 24,31
 Object Output( Variant Out1) ;  //_GUI 57,30
 Object Output:A( Variant Out2) ;  //_GUI 57,33
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 43,29
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 31,29

 //_ Behavior Topology
 Output.0 = VariantIn.1;  
 Output:A.0 = VariantIn.0;  
 VariantIn.0 = LSB.0;  
 LSB.0 = Input.0;  
}

Object ( NULL Out1, NULL Out1) ExposeLSB( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\ExposeLSB",Icon="Exposer_In",Documentation="NULL"
{
 // Date:
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 36,32
 Object Output( NULL Out1) ;  //_GUI 67,32
 Object Output:A( NULL Out1) ;  //_GUI 67,38
 Object ( NULL Out1, NULL Out2, NULL Out3) Junction
    ( NULL In0) ;  //_GUI 59,32

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction.2;  //_GUI 60,39
 Junction.0 = Input.0;  
}

Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Variant Constant) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Append) Input;  //_GUI 12,38
 Object ( Variant Constant) Input:A;  //_GUI 12,47
 Object Output( Variant N_Bits) ;  //_GUI 105,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 20,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In3) ;  //_GUI 20,29
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 37,34
 Object Text;  //_GUI 30,9,At each recursive step, the size of the Append data set is doubled and passed on.The LSB of Constant is removed and used in this stage.  The remaining bits are passed on.
 Object Text;  //_GUI 21,56,Remove the LSB.  If it is 1, we concatenate Append with the N_Bits from the inner recursions.
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 35,25
 Object ( Variant Out1, Variant Out1) ExposeLSB( Variant In1) ;  //_GUI 18,45
 //_ Attributes Documentation="Error"
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 75,27
 Object ( NULL Out1) NULL;  //_GUI 23,31
 Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Variant Constant) ;  //_GUI 52,26
 //_ Attributes Documentation="var"

 //_ Behavior Topology
 Output.0 = CollectMSB:A.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = Junction.0;  
 $Select.0 = NULL.0;  //_GUI 36,36, 36,34
 $Select.1 = Junction.1;  
 $Select.2 = ExposeLSB.1;  //_GUI 33,42, 33,50
 CollectMSB.0 = Junction:A.1;  //_GUI 21,27
 CollectMSB.1 = Junction:A.2;  
 ExposeLSB.0 = Input:A.0;  
 CollectMSB:A.0 = "$Constant->N_Bits".0;  
 CollectMSB:A.1 = $Select.0;  //_GUI 75,37
 "$Constant->N_Bits".0 = CollectMSB.0;  
 "$Constant->N_Bits".1 = ExposeLSB.0;  //_GUI 50,31, 50,47
}

Object ( Variant N_Bits) "$Constant->N_Bits"( Variant Append, Bit Constant) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Append) Input;  //_GUI 11,41
 Object ( Bit Constant) Input:A;  //_GUI 11,44
 Object Output( Variant N_Bits) ;  //_GUI 44,39
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 31,37
 Object Text;  //_GUI 18,11,Here we have the most significant bit of the original Constant.  Append is the number of bits that the MSB represents (if it is 1).Because of MinRep, this bit is guarnteed to be a 1 unless the conatant passed to the base object is zero, so we still need to do a check.
 Object ( NULL Out1) NULL;  //_GUI 17,34

 //_ Behavior Topology
 Output.0 = $Select.0;  
 $Select.0 = NULL.0;  //_GUI 30,39, 30,37
 $Select.1 = Input.0;  
 $Select.2 = Input:A.0;  
}

Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 // See inside and the other overload for documentation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 18,42
 Object ( Variant Data) Input:A;  //_GUI 18,55
 Object Output( Bit OFL) ;  //_GUI 241,34
 Object Output:A( Variant Out1) ;  //_GUI 241,48
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 104,54
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 205,48
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 33,67
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 118,53
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 88,58
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 29,42
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 33,71
 Object Text;  //_GUI 207,63,So if the data is shorter then the type, we need to tack on some zero fill on the top. Otherwise we just truncate it.
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 205,32
 Object ( Variant Hi, Variant Lo) Lo_N:A( Variant Data
    , Variant Lo_N) ;  //_GUI 104,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 199,55
 Object Text;  //_GUI 144,13,If we lose non-zero data on the high end and we weren't signed, that's an overflow. If we lose non-high data on the upper end and we were signed, that's an overflow.
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 170,30
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out11) ExposeMSB( Variant In1) ;  //_GUI 91,61
 //_ Attributes Documentation="Error"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 174,55
 Object Text;  //_GUI 29,9,The #0 is for data truncation and the #1 case is for data extension.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 88,63
 Object ( Variant O) $Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 145,54
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 135,56
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 134,55
 Object Text;  //_GUI 108,65,So if signed, we prepend all high bits else prepend all low bits.
 Object ( Variant Out1, Variant Out11) ExposeMSB:A( Variant In1) ;  //_GUI 86,29
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:G
    ( Variant In3) ;  //_GUI 80,39
 Object ( Variant O) $Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 155,30
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1) INVERT:A( Variant In1) ;  //_GUI 145,32
 //_ Attributes Documentation="Variant"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:H
    ( Variant In0) ;  //_GUI 144,31
 Object ( Bit "#1") Input:B;  //_GUI 199,36
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) XOR( Variant In1, Variant In2) ;  //_GUI 172,41
 //_ Attributes Documentation="Bit/Bit"
 Object ( Variant Out1, Variant Out11) ExposeMSB:B( Variant In1) ;  //_GUI 130,40
 //_ Attributes Documentation="Error"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:I
    ( Variant In0) ;  //_GUI 124,42
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:J
    ( Variant In0) ;  //_GUI 150,37
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 184,31
 //_ Attributes Documentation="ztlist/ztlist"
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 223,46
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 229,32
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 10,69
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:K
    ( Variant In0) ;  //_GUI 26,55
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:L
    ( Variant In0) ;  //_GUI 48,50
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:M
    ( Bit In0) ;  //_GUI 52,67
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,60
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:N
    ( Variant In0) ;  //_GUI 48,28
 Object ( Variant Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,27
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:O
    ( Bit In0) ;  //_GUI 52,45
 Object ( Variant Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 61,38

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 Lo_N.0 = $Select:E.0;  //_GUI 87,56, 87,46, 71,46
 Lo_N.1 = Junction:A.1;  
 $Select.0 = Junction:I.2;  //_GUI 125,50
 $Select.1 = CollectMSB.0;  //_GUI 194,53, 194,58
 $Select.2 = Junction:D.2;  
 Junction.0 = Junction:C.0;  
 Zero.0 = Lo_N.0;  
 Junction:A.0 = $Select:C.0;  //_GUI 79,59, 79,63
 Junction:B.0 = Input.0;  
 Junction:C.0 = BitA_Gt_BitB.0;  
 $Select:A.0 = OR.0;  
 $Select:A.1 = Input:B.0;  
 $Select:A.2 = Junction:D.1;  //_GUI 200,40
 Lo_N:A.0 = Junction:G.2;  
 Lo_N:A.1 = $Select:D.0;  //_GUI 75,43, 75,30
 Junction:D.0 = Junction:C.1;  //_GUI 200,72
 NotZero.0 = $Mux:A.0;  
 ExposeMSB.0 = Junction:E.1;  
 CollectMSB.0 = $Mux.0;  
 CollectMSB.1 = Junction:E.2;  //_GUI 174,70, 89,70
 Junction:E.0 = Junction:A.2;  
 $Mux.0 = Junction:F.1;  
 $Mux.1 = INVERT.0;  
 $Mux.2 = ExposeMSB.0;  //_GUI 118,62, 118,63
 INVERT.0 = Junction:F.2;  
 Junction:F.0 = Zero.0;  
 ExposeMSB:A.0 = Junction:G.1;  //_GUI 81,32
 Junction:G.0 = $Select:B.0;  //_GUI 81,52
 $Mux:A.0 = Junction:H.1;  
 $Mux:A.1 = INVERT:A.0;  
 $Mux:A.2 = Junction:J.1;  
 INVERT:A.0 = Junction:H.2;  
 Junction:H.0 = Lo_N:A.0;  //_GUI 128,32, 128,40
 XOR.0 = Junction:J.2;  //_GUI 151,43
 XOR.1 = ExposeMSB:B.0;  //_GUI 147,46, 147,42
 ExposeMSB:B.0 = Junction:I.1;  
 Junction:I.0 = Lo_N:A.1;  
 Junction:J.0 = ExposeMSB:A.0;  //_GUI 122,38, 122,31
 OR.0 = NotZero.0;  
 OR.1 = XOR.0;  //_GUI 184,44
 Context.0 = Junction:B.0;  //_GUI 223,26, 30,26
 Context.1 = $Select.0;  
 VouchBit.0 = $Select:A.0;  
 BitA_Gt_BitB.0 = Junction:B.2;  //_GUI 10,48, 30,48
 BitA_Gt_BitB.1 = Junction:K.2;  //_GUI 6,74, 6,62, 27,62
 Junction:K.0 = Input:A.0;  
 Junction:L.0 = Junction:K.1;  //_GUI 38,51, 38,56
 $Select:B.0 = Junction:L.1;  
 $Select:B.2 = Junction:M.0;  //_GUI 53,57
 Junction:M.0 = Junction.2;  
 $Select:C.1 = Junction:L.2;  //_GUI 49,65
 $Select:C.2 = Junction:M.1;  
 Junction:N.0 = Junction:B.1;  //_GUI 39,29, 39,43
 $Select:D.0 = Junction:N.1;  
 $Select:D.2 = Junction:O.0;  //_GUI 53,35
 Junction:O.0 = Junction.1;  //_GUI 34,46
 $Select:E.1 = Junction:N.2;  //_GUI 49,43
 $Select:E.2 = Junction:O.1;  
}

Object ( List OFL, List Out1) TwosExtnd( Variant Type
    , List Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="var/List"
{
 // Converts the Leaves of a list to the type.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 15,17
 Object ( List Data) Input:A;  //_GUI 15,21
 Object Output( List OFL) ;  //_GUI 89,11
 Object Output:A( List Out1) ;  //_GUI 84,21
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 36,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 69,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 72,9
 Object ( Variant OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 40,31
 Object ( Variant OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 40,16

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 Junction.0 = Input.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = TwosExtnd.1;  //_GUI 63,24, 63,36
 ListOut.1 = TwosExtnd:A.1;  
 ListOut:A.0 = TwosExtnd.0;  //_GUI 56,14, 56,33
 ListOut:A.1 = TwosExtnd:A.0;  //_GUI 52,11
 TwosExtnd.0 = Junction.2;  //_GUI 37,33
 TwosExtnd.1 = ListIn.0;  //_GUI 32,36
 TwosExtnd:A.0 = Junction.1;  
 TwosExtnd:A.1 = ListIn.1;  
}

Object ( List OFL, List Out1) TwosExtnd( List Type
    , List Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="list"
{
 // See inside and the other overload for documentation.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 14,37
 Object ( List Data) Input:A;  //_GUI 14,48
 Object Output( List OFL) ;  //_GUI 65,42
 Object Output:A( List Out1) ;  //_GUI 65,53
 Object ( Bit OFL, Variant Out1) TwosExtnd( Variant Type
    , Variant Data) ;  //_GUI 37,35
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 20,35
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,40
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 20,46
 Object ( Bit OFL, Variant Out1) TwosExtnd:A( Variant Type
    , Variant Data) ;  //_GUI 34,51
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,51

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 TwosExtnd.0 = ListIn.1;  
 TwosExtnd.1 = ListIn:A.1;  //_GUI 37,48
 ListIn.0 = Input.0;  
 ListOut.0 = TwosExtnd:A.0;  //_GUI 46,45
 ListOut.1 = TwosExtnd.0;  //_GUI 52,37
 ListIn:A.0 = Input:A.0;  
 TwosExtnd:A.0 = ListIn.0;  //_GUI 34,40
 TwosExtnd:A.1 = ListIn:A.0;  //_GUI 31,56
 ListOut:A.0 = TwosExtnd:A.1;  
 ListOut:A.1 = TwosExtnd.1;  //_GUI 49,53
}

Object ( Variant Max) $MaxSigned( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller Signed size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Bit OFL, NULL Out1) PadRight( NULL Type
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="NULL/var"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( Variant Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,12
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit Out1) NotZero( Variant In1) ;  //_GUI 23,21

 //_ Behavior Topology
 Output.0 = NotZero.0;  //_GUI 35,13
 Output:A.0 = Input.0;  
 NotZero.0 = Input:A.0;  
}

Object ( Bit OFL, NULL Out1) PadRight( NULL Type
    , NULL Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="NULL/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( NULL Out1) ;  //_GUI 51,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) PadRight( Variant Type
    , NULL Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal",Documentation="var/NULL"
{
 // Will convert an unsigned integer to a different sized unsigned integer.  Data truncation will force the OFL output high.
 //
 // Date Last Modified:
 // Jan 2004
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 14,17
 Object ( NULL Data) Input:A;  //_GUI 14,23
 Object Output( Bit OFL) ;  //_GUI 58,11
 Object Output:A( Variant Out1) ;  //_GUI 53,17
 Object ( Bit In) Input:B;  //_GUI 49,11
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 32,15

 //_ Behavior Topology
 Output.0 = Input:B.0;  
 Output:A.0 = Zero.0;  
 Zero.0 = Input.0;  
}

Object ( Bit OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced"
{
 // Similar to UExtnd except adds or removes bits from the least significant end rather than from the most significant end of the number.  If Type is a Variant and Data is a List, PadRight is called on each element of the list with the specified Type.  If both Type and Data are lists, then PadRight is called on each respective input pair.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to right pad
 //
 // Outputs:
 //
 // Bit/List OFL 1 if any non-zero bits were removed.  This output is asynchronous and may have difficulty meeting timing specifications with large reductions in dataset sizes and/or faster frequencies.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,38
 Object ( Variant Data) Input:A;  //_GUI 7,51
 Object Output( Bit OFL) ;  //_GUI 190,29
 Object Output:A( Variant Out1) ;  //_GUI 179,37
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 44,37
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 79,50
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In3) ;  //_GUI 38,54
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 95,49
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 69,54
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 34,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 38,67
 Object Text;  //_GUI 52,73,So if the data is shorter then the type, we need to tack on some zero fill on the bottom.
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,27
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 44,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 138,51
 Object Text;  //_GUI 42,26,If we lose non-zero data on the low end, that's an overflow.
 Object ( Variant Out1) NotZero( Variant In1) ;  //_GUI 102,33
 //_ Attributes Documentation="Bit"
 Object ( Variant Data) ZeroNulls( Variant Data, Variant Type) ;  //_GUI 121,34
 //_ Attributes Documentation="Variant"
 Object ( Bit In) Input:B;  //_GUI 117,38
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 97,10,If inputs Type and Data are the same sizes, the Lo output of Hi_N will be NULL.  In this case there is no overflow, so change it to a bit of value zero with ZeroNulls.
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 178,27
 Object ( Bit In) Input:C;  //_GUI 138,31
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) BitA_Ge_BitB( Variant A, Variant B) ;  //_GUI 19,65
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In0) ;  //_GUI 18,38
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:F
    ( Variant In0) ;  //_GUI 14,51
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 122,50
 //_ Attributes Documentation="ztl/var"
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 162,35
 Object Text;  //_GUI 11,30,so the #0 case is shrinking the data
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 79,34

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = Context.0;  
 $SelectOut.0 = Junction:B.1;  
 $SelectOut.1 = Junction.1;  //_GUI 39,42
 Lo_N.0 = $SelectOut.1;  //_GUI 68,52, 68,42
 Lo_N.1 = Junction:A.1;  
 $Select.0 = Hi_N.0;  //_GUI 95,46, 95,36
 $Select.1 = PushLsb.0;  //_GUI 132,49
 $Select.2 = Junction:D.2;  
 Junction.0 = Junction:C.0;  
 Zero.0 = Lo_N.0;  
 Junction:A.0 = $SelectOut:A.1;  
 Junction:B.0 = Junction:E.1;  
 Junction:C.0 = BitA_Ge_BitB.0;  
 $Select:A.0 = ZeroNulls.0;  //_GUI 134,29, 134,37
 $Select:A.1 = Input:C.0;  
 $Select:A.2 = Junction:D.1;  //_GUI 139,35
 $SelectOut:A.0 = Junction:F.1;  
 $SelectOut:A.1 = Junction.2;  
 Junction:D.0 = Junction:C.1;  //_GUI 139,68
 NotZero.0 = Hi_N.1;  //_GUI 98,36, 98,39
 ZeroNulls.0 = NotZero.0;  
 ZeroNulls.1 = Input:B.0;  
 VouchBit.0 = $Select:A.0;  
 BitA_Ge_BitB.0 = Junction:E.2;  
 BitA_Ge_BitB.1 = Junction:F.2;  //_GUI 15,70
 Junction:E.0 = Input.0;  
 Junction:F.0 = Input:A.0;  
 PushLsb.0 = Junction:A.2;  //_GUI 113,52, 113,64, 70,64
 PushLsb.1 = Zero.0;  //_GUI 105,55
 Context.0 = Junction:B.0;  //_GUI 162,8, 35,8
 Context.1 = $Select.0;  //_GUI 158,40, 158,47
 Hi_N.0 = $SelectOut:A.0;  //_GUI 62,36, 62,52
 Hi_N.1 = $SelectOut.0;  
}

Object ( List OFL, List Out1) PadRight( Variant Type
    , List Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced",Documentation="Var/List"
{
 // Similar to UExtnd except adds or removes bits from the least significant end rather than from the most significant end of the number.  If Type is a Variant and Data is a List, PadRight is called on each element of the list with the specified Type.  If both Type and Data are lists, then PadRight is called on each respective input pair.
 //
 // Inputs:
 //
 // Var/List Type: The output dataset
 //
 // Var/List Data: The data to right pad
 //
 // Outputs:
 //
 // Bit/List OFL 1 if any non-zero bits were removed.  This output is asynchronous and may have difficulty meeting timing specifications with large reductions in dataset sizes and/or faster frequencies.
 //
 // Var/List output: The resulting output of dataset Type
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,17
 Object ( List Data) Input:A;  //_GUI 7,21
 Object Output( List OFL) ;  //_GUI 65,12
 Object Output:A( List Out1) ;  //_GUI 65,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 13,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,10
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,17
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 33,16
 //_ Attributes Documentation="var/List"
 Object ( Variant OFL, Variant Out1) PadRight:A( Variant Type
    , Variant Data) ;  //_GUI 33,31
 //_ Attributes Documentation="var/List"

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = PadRight:A.1;  //_GUI 49,24, 49,36
 ListOut.1 = PadRight.1;  
 ListOut:A.0 = PadRight:A.0;  //_GUI 46,15, 46,33
 ListOut:A.1 = PadRight.0;  //_GUI 43,12
 Junction.0 = Input.0;  
 PadRight.0 = Junction.1;  
 PadRight.1 = ListIn.1;  
 PadRight:A.0 = Junction.2;  //_GUI 29,33
 PadRight:A.1 = ListIn.0;  //_GUI 24,36
}

Object ( List OFL, List Out1) PadRight( List Type
    , List Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced",Documentation="List\\List"
{
 // Revision 1
 //_ Object Prototypes
 Object ( List Type) Input;  //_GUI 17,21
 Object ( List Data) Input:A;  //_GUI 17,30
 Object Output( List OFL) ;  //_GUI 75,15
 Object Output:A( List Out1) ;  //_GUI 75,24
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 23,28
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 62,22
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 62,13
 Object ( Variant OFL, Variant Out1) PadRight( Variant Type
    , Variant Data) ;  //_GUI 43,19
 //_ Attributes Documentation="var/List"
 Object ( Variant OFL, Variant Out1) PadRight:A( Variant Type
    , Variant Data) ;  //_GUI 43,34
 //_ Attributes Documentation="var/List"
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 23,19

 //_ Behavior Topology
 Output.0 = ListOut:A.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = PadRight:A.1;  //_GUI 59,27, 59,39
 ListOut.1 = PadRight.1;  
 ListOut:A.0 = PadRight:A.0;  //_GUI 56,18, 56,36
 ListOut:A.1 = PadRight.0;  //_GUI 53,15
 PadRight.0 = ListIn:A.1;  
 PadRight.1 = ListIn.1;  //_GUI 43,30
 PadRight:A.0 = ListIn:A.0;  //_GUI 39,36, 39,24
 PadRight:A.1 = ListIn.0;  //_GUI 34,39
 ListIn:A.0 = Input.0;  
}

Object ( Variant Max) $MaxFract( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller fixed-point fraction size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Variant Max) $MaxSWhole( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller fixed-point sign and whole size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Variant SBExp, Variant Mant) ExposeFloating( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object exposes the Sign and Biased Exponent portion along with the Mantissa (high bit implied) portion of a value from a Floating dataset.
 //
 // Inputs:
 //
 // Variant input: The Floating value to expose.
 //
 // Outputs:
 //
 // Variant SBExp: The sign bit (as MSB) along with the biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 11,20
 Object Output( Variant SBExp) ;  //_GUI 43,19
 Object Output:A( Variant Mant) ;  //_GUI 43,22
 Object ( List Out1) FloatingIn( Floating In) ;  //_GUI 17,18
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 30,18
 Object Text;  //_GUI 48,14,Sign and Biased exponent

 //_ Behavior Topology
 Output.0 = ListIn.1;  
 Output:A.0 = ListIn.0;  
 FloatingIn.0 = Input.0;  
 ListIn.0 = FloatingIn.0;  
}

Object ( Floating Out1) CollectFloating( Variant SBExp, Variant Mant) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\Advanced"
{
 // This object combines the Sign and Biased Exponent with the Mantissa (high bit implied) portions of a value into a Floating dataset.
 //
 // Inputs:
 //
 // Variant SBExp: The sign bit (as MSB) along with the biased exponent.
 //
 // Variant Mant: The mantissa (or significand) without the most significant bit.
 //
 // Outputs:
 //
 // Variant output: The resulting encoded Floating value.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant SBExp) Input;  //_GUI 24,20
 Object ( Variant Mant) Input:A;  //_GUI 24,23
 Object Output( Floating Out1) ;  //_GUI 71,21
 Object ( Floating Out) FloatingOut( List In1) ;  //_GUI 57,19
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 44,19
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 31,18
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 31,21

 //_ Behavior Topology
 Output.0 = FloatingOut.0;  
 FloatingOut.0 = ListOut.0;  
 ListOut.0 = MSB:A.0;  
 ListOut.1 = MSB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
}

Object ( Bit OFL, Floating Out2) FloatExtnd( Floating Type
    , Floating Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Changes the size of a floating-point number by either extending or shrinking the exponent and/or the mantissa.  This object is asynchronous and may have difficulty meeting timing specifications with large datasets and/or faster frequencies.
 //
 // Inputs:
 //
 // Floating Type: The destination dataset for the floating-point conversion.
 //
 // Floating Data: The floating-point value to be converted.
 //
 // Outputs:
 //
 // Bit OFL: Indicates that there was an overflow in the conversion (shrinking) of the exponent.
 //
 // Variant output: The floating-point value represented in the destination Floating dataset specified with the Type input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating Type) Input;  //_GUI 11,13
 Object ( Floating Data) Input:A;  //_GUI 10,28
 Object Output( Bit OFL) ;  //_GUI 343,47
 Object Output:A( Floating Out2) ;  //_GUI 353,62
 Object ( Floating Out1) CollectFloating( Variant Sign, Variant BExp
    , Variant Mant) ;  //_GUI 265,63
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating
    ( Floating In1) ;  //_GUI 51,11
 Object ( Bit Add1Exp, Variant Out2) ConvMant( Variant Type
    , Variant Data) ;  //_GUI 149,82
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 293,66
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 278,73
 Object Text;  //_GUI 144,99,Convert mantissa.If shrinking mantissa, round.If expanding, zero extend LSBs.
 Object Text;  //_GUI 268,80,Zero the Data when SetTo0, or EqualZero
 Object Text;  //_GUI 289,51,Pass OFL through when not zero
 Object Text;  //_GUI 292,74,Pass data through when not zeroing
 Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) ConvBExp
    ( Variant Type, Variant Data) ;  //_GUI 149,70
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 185,78
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 181,77
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 266,73
 Object Text;  //_GUI 198,57,OFL when SetToMaxPos or CO
 Object Text;  //_GUI 196,98,If the entire mantissa rounds up, then we add 1 to the BExp (which could carry over). It's not an overflow because we have the OFL triggering on a 255 exponent. This allows us to roll the exponent up to 255 for an even infinity.
 Object ( Floating Out) $Cast( Variant Data, Floating Type) ;  //_GUI 341,60
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 195,76
 Object ( Variant Out1) OR:A( Variant In1, Variant In2) ;  //_GUI 236,65
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 250,77
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 222,76
 Object ( Bit Sign, Variant BExp, Variant Exp
    , Variant Mant, Variant IMant, Bit Zero, Bit Denormalized
    , Bit Infinity, Bit QNaN, Bit SNaN, Bit NaN) ExposeFloating:A
    ( Floating In1) ;  //_GUI 108,53
 //_ Attributes Documentation="with NaN"
 Object ( Bit Out) OR:B( Bit In1, Bit In2) ;  //_GUI 193,67
 Object ( Bit Out) OR:C( Bit In1, Bit In2) ;  //_GUI 200,47
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 185,71
 Object ( Variant Out1) OR:D( Variant In1, Variant In2) ;  //_GUI 213,64
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 227,66
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 92,51
 Object ( Bit Sign, Variant BExp, Variant Mant) ExposeFloating:B
    ( Floating In1) ;  //_GUI 50,26
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 327,62
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 331,45
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 72,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 69,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 321,52
 Object ( Bit Out) OR:E( Bit In1, Bit In2) ;  //_GUI 109,27
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 77,26
 Object ( Bit Out1) BitA_Ne_BitB:A( Variant A, Variant B) ;  //_GUI 77,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 127,29
 Object ( Bit "#0") Input:B;  //_GUI 309,46
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:G
    ( Floating In0) ;  //_GUI 35,28
 Object Text;  //_GUI 24,55,turn this thing into a passthrough in the case where the datasets are equal
 Object ( Floating Out1, Floating Out2, Floating Out3) Junction:H
    ( Floating In0) ;  //_GUI 285,65

 //_ Behavior Topology
 Output.0 = $Select:A.0;  
 Output:A.0 = $Cast.0;  
 CollectFloating.0 = ExposeFloating:A.0;  //_GUI 260,65, 260,55
 CollectFloating.1 = OR:A.0;  
 CollectFloating.2 = AND:A.0;  //_GUI 260,71
 ExposeFloating.0 = Input.0;  
 ConvMant.0 = Junction:D.1;  //_GUI 146,84, 146,19
 ConvMant.1 = ExposeFloating:A.3;  //_GUI 138,87, 138,64
 AND.0 = Junction:H.2;  //_GUI 286,68
 AND.1 = INVERT.0;  //_GUI 290,71, 290,76
 INVERT.0 = OR.0;  
 ConvBExp.0 = Junction:C.1;  //_GUI 149,16
 ConvBExp.1 = ExposeFloating:A.1;  //_GUI 141,75, 141,58
 Zero.0 = Junction.2;  //_GUI 182,81
 Junction.0 = ConvBExp.2;  
 OR.0 = ConvBExp.1;  
 OR.1 = ExposeFloating:A.6;  //_GUI 266,96, 131,96, 131,73
 $Cast.0 = $Select.0;  
 $Cast.1 = Junction:H.0;  //_GUI 286,62
 ADSU.0 = Junction.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = ConvMant.0;  //_GUI 169,87, 169,84
 OR:A.0 = Junction:B.1;  
 OR:A.1 = ADSU.2;  //_GUI 236,84
 AND:A.0 = INVERT:A.0;  
 AND:A.1 = ConvMant.1;  //_GUI 250,92, 165,92, 165,87
 INVERT:A.0 = Junction:B.2;  //_GUI 222,72, 228,72
 ExposeFloating:A.0 = $SelectOut.1;  
 OR:B.0 = ExposeFloating:A.7;  //_GUI 135,69, 135,76
 OR:B.1 = Junction:A.1;  
 OR:C.0 = ExposeFloating:A.10;  //_GUI 128,49, 128,85
 OR:C.1 = Junction:A.0;  //_GUI 186,52
 Junction:A.0 = ConvBExp.0;  
 OR:D.0 = OR:B.0;  //_GUI 203,66
 OR:D.1 = ADSU.0;  
 Junction:B.0 = OR:D.0;  
 $SelectOut.0 = Junction:G.2;  //_GUI 36,53
 $SelectOut.1 = Junction:F.2;  //_GUI 78,56, 78,46, 128,46
 ExposeFloating:B.0 = Junction:G.1;  
 $Select.0 = $SelectOut.0;  //_GUI 327,24, 104,24
 $Select.1 = AND.0;  //_GUI 310,67, 310,69
 $Select.2 = Junction:E.2;  //_GUI 322,70
 $Select:A.0 = Input:B.0;  
 $Select:A.1 = OR:C.0;  
 $Select:A.2 = Junction:E.1;  
 Junction:C.0 = ExposeFloating.1;  
 Junction:D.0 = ExposeFloating.2;  
 Junction:E.0 = Junction:F.1;  //_GUI 322,30
 OR:E.0 = BitA_Ne_BitB.0;  
 OR:E.1 = BitA_Ne_BitB:A.0;  //_GUI 98,32, 98,39
 BitA_Ne_BitB.0 = Junction:C.2;  //_GUI 73,28
 BitA_Ne_BitB.1 = ExposeFloating:B.1;  
 BitA_Ne_BitB:A.0 = Junction:D.2;  //_GUI 70,38
 BitA_Ne_BitB:A.1 = ExposeFloating:B.2;  //_GUI 66,41
 Junction:F.0 = OR:E.0;  
 Junction:G.0 = Input:A.0;  
 Junction:H.0 = CollectFloating.0;  
}

Object ( Variant Max) $MaxMant( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller floating-point mantissa size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Variant Max) $MaxSBExp( Variant A, Variant B
    , Bit Warn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,20
 Object ( Variant B) Input:A;  //_GUI 23,23
 Object ( Bit Warn) Input:B;  //_GUI 23,36
 Object Output( Variant Max) ;  //_GUI 54,23
 Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) ;  //_GUI 36,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 32,20
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,23
 Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 36,28
 Object Output:A( Bit Warning) ;  //_GUI 66,31
 //_ Attributes Trap="Warning: Converting smaller floating-point sign and biased exponent size to larger size."
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 54,29

 //_ Behavior Topology
 Output.0 = OrderDatasets.1;  
 OrderDatasets.0 = Junction.1;  
 OrderDatasets.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 BitA_Ne_BitB.0 = Junction.2;  //_GUI 33,30
 BitA_Ne_BitB.1 = Junction:A.2;  //_GUI 30,33
 Output:A.0 = AND.0;  
 AND.0 = BitA_Ne_BitB.0;  
 AND.1 = Input:B.0;  //_GUI 53,34, 53,37
}

Object ( Bit Out1) $SymmInvalidDS( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 13,19
 Object Output( Bit Out1) ;  //_GUI 72,21
 Object ( Bit Out1) IsFloating( Variant In1) ;  //_GUI 24,17
 //_ Attributes Documentation="Floating"
 Object ( Bit Out1) IsList( Variant In1) ;  //_GUI 24,25
 //_ Attributes Documentation="list"
 Object ( Bit Out1) IsComplex( Variant In1) ;  //_GUI 24,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 19,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In1) ;  //_GUI 19,27
 Object Text;  //_GUI 17,48,The datasets Floating, List and Complex only support symmetrize with themselves, not with anything else.
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 43,18
 Object ( Bit Out) OR:A( Bit In1, Bit In2) ;  //_GUI 59,19

 //_ Behavior Topology
 Output.0 = OR:A.0;  
 IsFloating.0 = Junction.1;  
 IsList.0 = Junction:A.1;  
 IsComplex.0 = Junction:A.2;  //_GUI 20,36
 Junction.0 = Input.0;  
 Junction:A.0 = Junction.2;  
 OR.0 = IsFloating.0;  
 OR.1 = IsList.0;  //_GUI 38,23, 38,28
 OR:A.0 = OR.0;  
 OR:A.1 = IsComplex.0;  //_GUI 59,28, 42,28, 42,36
}

Object ( Bit Out1) SameDataSets( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Bit"
{
 // Returns 1 if the two input datasets have the same outermost dataset.
 //
 // Will return 1 even if the contents of both outermost datasets are different, as long as the outermost datasets themselves are the same.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be contextual dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Contextual, 0 otherwise.
 //
 // Examples:
 //
 // SameDataSets ( MSB003, MSB003 ) = 1
 // SameDataSets ( MSB003, LSB003 ) = 0
 // SameDataSets ( MSB003, MSB004 ) = 0
 // SameDataSets ( Fixed ( 5.3 ), Fixed ( 20.20 ) ) = 1
 // SameDataSets ( List ( MSB003, BIN008 ), List ( Bit, Bit ) ) = 1
 // SameDataSets ( Signed ( MSB003 ), Signed ( MSB004 ) ) = 1
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 43,22
 Object ( Bit In2) Input:A;  //_GUI 43,25
 Object Output( Bit Out1) ;  //_GUI 69,22
 Object ( Bit In) Input:B;  //_GUI 59,22
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) SameDataSets( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns 1 if the two input datasets have the same outermost dataset.
 //
 // Will return 1 even if the contents of both outermost datasets are different, as long as the outermost datasets themselves are the same.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be contextual dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Contextual, 0 otherwise.
 //
 // Examples:
 //
 // SameDataSets ( MSB003, MSB003 ) = 1
 // SameDataSets ( MSB003, LSB003 ) = 0
 // SameDataSets ( MSB003, MSB004 ) = 0
 // SameDataSets ( Fixed ( 5.3 ), Fixed ( 20.20 ) ) = 1
 // SameDataSets ( List ( MSB003, BIN008 ), List ( Bit, Bit ) ) = 1
 // SameDataSets ( Signed ( MSB003 ), Signed ( MSB004 ) ) = 1
 //
 // Date:
 // 26 Jan 2003
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 43,22
 Object ( Variant In2) Input:A;  //_GUI 43,25
 Object Output( Bit Out1) ;  //_GUI 91,31
 Object ( Bit In) Input:B;  //_GUI 60,31
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:DSNum), $(NodeInfo:1:DSNum), =)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Eq_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Eq_BitB.0 = MSB.0;  
 $BitA_Eq_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 == 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Eq_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Eq_BitB.0 = Input.0;  
 $BitA_Eq_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Eq_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"
 Object Text;  //_GUI 8,29,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Eq_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Eq_BitB.0 = MSB.0;  
 $BitA_Eq_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 28,44,(0 > 0)

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), >)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 28,44,( ( ! 0) > 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Gt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 55,33
 Object ( Bit In) Input:B;  //_GUI 49,33
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 28,44,( 0 > ( ! 0) )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $SymmInvalidDS( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 25,26
 Object ( Variant In2) Input:A;  //_GUI 25,29
 Object Output( Bit Out1) ;  //_GUI 62,27
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 50,25
 Object ( Bit Out1) $SymmInvalidDS( Variant In1) ;  //_GUI 31,24
 Object ( Bit Out1) $SymmInvalidDS:A( Variant In1) ;  //_GUI 31,27

 //_ Behavior Topology
 Output.0 = OR.0;  
 OR.0 = $SymmInvalidDS.0;  
 OR.1 = $SymmInvalidDS:A.0;  
 $SymmInvalidDS.0 = Input.0;  
 $SymmInvalidDS:A.0 = Input:A.0;  
}

Object ( Variant Out1) AND( Variant In1, Variant In2
    , Variant In3, Variant In4) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async\\AND"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 21,22
 Object ( Variant In2) Input:A;  //_GUI 21,25
 Object ( Variant In3) Input:B;  //_GUI 21,29
 Object ( Variant In4) Input:C;  //_GUI 21,32
 Object Output( Variant Out1) ;  //_GUI 64,26
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 27,21
 Object ( Variant Out1) AND:A( Variant In1, Variant In2) ;  //_GUI 48,24
 Object ( Variant Out1) AND:B( Variant In1, Variant In2) ;  //_GUI 27,28

 //_ Behavior Topology
 Output.0 = AND:A.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
 AND:A.0 = AND.0;  //_GUI 43,26, 43,24
 AND:A.1 = AND:B.0;  //_GUI 43,29, 43,31
 AND:B.0 = Input:B.0;  
 AND:B.1 = Input:C.0;  
}

Object ( Variant Hi, List Lo) $BisectList_Low( List List
    , Variant LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List List) Input;  //_GUI 20,32
 Object ( Variant LSB) Input:A;  //_GUI 20,39
 Object Output( Variant Hi) ;  //_GUI 105,31
 Object Output:A( List Lo) ;  //_GUI 105,37
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( List Out1) PackLSB( Variant In1, Variant In2) ;  //_GUI 88,35
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object ( Variant MSB, Variant Out2) ListPopMsb( Variant In1) ;  //_GUI 34,30
 //_ Attributes Documentation="list"
 Object ( Variant Hi, Variant Lo) $BisectList_High( Variant MSB
    , Variant List) ;  //_GUI 53,30
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = $BisectList_High.0;  
 Output:A.0 = PackLSB.0;  
 PackLSB.0 = $BisectList_High.1;  //_GUI 78,37, 78,35
 PackLSB.1 = Input:A.0;  
 ListPopMsb.0 = Input.0;  
 $BisectList_High.0 = ListPopMsb.0;  
 $BisectList_High.1 = ListPopMsb.1;  
}

Object ( Variant Hi, Variant Lo) $BisectList_Low( Variant List
    , Variant LSB) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant List) Input;  //_GUI 20,32
 Object ( Variant LSB) Input:A;  //_GUI 20,39
 Object Output( Variant Hi) ;  //_GUI 70,32
 Object Output:A( Variant Lo) ;  //_GUI 96,39
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant MSB, Variant Out1) $ListPopMsb( Variant In2
    , Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 15,12
 Object ( Variant In1) Input:A;  //_GUI 15,18
 Object Output( Variant MSB) ;  //_GUI 51,12
 Object Output:A( Variant Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant MSB, List Out1) $ListPopMsb( List In2
    , Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In2) Input;  //_GUI 15,31
 Object ( Variant In1) Input:A;  //_GUI 15,36
 Object Output( Variant MSB) ;  //_GUI 68,30
 Object Output:A( List Out1) ;  //_GUI 68,34
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,32
 Object ( Variant MSB, Variant Out1) $ListPopMsb( Variant In2
    , Variant In1) ;  //_GUI 37,29
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $ListPopMsb.0;  
 Output:A.0 = ListOut.0;  
 ListIn.0 = Input.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = $ListPopMsb.1;  
 $ListPopMsb.0 = ListIn.1;  
 $ListPopMsb.1 = ListIn.0;  
}

Object ( Variant MSB, NULL Out1) $ListPopMsb( Variant In2
    , NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 15,12
 Object ( NULL In1) Input:A;  //_GUI 15,18
 Object Output( Variant MSB) ;  //_GUI 51,12
 Object Output:A( NULL Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL MSB, NULL Out1) $ListPopMsb( NULL In2
    , NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 15,12
 Object ( NULL In1) Input:A;  //_GUI 15,18
 Object Output( NULL MSB) ;  //_GUI 51,12
 Object Output:A( NULL Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL MSB, Variant Out1) $ListPopMsb( NULL In2
    , Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In2) Input;  //_GUI 15,12
 Object ( Variant In1) Input:A;  //_GUI 15,18
 Object Output( NULL MSB) ;  //_GUI 51,12
 Object Output:A( Variant Out1) ;  //_GUI 51,18

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,30
 Object ( Variant In1) Input:A;  //_GUI 12,34
 Object Output( Variant Out1) ;  //_GUI 137,21
 Object Text;  //_GUI 41,2,Remove all MSBs that are the same, except one.
 Object Text;  //_GUI 89,49,If the two MSBs are the same, remove the MSB then recurse.
 Object ( Bit Out1) Equal( Variant In1, Variant In2) ;  //_GUI 47,29
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 26,32
 //_ Attributes Documentation="bit"
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant D
    , Bit S) ;  //_GUI 67,27
 Object ( Variant "#0", Variant "#1") $SelectOut:A( Variant D
    , Bit S) ;  //_GUI 67,18
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 62,31
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 18,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 21,34
 Object ( Variant "#0", Variant "#1") $SelectOut:B( Variant D
    , Bit S) ;  //_GUI 67,36
 Object ( Variant "#0", Variant "#1") $SelectOut:C( Variant D
    , Bit S) ;  //_GUI 67,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 42,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In1) ;  //_GUI 62,40
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 96,18
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 123,19
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In1) ;  //_GUI 62,50
 Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Variant In1) ;  //_GUI 92,39
 //_ Attributes Documentation="bit/var"
 Object Text;  //_GUI 88,7,If the two MSBs are different, put the MSB back on and we are done.

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Equal.0 = Junction:A.1;  
 Equal.1 = Junction:C.1;  
 ExposeMSB.0 = Junction:B.1;  
 $SelectOut.0 = Junction:B.0;  //_GUI 67,27, 22,27
 $SelectOut.1 = Junction.1;  
 $SelectOut:A.0 = Junction:A.0;  //_GUI 19,20
 $SelectOut:A.1 = Junction.0;  //_GUI 63,23
 Junction.0 = Equal.0;  
 Junction:A.0 = Input.0;  
 Junction:B.0 = Input:A.0;  
 $SelectOut:B.0 = Junction:C.2;  //_GUI 43,38
 $SelectOut:B.1 = Junction:D.1;  
 $SelectOut:C.0 = ExposeMSB.1;  //_GUI 39,48
 $SelectOut:C.1 = Junction:E.1;  
 Junction:C.0 = ExposeMSB.0;  
 Junction:D.0 = Junction.2;  
 CollectLSB.0 = $SelectOut:A.0;  
 CollectLSB.1 = $SelectOut.0;  //_GUI 87,23, 87,29
 $Select.0 = CollectLSB.0;  
 $Select.1 = $Min_Rep_Twos.0;  //_GUI 116,24, 116,42
 $Select.2 = Junction:E.2;  //_GUI 123,58, 63,58
 Junction:E.0 = Junction:D.2;  
 $Min_Rep_Twos.0 = $SelectOut:B.1;  
 $Min_Rep_Twos.1 = $SelectOut:C.1;  //_GUI 85,44, 85,51
}

Object ( Variant Out1) $Min_Rep_Twos( Bit In1, Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 12,30
 Object ( Bit In1) Input:A;  //_GUI 12,33
 Object Output( Variant Out1) ;  //_GUI 50,31
 Object ( Variant Out1) CollectLSB( Variant In2, Variant In3) ;  //_GUI 19,29
 Object Text;  //_GUI 31,43,Min_Rep_Twos(1)=01Min_Rep_Twos(0)=00Min_Rep_Twos(-1)=11Min_Rep_Twos(-2)=10

 //_ Behavior Topology
 Output.0 = CollectLSB.0;  
 CollectLSB.0 = Input.0;  
 CollectLSB.1 = Input:A.0;  
}

Object ( NULL Out1) $Min_Rep_Twos( Bit In1, NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,13
 Object ( NULL In1) Input:A;  //_GUI 10,16
 Object Output( NULL Out1) ;  //_GUI 29,16
 Object ( Bit In) Input:B;  //_GUI 17,21
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Output:A( Bit Trap) ;  //_GUI 25,21
 //_ Attributes Trap="A two's complement number can't be represented with a single bit."
 Object Text;  //_GUI 18,32,This overload will only get called in the unusual case where the call to Min_Rep_Twos had an input dataset of a contextual dataset that wrapped a single bit.

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input:B.0;  
}

Object ( Variant S) Add_CI( Variant A, Variant B
    , Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\Advanced\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 15,15
 Object ( Variant B) Input:A;  //_GUI 15,18
 Object ( Bit CI) Input:B;  //_GUI 15,24
 //_ Attributes Constant="0"
 Object Output( Variant S) ;  //_GUI 48,21
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 26,14

 //_ Behavior Topology
 Output.0 = ADSU.2;  
 ADSU.0 = Input.0;  
 ADSU.1 = Input:A.0;  
 ADSU.3 = Input:B.0;  
}

Object ( List MsbList) MsbList( List AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/list"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 97,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 34,31
 Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) ;  //_GUI 57,38
 Object ( List MsbList) MsbList( List AnyList) ;  //_GUI 27,40
 //_ Attributes Documentation="list"
 Object ( List MsbList) AppendMsbList:A( Variant AnyList, Variant MsbList) ;  //_GUI 79,31

 //_ Behavior Topology
 Output.0 = AppendMsbList:A.0;  
 ListIn.0 = Input.0;  
 AppendMsbList.0 = ListIn.0;  //_GUI 51,40, 51,36
 AppendMsbList.1 = MsbList.0;  
 MsbList.0 = Input:A.0;  
 AppendMsbList:A.0 = ListIn.1;  
 AppendMsbList:A.1 = AppendMsbList.0;  //_GUI 76,36, 76,41
}

Object ( List MsbList) MsbList( Variant AnyList_Hi, List AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( List AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 80,34
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 67,32
 Object ( List MsbList) MsbList( List AnyList) ;  //_GUI 26,40
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = MsbList.0;  //_GUI 54,37, 54,43
 ListOut.1 = Input.0;  
 MsbList.0 = Input:A.0;  
}

Object ( List MsbList) MsbList( List AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 103,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 32,31
 Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) ;  //_GUI 81,31
 Object ( List MsbList) AppendMsbList:A( Variant AnyList, Variant MsbList) ;  //_GUI 52,38

 //_ Behavior Topology
 Output.0 = AppendMsbList.0;  
 ListIn.0 = Input.0;  
 AppendMsbList.0 = ListIn.1;  
 AppendMsbList.1 = AppendMsbList:A.0;  //_GUI 76,36, 76,41
 AppendMsbList:A.0 = ListIn.0;  //_GUI 47,40, 47,36
 AppendMsbList:A.1 = Input:A.0;  
}

Object ( List MsbList) MsbList( Variant AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 54,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 33,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( NULL MsbList) MsbList( NULL AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( NULL MsbList) ;  //_GUI 34,33

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant MsbList) MsbList( Variant AnyList_Hi, NULL AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList_Hi) Input;  //_GUI 20,33
 Object ( NULL AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant MsbList) ;  //_GUI 81,33
 Object ( Variant MsbList) MsbList( Variant AnyList) ;  //_GUI 33,31

 //_ Behavior Topology
 Output.0 = MsbList.0;  
 MsbList.0 = Input.0;  
}

Object ( Variant MsbList) MsbList( NULL AnyList_Hi, Variant AnyList_Lo) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 // This object converts and combines the two list inputs of any shape to an MSB ordered list.
 //
 // Inputs:
 //
 // Variant AnyList_Hi: The list to reshape and put on the high (MSB) end of the output list.
 //
 // Variant AnyList_Lo: The list to reshape and put on the low (LSB) end of the output list.
 //
 // Outputs:
 //
 // Variant LsbList: The combined list in the same significance order but a different construction order (a different shape).
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL AnyList_Hi) Input;  //_GUI 20,33
 Object ( Variant AnyList_Lo) Input:A;  //_GUI 20,42
 Object Output( Variant MsbList) ;  //_GUI 74,42
 Object ( Variant MsbList) MsbList( Variant AnyList) ;  //_GUI 32,40

 //_ Behavior Topology
 Output.0 = MsbList.0;  
 MsbList.0 = Input:A.0;  
}

Object ( Bit OFL, Variant S) Sub( Variant A
    , Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async"
{
 // Same as Sub (2,1) except has an extra OFL output.
 //
 // Because this is an asynchronous object, larger datasets at higher frequencies or using it in combination with other asynchronous circuitry may cause it to have difficulty passing timing specifications.
 //
 // Inputs:
 //
 // Variant A: Value
 //
 // Variant B: Value
 //
 // Outputs:
 //
 // Variant OFL: Overflow is output as high if the operation overflowed.  The dataset is a List of bits if inputs were list, Bit otherwise.
 //
 // Variant S: The result of A minus B or a list of results
 //
 // Dataset Coverage:
 //
 // MSBxxx, LSBxxx and BINxxx (unsigned), Signed, Floating, Fixed, Complex and List. If one input is a list and the other is not, the other is duplicated into an equivalent list of the one.  A and B pairs must have the same dataset (with the exception of MSBxxx, LSBxxx and BINxxx) or undefined behavior will occur and if they don't have the same bit length, they are symmetrized and a warning is generated.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 5,17
 Object ( Variant B) Input:A;  //_GUI 5,20
 Object Output( Bit OFL) ;  //_GUI 77,17
 Object Output:A( Variant S) ;  //_GUI 77,20
 Object ( Bit CI) Input:B;  //_GUI 10,26
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 65,15
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 16,16
 Object ( Variant OFL, Variant S) $ResolveError( Variant CO
    , Variant OFL, Variant S) ;  //_GUI 48,16
 Object ( Bit SUB) Input:C;  //_GUI 10,23
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 36,15
 Object Text;  //_GUI 31,7,Change CO into an error for unsigned values

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = $ResolveError.1;  
 VouchBit.0 = $ResolveError.0;  
 ADSU.0 = Input.0;  
 ADSU.1 = Input:A.0;  
 ADSU.2 = Input:C.0;  
 ADSU.3 = Input:B.0;  
 $ResolveError.0 = INVERT.0;  
 $ResolveError.1 = ADSU.1;  
 $ResolveError.2 = ADSU.2;  
 INVERT.0 = ADSU.0;  
}

Object ( List OFL, List S) Sub( List A
    , Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/Variant"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 4,16
 Object ( Variant B) Input:A;  //_GUI 4,27
 Object Output( List OFL) ;  //_GUI 65,16
 Object Output:A( List S) ;  //_GUI 65,25
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 23,27
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 27,14
 //_ Attributes Documentation="List/List"
 Object ( Variant OFL, Variant S) Sub:A( Variant A
    , Variant B) ;  //_GUI 27,23
 //_ Attributes Documentation="List/List"
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 10,14
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,23

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListOut.0 = Sub:A.0;  //_GUI 48,19, 48,25
 ListOut.1 = Sub.0;  
 Junction.0 = Input:A.0;  
 Sub.0 = ListIn.1;  
 Sub.1 = Junction.0;  //_GUI 24,19
 Sub:A.0 = ListIn.0;  //_GUI 27,22, 21,22
 Sub:A.1 = Junction.1;  
 ListIn.0 = Input.0;  
 ListOut:A.0 = Sub:A.1;  
 ListOut:A.1 = Sub.1;  //_GUI 52,22, 44,22
}

Object ( List OFL, List S) Sub( Variant A
    , List B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="Variant/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 6,11
 Object ( List B) Input:A;  //_GUI 6,21
 Object Output( List OFL) ;  //_GUI 69,12
 Object Output:A( List S) ;  //_GUI 69,21
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 12,19
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 28,11
 Object ( Variant OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 31,10
 //_ Attributes Documentation="List/List"
 Object ( Variant OFL, Variant S) Sub:A( Variant A
    , Variant B) ;  //_GUI 31,19
 //_ Attributes Documentation="List/List"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,10
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 54,19

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 Junction.0 = Input.0;  
 Sub.0 = Junction.1;  
 Sub.1 = ListIn.1;  //_GUI 26,15, 26,21
 Sub:A.0 = Junction.2;  //_GUI 29,21
 Sub:A.1 = ListIn.0;  
 ListOut.0 = Sub:A.0;  //_GUI 51,15, 51,21
 ListOut.1 = Sub.0;  
 ListOut:A.0 = Sub:A.1;  
 ListOut:A.1 = Sub.1;  //_GUI 54,18, 48,18
}

Object ( List OFL, List S) Sub( List A
    , List B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal",Documentation="List/List"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List A) Input;  //_GUI 6,9
 Object ( List B) Input:A;  //_GUI 6,17
 Object Output( List OFL) ;  //_GUI 65,9
 Object Output:A( List S) ;  //_GUI 65,17
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 12,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 52,7
 Object ( Variant Out1, Variant Out2) ListIn:A( List In) ;  //_GUI 12,7
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 52,15
 Object ( Bit OFL, Variant S) Sub( Variant A
    , Variant B) ;  //_GUI 29,7
 Object ( Bit OFL, Variant S) Sub:A( Variant A
    , Variant B) ;  //_GUI 29,15

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = Sub:A.0;  //_GUI 49,12, 49,17
 ListOut.1 = Sub.0;  
 ListIn:A.0 = Input.0;  
 ListOut:A.0 = Sub:A.1;  
 ListOut:A.1 = Sub.1;  //_GUI 52,14, 46,14
 Sub.0 = ListIn:A.1;  
 Sub.1 = ListIn.1;  //_GUI 26,12, 26,17
 Sub:A.0 = ListIn:A.0;  //_GUI 29,15, 23,15
 Sub:A.1 = ListIn.0;  
}

Object ( Bit CO, Bit S) $$ADSU( Bit A
    , Bit B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 14,20
 Object ( Bit B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,26
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,29
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 50,20
 Object Output:A( Bit S) ;  //_GUI 50,23
 Object ( Variant CO, Variant S) $$ADSU_logic( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 21,19
 //_ Attributes Documentation="bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 38,18
 Object ( Bit Out1) VouchBit:A( Variant In1) ;  //_GUI 38,21

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = VouchBit:A.0;  
 $$ADSU_logic.0 = Input.0;  
 $$ADSU_logic.1 = Input:A.0;  
 $$ADSU_logic.2 = Input:B.0;  
 $$ADSU_logic.3 = Input:C.0;  
 VouchBit.0 = $$ADSU_logic.0;  
 VouchBit:A.0 = $$ADSU_logic.1;  
}

Object ( Bit CO, Variant S) $$ADSU( Variant A
    , Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,32
 Object ( Variant B) Input:A;  //_GUI 23,40
 Object ( Bit ADD) Input:B;  //_GUI 26,46
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 27,52
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 145,24
 Object Output:A( Variant S) ;  //_GUI 145,42
 Object ( Variant Out1) $Cast( Variant Data, Variant Type) ;  //_GUI 131,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 33,30
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 110,42
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 33,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 71,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,32
 Object ( Variant CO, Variant S) $$ADSU( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,42
 //_ Attributes Documentation="bit"
 Object ( Variant CO, Variant S) $$ADSU:A( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,23
 //_ Attributes Documentation="bit"
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 128,22

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = $Cast.0;  
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction:A.0;  //_GUI 125,42, 125,19, 30,19
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $$ADSU.1;  
 VariantOut.1 = $$ADSU:A.1;  //_GUI 110,28
 VariantIn:A.0 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 $$ADSU.0 = VariantIn.0;  //_GUI 79,44, 79,35
 $$ADSU.1 = VariantIn:A.0;  //_GUI 76,47, 76,43
 $$ADSU.2 = Junction.2;  //_GUI 72,50
 $$ADSU.3 = Input:C.0;  
 $$ADSU:A.0 = VariantIn.1;  //_GUI 66,25, 66,32
 $$ADSU:A.1 = VariantIn:A.1;  //_GUI 69,28, 69,40
 $$ADSU:A.2 = Junction.0;  //_GUI 72,31
 $$ADSU:A.3 = $$ADSU.0;  //_GUI 83,39, 93,39
 VouchBit.0 = $$ADSU:A.0;  
}

Object ( NULL CO, NULL S) $$ADSU( NULL A
    , NULL B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 14,17
 Object ( NULL B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( NULL CO) ;  //_GUI 124,17
 Object Output:A( NULL S) ;  //_GUI 124,23

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant Data) List_Mux_Sel( Variant ListData, NULL Sel) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 23,11
 Object ( NULL Sel) Input:A;  //_GUI 23,24
 Object Output( Variant Data) ;  //_GUI 82,11
 Object Text;  //_GUI 25,6,The leaf for a 1-dimention mux where the Sel was not a ZTList.
 Object Text;  //_GUI 18,33,We are not selecting, so pass the data through.

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Data) List_Mux_Sel( Variant ListData, Variant Sel) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Multiplexers\\Async"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant ListData) Input;  //_GUI 14,27
 Object ( Variant Sel) Input:A;  //_GUI 15,41
 Object Output( Variant Data) ;  //_GUI 150,36
 Object ( Variant Out1) "2^N_List"( Variant In1) ;  //_GUI 21,25
 Object Text;  //_GUI 18,14,Bring the number of elements up to a power of two.
 Object ( Variant Size) ListSize( Variant List) ;  //_GUI 54,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 51,27
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 66,32
 Object ( Variant OFL, Variant Out2) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 85,33
 //_ Attributes Documentation="ztlist"
 Object ( Variant Out1) INVERT( Variant In1) ;  //_GUI 123,48
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 133,34
 //_ Attributes Documentation="ztlist/zlist"
 Object ( Variant Data) $List_Mux_Sel( Variant ListData, Variant Sel) ;  //_GUI 115,33
 //_ Attributes Documentation="var/var"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 102,35
 Object ( Variant Out1) 2MinList( Variant In1) ;  //_GUI 39,25
 //_ Attributes Documentation="var"
 Object Text;  //_GUI 38,17,Make at least two elements

 //_ Behavior Topology
 Output.0 = AND.0;  
 "2^N_List".0 = Input.0;  
 ListSize.0 = Junction.2;  //_GUI 52,35
 Junction.0 = 2MinList.0;  
 MaskToNum.0 = ListSize.0;  
 UExtnd.0 = MaskToNum.0;  
 UExtnd.1 = Input:A.0;  //_GUI 85,42
 INVERT.0 = UExtnd.0;  //_GUI 99,51, 99,35
 AND.0 = $List_Mux_Sel.0;  
 AND.1 = INVERT.0;  
 $List_Mux_Sel.0 = Junction.1;  //_GUI 115,28
 $List_Mux_Sel.1 = MSB.0;  
 MSB.0 = UExtnd.1;  
 2MinList.0 = "2^N_List".0;  
}

Object ( Variant Out1, Variant ZeroTheResult) ShiftByFilter( Variant Data
    , Variant ShiftBy) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal"
{
 // Object Name:
 // ShiftByFilter
 //
 // Description:
 // This object shaves down the ShiftBy data set so that it is only large enough to encode the bitlength of the data set to be shifted.  The ShiftByFilter output will roll over if the shift by value exceeds the number of bits of the minimum bit representation needed for the maximum shift by value.  In this case, the ZeroTheResult output will go high and the result of the next stage should be ignored and be replaced with zero (an AND gate).
 //
 // Date:
 // made so won't roll-over
 // 02/04/04
 // added ZeroTheResult instead, faster
 // 07/27/04
 // Removed use of BitLength32, added BitA_Lt_BitB
 // 11/16/04
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 9,35
 Object ( Variant ShiftBy) Input:A;  //_GUI 11,45
 Object Output( Variant Out1) ;  //_GUI 121,17
 Object Output:A( Variant ZeroTheResult) ;  //_GUI 125,40
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 41,44
 Object Text;  //_GUI 17,6,Get the min rep for the bit length
 Object Text;  //_GUI 42,33,Strip off any high bits
 Object Text;  //_GUI 57,52,IsNull is true if there are no extra bits.
 Object Text;  //_GUI 64,12,If there are extra bits, if any of them are high, we know our shift amount will exceed the bit length of our data and the result is guaranteed to be zero.  Note that we used to have a MUX in here instead of the ZeroTheResult output, which was slower.
 Object Text;  //_GUI 116,50,If there are no extra bits we don't want to zero the result.  Note: Don't use an AND gate instead of $Select becasue no NULL overload available.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 35,48
 Object Text;  //_GUI 77,68,Lo_N will pad if Lo_N input is larger than Data.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 20,45
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 65,62
 Object Text;  //_GUI 40,84,In the case where bitlen(Data) is larger than the shift dataset, we don't wan the Lo_N to pad it.
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 20,66
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 48,69
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 22,33
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 90,38
 Object ( Bit "#1") Input:B;  //_GUI 84,42
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 68,43
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 55,45

 //_ Behavior Topology
 Output.0 = $Select.0;  //_GUI 111,18, 111,65
 Output:A.0 = $Select:A.0;  
 Lo_N.0 = Junction:A.1;  
 Lo_N.1 = Junction.1;  
 Junction.0 = MaskToNum.0;  
 Junction:A.0 = Input:A.0;  
 $Select.0 = Lo_N.1;  //_GUI 51,64
 $Select.1 = Junction:B.1;  
 $Select.2 = BitA_Gt_BitB.0;  //_GUI 65,72
 Junction:B.0 = Junction:A.2;  
 BitA_Gt_BitB.0 = Junction.2;  //_GUI 36,71
 BitA_Gt_BitB.1 = Junction:B.2;  //_GUI 21,74
 MaskToNum.0 = Input.0;  
 $Select:A.0 = Junction:C.0;  //_GUI 56,40
 $Select:A.1 = Input:B.0;  
 $Select:A.2 = IsNULL.0;  
 IsNULL.0 = Junction:C.1;  
 Junction:C.0 = Lo_N.0;  
}

Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Bit IsTwos) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal"
{
 // This object produces an LSB list of all the possible shifts of the data. The Lower part is the carry-off (or falloff) of the data. All the output data elements will be LSB. So for example, the first element of Upper will be the unshifted data, the second element will be the data shifted to the right one bit, etc.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 26,11
 Object ( Bit IsTwos) Input:A;  //_GUI 28,29
 //_ Attributes Constant="0"
 Object Output( Variant RightUpper) ;  //_GUI 152,23
 Object Output:A( Variant RightLower) ;  //_GUI 143,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 86,11
 Object ( Bit LSB) Input:B;  //_GUI 72,26
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 116,19
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 112,31
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 86,33
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 81,11
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 35,9
 Object ( Variant MSB, Variant Out2) ListPopMsb( Variant In1) ;  //_GUI 133,19
 //_ Attributes Documentation="list"
 Object ( Variant MSB, Variant Out2) ListPopMsb:A( Variant In1) ;  //_GUI 128,31
 //_ Attributes Documentation="list"
 Object Text;  //_GUI 124,12,We don't really need the values from the leaf node
 Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Variant Size, Bit IsTwos) ;  //_GUI 87,22

 //_ Behavior Topology
 Output.0 = ListPopMsb.1;  
 Output:A.0 = ListPopMsb:A.1;  
 Junction.0 = Junction:A.1;  
 ListOut.0 = Junction.1;  //_GUI 111,24, 111,12
 ListOut.1 = PossibleRightShifts.0;  //_GUI 106,21
 ListOut:A.0 = Zero.0;  
 ListOut:A.1 = PossibleRightShifts.1;  //_GUI 106,33
 Zero.0 = Junction:A.2;  //_GUI 82,36
 Junction:A.0 = LSB.0;  
 LSB.0 = Input.0;  
 ListPopMsb.0 = ListOut.0;  
 ListPopMsb:A.0 = ListOut:A.0;  
 PossibleRightShifts.0 = Junction.2;  
 PossibleRightShifts.1 = Input:B.0;  
 PossibleRightShifts.2 = Input:A.0;  
}

Object ( Variant Out1) "2^N_Bits"( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // Description:
 // This object produces a data set whose bitlength is 2^N bits, where N is the bitlength of the incoming data set.  The numeric value carried by the data set will be 0.
 //
 // Inputs:
 // In1:
 //
 // Outputs:
 // Out1:
 //
 // Date:
 // 1/7/05
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,37
 Object Output( Variant Out1) ;  //_GUI 89,37
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 74,35
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 36,35
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 66,39
 Object ( Variant Out1) "2^N_Bits"( Variant In1) ;  //_GUI 54,37

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Junction.0;  //_GUI 67,37
 CollectMSB.1 = Junction.1;  
 ExposeMSB.0 = Input.0;  
 Junction.0 = "2^N_Bits".0;  
 "2^N_Bits".0 = ExposeMSB.1;  
}

Object ( Variant Out1) "2^N_Bits"( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // Description:
 // This object produces a data set whose bitlength is 2^N bits, where N is the bitlength of the incoming data set.  The numeric value carried by the data set will be 0.
 //
 // Inputs:
 // In1:
 //
 // Outputs:
 // Out1:
 //
 // Date:
 // 1/7/05
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 28,37
 Object Output( Variant Out1) ;  //_GUI 75,38
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 60,36
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 34,35
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,37

 //_ Behavior Topology
 Output.0 = CollectMSB.0;  
 CollectMSB.0 = Junction.1;  
 CollectMSB.1 = Junction.2;  //_GUI 54,41
 Zero.0 = Input.0;  
 Junction.0 = Zero.0;  
}

Object ( Bit Out1) "2^N_Bits"( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // Description:
 // This object produces a data set whose bitlength is 2^N bits, where N is the bitlength of the incoming data set.  The numeric value carried by the data set will be 0.
 //
 // Inputs:
 // In1:
 //
 // Outputs:
 // Out1:
 //
 // Date:
 // 8/7/05
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 12,15
 Object Output( Bit Out1) ;  //_GUI 34,15
 Object ( Bit In) Input:A;  //_GUI 28,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Variant Val) Encoder( Variant Mask) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Encoders/Decoders\\Async"
{
 // A basic encoder.  A set of bits is passed in with one bit, the Xth bit (from LSB), asserted.  This set of bits is encoded into the output, which has the value of X.  If the Mask has anything other than one bit asserted, the output Val is undefined.
 //
 // Inputs:
 //
 // Variant Mask: The bits to be encoded (Only one asserted at a time)
 //
 // Outputs:
 //
 // Variant Val: The resulting encoded value
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Mask) Input;  //_GUI 31,28
 Object Output( Variant Val) ;  //_GUI 53,28
 Object ( Variant Num) MaskToNum( Variant Mask) ;  //_GUI 37,26

 //_ Behavior Topology
 Output.0 = MaskToNum.0;  
 MaskToNum.0 = Input.0;  
}

Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, Variant ShBy) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 37,32
 Object ( Variant ShBy) Input:A;  //_GUI 37,39
 Object Output( Variant Val) ;  //_GUI 156,31
 Object Output:A( Variant ShiftMask) ;  //_GUI 156,41
 Object Output:B( Variant ShiftNum) ;  //_GUI 156,57
 Object Output:C( Bit Zero) ;  //_GUI 156,78
 Object ( Variant Out1, Variant Out1) ExposeBIN( Variant In1) ;  //_GUI 48,45
 //_ Attributes Documentation="Bit"
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 141,55
 Object ( Variant C, Variant Out2) SHL( Variant In1
    , Variant C) ;  //_GUI 49,35
 //_ Attributes Documentation="Bit_Carry"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 43,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 44,39
 Object Text;  //_GUI 47,56,If ExposeBIN's input is bit, the top output is NULL
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 80,36
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 129,54
 Object ( Variant O) Mux( Variant A, Variant B
    , Bit S) ;  //_GUI 86,29
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 66,34
 Object ( Variant O) Mux:A( Variant A, Variant B
    , Bit S) ;  //_GUI 143,39
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 120,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In1) ;  //_GUI 44,47
 Object ( Variant Out1) CollectBIN( Variant In1, Variant In2) ;  //_GUI 128,33
 Object ( Variant Out1) CollectBIN:A( Variant In1, Variant In2) ;  //_GUI 128,41
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 130,75
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 143,76
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In3) ;  //_GUI 123,42
 Object Text;  //_GUI 29,22,Initially ShBy is half the size of Val
 Object Text;  //_GUI 61,17,If any of the most significant ShBy number of bits are high, we pass through the unshifted data.
 Object Text;  //_GUI 99,19,Reduce ShBy by half and recurse.
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In0) ;  //_GUI 126,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In1) ;  //_GUI 126,56
 Object Text;  //_GUI 124,17,If any of the most significant ShBy number of bits are high, we pass through the unshifted ShiftMask.
 Object Text;  //_GUI 139,64,Add a most significant bit to ShiftNum
 Object ( Variant Val, Variant ShiftMask, Variant ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, Variant ShBy) ;  //_GUI 99,30

 //_ Behavior Topology
 Output.0 = $LeftJustify.0;  
 Output:A.0 = Mux:A.0;  
 Output:B.0 = CollectMSB.0;  
 Output:C.0 = AND.0;  
 ExposeBIN.0 = Junction:D.1;  
 CollectMSB.0 = INVERT.0;  
 CollectMSB.1 = $LeftJustify.2;  //_GUI 118,60, 118,38
 SHL.0 = Junction.2;  //_GUI 44,37
 SHL.1 = Junction:A.1;  
 Junction.0 = Input.0;  
 Junction:A.0 = Input:A.0;  
 Junction:B.0 = OR-NInput.0;  
 INVERT.0 = Junction:G.1;  
 Mux.0 = SHL.1;  //_GUI 62,31, 62,40
 Mux.1 = Junction.1;  //_GUI 83,34, 83,33
 Mux.2 = Junction:B.1;  
 OR-NInput.0 = SHL.0;  
 Mux:A.0 = CollectBIN.0;  //_GUI 141,41, 141,36
 Mux:A.1 = CollectBIN:A.0;  
 Mux:A.2 = Junction:F.1;  //_GUI 143,50
 Junction:C.0 = $LeftJustify.1;  
 Junction:D.0 = Junction:A.2;  
 CollectBIN.0 = Junction:C.1;  
 CollectBIN.1 = Junction:E.1;  //_GUI 124,38
 CollectBIN:A.0 = Junction:E.2;  
 CollectBIN:A.1 = Junction:C.2;  //_GUI 121,46
 INVERT:A.0 = Junction:G.2;  //_GUI 127,78
 AND.0 = INVERT:A.0;  
 AND.1 = $LeftJustify.3;  //_GUI 115,81, 115,41
 Junction:E.0 = Junction:D.2;  //_GUI 124,54, 45,54
 Junction:F.0 = Junction:B.2;  //_GUI 81,50
 Junction:G.0 = Junction:F.2;  
 $LeftJustify.0 = Mux.0;  
 $LeftJustify.1 = ExposeBIN.0;  //_GUI 99,47
}

Object ( Variant Val, Variant ShiftMask, NULL ShiftNum
    , Bit Zero) $LeftJustify( Variant Val, NULL ShiftIn) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Val) Input;  //_GUI 28,17
 Object ( NULL ShiftIn) Input:A;  //_GUI 28,32
 Object Output( Variant Val) ;  //_GUI 72,17
 Object Output:A( Variant ShiftMask) ;  //_GUI 72,22
 Object Output:B( NULL ShiftNum) ;  //_GUI 72,32
 Object Output:C( Bit Zero) ;  //_GUI 72,39
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 37,21
 //_ Attributes Documentation="bit"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 34,17
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 60,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 55,22

 //_ Behavior Topology
 Output.0 = Junction.1;  
 Output:A.0 = Junction:A.1;  
 Output:B.0 = Input:A.0;  
 Output:C.0 = INVERT.0;  
 ExposeMSB.0 = Junction.2;  //_GUI 35,24
 Junction.0 = Input.0;  
 INVERT.0 = Junction:A.2;  //_GUI 56,40
 Junction:A.0 = ExposeMSB.0;  
}

Object ( Variant Out1, Variant LSB) $ListPopLsb( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,18
 Object ( Variant In2) Input:A;  //_GUI 15,31
 Object Output( Variant Out1) ;  //_GUI 51,18
 Object Output:A( Variant LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List Out1, Variant LSB) $ListPopLsb( Variant In1
    , List In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,24
 Object ( List In2) Input:A;  //_GUI 15,31
 Object Output( List Out1) ;  //_GUI 68,25
 Object Output:A( Variant LSB) ;  //_GUI 68,33
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 21,29
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 54,23
 Object ( Variant Out1, Variant LSB) $ListPopLsb( Variant In1
    , Variant In2) ;  //_GUI 37,29
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = $ListPopLsb.1;  
 ListIn.0 = Input:A.0;  
 ListOut.0 = $ListPopLsb.0;  //_GUI 51,28, 51,31
 ListOut.1 = Input.0;  
 $ListPopLsb.0 = ListIn.1;  
 $ListPopLsb.1 = ListIn.0;  
}

Object ( NULL Out1, Variant LSB) $ListPopLsb( NULL In1
    , Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,18
 Object ( Variant In2) Input:A;  //_GUI 15,31
 Object Output( NULL Out1) ;  //_GUI 51,18
 Object Output:A( Variant LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL Out1, NULL LSB) $ListPopLsb( NULL In1
    , NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 15,18
 Object ( NULL In2) Input:A;  //_GUI 15,31
 Object Output( NULL Out1) ;  //_GUI 51,18
 Object Output:A( NULL LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Variant Out1, NULL LSB) $ListPopLsb( Variant In1
    , NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 15,18
 Object ( NULL In2) Input:A;  //_GUI 15,31
 Object Output( Variant Out1) ;  //_GUI 51,18
 Object Output:A( NULL LSB) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Gt_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Gt_BitB.0 = MSB.0;  
 $BitA_Gt_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Gt_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Gt_BitB.0 = Input.0;  
 $BitA_Gt_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 17,12
 Object ( Bit Out1) $BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object Text;  //_GUI 9,27,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.

 //_ Behavior Topology
 Output.0 = $BitA_Gt_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Gt_BitB.0 = MSB.0;  
 $BitA_Gt_BitB.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Gt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is greater than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 14,27,( 0 > 0 )

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant Min, Variant Max) OrderDatasets( Variant In1
    , Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,13
 Object ( Variant In2) Input:A;  //_GUI 11,16
 Object Output( Variant Min) ;  //_GUI 68,14
 Object Output:A( Variant Max) ;  //_GUI 68,25
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 48,30
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 44,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 40,13
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,12
 Object ( Variant Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 56,23
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 26,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 17,16
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 20,13

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Junction.0 = BitA_Gt_BitB.0;  
 Junction:A.0 = Junction:C.1;  
 Junction:B.0 = Junction:D.1;  
 $Select.0 = Junction:B.1;  
 $Select.1 = Junction:A.1;  
 $Select.2 = Junction.0;  //_GUI 49,20
 $Select:A.0 = Junction:A.2;  //_GUI 45,25
 $Select:A.1 = Junction:B.2;  //_GUI 41,28
 $Select:A.2 = Junction.1;  
 BitA_Gt_BitB.0 = Junction:D.2;  //_GUI 21,30
 BitA_Gt_BitB.1 = Junction:C.2;  //_GUI 18,33
 Junction:C.0 = Input:A.0;  
 Junction:D.0 = Input.0;  
}

Object ( NULL Min, Variant Max) OrderDatasets( NULL In1
    , Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/Var"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 11,13
 Object ( Variant In2) Input:A;  //_GUI 11,16
 Object Output( NULL Min) ;  //_GUI 68,13
 Object Output:A( Variant Max) ;  //_GUI 68,16

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL Min, NULL Max) OrderDatasets( NULL In1
    , NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="NULL/NULL"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 11,13
 Object ( NULL In2) Input:A;  //_GUI 11,16
 Object Output( NULL Min) ;  //_GUI 68,13
 Object Output:A( NULL Max) ;  //_GUI 68,16

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( NULL Min, Variant Max) OrderDatasets( Variant In1
    , NULL In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Var/NULL"
{
 // Orders the two datasets with respect to dataset length.  It does this by comparing the bit lengths of the two inputs and rearranges the datasets if necessary to output the smaller dataset on top (Min).
 //
 // Inputs:
 //
 // Variant input: One of the two datasets to order.
 //
 // Variant input: One of the two datasets to order.
 //
 // Outputs:
 //
 // Variant Min: The smaller of the two input datasets.
 //
 // Variant Max: The larger of the two input datasets.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 11,13
 Object ( NULL In2) Input:A;  //_GUI 11,16
 Object Output( NULL Min) ;  //_GUI 68,16
 Object Output:A( Variant Max) ;  //_GUI 68,19

 //_ Behavior Topology
 Output.0 = Input:A.0;  
 Output:A.0 = Input.0;  //_GUI 24,20, 24,14
}

Object ( Bit Out1) BitA_Ne_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Ne_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Ne_BitB.0 = MSB.0;  
 $BitA_Ne_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Ne_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,! (0 == 0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Ne_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Ne_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Ne_BitB.0 = Input.0;  
 $BitA_Ne_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Ne_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="Var/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 8,24,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12

 //_ Behavior Topology
 Output.0 = $BitA_Ne_BitB.0;  
 $BitA_Ne_BitB.0 = MSB.0;  
 $BitA_Ne_BitB.1 = Input:A.0;  
 MSB.0 = Input.0;  
}

Object ( Bit Add1Exp, Variant Out2) ConvMant( Variant Type
    , Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Changes the size of a floating-point mantissa.  If expanding, adds zeros to the LSB end.  If shrinking, rounds.  Rounding can roll over the mantissa in which case Add1Exp goes high.
 //
 // Inputs:
 //
 // Variant Type: The destination dataset for the mantissa conversion.  This dataset size is without the implied high bit.
 //
 // Variant Data: The floating-point mantissa to be converted.  This dataset does not hold the implied high bit.
 //
 // Outputs:
 //
 // Bit Add1Exp: Indicates that mantissa rolled over from a round after shrinking.
 //
 // Variant output: The mantissa represented in the new dataset.  Implied bit not represented.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 30,55
 Object ( Variant Data) Input:A;  //_GUI 30,59
 Object Output( Bit Add1Exp) ;  //_GUI 155,56
 Object Output:A( Variant Out2) ;  //_GUI 157,67
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 73,55
 Object ( Variant Hi, Variant Lo) Hi_N( Variant Data
    , Variant Hi_N) ;  //_GUI 41,58
 Object Text;  //_GUI 75,26,Rounding can roll over mantissa (without explicit bit) [1.]11111111[1111]+[0.]00000001---------------------[10.]00000000 == [1.]00000000 * 2^1Courier New,10,0,0
 Object Text;  //_GUI 42,85,Grab bit for rounding
 Object Text;  //_GUI 32,37,If Type has more bits than Data, Hi_N will zero extend the LSBs of the Hi output to match the size of Type and the Lo output becomes NULL.
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 57,53
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 58,67
 Object ( Variant Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 84,67
 Object ( Bit "#1") Input:B;  //_GUI 78,71
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1) IsNULL( Variant In1) ;  //_GUI 74,87
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 73,68
 Object ( Bit CO, Bit OFL, Variant S) ADSU
    ( Variant A, Variant B, Bit ADD, Bit CI) ;  //_GUI 100,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 83,81
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 139,54
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 74,56
 //_ Attributes Documentation="Bit"
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 139,65
 Object ( Bit "#1") Input:C;  //_GUI 133,58
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 135,72

 //_ Behavior Topology
 Output.0 = $Select:A.0;  
 Output:A.0 = $Select:B.0;  
 Junction.0 = MSB.0;  
 Hi_N.0 = Input:A.0;  
 Hi_N.1 = Input.0;  //_GUI 39,63, 39,56
 MSB.0 = Hi_N.0;  //_GUI 54,56, 54,60
 PopMsb.0 = Hi_N.1;  //_GUI 54,70, 54,63
 $Select.0 = Junction:A.1;  
 $Select.1 = Input:B.0;  
 $Select.2 = Junction:B.1;  
 IsNULL.0 = Junction:A.2;  
 Junction:A.0 = PopMsb.0;  
 ADSU.0 = Junction.1;  
 ADSU.1 = Zero.0;  
 ADSU.3 = $Select.0;  //_GUI 97,65, 97,70
 Junction:B.0 = IsNULL.0;  
 $Select:A.0 = ADSU.0;  
 $Select:A.1 = Input:C.0;  
 $Select:A.2 = Junction:C.1;  //_GUI 136,62
 Zero.0 = Junction.2;  
 $Select:B.0 = ADSU.2;  //_GUI 118,67
 $Select:B.1 = Junction.0;  //_GUI 126,70, 126,52, 74,52
 $Select:B.2 = Junction:C.2;  
 Junction:C.0 = Junction:B.2;  //_GUI 136,82
}

Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) ConvBExp
    ( Variant Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\Async\\Advanced\\Floating"
{
 // Changes the size of a biased Exponent.  If shrinking, the exponent can overflow (SetToMaxPos) or underflow (SetTo0).
 //
 // Inputs:
 //
 // Variant Type: The destination dataset for the biased exponent conversion.
 //
 // Variant Data: The floating-point biased exponent to be converted.
 //
 // Outputs:
 //
 // Bit SetToMaxPos: Indicates that the incoming exponent value was too large to be represented in the destination dataset.
 //
 // Bit SetTo0: Indicates that the incoming exponent value was too small to be represented in the destination dataset, so just represent the floating-point number as a zero.
 //
 // Variant output: The converted biased exponent.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 7,39
 Object ( Variant Data) Input:A;  //_GUI 7,48
 Object Output( Bit SetToMaxPos) ;  //_GUI 168,5
 Object Output:A( Bit SetTo0) ;  //_GUI 168,17
 Object Output:B( Variant Out3) ;  //_GUI 168,29
 Object ( Variant "#0", Variant "#1") Deselect( Variant In1
    , Bit S) ;  //_GUI 40,47
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 13,48
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 16,39
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 36,51
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 36,56
 Object ( Bit Out1) BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 20,31
 Object ( Variant "#0", Variant "#1") Deselect:A( Variant In1
    , Bit S) ;  //_GUI 65,15
 Object ( Variant "#0", Variant "#1") Deselect:B( Variant In1
    , Bit S) ;  //_GUI 65,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 61,33
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 61,27
 Object ( Variant "#0", Variant "#1") Deselect:C( Variant In1
    , Bit S) ;  //_GUI 40,38
 Object ( Variant Out1) $ConvBExpGrow( Variant Type, Variant Data) ;  //_GUI 86,41
 Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) $ConvBExpShrink
    ( Variant Type, Variant Data) ;  //_GUI 85,23
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 118,21
 Object ( Bit In) Input:B;  //_GUI 114,3
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In0) ;  //_GUI 120,3
 Object ( Bit In) Input:C;  //_GUI 134,7
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:H
    ( Bit In0) ;  //_GUI 140,7
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:I
    ( Bit In3) ;  //_GUI 138,34
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:J
    ( Bit In3) ;  //_GUI 138,22
 Object Text;  //_GUI 39,59,Type > Data
 Object Text;  //_GUI 122,38,Type < Data
 Object Text;  //_GUI 142,39,Type > Data
 Object Text;  //_GUI 64,36,Type < Data
 Object Text;  //_GUI 79,13,Type = Data (pass through)
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:K
    ( Bit In0) ;  //_GUI 118,33
 Object ( Bit Out1) BitA_Gt_BitB( Variant A, Variant B) ;  //_GUI 20,54
 Object ( Bit Out) $Select( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,3
 Object ( Bit Out) $Select:A( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 144,15
 Object ( Variant Out) $Select:B( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 143,27
 Object ( Variant Out) $Select:C( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 124,26
 Object ( Bit Out) $Select:D( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 124,14
 Object ( Bit Out) $Select:E( Variant "#0", Variant "#1"
    , Bit S) ;  //_GUI 124,2

 //_ Behavior Topology
 Output.0 = $Select.0;  
 Output:A.0 = $Select:A.0;  
 Output:B.0 = $Select:B.0;  
 Deselect.0 = Junction.1;  
 Deselect.1 = Junction:B.2;  
 Junction.0 = Input:A.0;  
 Junction:A.0 = Input.0;  
 Junction:B.0 = Junction:C.0;  
 Junction:C.0 = BitA_Gt_BitB.0;  
 BitA_Lt_BitB.0 = Junction:A.0;  //_GUI 17,33
 BitA_Lt_BitB.1 = Junction.0;  //_GUI 14,36
 Deselect:A.0 = Deselect:C.0;  //_GUI 53,17, 53,40
 Deselect:A.1 = Junction:E.1;  //_GUI 62,20
 Deselect:B.0 = Deselect.0;  //_GUI 57,25, 57,49
 Deselect:B.1 = Junction:E.2;  
 Junction:D.0 = BitA_Lt_BitB.0;  
 Junction:E.0 = Junction:D.0;  
 Deselect:C.0 = Junction:A.1;  
 Deselect:C.1 = Junction:B.1;  //_GUI 37,43
 $ConvBExpGrow.0 = Deselect:C.1;  
 $ConvBExpGrow.1 = Deselect.1;  //_GUI 61,46, 61,52
 $ConvBExpShrink.0 = Deselect:A.1;  //_GUI 83,25, 83,20
 $ConvBExpShrink.1 = Deselect:B.1;  
 Junction:F.0 = Junction:K.0;  
 Junction:G.0 = Input:B.0;  
 Junction:H.0 = Input:C.0;  
 Junction:I.0 = Junction:C.1;  //_GUI 139,57
 Junction:J.0 = Junction:I.1;  
 Junction:K.0 = Junction:D.1;  
 BitA_Gt_BitB.0 = Junction:A.2;  //_GUI 17,56
 BitA_Gt_BitB.1 = Junction.2;  //_GUI 14,59
 $Select.0 = $Select:E.0;  
 $Select.1 = Junction:H.1;  
 $Select.2 = Junction:J.1;  //_GUI 139,11
 $Select:A.0 = $Select:D.0;  
 $Select:A.1 = Junction:H.2;  //_GUI 141,20
 $Select:A.2 = Junction:J.2;  
 $Select:B.0 = $Select:C.0;  
 $Select:B.1 = $ConvBExpGrow.0;  //_GUI 136,32, 136,44
 $Select:B.2 = Junction:I.2;  
 $Select:C.0 = Deselect:B.0;  //_GUI 116,28, 116,17, 79,17, 79,25
 $Select:C.1 = $ConvBExpShrink.2;  
 $Select:C.2 = Junction:K.1;  
 $Select:D.0 = Junction:G.2;  //_GUI 121,16
 $Select:D.1 = $ConvBExpShrink.1;  //_GUI 113,19, 113,28
 $Select:D.2 = Junction:F.2;  
 $Select:E.0 = Junction:G.1;  
 $Select:E.1 = $ConvBExpShrink.0;  //_GUI 110,7, 110,25
 $Select:E.2 = Junction:F.1;  //_GUI 119,10
}

Object ( Bit Out1) IsFloating( Floating In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Floating"
{
 // Returns true if the input dataset is a Floating dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be Floating.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Floating, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Floating In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsFloating( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a Floating dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be Floating.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Floating, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsList( List In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="list"
{
 // Returns true if the input dataset is a List dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be List.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is List, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsList( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a List dataset.  Returns false in all other cases.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be List.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is List, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsComplex( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip"
{
 // Returns true if the input dataset is a complex dataset.  Returns false in all other cases.  A complex dataset is a contextual dataset of a list of two elements.  The most significant is the real portion and the least significant is the imaginary portion.  The datasets of both portions can be unsigned (MSBxxx, LSBxxx, BINxxx), Signed, Fixed or Floating.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a complex dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Conomplex, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) IsComplex( Complex In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\DatasetInfo/Manip\\$Internal",Documentation="Complex"
{
 // Returns true if the input dataset is a complex dataset.  Returns false in all other cases.  A complex dataset is a contextual dataset of a list of two elements.  The most significant is the real portion and the least significant is the imaginary portion.  The datasets of both portions can be unsigned (MSBxxx, LSBxxx, BINxxx), Signed, Fixed or Floating.
 //
 // Inputs:
 //
 // Variant input: The input that is tested to be a complex dataset.
 //
 // Outputs:
 //
 // Bit output: 1 if input dataset is Conomplex, 0 otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Complex In1) Input;  //_GUI 33,21
 Object Output( Bit Out1) ;  //_GUI 63,21
 Object ( Bit In) Input:A;  //_GUI 58,21
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), =)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 == 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != (!0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Eq_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != (!0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( List Out1) PackLSB( Variant In1, Variant In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\LSB\\PackLSB",Icon="Exposer_Out"
{
 // Packs input elements into an LSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,21
 Object ( Variant In2) Input:A;  //_GUI 28,24
 Object Output( List Out1) ;  //_GUI 51,22
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 35,20

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( List Hi, Variant Lo) $BisectList_High( Variant MSB
    , List List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 22,28
 Object ( List List) Input:A;  //_GUI 22,33
 Object Output( List Hi) ;  //_GUI 104,29
 Object Output:A( Variant Lo) ;  //_GUI 102,35
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object ( List Out1) PackMSB( Variant In2, Variant In3) ;  //_GUI 84,27
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.
 Object ( Variant Out1, Variant LSB) ListPopLsb( Variant In1) ;  //_GUI 34,31
 //_ Attributes Documentation="ztlist"
 Object ( Variant Hi, Variant Lo) $BisectList_Low( Variant List
    , Variant LSB) ;  //_GUI 54,31
 //_ Attributes Documentation="list"

 //_ Behavior Topology
 Output.0 = PackMSB.0;  
 Output:A.0 = $BisectList_Low.1;  
 PackMSB.0 = Input.0;  
 PackMSB.1 = $BisectList_Low.0;  //_GUI 82,32, 82,33
 ListPopLsb.0 = Input:A.0;  
 $BisectList_Low.0 = ListPopLsb.0;  
 $BisectList_Low.1 = ListPopLsb.1;  
}

Object ( Variant Hi, Variant Lo) $BisectList_High( Variant MSB
    , Variant List) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant MSB) Input;  //_GUI 22,28
 Object ( Variant List) Input:A;  //_GUI 22,33
 Object Output( Variant Hi) ;  //_GUI 95,28
 Object Output:A( Variant Lo) ;  //_GUI 67,33
 Object Text;  //_GUI 72,20,We just make these into LSB data types because we can't figure out what the real data type should be.
 Object Text;  //_GUI 20,11,Basically what we do here is pop an element off of the bottom and another off of the top then recurse.  Then when we get the Hi and Lo back append to the Lo and prepend to the Hi.

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List MsbList) AppendMsbList( List AnyList, Variant MsbList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal",Documentation="list/var"
{
 // Works for the var/list and the list/list case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( List AnyList) Input;  //_GUI 20,42
 Object ( Variant MsbList) Input:A;  //_GUI 20,50
 Object Output( List MsbList) ;  //_GUI 101,42
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 26,40
 Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) ;  //_GUI 50,46
 Object ( List MsbList) AppendMsbList:A( Variant AnyList, Variant MsbList) ;  //_GUI 79,40

 //_ Behavior Topology
 Output.0 = AppendMsbList:A.0;  
 ListIn.0 = Input.0;  
 AppendMsbList.0 = ListIn.0;  //_GUI 43,48, 43,45
 AppendMsbList.1 = Input:A.0;  
 AppendMsbList:A.0 = ListIn.1;  
 AppendMsbList:A.1 = AppendMsbList.0;  //_GUI 75,45, 75,49
}

Object ( List MsbList) AppendMsbList( Variant AnyList, Variant MsbList) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Lists\\$Internal"
{
 // Works for the var/var and the list/var case
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant AnyList) Input;  //_GUI 20,33
 Object ( Variant MsbList) Input:A;  //_GUI 20,42
 Object Output( List MsbList) ;  //_GUI 69,37
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 39,35

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  //_GUI 25,40, 25,43
 ListOut.1 = Input.0;  //_GUI 25,37, 25,34
}

Object ( Bit CO, Bit S) $$ADSU_logic( Bit A
    , Bit B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit A) Input;  //_GUI 14,20
 Object ( Bit B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 124,17
 Object Output:A( Bit S) ;  //_GUI 124,29
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 20,30
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 36,20
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 86,22
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 82,31
 Object ( Bit Out1) XOR( Bit In1, Bit In2) ;  //_GUI 92,27
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:A( Bit In1, Bit In2) ;  //_GUI 64,20
 //_ Attributes Documentation="Bit/Bit"
 Object ( Bit Out1) XOR:B( Bit In1, Bit In2) ;  //_GUI 48,19
 //_ Attributes Documentation="Bit/Bit"
 Object Text;  //_GUI 27,48,This object will likely be overloaded with an optimized system specific implementation.
 Object ( Bit O) $Mux( Bit A, Bit B
    , Bit S) ;  //_GUI 94,15
 //_ Attributes Documentation="Bit"

 //_ Behavior Topology
 Output.0 = $Mux.0;  
 Output:A.0 = XOR.0;  
 INVERT.0 = Input:B.0;  
 Junction.0 = Input.0;  
 Junction:A.0 = XOR:A.0;  
 Junction:B.0 = Input:C.0;  //_GUI 83,41
 XOR.0 = Junction:A.2;  //_GUI 87,29
 XOR.1 = Junction:B.2;  
 XOR:A.0 = XOR:B.0;  
 XOR:A.1 = INVERT.0;  //_GUI 64,33
 XOR:B.0 = Junction.1;  
 XOR:B.1 = Input:A.0;  
 $Mux.0 = Junction.0;  //_GUI 37,17
 $Mux.1 = Junction:B.1;  //_GUI 83,20
 $Mux.2 = Junction:A.1;  
}

Object ( Bit CO, Variant S) $$ADSU_logic( Variant A
    , Variant B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 23,32
 Object ( Variant B) Input:A;  //_GUI 23,40
 Object ( Bit ADD) Input:B;  //_GUI 26,46
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 27,52
 //_ Attributes Constant="0"
 Object Output( Bit CO) ;  //_GUI 145,24
 Object Output:A( Variant S) ;  //_GUI 150,42
 Object ( Variant Out1) $Cast( Variant Data, Variant Type) ;  //_GUI 136,40
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 33,30
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 115,42
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 33,38
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 71,46
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 29,32
 Object ( Bit Out1) VouchBit( Variant In1) ;  //_GUI 133,22
 Object ( Variant CO, Variant S) $$ADSU_logic( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,42
 //_ Attributes Documentation="bit"
 Object ( Variant CO, Variant S) $$ADSU_logic:A( Variant A
    , Variant B, Bit ADD, Bit CI) ;  //_GUI 83,23
 //_ Attributes Documentation="bit"

 //_ Behavior Topology
 Output.0 = VouchBit.0;  
 Output:A.0 = $Cast.0;  
 $Cast.0 = VariantOut.0;  
 $Cast.1 = Junction:A.0;  //_GUI 130,42, 130,19, 30,19
 VariantIn.0 = Junction:A.1;  
 VariantOut.0 = $$ADSU_logic.1;  
 VariantOut.1 = $$ADSU_logic:A.1;  //_GUI 115,28
 VariantIn:A.0 = Input:A.0;  
 Junction.0 = Input:B.0;  
 Junction:A.0 = Input.0;  
 VouchBit.0 = $$ADSU_logic:A.0;  
 $$ADSU_logic.0 = VariantIn.0;  //_GUI 79,44, 79,35
 $$ADSU_logic.1 = VariantIn:A.0;  //_GUI 76,47, 76,43
 $$ADSU_logic.2 = Junction.2;  //_GUI 72,50
 $$ADSU_logic.3 = Input:C.0;  
 $$ADSU_logic:A.0 = VariantIn.1;  //_GUI 66,25, 66,32
 $$ADSU_logic:A.1 = VariantIn:A.1;  //_GUI 69,28, 69,40
 $$ADSU_logic:A.2 = Junction.0;  //_GUI 72,31
 $$ADSU_logic:A.3 = $$ADSU_logic.0;  //_GUI 83,39, 98,39
}

Object ( NULL CO, NULL S) $$ADSU_logic( NULL A
    , NULL B, Bit ADD, Bit CI) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\ArithmeticOps\\Async\\$Internal\\Foundation",Documentation="NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 14,17
 Object ( NULL B) Input:A;  //_GUI 14,23
 Object ( Bit ADD) Input:B;  //_GUI 14,32
 //_ Attributes Constant="1"
 Object ( Bit CI) Input:C;  //_GUI 14,40
 //_ Attributes Constant="0"
 Object Output( NULL CO) ;  //_GUI 40,17
 Object Output:A( NULL S) ;  //_GUI 40,23

 //_ Behavior Topology
 Output.0 = Input.0;  
 Output:A.0 = Input:A.0;  
}

Object ( List RightUpper, List RightLower) PossibleRightShifts( Variant Data
    , Variant Size, Bit IsTwos) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Data) Input;  //_GUI 30,23
 Object ( Variant Size) Input:A;  //_GUI 40,35
 Object ( Bit IsTwos) Input:B;  //_GUI 41,46
 //_ Attributes Constant="0"
 Object Output( List RightUpper) ;  //_GUI 166,31
 Object Output:A( List RightLower) ;  //_GUI 178,43
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 64,34
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 93,22
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 78,36
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 153,29
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 156,41
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 83,15
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 101,43
 Object ( Bit OFL, Variant Out1) UExtnd( Variant Type
    , Variant Data) ;  //_GUI 86,51
 //_ Attributes Documentation="PadLeft"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 141,20
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 64,13
 Object Text;  //_GUI 10,56,This object creates LSB lists of all the possible right shifts for a dataset.It's true: this object is a bit of a mystery, but here's the basic plan. We pop bits off of the right of our incoming data and pad the top of the remaining data with zeros. This is our standard shift. The falloff data is built from the popped-off data.
 Object ( Variant Out1) PushLsb:A( Variant In1, Variant LSB) ;  //_GUI 128,18
 Object ( Variant Out1, Variant LSB) PopLsb( Variant In1) ;  //_GUI 49,21
 Object ( Variant MSB, Variant Out2) PopMsb:A( Variant In1) ;  //_GUI 41,2
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 40,23
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 71,2
 Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Variant Data
    , Variant Size, Bit IsTwos) ;  //_GUI 94,32
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 54,46
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 104,3
 //_ Attributes Documentation="ztlist/ztlist"

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 Output:A.0 = ListOut:A.0;  
 PushLsb.0 = Input:A.0;  
 PushLsb.1 = PopLsb.1;  //_GUI 59,39
 Junction.0 = PopLsb.0;  
 Junction:A.0 = PushLsb.0;  
 ListOut.0 = Junction:B.1;  //_GUI 150,34, 150,21
 ListOut.1 = PossibleRightShifts.0;  //_GUI 146,31, 146,34
 ListOut:A.0 = ReverseBits.0;  
 ListOut:A.1 = PossibleRightShifts.1;  //_GUI 136,43, 136,37
 Zero.0 = PopMsb.1;  
 ReverseBits.0 = UExtnd.1;  //_GUI 98,46, 98,56
 UExtnd.0 = Junction:B.2;  //_GUI 86,28, 142,28
 UExtnd.1 = Junction:A.2;  //_GUI 79,56
 Junction:B.0 = PushLsb:A.0;  
 PopMsb.0 = Junction:A.0;  //_GUI 64,29, 79,29
 PushLsb:A.0 = OR.0;  //_GUI 128,6
 PushLsb:A.1 = Junction.1;  
 PopLsb.0 = Junction:C.1;  
 PopMsb:A.0 = Junction:C.0;  
 Junction:C.0 = Input.0;  
 AND.0 = PopMsb:A.0;  
 AND.1 = Junction:D.0;  //_GUI 55,7
 PossibleRightShifts.0 = Junction.2;  
 PossibleRightShifts.1 = Junction:A.1;  
 PossibleRightShifts.2 = Junction:D.1;  //_GUI 91,40, 91,47
 Junction:D.0 = Input:B.0;  
 OR.0 = AND.0;  
 OR.1 = Zero.0;  //_GUI 98,8, 98,18
}

Object ( Variant RightUpper, Variant RightLower) PossibleRightShifts( Bit Data
    , Variant Size, Bit IsTwos) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Shifters\\$Internal",Documentation="leaf"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Data) Input;  //_GUI 26,43
 Object ( Variant Size) Input:A;  //_GUI 15,49
 Object ( Bit IsTwos) Input:B;  //_GUI 29,59
 //_ Attributes Constant="0"
 Object Output( Variant RightUpper) ;  //_GUI 95,24
 Object Output:A( Variant RightLower) ;  //_GUI 92,41
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 79,41
 Object ( Variant Out1) Zero( Variant In1) ;  //_GUI 69,21
 Object ( Variant Out1) PushLsb( Variant In1, Variant LSB) ;  //_GUI 52,39
 Object ( Variant Out1) ReverseBits( Variant In1) ;  //_GUI 64,39
 Object ( Variant MSB, Variant Out2) PopMsb( Variant In1) ;  //_GUI 21,47
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 61,55
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 41,43
 Object ( Variant Out1) OR( Variant In1, Variant In2) ;  //_GUI 83,22
 //_ Attributes Documentation="ztlist/ztlist"

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = Junction.1;  
 Junction.0 = ReverseBits.0;  
 Zero.0 = Junction.0;  //_GUI 69,35, 80,35
 PushLsb.0 = PopMsb.1;  //_GUI 48,41, 48,52
 PushLsb.1 = Junction:A.1;  
 ReverseBits.0 = PushLsb.0;  
 PopMsb.0 = Input:A.0;  
 AND.0 = Junction:A.2;  //_GUI 42,57
 AND.1 = Input:B.0;  
 Junction:A.0 = Input.0;  
 OR.0 = Zero.0;  
 OR.1 = AND.0;  //_GUI 83,58
}

Object ( Bit Out1) $BitA_Ne_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), =, !)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ne_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,! (0 == 0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ne_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != ! 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Ne_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is not equal to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 19,23,0 != ! 0
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="1"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant "#0", Variant "#1") Deselect( Variant In1
    , Bit S) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced"
{
 // Does a compile time deselect between two output paths.  Can be thought of as a compile time demultiplexer. Used to be the $SelectOut object.  The path that is not selected should get removed with sourceless removal.  Sometimes sourceless removal doesn't remove everything that was desired, so it is recommended that the Select object be used in conjunction with Deselect.
 //
 // Inputs:
 //
 // Variant input: The input that will become #0 or #1.
 //
 // Bit S: This select bit must be a constant or compile will halt.  A value of 0 causes the input to be connected to the #0 output and the #1 output is internally left hanging causing sourceless removal to take effect.  A value of 1 causes the input to be connected to the #1 output and the #0 output is internally left hanging causing sourceless removal to take effect.
 //
 // Outputs:
 //
 // Variant #0: A pass through of the input if S is 0, internally disconnected otherwise.
 //
 // Variant #1: A pass through of the input if S is 1, internally disconnected otherwise.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 28,19
 Object ( Bit S) Input:A;  //_GUI 28,22
 //_ Attributes Constant="0"
 Object Output( Variant "#0") ;  //_GUI 48,19
 Object Output:A( Variant "#1") ;  //_GUI 48,22
 Object ( Variant "#0", Variant "#1") $SelectOut( Variant In1
    , Bit S) ;  //_GUI 34,18

 //_ Behavior Topology
 Output.0 = $SelectOut.0;  
 Output:A.0 = $SelectOut.1;  
 $SelectOut.0 = Input.0;  
 $SelectOut.1 = Input:A.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\BitLenMath/Comp"
{
 // Returns a 1 if the number of bits in A is less than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object ( Variant Out1) MSB:A( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,Must pass the inputs through MSB because the number-of-bits input macro used in the $ version doesn't report the number of bits for variant or variant derived datasets.
 Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="bit/bit"

 //_ Behavior Topology
 Output.0 = $BitA_Lt_BitB.0;  
 MSB.0 = Input.0;  
 MSB:A.0 = Input:A.0;  
 $BitA_Lt_BitB.0 = MSB.0;  
 $BitA_Lt_BitB.1 = MSB:A.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 // Returns a 1 if the number of bits in A is less than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object Text;  //_GUI 18,23,(0 < 0)
 Object ( Bit In) Input:B;  //_GUI 42,15
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 // Returns a 1 if the number of bits in A is less than the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 10,14
 Object ( Variant B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,15
 Object Text;  //_GUI 8,24,The B input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 31,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Lt_BitB.0;  
 MSB.0 = Input:A.0;  
 $BitA_Lt_BitB.0 = Input.0;  
 $BitA_Lt_BitB.1 = MSB.0;  
}

Object ( Bit Out1) BitA_Lt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 // Returns a 1 if the number of bits in A is less than to the number of bits in B.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 10,14
 Object ( NULL B) Input:A;  //_GUI 10,17
 Object Output( Bit Out1) ;  //_GUI 48,15
 Object ( Variant Out1) MSB( Variant In1) ;  //_GUI 18,12
 Object Text;  //_GUI 8,29,The A input could be a contextual dataset wrapping NULL, so MSB it and send it on to check for a NULL/NULL.
 Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) ;  //_GUI 30,13
 //_ Attributes Documentation="var/var"

 //_ Behavior Topology
 Output.0 = $BitA_Lt_BitB.0;  
 MSB.0 = Input.0;  
 $BitA_Lt_BitB.0 = MSB.0;  
 $BitA_Lt_BitB.1 = Input:A.0;  
}

Object ( Variant Out1) $ConvBExpGrow( Variant Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 8,15
 Object ( Variant Data) Input:A;  //_GUI 8,25
 Object Output( Variant Out1) ;  //_GUI 92,20
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 19,23
 //_ Attributes Documentation="bit"
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 19,14
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 14,25
 Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3) ;  //_GUI 65,20
 Object ( Variant Out1) DupBit( Bit Bit, Variant DupSize) ;  //_GUI 50,11
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 38,10
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In3) ;  //_GUI 33,21
 Object Text;  //_GUI 6,52,BExp - Bias = BExp + (-Bias) = SExp = SExp = SignExt + Bias = BExp(4) = BExp(5)000  - 011  = 000  +   101   = 101  = -3   = 1101    + 0111 = 0100    = 01100001  - 011  = 001  +   101   = 110  = -2   = 1101    + 0111 = 0101    = 01101010  - 011  = 010  +   101   = 111  = -1   = 1101    + 0111 = 0110    = 01100011  - 011  = 011  +   101   = 000  =  0   = 0000    + 0111 = 0111    = 01101100  - 011  = 100  +   101   = 001  =  1   = 0001    + 0111 = 1000    = 10000101  - 011  = 101  +   101   = 010  =  2   = 0010    + 0111 = 1001    = 10001110  - 011  = 110  +   101   = 011  =  3   = 0011    + 0111 = 1010    = 10010111  - 011  = 111  +   101   = 100  = (4)  = 0100    + 0111 = 1011    = 10011Courier New,8,0,0
 Object Text;  //_GUI 7,32,To expand a biased exponent1. remove bias2. sign extend3. add biasThis can be done a lot faster by observing the pattern below
 Object Text;  //_GUI 6,79,For example a 4 bit binary number represented by the bit positions A through DABCD expanded by 3 bits turns into  ___AAAABCDWhich is A followed by the inverse of A for all expanded bits, followed by the rest of the previously existing bits B, C and D.Courier New,8,0,0
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 80,18
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 14,15

 //_ Behavior Topology
 Output.0 = Context.0;  
 ExposeMSB.0 = Junction.1;  
 Lo_N.0 = Junction:B.1;  
 Lo_N.1 = Junction.0;  //_GUI 15,19
 Junction.0 = Input:A.0;  
 CollectMSB.0 = Junction:A.2;  
 CollectMSB.1 = DupBit.0;  //_GUI 62,25, 62,14
 CollectMSB.2 = ExposeMSB.1;  
 DupBit.0 = INVERT.0;  
 DupBit.1 = Lo_N.0;  
 INVERT.0 = Junction:A.1;  //_GUI 34,13
 Junction:A.0 = ExposeMSB.0;  //_GUI 34,25
 Context.0 = Junction:B.0;  //_GUI 80,7, 15,7
 Context.1 = CollectMSB.0;  
 Junction:B.0 = Input.0;  
}

Object ( Bit SetToMaxPos, Bit SetTo0, Variant Out3) $ConvBExpShrink
    ( Variant Type, Variant Data) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Converters\\$Internal"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant Type) Input;  //_GUI 6,22
 Object ( Variant Data) Input:A;  //_GUI 6,28
 Object Output( Bit SetToMaxPos) ;  //_GUI 171,17
 Object Output:A( Bit SetTo0) ;  //_GUI 165,26
 Object Output:B( Variant Out3) ;  //_GUI 145,39
 Object Text;  //_GUI 4,98,For example a 7 bit binary number represented by the bit positions A through GABCDEFG Shrunk by 3 bits turns into AEFGThere is no error if B,C and D all have the same value as the inverse of A.If they are not the inverse of A and A is high, output SetToMaxPos. If they are not the inverse of A and A is low, output SetToZero.Courier New,8,0,0
 Object ( Variant Hi, Variant Lo) Lo_N( Variant Data
    , Variant Lo_N) ;  //_GUI 37,20
 Object ( Variant Out1, Variant Out1) ExposeMSB( Variant In1) ;  //_GUI 50,16
 //_ Attributes Documentation="bit"
 Object ( Bit Out) INVERT( Bit In1) ;  //_GUI 69,15
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 90,16
 Object ( Bit Out1) AND-NInput( Variant In1) ;  //_GUI 109,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 105,18
 Object Text;  //_GUI 6,45,To shrink a biased exponent1. remove bias2. Remove high bits. If high bit low and others not then error to MaxPos.  If high bit high and others not, send to zero.3. add biasThis can be done a lot faster by observing the pattern below in an expand:
 Object Text;  //_GUI 6,69,BExp - Bias = BExp + (-Bias) = SExp = SExp = SignExt + Bias = BExp(4) = BExp(5) = BExp(2) 000  - 011  = 000  +   101   = 101  = -3   = 1101    + 0111 = 0100    = 01100   = sz    001  - 011  = 001  +   101   = 110  = -2   = 1101    + 0111 = 0101    = 01101   = sz010  - 011  = 010  +   101   = 111  = -1   = 1101    + 0111 = 0110    = 01100   = 00011  - 011  = 011  +   101   = 000  =  0   = 0000    + 0111 = 0111    = 01101   = 01100  - 011  = 100  +   101   = 001  =  1   = 0001    + 0111 = 1000    = 10000   = 10101  - 011  = 101  +   101   = 010  =  2   = 0010    + 0111 = 1001    = 10001   = 11110  - 011  = 110  +   101   = 011  =  3   = 0011    + 0111 = 1010    = 10010   = mp111  - 011  = 111  +   101   = 100  = (4)  = 0100    + 0111 = 1011    = 10011   = mpCourier New,8,0,0
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 65,17
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 81,39
 Object ( Variant Out1, Variant Out1) ExposeMSB:A( Variant In1) ;  //_GUI 16,20
 //_ Attributes Documentation="bit"
 Object Text;  //_GUI 13,11,Shrink Type by one bit because will put MSB back on later
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 129,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 12,22
 Object ( Bit Out1) OR-NInput( Variant In1) ;  //_GUI 109,16
 Object ( Bit Out) INVERT:A( Bit In1) ;  //_GUI 125,23
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 130,14
 Object ( Bit Out) AND:A( Bit In1, Bit In2) ;  //_GUI 140,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 83,17
 Object ( Bit Out1) AND-NInput:A( Variant In1) ;  //_GUI 109,30
 Object ( Bit Out) OR( Bit In1, Bit In2) ;  //_GUI 154,15
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:D
    ( Variant In0) ;  //_GUI 104,41

 //_ Behavior Topology
 Output.0 = OR.0;  
 Output:A.0 = AND:A.0;  
 Output:B.0 = Context.0;  
 Lo_N.0 = Input:A.0;  //_GUI 35,22, 35,29
 Lo_N.1 = ExposeMSB:A.1;  
 ExposeMSB.0 = Lo_N.0;  //_GUI 48,19, 48,22
 INVERT.0 = Junction:A.1;  
 CollectMSB.0 = Junction:C.1;  
 CollectMSB.1 = ExposeMSB.1;  
 AND-NInput.0 = Junction.2;  //_GUI 106,26
 Junction.0 = CollectMSB.0;  
 Junction:A.0 = ExposeMSB.0;  
 CollectMSB:A.0 = Junction:A.2;  //_GUI 66,41
 CollectMSB:A.1 = Lo_N.1;  //_GUI 48,44, 48,25
 ExposeMSB:A.0 = Junction:B.1;  
 Context.0 = Junction:B.2;  //_GUI 100,39, 100,37, 13,37
 Context.1 = Junction:D.1;  
 Junction:B.0 = Input.0;  
 OR-NInput.0 = Junction.1;  
 INVERT:A.0 = AND-NInput.0;  
 AND.0 = Junction:A.0;  //_GUI 130,9, 66,9
 AND.1 = OR-NInput.0;  
 AND:A.0 = INVERT:A.0;  
 AND:A.1 = Junction:C.2;  //_GUI 84,29
 Junction:C.0 = INVERT.0;  
 AND-NInput:A.0 = Junction:D.0;  //_GUI 105,33
 OR.0 = AND.0;  
 OR.1 = AND-NInput:A.0;  //_GUI 154,33
 Junction:D.0 = CollectMSB:A.0;  
}

Object ( List Out1) PackMSB( Variant In2, Variant In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\PackMSB",Icon="Exposer_Out"
{
 // Packs input elements into an MSB-shaped List
 //
 // Date:
 // 25 Oct 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In2) Input;  //_GUI 14,19
 Object ( Variant In3) Input:A;  //_GUI 14,22
 Object Output( List Out1) ;  //_GUI 35,20
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 20,18

 //_ Behavior Topology
 Output.0 = ListOut.0;  
 ListOut.0 = Input:A.0;  
 ListOut.1 = Input.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( Variant A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 65,46
 Object ( Bit Constant) Input:B;  //_GUI 59,46
 //_ Attributes PromoteToParentObject="False",Constant="$($(NodeInfo:0:BitLen), $(NodeInfo:1:BitLen), <)"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( NULL A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 49,35
 Object ( Bit In) Input:B;  //_GUI 43,35
 //_ Attributes PromoteToParentObject="False",Constant="0"

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( NULL A, Variant B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="NULL/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL A) Input;  //_GUI 24,33
 Object ( Variant B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 49,35
 Object ( Bit In) Input:B;  //_GUI 43,35
 //_ Attributes PromoteToParentObject="False",Constant="1"
 Object Text;  //_GUI 24,46,0 is less than anything greater than zero.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Bit Out1) $BitA_Lt_BitB( Variant A, NULL B) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\$Internal",Documentation="var/NULL"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 24,33
 Object ( NULL B) Input:A;  //_GUI 24,36
 Object Output( Bit Out1) ;  //_GUI 49,35
 Object ( Bit In) Input:B;  //_GUI 43,35
 //_ Attributes PromoteToParentObject="False",Constant="0"
 Object Text;  //_GUI 24,46,anything greater than zero is not less than 0.

 //_ Behavior Topology
 Output.0 = Input:B.0;  
}

Object ( Variant Out1) CollectMSB( Variant In1, Variant In2
    , Variant In3) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Exposers/Collectors\\MSB\\CollectMSB",Icon="Exposer_Out"
{
 // Date:
 // 14 Nov 2002
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 26,32
 Object ( Variant In2) Input:A;  //_GUI 26,38
 Object ( Variant In3) Input:B;  //_GUI 26,41
 Object Output( Variant Out1) ;  //_GUI 68,33
 Object ( Variant Out1) CollectMSB( Variant In2, Variant In3) ;  //_GUI 33,37
 Object ( Variant Out1) CollectMSB:A( Variant In2, Variant In3) ;  //_GUI 51,31

 //_ Behavior Topology
 Output.0 = CollectMSB:A.0;  
 CollectMSB.0 = Input:A.0;  
 CollectMSB.1 = Input:B.0;  
 CollectMSB:A.0 = Input.0;  
 CollectMSB:A.1 = CollectMSB.0;  //_GUI 48,36, 48,40
}

Object ( Bit Out1) DupBit( Bit Bit, Bit DupSize) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="bit"
{
 // The input Bit is duplicated into all of the bits in the dataset DupSize.
 //
 // Inputs:
 //
 // Bit Bit: This is the bit that will be duplicated.
 //
 // Variant DupSize: This is the dataset that will be filled with the bit Bit.
 //
 // Outputs:
 //
 // Variant output: The output dataset is the same as DupSize.  Its value is either a binary value all ones or all zeros depending upon the value of the Bit input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Bit) Input;  //_GUI 45,30
 Object ( Bit DupSize) Input:A;  //_GUI 45,41
 Object Output( Bit Out1) ;  //_GUI 59,30

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) DupBit( Bit Bit, Variant DupSize) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits"
{
 // The input Bit is duplicated into all of the bits in the dataset DupSize.
 //
 // Inputs:
 //
 // Bit Bit: This is the bit that will be duplicated.
 //
 // Variant DupSize: This is the dataset that will be filled with the bit Bit.
 //
 // Outputs:
 //
 // Variant output: The output dataset is the same as DupSize.  Its value is either a binary value all ones or all zeros depending upon the value of the Bit input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Bit) Input;  //_GUI 45,30
 Object ( Variant DupSize) Input:A;  //_GUI 45,41
 Object Output( Variant Out1) ;  //_GUI 119,37
 Object ( Variant Out) VariantOut( Variant In1, Variant In2) ;  //_GUI 94,37
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 53,41
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 59,39
 Object ( Variant Out1) DupBit( Bit Bit, Variant DupSize) ;  //_GUI 79,36
 Object ( Variant Out1) DupBit:A( Bit Bit, Variant DupSize) ;  //_GUI 79,44
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In1) ;  //_GUI 73,37
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 107,35

 //_ Behavior Topology
 Output.0 = Cast.0;  
 VariantOut.0 = DupBit:A.0;  //_GUI 94,47
 VariantOut.1 = DupBit.0;  
 Junction.0 = Input:A.0;  
 VariantIn.0 = Junction.1;  
 DupBit.0 = Junction:A.1;  
 DupBit.1 = VariantIn.1;  
 DupBit:A.0 = Junction:A.2;  //_GUI 74,46
 DupBit:A.1 = VariantIn.0;  //_GUI 70,49
 Junction:A.0 = Input.0;  //_GUI 74,31
 Cast.0 = Junction.0;  //_GUI 107,34, 54,34
 Cast.1 = VariantOut.0;  
}

Object ( NULL Out1) DupBit( Bit Bit, NULL DupSize) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\GrammaticalOps\\Advanced\\Bits\\$Internal",Documentation="NULL"
{
 // The input Bit is duplicated into all of the bits in the dataset DupSize.
 //
 // Inputs:
 //
 // Bit Bit: This is the bit that will be duplicated.
 //
 // Variant DupSize: This is the dataset that will be filled with the bit Bit.
 //
 // Outputs:
 //
 // Variant output: The output dataset is the same as DupSize.  Its value is either a binary value all ones or all zeros depending upon the value of the Bit input.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit Bit) Input;  //_GUI 45,30
 Object ( NULL DupSize) Input:A;  //_GUI 45,41
 Object Output( NULL Out1) ;  //_GUI 58,41

 //_ Behavior Topology
 Output.0 = Input:A.0;  
}

Object ( Bit Out1) AND-NInput( Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\Async\\Advanced"
{
 // All bits are ANDed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ANDing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 78,29
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 26,29
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 40,29
 //_ Attributes Documentation="var/bit"
 Object ( Bit Out1) $Cast( Variant Data, Bit Type) ;  //_GUI 64,27
 Object ( Variant Out1) BIN( Variant In1) ;  //_GUI 14,29

 //_ Behavior Topology
 Output.0 = $Cast.0;  
 VariantIn.0 = BIN.0;  
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
 $Cast.0 = $AND-NInput.0;  
 BIN.0 = Input.0;  
}

Object ( Bit Out1) AND-NInput( Bit In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="bit"
{
 // All bits are ANDed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ANDing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 10,31
 Object Output( Bit Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( NULL Out1) AND-NInput( NULL In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="NULL"
{
 // All bits are ANDed together to produce a single bit output.
 //
 // Inputs:
 //
 // Variant input: Any dataset.
 //
 // Outputs:
 //
 // Variant output: A single bit output that is the result of ANDing all input bits.
 //
 // Revision 1
 //_ Object Prototypes
 Object ( NULL In1) Input;  //_GUI 10,31
 Object Output( NULL Out1) ;  //_GUI 55,31

 //_ Behavior Topology
 Output.0 = Input.0;  
}

Object ( Variant Out1) $AND-NInput( Variant In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="var/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,24
 Object ( Bit In2) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 27,22
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 43,22
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = AND.0;  
 VariantIn.0 = Input.0;  
 AND.0 = $AND-NInput.0;  
 AND.1 = Input:A.0;  //_GUI 59,32
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
}

Object ( Variant Out1) $AND-NInput( Variant In1, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="var/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Variant In1) Input;  //_GUI 10,20
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1, Variant Out2) VariantIn:A( Variant In) ;  //_GUI 16,18
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"
 Object ( Variant Out1) $AND-NInput:A( Variant In1, Variant In2) ;  //_GUI 30,18
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = AND.0;  
 VariantIn.0 = Input:A.0;  
 VariantIn:A.0 = Input.0;  
 AND.0 = $AND-NInput:A.0;  //_GUI 59,21
 AND.1 = $AND-NInput.0;  //_GUI 59,32
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
 $AND-NInput:A.0 = VariantIn:A.1;  
 $AND-NInput:A.1 = VariantIn:A.0;  
}

Object ( Variant Out1) $AND-NInput( Bit In2, Variant In1) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="bit/var"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In2) Input;  //_GUI 10,24
 Object ( Variant In1) Input:A;  //_GUI 10,31
 Object Output( Variant Out1) ;  //_GUI 75,25
 Object ( Variant Out1, Variant Out2) VariantIn( Variant In) ;  //_GUI 16,29
 Object ( Variant Out1) AND( Variant In1, Variant In2) ;  //_GUI 59,23
 Object ( Variant Out1) $AND-NInput( Variant In1, Variant In2) ;  //_GUI 30,29
 //_ Attributes Documentation="var/bit"

 //_ Behavior Topology
 Output.0 = AND.0;  
 VariantIn.0 = Input:A.0;  
 AND.0 = Input.0;  
 AND.1 = $AND-NInput.0;  //_GUI 59,32
 $AND-NInput.0 = VariantIn.1;  
 $AND-NInput.1 = VariantIn.0;  
}

Object ( Bit Out1) $AND-NInput( Bit In1, Bit In2) 
//_ Attributes TreeGroup="Corelib\\CoreLib\\Gates\\$Internal\\$AND",Documentation="bit/bit"
{
 //
 // Revision 1
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 11,24
 Object ( Bit In2) Input:A;  //_GUI 11,27
 Object Output( Bit Out1) ;  //_GUI 31,25
 Object ( Bit Out) AND( Bit In1, Bit In2) ;  //_GUI 17,23

 //_ Behavior Topology
 Output.0 = AND.0;  
 AND.0 = Input.0;  
 AND.1 = Input:A.0;  
}

